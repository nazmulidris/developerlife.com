<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" /><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Guide to parsing with nom | developerlife.com</title>
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="Guide to parsing with nom" />
<meta name="author" content="Nazmul Idris" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This tutorial is a guide to parsing with nom. It covers the basics of parsing and how to use nom to parse a string into a data structure. We will cover a variety of different examples ranging from parsing simple CSS like syntax to a full blown Markdown parser." />
<meta property="og:description" content="This tutorial is a guide to parsing with nom. It covers the basics of parsing and how to use nom to parse a string into a data structure. We will cover a variety of different examples ranging from parsing simple CSS like syntax to a full blown Markdown parser." />
<link rel="canonical" href="http://developerlife.com/2023/02/20/guide-to-nom-parsing/" />
<meta property="og:url" content="http://developerlife.com/2023/02/20/guide-to-nom-parsing/" />
<meta property="og:site_name" content="developerlife.com" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-02-20T09:00:00-06:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Guide to parsing with nom" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Nazmul Idris"},"dateModified":"2023-02-20T09:00:00-06:00","datePublished":"2023-02-20T09:00:00-06:00","description":"This tutorial is a guide to parsing with nom. It covers the basics of parsing and how to use nom to parse a string into a data structure. We will cover a variety of different examples ranging from parsing simple CSS like syntax to a full blown Markdown parser.","headline":"Guide to parsing with nom","mainEntityOfPage":{"@type":"WebPage","@id":"http://developerlife.com/2023/02/20/guide-to-nom-parsing/"},"url":"http://developerlife.com/2023/02/20/guide-to-nom-parsing/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css" />

  <!-- Add favicon -->
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />

  <!-- Add font awesome -->
  <link
    rel="stylesheet"
    href="https://use.fontawesome.com/releases/v5.2.0/css/all.css"
    integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ"
    crossorigin="anonymous"
  />

  <!-- Add Google fonts-->
  <link
    href="https://fonts.googleapis.com/css?family=Spline+Sans|Work+Sans|Fira+Mono|Fira+Sans|Google+Sans|Lexend+Deca&display=swap"
    rel="stylesheet"
  /><link type="application/atom+xml" rel="alternate" href="http://developerlife.com/feed.xml" title="developerlife.com" /><!-- https://developers.google.com/analytics/devguides/collection/gtagjs -->
<script async
        src="https://www.googletagmanager.com/gtag/js?id=G-NQY9ECC58H"></script>
<script>
  window.dataLayer = window.dataLayer || []

  function gtag() {
    window.dataLayer.push(arguments)
  }

  gtag("js", new Date())
  gtag("config", "G-NQY9ECC58H")
</script>
<!-- https://us14.admin.mailchimp.com/account/connected-sites/site-detail/ -->

<script id="mcjs">
  !(function (c, h, i, m, p) {
    ;(m = c.createElement(h)),
      (p = c.getElementsByTagName(h)[0]),
      (m.async = 1),
      (m.src = i),
      p.parentNode.insertBefore(m, p)
  })(
    document,
    "script",
    "https://chimpstatic.com/mcjs-connected/js/users/c2470ddfa863eb8ace707651b/2bb3bcad193ef862398700457.js"
  )
</script>
</head>
<body><!-- https://github.com/mermaid-js/mermaid/blob/develop/docs/n00b-gettingStarted.md -->
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>

<script>
  // https://mermaid-js.github.io/mermaid/#/theming
  mermaid.initialize({
    startOnLoad: true,
    theme: "dark",
    themeVariables: {
      fontFamily: "Fira Code",
      fontSize: "0.95rem",
      darkMode: true,
      primaryColor: "#2f9ece",
      mainBkg: "#303439",
    },
  })
</script>
<header class="site-header" role="banner">

    <div class="wrapper header-wrapper"><div class="logo-container">
        <div class="logo-image">
          <a class="site-title"
             rel="author"
             href="/">
              <!-- This is the logo image placeholder. -->
                <picture>
                  <source srcset="/assets/dl-logo-icon-dark.svg" media="(max-width: 600px)"/>
                  <img  src="/assets/dl-logo-icon-and-text-dark.svg" />
                </picture>
          </a>
        </div>
      </div><nav class="site-nav">
            <input type="checkbox" id="nav-trigger" class="nav-trigger"/>
            <label for="nav-trigger">
          <span class="menu-icon">
              <svg class="svg-icon">
              <use xlink:href="/assets/minima-social-icons.svg#menu">
              </use>
            </svg>
          </span>
            </label>

            <div class="trigger"><!--
    Iterate over all the pages in the site, where page_cursor holds the current
    page for each pass of the for loop.
    Note that page is the currently loaded page itself.
--><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Android/"> Android </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/CC/"> Concurrency </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/CLI/"> CLI </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/CS/"> CS </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/DB/"> Database </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/DI/"> DI </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/FE/"> Frontend </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Hardware/"> Hardware </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/IJ/"> IntelliJ </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/KT/"> Kotlin </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Linux/"> Linux </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/MP/"> MP </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Misc/"> Misc </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Node/"> Node </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Productivity/"> Productivity </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/RN/"> React-Native </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/React/"> React </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Rust/"> Rust </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Server/"> Server </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/State/"> State-Management </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Stories/"> Stories </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/TDD/"> Testing </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/TS/"> TypeScript </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/TUI/"> TUI </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Web/"> Web </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/about-me/"> Nazmul Idris </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/about-site/"> About Us </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/authors/"> Authors </a></div>
        </nav></div>
</header>

<!-- Debug to show the value of page.title and page.category variables -->
<!--<pre>page_cursor.exclude = nil</pre>-->
<!--<pre>page.exclude = nil</pre>-->
<!--<pre>page.title = &quot;Guide to parsing with nom&quot;</pre>-->
<!--<pre>page.category = nil</pre>-->
<!--<pre>page.title (json) = Guide to parsing with nom</pre>-->
<!--<pre>page.category (json) = </pre>-->
<div class="page-and-sidebar-wrapper">
      <main class="page-content" aria-label="Content">
        <div class="wrapper"><article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting"><header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Guide to parsing with nom</h1>

    <!-- Create all the variables needed for this page (and all the includes) -->
    

    <div class="post-meta">
        <p>
            <!-- Date -->Feb 20, 2023

            <!--Author-->
            ‚àô <a href="/about-me">Nazmul Idris</a>

            <!-- One line social blurb --><ul class="contact-list">
    <li class="p-name">Hi, I'm
            <a href="/about-me">Nazmul</a>,
            an ex-Googler, <a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/tui" target="_blank">r3bl_tui maintainer</a>, SWE, entrepreneur, designer, leader,
            TaiChi-er, racer, storyteller.
            <!-- This is font awesome icon -->
            I <i class="fas fa-heart"></i>
            leadership, authenticity, empowerment, lifelong learning,
            <i class="fas fa-code"></i>,
            <i class="fas fa-terminal"></i>, &
            <i class="fas fa-coffee"></i>,
            üòÉ.</li>
</ul>
</p>
    </div><div class="social-media-container">
  <!-- <iframe
    src="https://github.com/sponsors/nazmulidris/button"
    title="Sponsor nazmulidris"
    height="35"
    width="116"
    style="border: 0; padding-right: 6px"
  ></iframe> -->

  <a href="/subscribe.html" target="_blank"
    ><kbd>Subscribe for updates</kbd></a
  ><p class="social-media-item">
    <a
      href="https://www.linkedin.com/in/nazmulidris"
      target="_blank"
    >
      <svg class="svg-icon">
        <use xlink:href="/assets/minima-social-icons.svg#linkedin"></use>
      </svg>
    </a>
  </p><p class="social-media-item">
    <a href="https://www.youtube.com/channel/UCMcsxfCwzwDevc3NRqFgfEg" target="_blank">
      <svg class="svg-icon">
        <use xlink:href="/assets/minima-social-icons.svg#youtube"></use>
      </svg>
    </a>
  </p><p class="social-media-item">
    <a href="https://www.github.com/nazmulidris" target="_blank">
      <svg class="svg-icon">
        <use xlink:href="/assets/minima-social-icons.svg#github"></use>
      </svg>
    </a>
  </p><p class="social-media-item">
    <a href="/feed.xml" target="_blank">
      <svg class="svg-icon">
        <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
      </svg>
    </a>
  </p></div>
</header>
<div class="post-content e-content" itemprop="articleBody">
        
<blockquote>

üëÄ Watch Rust ü¶Ä live coding videos on our <a
href="https://www.youtube.com/@developerlifecom">YouTube Channel</a>.

<br/>

<iframe width="560" height="315"
  src="https://www.youtube.com/embed/videoseries?si=7gmhXY5DVYJG7OdU&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8"
  title="YouTube video player" frameborder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
  referrerpolicy="strict-origin-when-cross-origin" allowfullscreen>
</iframe>

</blockquote>

        <!-- If a page has a hero-image defined in it, then show it here -->


        <p><img class="post-hero-image" src="/assets/nom-parser.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#documentation">Documentation</a></li>
  <li><a href="#getting-to-know-nom-using-a-simple-example">Getting to know nom using a simple example</a>
    <ul>
      <li><a href="#parsing-hex-color-codes">Parsing hex color codes</a></li>
      <li><a href="#what-does-this-code-do-how-does-it-work">What does this code do, how does it work?</a></li>
      <li><a href="#generalized-workflow">Generalized workflow</a></li>
    </ul>
  </li>
  <li><a href="#build-a-markdown-parser">Build a Markdown parser</a></li>
</ul>

<!-- /TOC -->
      <h2 id="introduction">
        
        
          Introduction <a href="#introduction">#</a>
        
        
      </h2>
    
<p><a id="markdown-introduction" name="introduction"></a></p>

<p>This tutorial is a guide to parsing with nom. It covers the basics of parsing and how to use nom to
parse a string into a data structure. We will cover a variety of different examples ranging from
parsing simple CSS like syntax to a full blown Markdown parser.</p>

<p>This tutorial has 2 examples in it:</p>

<ol>
  <li><a href="#getting-to-know-nom-using-a-simple-example">CSS style syntax</a></li>
  <li><a href="#build-a-markdown-parser">Markdown parser</a></li>
</ol>
<blockquote>

üëÄ Watch Rust ü¶Ä live coding videos on our <a href="https://www.youtube.com/@developerlifecom">YouTube Channel</a>.

<br />
<br />

<iframe width="560" height="315" src="https://www.youtube.com/embed/videoseries?si=7gmhXY5DVYJG7OdU&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<br />
<br />

üì¶ Install our useful Rust command line apps using <code>cargo install r3bl-cmdr</code>
(they are from the <a href="https://github.com/r3bl-org/r3bl-open-core">r3bl-open-core</a>
project):
<ul>
  <li>üê±<code>giti</code>: run interactive git commands with confidence in your terminal</li>
  <li>ü¶ú<code>edi</code>: edit Markdown with style in your terminal</li>
</ul>

<p>
<kbd>giti in action</kbd>
<video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/262f59d1-a95c-4af3-accf-c3d6cac6e586" type="video/mp4" />
</video>
</p>

<p>
<kbd>edi in action</kbd>
<video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/f2c4b07d-b5a2-4f41-af7a-06d1b6660c41" type="video/mp4" />
</video>
</p>

</blockquote>
<blockquote>
  <p>For more information on general Rust type system design (functional approach rather than
object oriented), please take a look at this <a href="https://arxiv.org/pdf/2307.07069.pdf">paper</a>
by Will Crichton demonstrating Typed Design Patterns with Rust.</p>
</blockquote>
      <h2 id="documentation">
        
        
          Documentation <a href="#documentation">#</a>
        
        
      </h2>
    
<p><a id="markdown-documentation" name="documentation"></a></p>

<p>nom is a huge topic. This tutorial takes a hands on approach to learning nom. However, the resources
listed below are very useful for learning nom. Think of them as a reference guide and deep dive into
how the nom library works.</p>

<ul>
  <li>Useful:
    <ul>
      <li>Source code examples (fantastic way to learn nom):
        <ul>
          <li><a href="https://github.com/dimfeld/export-logseq-notes/tree/master/src">export-logseq-notes repo</a></li>
        </ul>
      </li>
      <li>Videos:
        <ul>
          <li><a href="https://youtu.be/EXEMm5173SM">Intro from the author 7yrs old</a></li>
          <li>Nom 7 deep dive videos:
            <ul>
              <li><a href="https://youtu.be/Igajh2Vliog">Parsing name, age, and preference from natural language input</a></li>
              <li><a href="https://youtu.be/Xm4jrjohDN8">Parsing number ranges</a></li>
              <li><a href="https://youtu.be/6b2ymQWldoE">Parsing lines of text</a></li>
            </ul>
          </li>
          <li>Nom 6 videos (deep dive into how nom combinators themselves are constructed):
            <ul>
              <li><a href="https://youtu.be/zHF6j1LvngA">Deep dive, Part 1</a></li>
              <li><a href="https://youtu.be/9GLFJcSO08Y">Deep dive, Part 2</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Tutorials:
        <ul>
          <li><a href="https://codeandbitters.com/lets-build-a-parser/">Build a JSON parser using nom7</a></li>
          <li><a href="https://github.com/benkay86/nom-tutorial">Excellent beginner to advanced</a></li>
          <li><a href="https://github.com/rust-bakery/nom/blob/main/doc/making_a_new_parser_from_scratch.md">Write a parser from scratch</a></li>
        </ul>
      </li>
      <li>Reference docs:
        <ul>
          <li><a href="https://tfpk.github.io/nominomicon/introduction.html">nominomicon</a></li>
          <li><a href="https://github.com/rust-bakery/nom/blob/main/doc/choosing_a_combinator.md">What combinator or parser to use?</a></li>
          <li><a href="https://docs.rs/nom/7.1.3/nom/">docs.rs</a></li>
          <li><a href="https://github.com/rust-bakery/nom/blob/main/doc/upgrading_to_nom_5.md">Upgrading to nom 5.0</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Less useful:
    <ul>
      <li><a href="https://github.com/rust-bakery/nom">README</a></li>
      <li><a href="https://crates.io/crates/nom">nom crate</a></li>
    </ul>
  </li>
</ul>
      <h2 id="getting-to-know-nom-using-a-simple-example">
        
        
          Getting to know nom using a simple example <a href="#getting-to-know-nom-using-a-simple-example">#</a>
        
        
      </h2>
    
<p><a id="markdown-getting-to-know-nom-using-a-simple-example" name="getting-to-know-nom-using-a-simple-example"></a></p>

<p><a href="https://crates.io/crates/nom">nom</a> is a parser combinator library for Rust. You can write small
functions that parse a specific part of your input, and then combine them to build a parser that
parses the whole input. nom is very efficient and fast, it does not allocate memory when parsing if
it doesn‚Äôt have to, and it makes it very easy for you to do the same. nom uses streaming mode or
complete mode, and in this tutorial &amp; code examples provided we will be using complete mode.</p>

<p>Roughly the way it works is that you tell nom how to parse a bunch of bytes in a way that matches
some pattern that is valid for your data. It will try to parse as much as it can from the input, and
the rest of the input will be returned to you.</p>

<p>You express the pattern that you‚Äôre looking for by combining parsers. nom has a whole bunch of these
that come out of the box. And a huge part of learning nom is figuring out what these built in
parsers are and how to combine them to build a parser that does what you want.</p>

<p>Errors are a key part of it being able to apply a variety of different parsers to the same input. If
a parser fails, nom will return an error, and the rest of the input will be returned to you. This
allows you to combine parsers in a way that you can try to parse a bunch of different things, and if
one of them fails, you can try the next one. This is very useful when you are trying to parse a
bunch of different things, and you don‚Äôt know which one you are going to get.</p>
      <h3 id="parsing-hex-color-codes">
        
        
          Parsing hex color codes <a href="#parsing-hex-color-codes">#</a>
        
        
      </h3>
    
<p><a id="markdown-parsing-hex-color-codes" name="parsing-hex-color-codes"></a></p>

<p>Let‚Äôs dive into nom using a simple example of parsing
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color">hex color codes</a>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">//! This module contains a parser that parses a hex color string into a [Color] struct.</span>
<span class="cd">//! The hex color string can be in the following format `#RRGGBB`.</span>
<span class="cd">//! For example, `#FF0000` is red.</span>

<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">num</span><span class="p">::</span><span class="n">ParseIntError</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">nom</span><span class="p">::{</span><span class="nn">bytes</span><span class="p">::</span><span class="nn">complete</span><span class="p">::</span><span class="o">*</span><span class="p">,</span> <span class="nn">combinator</span><span class="p">::</span><span class="o">*</span><span class="p">,</span> <span class="nn">error</span><span class="p">::</span><span class="o">*</span><span class="p">,</span> <span class="nn">sequence</span><span class="p">::</span><span class="o">*</span><span class="p">,</span> <span class="n">IResult</span><span class="p">,</span> <span class="n">Parser</span><span class="p">};</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Color</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">red</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">green</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">blue</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Color</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">red</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">green</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">blue</span><span class="p">:</span> <span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cd">/// Helper functions to match and parse hex digits. These are not [Parser]</span>
<span class="cd">/// implementations.</span>
<span class="k">mod</span> <span class="n">helper_fns</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="cd">/// This function is used by [map_res] and it returns a [Result], not [IResult].</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">parse_str_to_hex_num</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="nn">std</span><span class="p">::</span><span class="nn">num</span><span class="p">::</span><span class="n">ParseIntError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nn">u8</span><span class="p">::</span><span class="nf">from_str_radix</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="cd">/// This function is used by [take_while_m_n] and as long as it returns `true`</span>
    <span class="cd">/// items will be taken from the input.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">match_is_hex_digit</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="nb">char</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="n">c</span><span class="nf">.is_ascii_hexdigit</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">parse_hex_seg</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IResult</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="nb">u8</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">map_res</span><span class="p">(</span>
            <span class="nf">take_while_m_n</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">match_is_hex_digit</span><span class="p">),</span>
            <span class="n">parse_str_to_hex_num</span><span class="p">,</span>
        <span class="p">)(</span><span class="n">input</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cd">/// These are [Parser] implementations that are used by [hex_color_no_alpha].</span>
<span class="k">mod</span> <span class="n">intermediate_parsers</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="cd">/// Call this to return function that implements the [Parser] trait.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">gen_hex_seg_parser_fn</span><span class="o">&lt;</span><span class="nv">'input</span><span class="p">,</span> <span class="n">E</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="n">Parser</span><span class="o">&lt;&amp;</span><span class="nv">'input</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">E</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">E</span><span class="p">:</span> <span class="n">FromExternalError</span><span class="o">&lt;&amp;</span><span class="nv">'input</span> <span class="nb">str</span><span class="p">,</span> <span class="n">ParseIntError</span><span class="o">&gt;</span> <span class="o">+</span> <span class="n">ParseError</span><span class="o">&lt;&amp;</span><span class="nv">'input</span> <span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nf">map_res</span><span class="p">(</span>
            <span class="nf">take_while_m_n</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nn">helper_fns</span><span class="p">::</span><span class="n">match_is_hex_digit</span><span class="p">),</span>
            <span class="nn">helper_fns</span><span class="p">::</span><span class="n">parse_str_to_hex_num</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cd">/// This is the "main" function that is called by the tests.</span>
<span class="k">fn</span> <span class="nf">hex_color_no_alpha</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IResult</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">Color</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// This tuple contains 3 ways to do the same thing.</span>
    <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="p">(</span>
        <span class="nn">helper_fns</span><span class="p">::</span><span class="n">parse_hex_seg</span><span class="p">,</span>
        <span class="nn">intermediate_parsers</span><span class="p">::</span><span class="nf">gen_hex_seg_parser_fn</span><span class="p">(),</span>
        <span class="nf">map_res</span><span class="p">(</span>
            <span class="nf">take_while_m_n</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nn">helper_fns</span><span class="p">::</span><span class="n">match_is_hex_digit</span><span class="p">),</span>
            <span class="nn">helper_fns</span><span class="p">::</span><span class="n">parse_str_to_hex_num</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">);</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="nf">tag</span><span class="p">(</span><span class="s">"#"</span><span class="p">)(</span><span class="n">input</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="p">(</span><span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span><span class="p">))</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">(</span><span class="n">it</span><span class="p">)(</span><span class="n">input</span><span class="p">)</span><span class="o">?</span><span class="p">;</span> <span class="c1">// same as `it.parse(input)?`</span>
    <span class="nf">Ok</span><span class="p">((</span><span class="n">input</span><span class="p">,</span> <span class="n">Color</span> <span class="p">{</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="p">}))</span>
<span class="p">}</span>

<span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">parse_valid_color</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">input</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="n">input</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"#2F14DF"</span><span class="p">);</span>
        <span class="n">input</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'üîÖ'</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nd">dbg!</span><span class="p">(</span><span class="nf">hex_color_no_alpha</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input</span><span class="p">));</span>

        <span class="k">let</span> <span class="nf">Ok</span><span class="p">((</span><span class="n">remainder</span><span class="p">,</span> <span class="n">color</span><span class="p">))</span> <span class="o">=</span> <span class="n">result</span> <span class="k">else</span> <span class="p">{</span> <span class="nd">panic!</span><span class="p">();</span> <span class="p">};</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">remainder</span><span class="p">,</span> <span class="s">"üîÖ"</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="nn">Color</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">47</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">223</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">parse_invalid_color</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nd">dbg!</span><span class="p">(</span><span class="nf">hex_color_no_alpha</span><span class="p">(</span><span class="s">"üîÖ#2F14DF"</span><span class="p">));</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">result</span><span class="nf">.is_err</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
      <h3 id="what-does-this-code-do-how-does-it-work">
        
        
          What does this code do, how does it work? <a href="#what-does-this-code-do-how-does-it-work">#</a>
        
        
      </h3>
    
<p><a id="markdown-what-does-this-code-do%2C-how-does-it-work%3F" name="what-does-this-code-do%2C-how-does-it-work%3F"></a></p>

<p>Please note that:</p>

<ul>
  <li>This string can be parsed: <code class="language-plaintext highlighter-rouge">#2F14DFüîÖ</code>.</li>
  <li>However, this string can‚Äôt <code class="language-plaintext highlighter-rouge">üîÖ#2F14DF</code>.</li>
</ul>

<p>So what is going on in the source code above?</p>

<ol>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">intermediate_parsers::hex_color_no_alpha()</code> function is the main function that orchestrates
all the other functions to parse an <code class="language-plaintext highlighter-rouge">input: &amp;str</code> and turn it into a <code class="language-plaintext highlighter-rouge">(&amp;str, Color)</code>.</p>

    <ul>
      <li>The <code class="language-plaintext highlighter-rouge">tag</code> combinator function is used to match the <code class="language-plaintext highlighter-rouge">#</code> character. This means that if the input
doesn‚Äôt start with <code class="language-plaintext highlighter-rouge">#</code>, the parser will fail (which is why <code class="language-plaintext highlighter-rouge">üîÖ#2F14DF</code> fails). It returns the
remaining input after <code class="language-plaintext highlighter-rouge">#</code>. And the output is <code class="language-plaintext highlighter-rouge">#</code> which we throw away.</li>
      <li>A <code class="language-plaintext highlighter-rouge">tuple</code> is created that takes 3 parsers, which all do the same exact thing, but are written
in 3 different ways just to demonstrate how these can be written.
        <ol>
          <li>The <code class="language-plaintext highlighter-rouge">helper_fns::parse_hex_seg()</code> function is added to a tuple.</li>
          <li>The higher order function <code class="language-plaintext highlighter-rouge">intermediate_parsers::gen_hex_seg_parser_fn()</code> is added to the
tuple.</li>
          <li>Finally, the <code class="language-plaintext highlighter-rouge">map_res</code> combinator is directly added to the tuple.</li>
        </ol>
      </li>
      <li>An extension function on this tuple called <code class="language-plaintext highlighter-rouge">parse()</code> is called w/ the <code class="language-plaintext highlighter-rouge">input</code> (thus far). This
is used to parse the input hex number.
        <ul>
          <li>It returns the remaining input after the hex number which is why <code class="language-plaintext highlighter-rouge">#2F14DFüîÖ</code> returns <code class="language-plaintext highlighter-rouge">üîÖ</code> as
the first item in the tuple.</li>
          <li>The second item in the tuple is the parsed color string turned into a <code class="language-plaintext highlighter-rouge">Color</code> struct.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Let‚Äôs look at the <code class="language-plaintext highlighter-rouge">helper_fns::parse_hex_seg</code> (the other 2 ways shown above do the same exact
thing). The signature of this function tells nom that you can call the function w/ <code class="language-plaintext highlighter-rouge">input</code>
argument and it will return <code class="language-plaintext highlighter-rouge">IResult&lt;Input, Output, Error&gt;</code>. This signature is the pattern that
we will end up using to figure out how to chain combinators together. Here‚Äôs how the <code class="language-plaintext highlighter-rouge">map_res</code>
combinator is used by <code class="language-plaintext highlighter-rouge">parse_hex_seg()</code> to actually do the parsing:</p>

    <ol>
      <li><code class="language-plaintext highlighter-rouge">take_while_m_n</code>: This combinator takes a range of characters (<code class="language-plaintext highlighter-rouge">2, 2</code>) and applies the
function <code class="language-plaintext highlighter-rouge">match_is_hex_digit</code> to determine whether the <code class="language-plaintext highlighter-rouge">char</code> is a hex digit (using
<code class="language-plaintext highlighter-rouge">is_ascii_hexdigit()</code> on the <code class="language-plaintext highlighter-rouge">char</code>). This is used to match a valid hex digit. It returns a
<code class="language-plaintext highlighter-rouge">&amp;str</code> slice of the matched characters. Which is then passed to the next combinator.</li>
      <li><code class="language-plaintext highlighter-rouge">parse_str_to_hex_num</code>: This parser is used on the string slice returned from above. It simply
takes string slice and turns it into a <code class="language-plaintext highlighter-rouge">Result&lt;u8&gt;, std::num::ParseIntError&gt;</code>. The error is
important, since if the string slice is not a valid hex digit, then we want to return this
error.</li>
    </ol>
  </li>
  <li>
    <p>The key concept in nom is the <code class="language-plaintext highlighter-rouge">Parser</code> trait which is implemented for any <code class="language-plaintext highlighter-rouge">FnMut</code> that accepts an
input and returns an <code class="language-plaintext highlighter-rouge">IResult&lt;Input, Output, Error&gt;</code>.</p>
    <ul>
      <li>If you write a simple function w/ the signature
<code class="language-plaintext highlighter-rouge">fn(input: Input) -&gt; IResult&lt;Input, Output, Error&gt;</code> then you are good to go! You just need to
call <code class="language-plaintext highlighter-rouge">parse()</code> on the <code class="language-plaintext highlighter-rouge">Input</code> type and this will kick off the parsing.</li>
      <li>Alternatively, you can just call the nom <code class="language-plaintext highlighter-rouge">tuple</code> function directly via
<code class="language-plaintext highlighter-rouge">nom::sequence::tuple(...)(input)?</code>. Or you can just call the <code class="language-plaintext highlighter-rouge">parse()</code> method on the tuple
since this is an extension function on tuples provided by nom.</li>
      <li><code class="language-plaintext highlighter-rouge">IResult</code> is a very important type alias. It encapsulates 3 key types that are related to
parsing:
        <ol>
          <li>The <code class="language-plaintext highlighter-rouge">Input</code> type is the type of the input that is being parsed. For example, if you are
parsing a string, then the <code class="language-plaintext highlighter-rouge">Input</code> type is <code class="language-plaintext highlighter-rouge">&amp;str</code>.</li>
          <li>The <code class="language-plaintext highlighter-rouge">Output</code> type is the type of the output that is returned by the parser. For example, if
you are parsing a string and you want to return a <code class="language-plaintext highlighter-rouge">Color</code> struct, then the <code class="language-plaintext highlighter-rouge">Output</code> type is
<code class="language-plaintext highlighter-rouge">Color</code>.</li>
          <li>The <code class="language-plaintext highlighter-rouge">Error</code> type is the type of the error that is returned by the parser. For example, if
you are parsing a string and you want to return a <code class="language-plaintext highlighter-rouge">nom::Err::Error</code> error, then the <code class="language-plaintext highlighter-rouge">Error</code>
type is <code class="language-plaintext highlighter-rouge">nom::Err::Error</code>. This is very useful when you are developing your parser
combinators and you run into errors and have to debug them.</li>
        </ol>
      </li>
    </ul>
  </li>
</ol>
      <h3 id="generalized-workflow">
        
        
          Generalized workflow <a href="#generalized-workflow">#</a>
        
        
      </h3>
    
<p><a id="markdown-generalized-workflow" name="generalized-workflow"></a></p>

<p>After the really complicated walk through above, we could have just written the entire thing
concisely like so:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">parse_hex_seg</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IResult</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="nb">u8</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nf">map_res</span><span class="p">(</span>
    <span class="nf">take_while_m_n</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">|</span><span class="n">it</span><span class="p">:</span> <span class="nb">char</span><span class="p">|</span> <span class="n">it</span><span class="nf">.is_ascii_hexdigit</span><span class="p">()),</span>
    <span class="p">|</span><span class="n">it</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">|</span> <span class="nn">u8</span><span class="p">::</span><span class="nf">from_str_radix</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span>
  <span class="p">)(</span><span class="n">input</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">hex_color_no_alpha</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IResult</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">Color</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">let</span> <span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="nf">tag</span><span class="p">(</span><span class="s">"#"</span><span class="p">)(</span><span class="n">input</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
  <span class="k">let</span> <span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="p">(</span><span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span><span class="p">))</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">((</span>
    <span class="nn">helper_fns</span><span class="p">::</span><span class="n">parse_hex_seg</span><span class="p">,</span>
    <span class="nn">helper_fns</span><span class="p">::</span><span class="n">parse_hex_seg</span><span class="p">,</span>
    <span class="nn">helper_fns</span><span class="p">::</span><span class="n">parse_hex_seg</span><span class="p">,</span>
  <span class="p">))(</span><span class="n">input</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
  <span class="nf">Ok</span><span class="p">((</span><span class="n">input</span><span class="p">,</span> <span class="n">Color</span> <span class="p">{</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="p">}))</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This is a very simple example, but it shows how you can combine parsers together to create more
complex parsers. You start w/ the simplest one first, and then build up from there.</p>

<ul>
  <li>In this case the simplest one is <code class="language-plaintext highlighter-rouge">parse_hex_seg()</code> which is used to parse a single hex segment.
Inside this function we call <code class="language-plaintext highlighter-rouge">map_res()</code> w/ the supplied <code class="language-plaintext highlighter-rouge">input</code> and simply return the result.
This is also a very common thing to do, is to wrap calls to other parsers in functions and then
re-use them in other parsers.</li>
  <li>Finally, the <code class="language-plaintext highlighter-rouge">hex_color_no_alpha()</code> function is used to parse a hex color w/o an alpha channel.
    <ul>
      <li>The <code class="language-plaintext highlighter-rouge">tag()</code> combinator is used to match the <code class="language-plaintext highlighter-rouge">#</code> character.</li>
      <li>The <code class="language-plaintext highlighter-rouge">tuple()</code> combinator is used to match the 3 hex segments.</li>
      <li>The <code class="language-plaintext highlighter-rouge">?</code> operator is used to return the error if there is one.</li>
      <li>The <code class="language-plaintext highlighter-rouge">Ok()</code> is used to return the parsed <code class="language-plaintext highlighter-rouge">Color</code> struct and the remaining input.</li>
    </ul>
  </li>
</ul>
      <h2 id="build-a-markdown-parser">
        
        
          Build a Markdown parser <a href="#build-a-markdown-parser">#</a>
        
        
      </h2>
    
<p><a id="markdown-build-a-markdown-parser" name="build-a-markdown-parser"></a></p>

<blockquote>
  <p>üí° You can get the source code for the Markdown parser shown in this article from the
<a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/tui/src/tui/md_parser"><code class="language-plaintext highlighter-rouge">r3bl-open-core</code></a>
repo.</p>

  <p>üåü Please star this repo on github if you like it üôè.</p>
</blockquote>

<p>The <a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/tui/src/tui/md_parser"><code class="language-plaintext highlighter-rouge">md_parser</code></a> module
in the <code class="language-plaintext highlighter-rouge">r3bl-open-core</code> repo contains a fully functional Markdown parser (and isn‚Äôt written as a test
but a real module that you can use in your projects that need a Markdown parser). This parser
supports standard Markdown syntax as well as some extensions that are added to make it work w/ R3BL
products. It makes a great starting point to study how a relatively complex parser is written. There
are lots of tests that you can follow along to understand what the code is doing.</p>

<p>Here are some entry points into the codebase.</p>

<ol>
  <li>
    <p>The main function
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/parser.rs"><code class="language-plaintext highlighter-rouge">parse_markdown()</code></a>
that does the parsing of a string slice into a
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/types.rs"><code class="language-plaintext highlighter-rouge">Document</code></a>.
The tests are provided alongside the code itself. And you can follow along to see how other
smaller parsers are used to build up this big one that parses the whole of the Markdown document.</p>

    <ol>
      <li>All the parsers related to parsing metadata specific for R3BL applications which are not
standard Markdown can be found in
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/parser_impl_metadata.rs"><code class="language-plaintext highlighter-rouge">parser_impl_metadata</code></a>.</li>
      <li>All the parsers that are related to parsing the main ‚Äúblocks‚Äù of Markdown, such as order
lists, unordered lists, code blocks, text blocks, heading blocks, can be found
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/parser_impl_block.rs"><code class="language-plaintext highlighter-rouge">parser_impl_block</code></a></li>
      <li>All the parsers that are related to parsing a single line of Markdown text, such as links,
bold, italic, etc. can be found
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/parser_impl_element.rs"><code class="language-plaintext highlighter-rouge">parser_impl_element</code></a></li>
    </ol>
  </li>
  <li>
    <p>The <a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/types.rs">types</a>
that are used to represent the Markdown document model
(<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/types.rs"><code class="language-plaintext highlighter-rouge">Document</code></a>)
and all the other intermediate types (<code class="language-plaintext highlighter-rouge">Fragment</code>, <code class="language-plaintext highlighter-rouge">Block</code>, etc) &amp; enums required for parsing.</p>
  </li>
</ol>

        <!--
    Display all the categories for this page
    More info:
    - Tutorial - http://tinyurl.com/yc6fq6zx
    - Liquid language reference - http://tinyurl.com/y8s4qpwo
-->
<div class="categories-block">
    
    
    <span class="category">
            <a href="/category/Rust">
                #rust</a>
        </span>
    
</div>

        
<blockquote>

üì¶ Install our useful Rust command line apps using <code>cargo install r3bl-cmdr</code>
(they are from the <a href="https://github.com/r3bl-org/r3bl-open-core">r3bl-open-core</a>
project):
<ul>
  <li>üê±<code>giti</code>: run interactive git commands with confidence in your terminal</li>
  <li>ü¶ú<code>edi</code>: edit Markdown with style in your terminal</li>
</ul>

<p>
<kbd>giti in action</kbd>
<video width="100%" controls>
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/262f59d1-a95c-4af3-accf-c3d6cac6e586" type="video/mp4"/>
</video>
</p>

<p>
<kbd>edi in action</kbd>
<video width="100%" controls>
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/f2c4b07d-b5a2-4f41-af7a-06d1b6660c41" type="video/mp4"/>
</video>
</p>

</blockquote>

        <!--
    Display related posts (by category)
    More info:
    - Tutorial - http://tinyurl.com/j5tevq7
    - Liquid language reference - http://tinyurl.com/y9ru5msq
-->
<div class="related-post-block">

    <h3>Related Posts</h3>

    <!-- Get all the related posts into the string `postsString`-->
    
    
    

    <!--
        At this point `postsString` string might look like:
        Post 3|Post 1|Post 3|Post 2|Post 1|Post 3|Post 2|
    -->

    <!-- Remove all the dupes from the `postsString` string, and split it into an array -->
    

    <ul>
        
            
                
                <li>
                    <a class="post-list" href="/2024/01/13/write-simple-netcat-in-rust/">
                        Write a simple netcat client and server in Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/01/13/write-simple-chat-server-in-rust/">
                        Write a simple TCP chat server in Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2023/09/17/tuify-clap/">
                        tuify your clap CLI apps and make them more interactive
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2023/08/28/justfile/">
                        Use just to manage project specific commands
                    </a>
                </li>
            
        
            
        
            
                
                <li>
                    <a class="post-list" href="/2022/08/04/rust-dsl-part-1/">
                        Create a simple DSL for CSS like syntax for TUIs
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2022/03/30/rust-proc-macro/">
                        Guide to Rust procedural macros
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2022/03/12/rust-redux/">
                        Write a Redux library in Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2022/03/12/rust-tokio/">
                        Write code using async/await in Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2022/03/02/rust-grep-cli-app/">
                        Build a grep CLI app in Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2022/02/24/rust-non-binary-tree/">
                        Build a non-binary tree that is thread safe using Rust
                    </a>
                </li>
            
        
    </ul>

</div>

        <a class="u-url" href="/2023/02/20/guide-to-nom-parsing/" hidden></a>
    </div></article>
</div>
      </main><div>
  <section class="sidebar">
    <h2 class="star-us-github-heading">
      Subscribe to our Rust live coding <a
      href="https://www.youtube.com/@developerlifecom">YouTube Channel</a><span
      class="heading-emoji"> ü¶Ä</span>
    </h2>

    <iframe width="330" height="185"
      src="https://www.youtube.com/embed/videoseries?si=i37Ei9nCfvslOoaI&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE"
      title="YouTube video player" frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
      referrerpolicy="strict-origin-when-cross-origin" allowfullscreen>
    </iframe>

    <br/>
    <br/>

    <h2 class="star-us-github-heading">
      Use our extensions, apps, binary and library crates<span class="heading-emoji"> üì¶</span>
    </h2>

    <ul class="sidebar-ul">
      <li class="app-container">
        <a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/cmdr" target="_blank">
          <img class="star-icon-img" src="/assets/r3bl-apps.svg" />
          <div class="sidebar-list-item">
            <p class="p-tag">INSTALL & USE OUR APPS (giti, edi)</p>
            <h3 class="sidebar-h3"><code>r3bl-cmdr</code></h3>
          </div>
        </a>
      </li>
      <li class="app-container">
        <a href="https://github.com/r3bl-org/shortlink" target="_blank">
          <img class="star-icon-img" src="/assets/r3bl-shortlink.svg" />
          <div class="sidebar-list-item">
            <p class="p-tag">SHORTLINK browser extension</p>
            <h3 class="sidebar-h3"><code>shortlink</code></h3>
          </div>
        </a>
      </li>
      <li class="app-container">
        <a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/tui" target="_blank">
          <img class="star-icon-img" src="/assets/crate.png" />
          <div class="sidebar-list-item">
            <p class="p-tag">R3BL TUI LIB</p>
            <h3 class="sidebar-h3"><code>r3bl_tui</code></h3>
          </div>
        </a>
      </li>
      <li class="app-container">
        <a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/tuify" target="_blank">
          <img class="star-icon-img" src="/assets/crate.png" />
          <div class="sidebar-list-item">
            <p class="p-tag">R3BL TUIFY LIB</p>
            <h3 class="sidebar-h3"><code>r3bl_tuify</code></h3>
          </div>
        </a>
      </li>
      <li class="app-container">
        <a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/terminal_async" target="_blank">
          <img class="star-icon-img" src="/assets/crate.png" />
          <div class="sidebar-list-item">
            <p class="p-tag">R3BL TERMINAL ASYNC LIB</p>
            <h3 class="sidebar-h3"><code>r3bl_terminal_async</code></h3>
          </div>
        </a>
      </li>
    </ul>
  </section>
</div>


</div><footer class="site-footer h-card">

    <div class="wrapper">

        <div class="footer-col-wrapper">

            <div class="footer-col"><!-- <p>
    developerlife.com site was started in Nov 1998 with coverage for
    topics related to Java, XML, and web and desktop technologies.
    Today it covers Kotlin, TypeScript, Node.js, React, Android, JDK,
    Web, Cloud technologies, User Experience Engineering (UXE)
    and design topics. ¬© Nazmul Idris 2022. All rights reserved.
</p> -->
<div>
  <p class="footer-p">
    developerlife.com site was started in Nov 1998 by <a href="https://developerlife.com/about-me/">Nazmul Idris</a>, with coverage for topics related to Java, XML,
    and web and desktop technologies. Today it covers Rust, TUI, CLI, Kotlin, TypeScript, Node.js, React, Android,
    JDK, Web, Cloud technologies, User Experience Engineering (UXE) and design topics. ¬© Nazmul
    Idris 2022. All rights reserved.
  </p>
  <div class="footer-container">
    <!-- element 1 -->
    <kbd>
      <a class="footer-elem-1" href="/subscribe.html" target="_blank"
        >Subscribe for updates</a
      >
    </kbd>

    <!-- element 2 -->
    <kbd>
      <a class="footer-elem-2" href="https://r3bl.com" target="_blank">Sponsored by R3BL</a>
    </kbd>
  </div>
</div>
</div>

        </div>

    </div>

</footer>
<script>
//open external links in a new window
function external_new_window() {
    for(var c = document.getElementsByTagName("a"), a = 0;a < c.length;a++) {
    var b = c[a];
    b.getAttribute("href") && b.hostname !== location.hostname && (b.target = "_blank")
    }
}
//open PDF links in a new window
function pdf_new_window ()
{
    if (!document.getElementsByTagName) return false;
    var links = document.getElementsByTagName("a");
    for (var eleLink=0; eleLink < links.length; eleLink ++) {
    if ((links[eleLink].href.indexOf('.pdf') !== -1)||(links[eleLink].href.indexOf('.doc') !== -1)||(links[eleLink].href.indexOf('.docx') !== -1)) {
        links[eleLink].onclick =
        function() {
            window.open(this.href);
            return false;
        }
    }
    }
} 
pdf_new_window()
external_new_window();
</script></body>
</html>
