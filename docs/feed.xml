<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://developerlife.com/feed.xml" rel="self" type="application/atom+xml" /><link href="http://developerlife.com/" rel="alternate" type="text/html" /><updated>2024-06-29T15:09:08-05:00</updated><id>http://developerlife.com/feed.xml</id><title type="html">developerlife.com</title><subtitle>Rust, TUI, Android, Web, Desktop, Cloud technologies, and UX engineering and design tutorials.</subtitle><author><name>Nazmul Idris</name></author><entry><title type="html">Build with Naz : Markdown parser in Rust and nom from r3bl_tui</title><link href="http://developerlife.com/2024/06/28/md-parser-rust-from-r3bl-tui/" rel="alternate" type="text/html" title="Build with Naz : Markdown parser in Rust and nom from r3bl_tui" /><published>2024-06-28T10:00:00-05:00</published><updated>2024-06-28T10:00:00-05:00</updated><id>http://developerlife.com/2024/06/28/md-parser-rust-from-r3bl-tui</id><content type="html" xml:base="http://developerlife.com/2024/06/28/md-parser-rust-from-r3bl-tui/"><![CDATA[<p><img class="post-hero-image" src="/assets/rust-tui-md-parser.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#nom-crate-review">nom crate review</a></li>
  <li><a href="#a-real-production-grade-markdown-parser-example">A real production grade Markdown parser example</a></li>
  <li><a href="#related-video">Related video</a></li>
  <li><a href="#architecture-and-parsing-order">Architecture and parsing order</a></li>
  <li><a href="#references">References</a></li>
</ul>

<!-- /TOC -->

<h2 id="introduction">Introduction</h2>
<p><a id="markdown-introduction" name="introduction"></a></p>

<p>This tutorial is a deep dive in a real Markdown parser written using nom in Rust. This MD
Parser is part of the <a href="https://crates.io/crates/r3bl_tui"><code class="language-plaintext highlighter-rouge">r3bl_tui</code></a> crate, which is part
of the <code class="language-plaintext highlighter-rouge">r3bl-open-core</code> repo. It goes over the architecture of thinking about building
complex parsers and the nitty gritty details the runtime nature and behavior when
combining nom parsers.</p>

<p>The <a href="https://crates.io/crates/r3bl_tui"><code class="language-plaintext highlighter-rouge">r3bl_tui</code></a> crate is a Text User Interface (TUI)
crate that is used in the <a href="https://r3bl.com">R3BL</a> suite of products. It is a very
powerful and flexible TUI crate that is used to build a variety of different applications.
It comes with a full featured Markdown editor component, and the parser that‚Äôs the focus
on this tutorial is used by that editor component to parse an input string slice into a
Markdown document model (AST representation in memory).</p>
<blockquote>

üëÄ Watch Rust ü¶Ä live coding videos on our <a href="https://www.youtube.com/@developerlifecom">YouTube Channel</a>.

<br />
<br />

<!-- video on rust polymorphism (no playlist) -->
<iframe src="https://www.youtube.com/embed/kYTgGtJjSro?si=XmW-_CAvCfB5e269" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<br />
<br />

üì¶ Install our useful Rust command line apps using <code>cargo install r3bl-cmdr</code>
(they are from the <a href="https://github.com/r3bl-org/r3bl-open-core">r3bl-open-core</a>
project):
<ul>
  <li>üê±<code>giti</code>: run interactive git commands with confidence in your terminal</li>
  <li>ü¶ú<code>edi</code>: edit Markdown with style in your terminal</li>
</ul>

<p>
<kbd>giti in action</kbd>
<video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/262f59d1-a95c-4af3-accf-c3d6cac6e586" type="video/mp4" />
</video>
</p>

<p>
<kbd>edi in action</kbd>
<video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/f2c4b07d-b5a2-4f41-af7a-06d1b6660c41" type="video/mp4" />
</video>
</p>

</blockquote>
<h2 id="nom-crate-review">nom crate review</h2>
<p><a id="markdown-nom-crate-review" name="nom-crate-review"></a></p>

<p><a href="https://crates.io/crates/nom"><code class="language-plaintext highlighter-rouge">nom</code></a> is a parser combinator library for Rust. You can write small
functions that parse a specific part of your input, and then combine them to build a parser that
parses the whole input. <code class="language-plaintext highlighter-rouge">nom</code> is very efficient and fast, it does not allocate memory when parsing if
it doesn‚Äôt have to, and it makes it very easy for you to do the same. <code class="language-plaintext highlighter-rouge">nom</code> uses streaming mode or
complete mode, and in this tutorial &amp; code examples provided we will be using complete mode.</p>

<p>Roughly the way it works is that you tell <code class="language-plaintext highlighter-rouge">nom</code> how to parse a bunch of bytes in a way that matches
some pattern that is valid for your data. It will try to parse as much as it can from the input, and
the rest of the input will be returned to you.</p>

<p>You express the pattern that you‚Äôre looking for by combining parsers. <code class="language-plaintext highlighter-rouge">nom</code> has a whole bunch of these
that come out of the box. And a huge part of learning <code class="language-plaintext highlighter-rouge">nom</code> is figuring out what these built in
parsers are and how to combine them to build a parser that does what you want.</p>

<p>Errors are a key part of it being able to apply a variety of different parsers to the same input. If
a parser fails, <code class="language-plaintext highlighter-rouge">nom</code> will return an error, and the rest of the input will be returned to you. This
allows you to combine parsers in a way that you can try to parse a bunch of different things, and if
one of them fails, you can try the next one. This is very useful when you are trying to parse a
bunch of different things, and you don‚Äôt know which one you are going to get.</p>

<blockquote>
  <p>We have a video and article on developerlife where you can learn more about <code class="language-plaintext highlighter-rouge">nom</code> and how to use it.</p>
  <ul>
    <li><a href="https://youtu.be/v3tMwr_ysPg">Video on nom fundamentals</a>.</li>
    <li><a href="https://developerlife.com/2023/02/20/guide-to-nom-parsing/">Article on nom fundamentals</a>.</li>
  </ul>
</blockquote>

<h2 id="a-real-production-grade-markdown-parser-example">A real production grade Markdown parser example</h2>
<p><a id="markdown-a-real-production-grade-markdown-parser-example" name="a-real-production-grade-markdown-parser-example"></a></p>

<p>The production
<a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/tui/src/tui/md_parser"><code class="language-plaintext highlighter-rouge">md_parser</code></a>
module in the <code class="language-plaintext highlighter-rouge">r3bl-open-core</code> repo contains a fully functional Markdown parser (that you
can use in your projects that need a Markdown parser). This parser supports standard
Markdown syntax as well as some extensions that are
added to make it work w/ <a href="https://r3bl.com">R3BL</a> products. It makes a great starting
point to study how a relatively complex parser is written. There are lots of tests that
you can follow along to understand what the code is doing.</p>

<blockquote>
  <p>üí° You can get the source code for the production Markdown parser used in <code class="language-plaintext highlighter-rouge">r3bl_tui</code> from the
<a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/tui/src/tui/md_parser"><code class="language-plaintext highlighter-rouge">r3bl-open-core</code></a>
repo.</p>

  <p>üåü Please star this repo on github if you like it üôè.</p>
</blockquote>

<p>The main entry point (function) for this Markdown parsing module is
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/parse_markdown.rs"><code class="language-plaintext highlighter-rouge">parse_markdown()</code></a>.</p>
<ul>
  <li>It takes a string slice.</li>
  <li>And returns a vector of <a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/types.rs"><code class="language-plaintext highlighter-rouge">MdBlock</code>s</a>.</li>
</ul>

<p>Here are some entry points into the codebase.</p>

<ol>
  <li>The main function
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/parse_markdown.rs"><code class="language-plaintext highlighter-rouge">parse_markdown()</code></a>
that does the parsing of a string slice into a
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/types.rs"><code class="language-plaintext highlighter-rouge">MdDocument</code></a>.
The tests are provided alongside the code itself. And you can follow along to see how
other smaller parsers are used to build up this big one that parses the whole of the
Markdown document.</li>
  <li>The
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/types.rs"><code class="language-plaintext highlighter-rouge">types</code></a> module
contain all the types that are used to represent the Markdown document model, such as <code class="language-plaintext highlighter-rouge">MdDocument</code>, <code class="language-plaintext highlighter-rouge">MdBlock</code>,
<code class="language-plaintext highlighter-rouge">MdLineFragment</code> and all the other intermediate types &amp; enums required for parsing.</li>
  <li>All the parsers related to parsing metadata specific for <a href="https://r3bl.com">R3BL</a>
applications which are not standard Markdown can be found in
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/extended/parse_metadata_kv.rs#L1"><code class="language-plaintext highlighter-rouge">parse_metadata_kv</code></a>
and
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/extended/parse_metadata_kcsv.rs#L1"><code class="language-plaintext highlighter-rouge">parse_metadata_kcsv</code></a>.</li>
  <li>All the parsers that are related to parsing the main ‚Äúblocks‚Äù of Markdown, such as
order lists, unordered lists, code blocks, text blocks, heading blocks, can be
found <a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/block/mod.rs#L3"><code class="language-plaintext highlighter-rouge">block</code></a>.</li>
  <li>All the parsers that are related to parsing a single line of Markdown text, such as
links, bold, italic, etc. can be found
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/fragment/mod.rs#L1"><code class="language-plaintext highlighter-rouge">fragment</code></a>.</li>
</ol>

<h2 id="related-video">Related video</h2>
<p><a id="markdown-related-video" name="related-video"></a></p>

<p>If you like to consume content via video, then you can watch this video that covers the same content
as this article, but in a live coding format.</p>

<!-- video on nom -->
<iframe src="https://www.youtube.com/embed/SbwvSHZRb1E?si=8UFyEKyF8sHnam-K" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<blockquote>
  <p>üí° You can get the source code for the production Markdown parser used in <code class="language-plaintext highlighter-rouge">r3bl_tui</code> from the
<a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/tui/src/tui/md_parser"><code class="language-plaintext highlighter-rouge">r3bl-open-core</code></a>
repo.</p>
</blockquote>

<h2 id="architecture-and-parsing-order">Architecture and parsing order</h2>
<p><a id="markdown-architecture-and-parsing-order" name="architecture-and-parsing-order"></a></p>

<p>This diagram showcases the order in which the parsers are called and how they are
composed together to parse a Markdown document.</p>

<!--
diagram:
https://asciiflow.com/#/share/eJzdlL9qwzAQxl%2Fl0JRChhLo0Gz9M3Rop2YUCNUWsYgsGfkcxxhD6dyhQwh9ltKnyZNUtus0hAYrJaXQQyAZf%2F6d7rN0JdE8FmSsM6WGRPFCWDImJSULSsbnZ6MhJYVbjZoVigW6B0oSK42VWMB6%2BbxePv7T8UKpBojkNAJwlT5Bwm0qWMztLDS5HpxACTsR8wTQAEYCAmOtCHBX0aIacgvdTDHXxengG3331U8LWb0B3IWXygQzmHMrucZ9e4DPGlGiEmzOVSZcmb0xqeV99W3YfJoyJVP0ITu2k%2Fd617F5hpGx3viLVu7HDjkeYAlcO7n3vh%2Fqn8MiwUOpp8wkyIRR%2B9PctMJD2Kk7tujjy30tvHU6f3ZgQj9PrpywPYfe7O62sbr5sFxixIxtZpMh0yJ3Nek6%2B8S9%2F8q0h%2B114vpii71679jVMcgde6u%2FLv%2B6C%2F7eeG1cVCY%2FjnVdUFKR6gNnN4sV)
-->

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>priority ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  high   ‚îÇ parse_markdown() {           map to the correct                    ‚îÇ
    ‚îÇ    ‚îÇ   many0(                     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫  MdBlock variant ‚îÇ
    ‚îÇ    ‚îÇ     parse_title_value()                              Title         ‚îÇ
    ‚îÇ    ‚îÇ     parse_tags_list()                                Tags          ‚îÇ
    ‚îÇ    ‚îÇ     parse_authors_list()                             Authors       ‚îÇ
    ‚îÇ    ‚îÇ     parse_date_value()                               Date          ‚îÇ
    ‚îÇ    ‚îÇ     parse_block_heading_opt_eol()                    Heading       ‚îÇ
    ‚îÇ    ‚îÇ     parse_block_smart_list()                         SmartList     ‚îÇ
    ‚îÇ    ‚îÇ     parse_block_code()                               CodeBlock     ‚îÇ
    ‚îÇ    ‚îÇ     parse_block_m..n_text_with_or_without_new_line() Text          ‚îÇ
    ‚îÇ    ‚îÇ   )                                                                ‚îÇ
    ‚ñº    ‚îÇ }                                                                  ‚îÇ
priority ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
  low
</code></pre></div></div>

<p>The parsing strategy in most cases is to parse the most specific thing first and then
parse the more general thing later. We often use the existence of <code class="language-plaintext highlighter-rouge">\n</code> (or <code class="language-plaintext highlighter-rouge">eol</code>) to
decide how far forwards we need to go into the input. And sometimes <code class="language-plaintext highlighter-rouge">\n</code> doesn‚Äôt exist
and we simply use the entire input (or end of input or <code class="language-plaintext highlighter-rouge">eoi</code>). You might see functions
that have these suffixes in their names. Another term you might see is
<code class="language-plaintext highlighter-rouge">with_or_without_new_line</code> which makes the parsing strategy explicit in the name.</p>

<p>The nature of <code class="language-plaintext highlighter-rouge">nom</code> parsers is to simply error out when they don‚Äôt match. And leave
the <code class="language-plaintext highlighter-rouge">input</code> untouched, so that another parser have a go at it again. The nature of
these parsing functions is kind of recursive in nature. So it‚Äôs important identify
edge and exit cases up front before diving into the parsing logic. You will see this
used in parsers which look for something more specific, if its not found, they error
out, and allow less specific parsers to have a go at it, and so on.</p>

<h2 id="the-priority-of-parsers">The priority of parsers</h2>

<p>As we drill down into the implementation further, we see that the parsers are
prioritized in the order of their specificity. The most specific parsers are called
first and the least specific parsers are called last. This is done to ensure that the
most specific parsers get a chance to parse the input first. And if they fail, then
the less specific parsers get a chance to parse the input.</p>

<!--
diagram:
https://asciiflow.com/#/share/eJytlFFuwjAMhq8S5QkkHtD2MjhLJCsNBqK6CUpTUYaQpp2h4iB7RDtNT7I0sK1ABYNhVapdJ1%2F%2F2G7X3MgM%2BdgURANOcoWOj%2Fla8FLw8ejleSD4KnhPo2HwPJY%2BBIIvpMsRErIqhUy6dGKXBposLLWfg3XxbgsPBpdA2mCvz9bs3IQwjGXSrIa9juxtFlmM7bVp07wVpk7OMjQ%2Bh8J4TYCWGnVodRB0nRWsWVZX7%2F9VtvmNHkBrRXVV1dVbvd0xSf7OIh4TI3X7cSjkdwUh99KFOsYGF2aCLlfWIaBzYE27zx20cOILtMbv4LS05QtUWpJ%2BxclVWiJV6nUYzC5ipMXNLmdN3X6u7e4Kl3DqQWdy9pAzR1rY3CnzZpqao0oTW4ax9zZkXHu6u7r7%2BSfaMTaxlnr9SFPSq3kYODop4Sl1QVIffgzGnvf2ROO%2BL4cnFz%2FPiyb4hm%2B%2BAFpUbMk%3D)
-->

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>parse_block_markdown_text_with_or_without_new_line() {
  many0(
    parse_inline_fragments_until_eol_or_eoi()
       )   ‚îÇ
}          ‚îÇ                                           ‚îÄ‚îÄmap to the correct‚îÄ‚îÄ‚ñ∫
           ‚îî‚îÄ‚ñ∫ alt(                                     MdLineFragment variant

             ‚ñ≤ p..e_f..t_s..s_with_underscore_err_on_new_line()  Italic
             ‚îÇ p..e_f..t_s..s_with_star_err_on_new_line()        Bold
specialized  ‚îÇ p..e_f..t_s..s_with_backtick_err_on_new_line()    InlineCode
parsers ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ p..e_f..t_s..s_with_left_image_err_on_new_line()  Image
             ‚îÇ p..e_f..t_s..s_with_left_link_err_on_new_line()   Link
             ‚îÇ p..e_f..t_s..s_with_checkbox_into_str()           Plain
             ‚ñº p..e_f..t_s..s_with_checkbox_checkbox_into_bool() Checkbox
catch all‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ p..e_f..t_plain_text_no_new_line()                Plain
parser
               )
</code></pre></div></div>

<p>The last one on the list in the diagram above is
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/block/parse_block_markdown_text_until_eol_or_eoi.rs"><code class="language-plaintext highlighter-rouge">parse_block_markdown_text_with_or_without_new_line()</code></a>.
Let‚Äôs zoom into this function and see how it is composed.</p>

<h2 id="the-catch-all-parser-which-is-the-most-complicated-and-the-lowest-priority">The ‚Äúcatch all‚Äù parser, which is the most complicated, and the lowest priority</h2>

<p>The most complicated parser is the ‚Äúcatch all‚Äù parser or the ‚Äúplain text‚Äù parser. This
parser is the last one in the chain and it simply consumes the rest of the input and
turns it into a <code class="language-plaintext highlighter-rouge">MdBlock::Text</code>. This parser is the most complicated because it has to
deal with all the edge cases and exit cases that other parsers have not dealt with.
Such as special characters like <code class="language-plaintext highlighter-rouge">`</code>, <code class="language-plaintext highlighter-rouge">*</code>, <code class="language-plaintext highlighter-rouge">_</code>, etc. They are all listed here:</p>

<ul>
  <li>If the input does not start with a special char in this
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/fragment/plain_parser_catch_all.rs"><code class="language-plaintext highlighter-rouge">get_sp_char_set_2()</code></a>,
then this is the ‚ÄúNormal case‚Äù. In this case the input is split at the first occurrence
of a special char in
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/fragment/plain_parser_catch_all.rs"><code class="language-plaintext highlighter-rouge">get_sp_char_set_3()</code></a>.
The ‚Äúbefore‚Äù part is <code class="language-plaintext highlighter-rouge">MdLineFragment::Plain</code> and the ‚Äúafter‚Äù part is parsed again by a
more specific parser.</li>
  <li>If the input starts with a special char in this <a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/fragment/plain_parser_catch_all.rs"><code class="language-plaintext highlighter-rouge">get_sp_char_set_2()</code></a> and it is not
in the <code class="language-plaintext highlighter-rouge">get_sp_char_set_1()</code> with only 1 occurrence, then the behavior is different
‚ÄúEdge case -&gt; Normal case‚Äù. Otherwise the behavior is ‚ÄúEdge case -&gt; Special case‚Äù.
    <ul>
      <li>‚ÄúEdge case -&gt; Normal case‚Äù takes all the characters until <code class="language-plaintext highlighter-rouge">\n</code> or end of input and
turns it into a <code class="language-plaintext highlighter-rouge">MdLineFragment::Plain</code>.</li>
      <li>‚ÄúEdge case -&gt; Special case‚Äù splits the <code class="language-plaintext highlighter-rouge">input</code> before and after the special char.
The ‚Äúbefore‚Äù part is turned into a <code class="language-plaintext highlighter-rouge">MdLineFragment::Plain</code> and the ‚Äúafter‚Äù part is
parsed again by a more specific parser.</li>
    </ul>
  </li>
</ul>

<p>The reason this parser gets called repeatedly is because it is the last one in the chain.
Its the lowest priority parser called by
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/fragment/parse_fragments_in_a_line.rs"><code class="language-plaintext highlighter-rouge">parse_inline_fragments_until_eol_or_eoi()</code></a>,
which itself is called:</p>
<ol>
  <li>Repeatedly in a loop by
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/block/parse_block_markdown_text_until_eol_or_eoi.rs"><code class="language-plaintext highlighter-rouge">parse_block_markdown_text_with_or_without_new_line()</code></a>.</li>
  <li>And by
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/block/parse_block_markdown_text_until_eol_or_eoi.rs#L80"><code class="language-plaintext highlighter-rouge">parse_block_markdown_text_with_checkbox_policy_with_or_without_new_line()</code></a>.</li>
</ol>

<h2 id="visualize-the-parsers-running-on-real-input">Visualize the parsers running on real input</h2>

<p>Let‚Äôs run some tests from the <code class="language-plaintext highlighter-rouge">md_parser</code> module with the
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/mod.rs#L34"><code class="language-plaintext highlighter-rouge">DEBUG_MD_PARSER_STDOUT</code></a>
flag set to <code class="language-plaintext highlighter-rouge">true</code>.</p>

<p>This will allow us to see the output of the parsers as they run on
real input. This is a great way to understand how the parsers are working and what they
are doing. This helps build an intuition around what happens at runtime which might not
match what you think is happening when you read the code.</p>

<ol>
  <li>The test we will run are in this file:
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/block/parse_block_markdown_text_until_eol_or_eoi.rs#L81"><code class="language-plaintext highlighter-rouge">tui/src/tui/md_parser/block/parse_block_markdown_text_until_eol_or_eoi.rs</code></a>.</li>
  <li>The test suite itself is called
<code class="language-plaintext highlighter-rouge">tests_parse_block_markdown_text_with_or_without_new_line</code>.</li>
  <li>And the function under test is
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/block/parse_block_markdown_text_until_eol_or_eoi.rs#L24"><code class="language-plaintext highlighter-rouge">parse_block_markdown_text_with_or_without_new_line()</code></a>.</li>
</ol>

<p>For convenience, here‚Äôs a copy of the test that we will run (in this
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/block/parse_block_markdown_text_until_eol_or_eoi.rs#L101">file</a>):</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">test_parse_hyperlink_markdown_text_1</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">input</span> <span class="o">=</span> <span class="s">"This is a _hyperlink: [foo](http://google.com)."</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="nf">parse_block_markdown_text_with_or_without_new_line</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
    <span class="nd">assert_eq2!</span><span class="p">(</span>
        <span class="n">it</span><span class="p">,</span>
        <span class="nf">Ok</span><span class="p">((</span>
            <span class="s">""</span><span class="p">,</span>
            <span class="nd">list!</span><span class="p">[</span>
                <span class="nn">MdLineFragment</span><span class="p">::</span><span class="nf">Plain</span><span class="p">(</span><span class="s">"This is a "</span><span class="p">,),</span>
                <span class="nn">MdLineFragment</span><span class="p">::</span><span class="nf">Plain</span><span class="p">(</span><span class="s">"_"</span><span class="p">,),</span>
                <span class="nn">MdLineFragment</span><span class="p">::</span><span class="nf">Plain</span><span class="p">(</span><span class="s">"hyperlink: "</span><span class="p">,),</span>
                <span class="nn">MdLineFragment</span><span class="p">::</span><span class="nf">Link</span><span class="p">(</span><span class="n">HyperlinkData</span> <span class="p">{</span>
                    <span class="n">text</span><span class="p">:</span> <span class="s">"foo"</span><span class="p">,</span>
                    <span class="n">url</span><span class="p">:</span> <span class="s">"http://google.com"</span><span class="p">,</span>
                <span class="p">},),</span>
                <span class="nn">MdLineFragment</span><span class="p">::</span><span class="nf">Plain</span><span class="p">(</span><span class="s">"."</span><span class="p">,),</span>
            <span class="p">],</span>
        <span class="p">))</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>You can see from the <code class="language-plaintext highlighter-rouge">assert_eq2!()</code> statements that the input <code class="language-plaintext highlighter-rouge">"This is a _hyperlink:
[foo](http://google.com)."</code> is turned into a abstract syntax tree (AST) which looks like
this:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span>
    <span class="nn">MdLineFragment</span><span class="p">::</span><span class="nf">Plain</span><span class="p">(</span><span class="s">"This is a "</span><span class="p">,),</span>
    <span class="nn">MdLineFragment</span><span class="p">::</span><span class="nf">Plain</span><span class="p">(</span><span class="s">"_"</span><span class="p">,),</span>
    <span class="nn">MdLineFragment</span><span class="p">::</span><span class="nf">Plain</span><span class="p">(</span><span class="s">"hyperlink: "</span><span class="p">,),</span>
    <span class="nn">MdLineFragment</span><span class="p">::</span><span class="nf">Link</span><span class="p">(</span><span class="n">HyperlinkData</span> <span class="p">{</span>
        <span class="n">text</span><span class="p">:</span> <span class="s">"foo"</span><span class="p">,</span>
        <span class="n">url</span><span class="p">:</span> <span class="s">"http://google.com"</span><span class="p">,</span>
    <span class="p">},),</span>
    <span class="nn">MdLineFragment</span><span class="p">::</span><span class="nf">Plain</span><span class="p">(</span><span class="s">"."</span><span class="p">,),</span>
<span class="p">]</span>
</code></pre></div></div>

<p>Note the ‚Äústrange‚Äù way in which <code class="language-plaintext highlighter-rouge">"_"</code> is handled. Instead of what we might expect <code class="language-plaintext highlighter-rouge">Plain("This is a _ hyperlink: ")</code>.
But we get 3 fragments instead of one. This is because of the lowest priority parser handles special characters
so that more specific parsers (higher priority) can have a go at it. So it doesn‚Äôt prematurely mark them as <code class="language-plaintext highlighter-rouge">Plain</code>.</p>

<p>Here are the commands to run one of the tests (make sure to run this in the <code class="language-plaintext highlighter-rouge">tui</code> subfolder):</p>

<pre class="pre-manual-highlight">
<span style="color:#F8F8F2">cargo</span> <span style="color:#FF79C6">test</span> <span style="color:#FF79C6">--</span> <span style="color:#FF79C6">--nocapture</span> <span style="color:#FF79C6">test_parse_hyperlink_markdown_text_1</span>
</pre>

<p>Here‚Äôs the output, which you can walk through to see the parsing algorithms in action:</p>

<pre class="pre-manual-highlight">
<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser _:
input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;, delim: &quot;_&quot;
count: 1, starts_w: false, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser *:
input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;, delim: &quot;*&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser `:
input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;, delim: &quot;`&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser take text between delims err on new line:
input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;, start_delim: &quot;![&quot;, end_delim: &quot;]&quot;
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;

<span style="color:#BF616A">‚¨¢‚¨¢</span> specialized parser error out with image:
input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;, delim: &quot;![&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser take text between delims err on new line:
input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;, start_delim: &quot;[&quot;, end_delim: &quot;]&quot;
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;

<span style="color:#BF616A">‚¨¢‚¨¢</span> specialized parser error out with link:
input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;, delim: &quot;[&quot;
<span style="color:#BF616A">‚¨¢‚¨¢</span> specialized parser for checkbox: Err(Error(Error { input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;, code: Tag }))

<span style="color:#B48EAD">‚ñà‚ñà</span> plain parser, input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;
<span style="color:#81A1C1">‚ñ≤‚ñ≤</span> normal case :: Ok((&quot;_hyperlink: [foo](http://google.com).&quot;, &quot;This is a &quot;))

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser _:
input: &quot;_hyperlink: [foo](http://google.com).&quot;, delim: &quot;_&quot;
count: 1, starts_w: true, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;_hyperlink: [foo](http://google.com).&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser *:
input: &quot;_hyperlink: [foo](http://google.com).&quot;, delim: &quot;*&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;_hyperlink: [foo](http://google.com).&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser `:
input: &quot;_hyperlink: [foo](http://google.com).&quot;, delim: &quot;`&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;_hyperlink: [foo](http://google.com).&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser take text between delims err on new line:
input: &quot;_hyperlink: [foo](http://google.com).&quot;, start_delim: &quot;![&quot;, end_delim: &quot;]&quot;
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;_hyperlink: [foo](http://google.com).&quot;

<span style="color:#BF616A">‚¨¢‚¨¢</span> specialized parser error out with image:
input: &quot;_hyperlink: [foo](http://google.com).&quot;, delim: &quot;![&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser take text between delims err on new line:
input: &quot;_hyperlink: [foo](http://google.com).&quot;, start_delim: &quot;[&quot;, end_delim: &quot;]&quot;
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;_hyperlink: [foo](http://google.com).&quot;

<span style="color:#BF616A">‚¨¢‚¨¢</span> specialized parser error out with link:
input: &quot;_hyperlink: [foo](http://google.com).&quot;, delim: &quot;[&quot;
<span style="color:#BF616A">‚¨¢‚¨¢</span> specialized parser for checkbox: Err(Error(Error { input: &quot;_hyperlink: [foo](http://google.com).&quot;, code: Tag }))

<span style="color:#B48EAD">‚ñà‚ñà</span> plain parser, input: &quot;_hyperlink: [foo](http://google.com).&quot;
<span style="color:#81A1C1">‚ñ≤‚ñ≤</span> edge case -&gt; special case :: rem: &quot;hyperlink: [foo](http://google.com).&quot;, output: &quot;_&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser _:
input: &quot;hyperlink: [foo](http://google.com).&quot;, delim: &quot;_&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;hyperlink: [foo](http://google.com).&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser *:
input: &quot;hyperlink: [foo](http://google.com).&quot;, delim: &quot;*&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;hyperlink: [foo](http://google.com).&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser `:
input: &quot;hyperlink: [foo](http://google.com).&quot;, delim: &quot;`&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;hyperlink: [foo](http://google.com).&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser take text between delims err on new line:
input: &quot;hyperlink: [foo](http://google.com).&quot;, start_delim: &quot;![&quot;, end_delim: &quot;]&quot;
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;hyperlink: [foo](http://google.com).&quot;

<span style="color:#BF616A">‚¨¢‚¨¢</span> specialized parser error out with image:
input: &quot;hyperlink: [foo](http://google.com).&quot;, delim: &quot;![&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser take text between delims err on new line:
input: &quot;hyperlink: [foo](http://google.com).&quot;, start_delim: &quot;[&quot;, end_delim: &quot;]&quot;
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;hyperlink: [foo](http://google.com).&quot;

<span style="color:#BF616A">‚¨¢‚¨¢</span> specialized parser error out with link:
input: &quot;hyperlink: [foo](http://google.com).&quot;, delim: &quot;[&quot;
<span style="color:#BF616A">‚¨¢‚¨¢</span> specialized parser for checkbox: Err(Error(Error { input: &quot;hyperlink: [foo](http://google.com).&quot;, code: Tag }))

<span style="color:#B48EAD">‚ñà‚ñà</span> plain parser, input: &quot;hyperlink: [foo](http://google.com).&quot;
<span style="color:#81A1C1">‚ñ≤‚ñ≤</span> normal case :: Ok((&quot;[foo](http://google.com).&quot;, &quot;hyperlink: &quot;))

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser _:
input: &quot;[foo](http://google.com).&quot;, delim: &quot;_&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;[foo](http://google.com).&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser *:
input: &quot;[foo](http://google.com).&quot;, delim: &quot;*&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;[foo](http://google.com).&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser `:
input: &quot;[foo](http://google.com).&quot;, delim: &quot;`&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;[foo](http://google.com).&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser take text between delims err on new line:
input: &quot;[foo](http://google.com).&quot;, start_delim: &quot;![&quot;, end_delim: &quot;]&quot;
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;[foo](http://google.com).&quot;

<span style="color:#BF616A">‚¨¢‚¨¢</span> specialized parser error out with image:
input: &quot;[foo](http://google.com).&quot;, delim: &quot;![&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser take text between delims err on new line:
input: &quot;[foo](http://google.com).&quot;, start_delim: &quot;[&quot;, end_delim: &quot;]&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser take text between delims err on new line:
input: &quot;(http://google.com).&quot;, start_delim: &quot;(&quot;, end_delim: &quot;)&quot;
<span style="color:#81A1C1">‚ñ≤‚ñ≤</span> specialized parser for link: Ok((&quot;.&quot;, HyperlinkData { text: &quot;foo&quot;, url: &quot;http://google.com&quot; }))

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser _:
input: &quot;.&quot;, delim: &quot;_&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;.&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser *:
input: &quot;.&quot;, delim: &quot;*&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;.&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser `:
input: &quot;.&quot;, delim: &quot;`&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;.&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser take text between delims err on new line:
input: &quot;.&quot;, start_delim: &quot;![&quot;, end_delim: &quot;]&quot;
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;.&quot;

<span style="color:#BF616A">‚¨¢‚¨¢</span> specialized parser error out with image:
input: &quot;.&quot;, delim: &quot;![&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser take text between delims err on new line:
input: &quot;.&quot;, start_delim: &quot;[&quot;, end_delim: &quot;]&quot;
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;.&quot;

<span style="color:#BF616A">‚¨¢‚¨¢</span> specialized parser error out with link:
input: &quot;.&quot;, delim: &quot;[&quot;
<span style="color:#BF616A">‚¨¢‚¨¢</span> specialized parser for checkbox: Err(Error(Error { input: &quot;.&quot;, code: Tag }))

<span style="color:#B48EAD">‚ñà‚ñà</span> plain parser, input: &quot;.&quot;
<span style="color:#81A1C1">‚ñ≤‚ñ≤</span> normal case :: Ok((&quot;&quot;, &quot;.&quot;))

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser _:
input: &quot;&quot;, delim: &quot;_&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser *:
input: &quot;&quot;, delim: &quot;*&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser `:
input: &quot;&quot;, delim: &quot;`&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser take text between delims err on new line:
input: &quot;&quot;, start_delim: &quot;![&quot;, end_delim: &quot;]&quot;
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;&quot;

<span style="color:#BF616A">‚¨¢‚¨¢</span> specialized parser error out with image:
input: &quot;&quot;, delim: &quot;![&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser take text between delims err on new line:
input: &quot;&quot;, start_delim: &quot;[&quot;, end_delim: &quot;]&quot;
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;&quot;

<span style="color:#BF616A">‚¨¢‚¨¢</span> specialized parser error out with link:
input: &quot;&quot;, delim: &quot;[&quot;
<span style="color:#BF616A">‚¨¢‚¨¢</span> specialized parser for checkbox: Err(Error(Error { input: &quot;&quot;, code: Tag }))

<span style="color:#B48EAD">‚ñà‚ñà</span> plain parser, input: &quot;&quot;
<span style="color:#BF616A">‚¨¢‚¨¢</span> normal case :: Err(Error(Error { input: &quot;&quot;, code: Eof }))
</pre>

<h2 id="see-this-in-action-in-r3bl-cmdr">See this in action in r3bl-cmdr</h2>

<p>If you want to use a TUI app that uses this Markdown Parser, run the following commands:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo <span class="nb">install </span>r3bl-cmdr
edi <span class="nt">--help</span>
</code></pre></div></div>

<p>This will install the <code class="language-plaintext highlighter-rouge">r3bl-cmdr</code> binary and run <code class="language-plaintext highlighter-rouge">edi</code>, which is a TUI Markdown editor
that you can use on any OS (Mac, Windows, Linux).</p>

<h2 id="references">References</h2>
<p><a id="markdown-references" name="references"></a></p>

<p><code class="language-plaintext highlighter-rouge">nom</code> is a huge topic. This tutorial takes a hands on approach to learning <code class="language-plaintext highlighter-rouge">nom</code>. However, the resources
listed below are very useful for learning <code class="language-plaintext highlighter-rouge">nom</code>. Think of them as a reference guide and deep dive into
how the <code class="language-plaintext highlighter-rouge">nom</code> library works.</p>

<ul>
  <li>Useful:
    <ul>
      <li>Source code examples (fantastic way to learn <code class="language-plaintext highlighter-rouge">nom</code>):
        <ul>
          <li><a href="https://github.com/dimfeld/export-logseq-notes/tree/master/src">export-logseq-notes repo</a></li>
        </ul>
      </li>
      <li>Videos:
        <ul>
          <li><a href="https://youtu.be/EXEMm5173SM">Intro from the author 7yrs old</a></li>
          <li><code class="language-plaintext highlighter-rouge">nom</code> 7 deep dive videos:
            <ul>
              <li><a href="https://youtu.be/Igajh2Vliog">Parsing name, age, and preference from natural language input</a></li>
              <li><a href="https://youtu.be/Xm4jrjohDN8">Parsing number ranges</a></li>
              <li><a href="https://youtu.be/6b2ymQWldoE">Parsing lines of text</a></li>
            </ul>
          </li>
          <li><code class="language-plaintext highlighter-rouge">nom</code> 6 videos (deep dive into how nom combinators themselves are constructed):
            <ul>
              <li><a href="https://youtu.be/zHF6j1LvngA">Deep dive, Part 1</a></li>
              <li><a href="https://youtu.be/9GLFJcSO08Y">Deep dive, Part 2</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Tutorials:
        <ul>
          <li><a href="https://codeandbitters.com/lets-build-a-parser/">Build a JSON parser using <code class="language-plaintext highlighter-rouge">nom</code> 7</a></li>
          <li><a href="https://github.com/benkay86/nom-tutorial">Excellent beginner to advanced</a></li>
          <li><a href="https://github.com/rust-bakery/nom/blob/main/doc/making_a_new_parser_from_scratch.md">Write a parser from scratch</a></li>
        </ul>
      </li>
      <li>Reference docs:
        <ul>
          <li><a href="https://tfpk.github.io/nominomicon/introduction.html">nominomicon</a></li>
          <li><a href="https://github.com/rust-bakery/nom/blob/main/doc/choosing_a_combinator.md">What combinator or parser to use?</a></li>
          <li><a href="https://docs.rs/nom/7.1.3/nom/">docs.rs</a></li>
          <li><a href="https://github.com/rust-bakery/nom/blob/main/doc/upgrading_to_nom_5.md">Upgrading to <code class="language-plaintext highlighter-rouge">nom</code> 5.0</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Less useful:
    <ul>
      <li><a href="https://github.com/rust-bakery/nom">README</a></li>
      <li><a href="https://crates.io/crates/nom"><code class="language-plaintext highlighter-rouge">nom</code> crate</a></li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><category term="TUI" /><summary type="html"><![CDATA[This tutorial is a deep dive in a real Markdown parser written using nom in Rust. This MD Parser is part of the r3bl_tui crate, which is part of the r3bl-open-core repo. It goes over the architecture of thinking about building complex parsers and the nitty gritty details the runtime nature and behavior when combining nom parsers.]]></summary></entry><entry><title type="html">Build with Naz : Rust error handling with miette</title><link href="http://developerlife.com/2024/06/10/rust-miette-error-handling/" rel="alternate" type="text/html" title="Build with Naz : Rust error handling with miette" /><published>2024-06-10T10:00:00-05:00</published><updated>2024-06-10T10:00:00-05:00</updated><id>http://developerlife.com/2024/06/10/rust-miette-error-handling</id><content type="html" xml:base="http://developerlife.com/2024/06/10/rust-miette-error-handling/"><![CDATA[<p><img class="post-hero-image" src="/assets/rust-miette.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#rust-error-handling-primer">Rust error handling primer</a></li>
  <li><a href="#more-resources-on-rust-error-handling">More resources on Rust error handling</a></li>
  <li><a href="#youtube-video-for-this-article">YouTube video for this article</a></li>
  <li><a href="#examples-of-rust-error-handling-with-miette">Examples of Rust error handling with miette</a>
    <ul>
      <li><a href="#example-1-simple-miette-usage">Example 1: Simple miette usage</a></li>
      <li><a href="#example-2-complex-miette-usage">Example 2: Complex miette usage</a></li>
      <li><a href="#parting-thoughts">Parting thoughts</a></li>
    </ul>
  </li>
  <li><a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</a></li>
</ul>

<!-- /TOC -->

<h2 id="rust-error-handling-primer">Rust error handling primer</h2>
<p><a id="markdown-rust-error-handling-primer" name="rust-error-handling-primer"></a></p>

<p>Rust has a powerful error handling system that is based on the
<a href="https://doc.rust-lang.org/std/result/"><code class="language-plaintext highlighter-rouge">Result</code></a> and <code class="language-plaintext highlighter-rouge">Option</code> types. For this tutorial we
will focus on the <code class="language-plaintext highlighter-rouge">Result</code> type, which is an enum that has two variants: <code class="language-plaintext highlighter-rouge">Ok</code> and <code class="language-plaintext highlighter-rouge">Err</code>.
The <code class="language-plaintext highlighter-rouge">Ok</code> variant is used to represent a successful result, while the <code class="language-plaintext highlighter-rouge">Err</code> variant is used
to represent an error.</p>

<p>The <a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code class="language-plaintext highlighter-rouge">Error</code></a> trait in Rust has to
be implemented for types that can be used as errors. The <code class="language-plaintext highlighter-rouge">Error</code> trait has a method called
<code class="language-plaintext highlighter-rouge">source</code> that returns a reference to the underlying cause of the error. This trait has two
supertraits: <code class="language-plaintext highlighter-rouge">Debug</code> and <code class="language-plaintext highlighter-rouge">Display</code>. The <code class="language-plaintext highlighter-rouge">Debug</code> trait is used to format the error for
debugging purposes (for the operator), while the <code class="language-plaintext highlighter-rouge">Display</code> trait is used to format the
error for displaying to the user.</p>

<p>The <code class="language-plaintext highlighter-rouge">?</code> operator can be used in order to propagate errors up the call stack. This operator
is used to unwrap the <code class="language-plaintext highlighter-rouge">Result</code> type and provide the inner value of the <code class="language-plaintext highlighter-rouge">Ok</code> variant.
Otherwise it returns from the function with the error, if it is the <code class="language-plaintext highlighter-rouge">Err</code> variant. This
operator can only be used in functions that return a <code class="language-plaintext highlighter-rouge">Result</code> type. Here‚Äôs an example:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Fails and produces output:</span>
<span class="cd">/// ```text</span>
<span class="cd">/// Error: ParseIntError { kind: InvalidDigit }</span>
<span class="cd">/// ```</span>
<span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">test</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">return_error_result</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">u32</span><span class="p">,</span> <span class="nn">std</span><span class="p">::</span><span class="nn">num</span><span class="p">::</span><span class="n">ParseIntError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="s">"1.2"</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">run</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="c1">// It is as if the `?` is turned into the following code.</span>
        <span class="c1">// let result = match result {</span>
        <span class="c1">//     Ok(value) =&gt; value,</span>
        <span class="c1">//     Err(err) =&gt; return Err(Box::new(err)),</span>
        <span class="c1">// }</span>
        <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">return_error_result</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

        <span class="c1">// The following lines will never be executed, since the previous</span>
        <span class="c1">// line will return from the function with an error.</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Result: {}"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>

    <span class="nf">run</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In the rest of the tutorial (and accompanying video), we will build upon this knowledge
and introduce <code class="language-plaintext highlighter-rouge">miette</code>, a crate that can make error handling in Rust powerful, flexible,
and easy to use. We will also learn more about the <code class="language-plaintext highlighter-rouge">thiserror</code> crate, which can be used to
easily create custom error types in Rust.</p>

<h2 id="more-resources-on-rust-error-handling">More resources on Rust error handling</h2>
<p><a id="markdown-more-resources-on-rust-error-handling" name="more-resources-on-rust-error-handling"></a></p>

<ul>
  <li><a href="https://docs.rs/thiserror/latest/thiserror/"><code class="language-plaintext highlighter-rouge">thiserror</code> crate</a>.</li>
  <li><a href="https://docs.rs/miette/latest/miette/"><code class="language-plaintext highlighter-rouge">miette</code> crate</a>.</li>
  <li><a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code class="language-plaintext highlighter-rouge">Error</code> trait</a>.</li>
  <li><a href="https://doc.rust-lang.org/std/result/"><code class="language-plaintext highlighter-rouge">Result</code> enum</a>.</li>
</ul>

<h2 id="youtube-video-for-this-article">YouTube video for this article</h2>
<p><a id="markdown-youtube-video-for-this-article" name="youtube-video-for-this-article"></a></p>

<p>This blog post has short examples on how to use <code class="language-plaintext highlighter-rouge">miette</code> to enhance Rust error handling. If
you like to learn via video, please watch the companion video on the <a href="https://www.youtube.com/@developerlifecom">developerlife.com
YouTube channel</a>.</p>

<!-- rust error handling with miette -->
<iframe src="https://www.youtube.com/embed/TmLF7vI8lKk?si=Xh5belp5zD-w-J3P" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<p><br /></p>

<h2 id="examples-of-rust-error-handling-with-miette">Examples of Rust error handling with miette</h2>
<p><a id="markdown-examples-of-rust-error-handling-with-miette" name="examples-of-rust-error-handling-with-miette"></a></p>

<p>Let‚Äôs create some examples to illustrate how to use <code class="language-plaintext highlighter-rouge">miette</code> to enhance Rust error
handling. You can run <code class="language-plaintext highlighter-rouge">cargo new --lib error-miette</code> to create a new library crate.</p>

<blockquote>
  <p>The code in the video and this tutorial are all in <a href="https://github.com/nazmulidris/rust-scratch/blob/main/error-miette/src/lib.rs">this GitHub
repo</a>.</p>
</blockquote>

<p>Then add the following to the <code class="language-plaintext highlighter-rouge">Cargo.toml</code> file that‚Äôs generated. These pull in all the
dependencies that we need for these examples.</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[package]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"error-miette"</span>
<span class="py">version</span> <span class="p">=</span> <span class="s">"0.1.0"</span>
<span class="py">edition</span> <span class="p">=</span> <span class="s">"2021"</span>

<span class="nn">[dependencies]</span>

<span class="c"># Pretty terminal output.</span>
<span class="py">crossterm</span> <span class="p">=</span> <span class="s">"0.27.0"</span>

<span class="c"># Error handling.</span>
<span class="py">thiserror</span> <span class="p">=</span> <span class="s">"1.0.61"</span>
<span class="py">miette</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"7.2.0"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"fancy"</span><span class="p">]</span> <span class="p">}</span>
<span class="py">pretty_assertions</span> <span class="p">=</span> <span class="s">"1.4.0"</span>
</code></pre></div></div>

<h3 id="example-1-simple-miette-usage">Example 1: Simple miette usage</h3>
<p><a id="markdown-example-1%3A-simple-miette-usage" name="example-1%3A-simple-miette-usage"></a></p>

<p>Then you can add the following code to the <code class="language-plaintext highlighter-rouge">src/lib.rs</code> file. You can note the following things
in the code:</p>
<ul>
  <li>We define a custom error type called <code class="language-plaintext highlighter-rouge">UnderlyingDatabaseError</code> using the <code class="language-plaintext highlighter-rouge">thiserror</code> crate.</li>
  <li>We define a function called <code class="language-plaintext highlighter-rouge">return_error_result</code> that returns a <code class="language-plaintext highlighter-rouge">Result&lt;u32, std::num::ParseIntError&gt;</code>.</li>
  <li>We write a test called <code class="language-plaintext highlighter-rouge">test_into_diagnostic</code> that demonstrates how to use <code class="language-plaintext highlighter-rouge">miette</code> to
add context to errors and display them in a user-friendly way. The test also
demonstrates how to use the <code class="language-plaintext highlighter-rouge">wrap_err</code> and <code class="language-plaintext highlighter-rouge">context</code> methods to add context to errors.
And how they are displayed in the error report (in the inverse order in which they were
added).</li>
  <li>We also demonstrate how to use the <code class="language-plaintext highlighter-rouge">into_diagnostic</code> method to convert a <code class="language-plaintext highlighter-rouge">Result</code> into a
<code class="language-plaintext highlighter-rouge">miette::Result</code>.</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="k">pub</span> <span class="k">mod</span> <span class="n">simple_miette_usage</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">crossterm</span><span class="p">::</span><span class="nn">style</span><span class="p">::</span><span class="n">Stylize</span><span class="p">;</span>
    <span class="k">use</span> <span class="nn">miette</span><span class="p">::{</span><span class="n">Context</span><span class="p">,</span> <span class="n">IntoDiagnostic</span><span class="p">};</span>

    <span class="nd">#[derive(Debug,</span> <span class="nd">thiserror::Error)]</span>
    <span class="k">pub</span> <span class="k">enum</span> <span class="n">UnderlyingDatabaseError</span> <span class="p">{</span>
        <span class="nd">#[error(</span><span class="s">"database corrupted"</span><span class="nd">)]</span>
        <span class="n">DatabaseCorrupted</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">return_error_result</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">u32</span><span class="p">,</span> <span class="nn">std</span><span class="p">::</span><span class="nn">num</span><span class="p">::</span><span class="n">ParseIntError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="s">"1.2"</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">test_into_diagnostic</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">error_result</span><span class="p">:</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">u32</span><span class="p">,</span> <span class="nn">std</span><span class="p">::</span><span class="nn">num</span><span class="p">::</span><span class="n">ParseIntError</span><span class="o">&gt;</span> <span class="o">=</span>
            <span class="nf">return_error_result</span><span class="p">();</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">error_result</span><span class="nf">.is_err</span><span class="p">());</span>

        <span class="c1">// The following line will return from this test.</span>
        <span class="c1">// let it: u32 = error_result.into_diagnostic()?;</span>

        <span class="k">let</span> <span class="n">new_miette_result</span><span class="p">:</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">error_result</span>
            <span class="nf">.into_diagnostic</span><span class="p">()</span>
            <span class="nf">.context</span><span class="p">(</span><span class="s">"üçç foo bar baz"</span><span class="p">)</span>
            <span class="nf">.wrap_err</span><span class="p">(</span><span class="nn">miette</span><span class="p">::</span><span class="nd">miette!</span><span class="p">(</span><span class="s">"custom string error"</span><span class="p">))</span>
            <span class="nf">.wrap_err</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="nn">ErrorKind</span><span class="p">::</span><span class="n">NotFound</span><span class="p">)</span>
            <span class="nf">.wrap_err</span><span class="p">(</span><span class="nn">UnderlyingDatabaseError</span><span class="p">::</span><span class="n">DatabaseCorrupted</span><span class="p">)</span>
            <span class="nf">.wrap_err</span><span class="p">(</span><span class="s">"üéÉ this is additional context about the failure"</span><span class="p">);</span>

        <span class="nd">assert!</span><span class="p">(</span><span class="n">new_miette_result</span><span class="nf">.is_err</span><span class="p">());</span>

        <span class="nd">println!</span><span class="p">(</span>
            <span class="s">"{}:</span><span class="se">\n</span><span class="s">{:?}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="s">"debug output"</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.bold</span><span class="p">(),</span>
            <span class="n">new_miette_result</span>
        <span class="p">);</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Err</span><span class="p">(</span><span class="k">ref</span> <span class="n">miette_report</span><span class="p">)</span> <span class="o">=</span> <span class="n">new_miette_result</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span>
                <span class="s">"{}:</span><span class="se">\n</span><span class="s">{:?}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                <span class="s">"miette report"</span><span class="nf">.red</span><span class="p">()</span><span class="nf">.bold</span><span class="p">(),</span>
                <span class="n">miette_report</span><span class="nf">.to_string</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">miette_report</span><span class="nf">.chain</span><span class="p">();</span>

            <span class="c1">// First.</span>
            <span class="nn">pretty_assertions</span><span class="p">::</span><span class="nd">assert_eq!</span><span class="p">(</span>
                <span class="n">iter</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="s">"üéÉ this is additional context about the failure"</span>
                    <span class="nf">.to_string</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="c1">// Second.</span>
            <span class="nn">pretty_assertions</span><span class="p">::</span><span class="nd">assert_eq!</span><span class="p">(</span>
                <span class="n">iter</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="s">"database corrupted"</span><span class="nf">.to_string</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="c1">// Third.</span>
            <span class="nn">pretty_assertions</span><span class="p">::</span><span class="nd">assert_eq!</span><span class="p">(</span>
                <span class="n">iter</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="s">"entity not found"</span><span class="nf">.to_string</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="c1">// Fourth.</span>
            <span class="nn">pretty_assertions</span><span class="p">::</span><span class="nd">assert_eq!</span><span class="p">(</span>
                <span class="n">iter</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="s">"custom string error"</span><span class="nf">.to_string</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="c1">// Fifth.</span>
            <span class="nn">pretty_assertions</span><span class="p">::</span><span class="nd">assert_eq!</span><span class="p">(</span>
                <span class="n">iter</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="s">"üçç foo bar baz"</span><span class="nf">.to_string</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="c1">// Final.</span>
            <span class="nn">pretty_assertions</span><span class="p">::</span><span class="nd">assert_eq!</span><span class="p">(</span>
                <span class="n">iter</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="s">"invalid digit found in string"</span><span class="nf">.to_string</span><span class="p">()</span>
            <span class="p">);</span>
        <span class="p">}</span>

        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">test_convert_report_into_error</span><span class="p">()</span> <span class="k">-&gt;</span>
        <span class="nn">std</span><span class="p">::</span><span class="nn">result</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">miette_result</span><span class="p">:</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span> <span class="o">=</span>
            <span class="nf">return_error_result</span><span class="p">()</span>
                <span class="nf">.into_diagnostic</span><span class="p">()</span>
                <span class="nf">.wrap_err</span><span class="p">(</span><span class="nn">miette</span><span class="p">::</span><span class="nn">Report</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span>
                    <span class="s">"wrapper for the source parse int error"</span><span class="p">,</span>
                <span class="p">));</span>

        <span class="c1">// let converted_result: Result&lt;u32, Box&lt;dyn Error&gt;&gt; =</span>
        <span class="c1">//     miette_result.map_err(|report| report.into());</span>

        <span class="k">let</span> <span class="n">converted_result</span><span class="p">:</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">result</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;&gt;</span> <span class="o">=</span>
            <span class="k">match</span> <span class="n">miette_result</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(()),</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">miette_report</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">boxed_error</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span> <span class="o">=</span>
                        <span class="n">miette_report</span><span class="nf">.into</span><span class="p">();</span>
                    <span class="nf">Err</span><span class="p">(</span><span class="n">boxed_error</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">};</span>

        <span class="nd">println!</span><span class="p">(</span>
            <span class="s">"{}:</span><span class="se">\n</span><span class="s">{:?}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="s">"debug output"</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.bold</span><span class="p">(),</span>
            <span class="n">converted_result</span>
        <span class="p">);</span>

        <span class="nd">assert!</span><span class="p">(</span><span class="n">converted_result</span><span class="nf">.is_err</span><span class="p">());</span>

        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="example-2-complex-miette-usage">Example 2: Complex miette usage</h3>
<p><a id="markdown-example-2%3A-complex-miette-usage" name="example-2%3A-complex-miette-usage"></a></p>

<p>Next, we will add the following code to the <code class="language-plaintext highlighter-rouge">src/lib.rs</code> file. You can note the following
things in the code:</p>

<ul>
  <li>We define a custom error type called <code class="language-plaintext highlighter-rouge">KvStoreError</code> using the <code class="language-plaintext highlighter-rouge">thiserror</code> crate.</li>
  <li>We define two variants for the <code class="language-plaintext highlighter-rouge">KvStoreError</code> enum: <code class="language-plaintext highlighter-rouge">CouldNotCreateDbFolder</code> and
<code class="language-plaintext highlighter-rouge">CouldNotGetOrCreateEnvOrOpenStore</code>. The latter variant has a field called <code class="language-plaintext highlighter-rouge">source</code> that
is of type <code class="language-plaintext highlighter-rouge">UnderlyingDatabaseError</code>, which is defined in the previous example.</li>
  <li>We define two functions called <code class="language-plaintext highlighter-rouge">return_flat_err</code> and <code class="language-plaintext highlighter-rouge">return_nested_err</code> that return
<code class="language-plaintext highlighter-rouge">miette::Result&lt;(), KvStoreError&gt;</code>.</li>
  <li>We write two tests called <code class="language-plaintext highlighter-rouge">fails_with_flat_err</code> and <code class="language-plaintext highlighter-rouge">fails_with_nested_err</code> that
demonstrate how to use <code class="language-plaintext highlighter-rouge">miette</code> to add context to errors and display them in a
user-friendly way. The tests also demonstrate how to use the <code class="language-plaintext highlighter-rouge">from</code> attribute to convert
an error of one type into an error of another type.</li>
  <li>We also demonstrate how to use the <code class="language-plaintext highlighter-rouge">#[diagnostic]</code> attribute to add a code and help URL
to the error type.</li>
  <li>We also demonstrate how to use the <code class="language-plaintext highlighter-rouge">#[from]</code> attribute to convert an error of one type
into an error of another type.</li>
  <li>We also demonstrate how to use the <code class="language-plaintext highlighter-rouge">#[error]</code> attribute to add a custom error message to
the error type.</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="k">pub</span> <span class="k">mod</span> <span class="n">complex_miette_usage</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span><span class="p">;</span>

    <span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="nn">simple_miette_usage</span><span class="p">::</span><span class="n">UnderlyingDatabaseError</span><span class="p">;</span>
    <span class="k">use</span> <span class="nn">pretty_assertions</span><span class="p">::</span><span class="n">assert_eq</span><span class="p">;</span>

    <span class="nd">#[derive(thiserror::Error,</span> <span class="nd">Debug,</span> <span class="nd">miette::Diagnostic)]</span>
    <span class="k">pub</span> <span class="k">enum</span> <span class="n">KvStoreError</span> <span class="p">{</span>
        <span class="nd">#[diagnostic(</span>
            <span class="nd">code(MyErrorCode::FileSystemError),</span>
            <span class="nd">help(</span><span class="s">"https://docs.rs/rkv/latest/rkv/enum.StoreError.html"</span><span class="nd">),</span>
            <span class="c1">// url(docsrs) /* Works if this code was on crates.io / docs.rs */</span>
        <span class="nd">)]</span>
        <span class="nd">#[error(</span><span class="s">"üìÇ Could not create db folder: '{db_folder_path}' on disk"</span><span class="nd">)]</span>
        <span class="n">CouldNotCreateDbFolder</span> <span class="p">{</span> <span class="n">db_folder_path</span><span class="p">:</span> <span class="nb">String</span> <span class="p">},</span>

        <span class="nd">#[diagnostic(</span>
            <span class="nd">code(MyErrorCode::StoreCreateOrAccessError),</span>
            <span class="nd">help(</span><span class="s">"https://docs.rs/rkv/latest/rkv/enum.StoreError.html"</span><span class="nd">),</span>
            <span class="c1">// url(docsrs) /* Works if this code was on crates.io / docs.rs */</span>
        <span class="nd">)]</span>
        <span class="nd">#[error(</span><span class="s">"üíæ Could not get or create environment, or open store"</span><span class="nd">)]</span>
        <span class="n">CouldNotGetOrCreateEnvOrOpenStore</span> <span class="p">{</span>
            <span class="nd">#[from]</span>
            <span class="n">source</span><span class="p">:</span> <span class="n">UnderlyingDatabaseError</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">return_flat_err</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">KvStoreError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nn">Result</span><span class="p">::</span><span class="nf">Err</span><span class="p">(</span><span class="nn">KvStoreError</span><span class="p">::</span><span class="n">CouldNotCreateDbFolder</span> <span class="p">{</span>
            <span class="n">db_folder_path</span><span class="p">:</span> <span class="s">"some/path/to/db"</span><span class="nf">.to_string</span><span class="p">(),</span>
        <span class="p">})</span>
    <span class="p">}</span>

    <span class="cd">/// This test will not run! It will fail and demonstrate the default</span>
    <span class="cd">/// [report handler](miette::ReportHandler) of the `miette` crate.</span>
    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">fails_with_flat_err</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">return_flat_err</span><span class="p">();</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Err</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">result</span> <span class="p">{</span>
            <span class="nd">assert_eq!</span><span class="p">(</span>
                <span class="nd">format!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">error</span><span class="p">),</span>
                <span class="s">"CouldNotCreateDbFolder { db_folder_path: </span><span class="se">\"</span><span class="s">some/path/to/db</span><span class="se">\"</span><span class="s"> }"</span>
            <span class="p">);</span>
        <span class="p">}</span>

        <span class="n">result</span><span class="o">?</span><span class="p">;</span>

        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">return_nested_err</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">KvStoreError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// Variant 1 - Very verbose.</span>
        <span class="k">let</span> <span class="n">store_error</span> <span class="o">=</span> <span class="nn">UnderlyingDatabaseError</span><span class="p">::</span><span class="n">DatabaseCorrupted</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">rkv_error</span> <span class="o">=</span> <span class="nn">KvStoreError</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">store_error</span><span class="p">);</span>
        <span class="nn">Result</span><span class="p">::</span><span class="nf">Err</span><span class="p">(</span><span class="n">rkv_error</span><span class="p">)</span>

        <span class="c1">// Variant 2.</span>
        <span class="c1">// Result::Err(KvStoreError::CouldNotGetOrCreateEnvOrOpenStore {</span>
        <span class="c1">//     source: UnderlyingDatabaseError::DatabaseCorrupted,</span>
        <span class="c1">// })</span>
    <span class="p">}</span>

    <span class="cd">/// This test will not run! It will fail and demonstrate the default</span>
    <span class="cd">/// [report handler](miette::ReportHandler) of the `miette` crate.</span>
    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">fails_with_nested_err</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">return_nested_err</span><span class="p">();</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Err</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">result</span> <span class="p">{</span>
            <span class="nd">assert_eq!</span><span class="p">(</span>
                <span class="nd">format!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">error</span><span class="p">),</span>
                <span class="s">"CouldNotGetOrCreateEnvOrOpenStore { source: DatabaseCorrupted }"</span>
            <span class="p">);</span>
        <span class="p">}</span>

        <span class="n">result</span><span class="o">?</span><span class="p">;</span>

        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="parting-thoughts">Parting thoughts</h3>
<p><a id="markdown-parting-thoughts" name="parting-thoughts"></a></p>

<p>For more sophisticated error handling examples, please check out the following links:</p>

<ul>
  <li><a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/terminal_async/src/public_api/terminal_async.rs#L57"><code class="language-plaintext highlighter-rouge">terminal_async.rs</code> in <code class="language-plaintext highlighter-rouge">r3bl_terminal_async</code>
crate</a>.</li>
  <li><a href="https://github.com/nazmulidris/rust-scratch/blob/main/tcp-api-server/src/standalone/kv.rs#L137"><code class="language-plaintext highlighter-rouge">kv.rs</code> in <code class="language-plaintext highlighter-rouge">tcp-api-server</code>
crate</a>.</li>
  <li><a href="https://github.com/nazmulidris/rust-scratch/blob/main/tcp-api-server/src/standalone/miette_setup_global_report_handler.rs">Custom global report handler for <code class="language-plaintext highlighter-rouge">miette</code> in <code class="language-plaintext highlighter-rouge">tcp-api-server</code>
crate</a>.</li>
</ul>

<h2 id="build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</h2>
<p><a id="markdown-build-with-naz-video-series-on-developerlife.com-youtube-channel" name="build-with-naz-video-series-on-developerlife.com-youtube-channel"></a></p>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a></li>
  <li>Playlists
    <ul>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmza94sS7UmJnN9gSCHTVTfz">Build with Naz, fundamental effective Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmwO69E7eiQ-ewnMME8ydgQ5">Build with Naz, effective async Rust and tokio</a></li>
      <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><summary type="html"><![CDATA[miette is an excellent crate that can make error handling in Rust powerful, flexible, and easy to use. It provides a way to create custom error types, add context to errors, and display errors in a user-friendly way. In this article, we'll explore how to use miette to improve error handling in your Rust applications.]]></summary></entry><entry><title type="html">Build with Naz : Rust typestate pattern</title><link href="http://developerlife.com/2024/05/28/typestate-pattern-rust/" rel="alternate" type="text/html" title="Build with Naz : Rust typestate pattern" /><published>2024-05-28T10:00:00-05:00</published><updated>2024-05-28T10:00:00-05:00</updated><id>http://developerlife.com/2024/05/28/typestate-pattern-rust</id><content type="html" xml:base="http://developerlife.com/2024/05/28/typestate-pattern-rust/"><![CDATA[<p><img class="post-hero-image" src="/assets/rust-typestate-pattern.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#what-is-the-typestate-pattern">What is the typestate pattern?</a></li>
  <li><a href="#more-resources-on-typestate-pattern-and-others-in-rust">More resources on typestate pattern and others in Rust</a></li>
  <li><a href="#youtube-video-for-this-article">YouTube video for this article</a></li>
  <li><a href="#examples-of-typestate-pattern-in-rust">Examples of typestate pattern in Rust</a>
    <ul>
      <li><a href="#example-1-simple-version-of-this-is-using-enums-to-encapsulate-states-as-variants">Example 1: Simple version of this is using enums to encapsulate states as variants</a></li>
      <li><a href="#example-2-slightly-more-complex-versions-are-where-one-type--data--another-type">Example 2: Slightly more complex versions are where one type + data = another type</a></li>
      <li><a href="#example-3-best-of-both-worlds-using-generics-and-struct--enum-with-a-marker-trait">Example 3: Best of both worlds, using generics and struct / enum with a marker trait</a></li>
      <li><a href="#parting-thoughts">Parting thoughts</a></li>
    </ul>
  </li>
  <li><a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</a></li>
</ul>

<!-- /TOC -->

<h2 id="what-is-the-typestate-pattern">What is the typestate pattern?</h2>
<p><a id="markdown-what-is-the-typestate-pattern%3F" name="what-is-the-typestate-pattern%3F"></a></p>

<p>The Typestate Pattern in Rust is a way to manage objects that go through different states
in their lifecycle. It leverages Rust‚Äôs powerful type system to enforce these states and
transitions between them, making your code safer and more predictable.</p>

<p>Here are the key ideas behind the Typestate Pattern:</p>

<ul>
  <li><em>States as structs</em>: Each possible state of the object is represented by a separate
struct. This lets you associate specific methods and data with each state.</li>
  <li><em>Transitions with ownership</em>: Methods that transition the object to a new state consume
the old state and return a value representing the new state. Rust‚Äôs ownership system
ensures you can‚Äôt accidentally use the object in an invalid state.</li>
  <li><em>Encapsulated functionality</em>: Methods are only available on the structs representing the
valid states. This prevents you from trying to perform actions that aren‚Äôt allowed in
the current state.</li>
</ul>

<p>Benefits of using the Typestate Pattern:</p>

<ul>
  <li><em>Safer code</em>: By statically checking types at compile time, the compiler prevents you from
accidentally using the object in an invalid state. This leads to fewer runtime errors
and more robust code.</li>
  <li><em>Improved readability</em>: The code becomes more self-documenting because the valid state
transitions are encoded in the types themselves.</li>
  <li><em>Clearer APIs</em>: By separating functionality based on state, APIs become more intuitive and
easier to understand.</li>
</ul>

<h2 id="more-resources-on-typestate-pattern-and-others-in-rust">More resources on typestate pattern and others in Rust</h2>
<p><a id="markdown-more-resources-on-typestate-pattern-and-others-in-rust" name="more-resources-on-typestate-pattern-and-others-in-rust"></a></p>

<ul>
  <li><a href="https://arxiv.org/pdf/2307.07069">Functional typed design patterns</a>.</li>
  <li><a href="https://gemini.google.com/app/5bd7fed51858cb4d">Enums and typestate (and limitations)</a>.</li>
  <li><a href="https://willcrichton.net/rust-api-type-patterns/typestate.html">Type-Driven API Design in Rust</a>.</li>
  <li><a href="https://ruk.si/notes/rust/typestate/">Rust typestate notes</a>.</li>
  <li><a href="https://rustype.github.io/notes/notes/rust-typestate-series/rust-typestate-part-1">Rusty Typestates - Starting Out</a>.</li>
  <li><a href="https://docs.rust-embedded.org/book/static-guarantees/typestate-programming.html">The Embedded Rust Book - Typestate programming</a>.</li>
  <li><a href="https://yoric.github.io/post/rust-typestate/">Typestates in Rust</a>.</li>
</ul>

<h2 id="youtube-video-for-this-article">YouTube video for this article</h2>
<p><a id="markdown-youtube-video-for-this-article" name="youtube-video-for-this-article"></a></p>

<p>This blog post has short examples on how to use the typestate pattern in Rust. If you like
to learn via video, please watch the companion video on the <a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube
channel</a>.</p>

<!-- rust typestate pattern -->
<iframe src="https://www.youtube.com/embed/FTSb0dyDOCA?si=ZdUYIxxGTsaAC1B3" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<p><br /></p>

<h2 id="examples-of-typestate-pattern-in-rust">Examples of typestate pattern in Rust</h2>
<p><a id="markdown-examples-of-typestate-pattern-in-rust" name="examples-of-typestate-pattern-in-rust"></a></p>

<p>Let‚Äôs create some examples to illustrate how to use the typestate pattern in Rust. You can run
<code class="language-plaintext highlighter-rouge">cargo new --bin typestate-pattern</code> to create a new binary crate.</p>

<blockquote>
  <p>The code in the video and this tutorial are all in <a href="https://github.com/nazmulidris/rust-scratch/blob/main/typestate-pattern/">this GitHub
repo</a>.</p>
</blockquote>

<p>Then add the following to the <code class="language-plaintext highlighter-rouge">Cargo.toml</code> file that‚Äôs generated. These pull in all the
dependencies that we need for these examples.</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[package]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"typestate-pattern"</span>
<span class="py">version</span> <span class="p">=</span> <span class="s">"0.1.0"</span>
<span class="py">edition</span> <span class="p">=</span> <span class="s">"2021"</span>

<span class="nn">[[bin]]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"ex1"</span>
<span class="py">path</span> <span class="p">=</span> <span class="s">"src/ex1.rs"</span>

<span class="nn">[[bin]]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"ex2"</span>
<span class="py">path</span> <span class="p">=</span> <span class="s">"src/ex2.rs"</span>

<span class="nn">[[bin]]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"ex3"</span>
<span class="py">path</span> <span class="p">=</span> <span class="s">"src/ex3.rs"</span>

<span class="nn">[[bin]]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"ex3_1"</span>
<span class="py">path</span> <span class="p">=</span> <span class="s">"src/ex3_1.rs"</span>

<span class="c"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span>

<span class="nn">[dependencies]</span>
<span class="py">crossterm</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.27.0"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"event-stream"</span><span class="p">]</span> <span class="p">}</span>
</code></pre></div></div>

<h3 id="example-1-simple-version-of-this-is-using-enums-to-encapsulate-states-as-variants">Example 1: Simple version of this is using enums to encapsulate states as variants</h3>
<p><a id="markdown-example-1%3A-simple-version-of-this-is-using-enums-to-encapsulate-states-as-variants" name="example-1%3A-simple-version-of-this-is-using-enums-to-encapsulate-states-as-variants"></a></p>

<p>Then you can add the following code to the <code class="language-plaintext highlighter-rouge">src/ex1.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">InputEvent</span> <span class="p">{</span>
    <span class="nf">Keyboard</span><span class="p">((</span><span class="n">KeyPress</span><span class="p">,</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Modifier</span><span class="o">&gt;&gt;</span><span class="p">)),</span>
    <span class="nf">Resize</span><span class="p">(</span><span class="n">Size</span><span class="p">),</span>
    <span class="nf">Mouse</span><span class="p">(</span><span class="n">MouseEvent</span><span class="p">),</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">Modifier</span> <span class="p">{</span>
    <span class="n">Shift</span><span class="p">,</span>
    <span class="n">Control</span><span class="p">,</span>
    <span class="n">Alt</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">KeyPress</span> <span class="p">{</span>
    <span class="nf">Char</span><span class="p">(</span><span class="nb">char</span><span class="p">),</span>
    <span class="n">Enter</span><span class="p">,</span>
    <span class="n">Backspace</span><span class="p">,</span>
    <span class="n">Delete</span><span class="p">,</span>
    <span class="n">Left</span><span class="p">,</span>
    <span class="n">Right</span><span class="p">,</span>
    <span class="n">Up</span><span class="p">,</span>
    <span class="n">Down</span><span class="p">,</span>
    <span class="n">Home</span><span class="p">,</span>
    <span class="n">End</span><span class="p">,</span>
    <span class="n">PageUp</span><span class="p">,</span>
    <span class="n">PageDown</span><span class="p">,</span>
    <span class="n">Tab</span><span class="p">,</span>
    <span class="nf">F</span><span class="p">(</span><span class="nb">u8</span><span class="p">),</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">Size</span> <span class="p">{</span>
    <span class="nf">Height</span><span class="p">(</span><span class="nb">u16</span><span class="p">),</span>
    <span class="nf">Width</span><span class="p">(</span><span class="nb">u16</span><span class="p">),</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">MouseEvent</span> <span class="p">{</span>
    <span class="nf">Press</span><span class="p">(</span><span class="n">MouseButton</span><span class="p">,</span> <span class="nb">u16</span><span class="p">,</span> <span class="nb">u16</span><span class="p">),</span>
    <span class="nf">Release</span><span class="p">(</span><span class="nb">u16</span><span class="p">,</span> <span class="nb">u16</span><span class="p">),</span>
    <span class="nf">Hold</span><span class="p">(</span><span class="nb">u16</span><span class="p">,</span> <span class="nb">u16</span><span class="p">),</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">MouseButton</span> <span class="p">{</span>
    <span class="n">Left</span><span class="p">,</span>
    <span class="n">Right</span><span class="p">,</span>
    <span class="n">Middle</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">InputEvent</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">pretty_print</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
            <span class="nn">InputEvent</span><span class="p">::</span><span class="nf">Keyboard</span><span class="p">((</span><span class="n">keypress</span><span class="p">,</span> <span class="n">modifiers</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">result</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">keypress</span><span class="p">);</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">modifiers</span><span class="p">)</span> <span class="o">=</span> <span class="n">modifiers</span> <span class="p">{</span>
                    <span class="n">result</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">modifiers</span><span class="p">));</span>
                <span class="p">}</span>
                <span class="n">result</span>
            <span class="p">}</span>
            <span class="nn">InputEvent</span><span class="p">::</span><span class="nf">Resize</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">size</span><span class="p">),</span>
            <span class="nn">InputEvent</span><span class="p">::</span><span class="nf">Mouse</span><span class="p">(</span><span class="n">mouse_event</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">mouse_event</span><span class="p">),</span>
        <span class="p">};</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">it</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">a_pressed</span> <span class="o">=</span> <span class="nn">InputEvent</span><span class="p">::</span><span class="nf">Keyboard</span><span class="p">((</span><span class="nn">KeyPress</span><span class="p">::</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'a'</span><span class="p">),</span> <span class="nb">None</span><span class="p">));</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">a_pressed</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">ctrl_c_pressed</span> <span class="o">=</span> <span class="nn">InputEvent</span><span class="p">::</span><span class="nf">Keyboard</span><span class="p">(</span>
        <span class="p">(</span><span class="nn">KeyPress</span><span class="p">::</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'c'</span><span class="p">),</span> <span class="nf">Some</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="nn">Modifier</span><span class="p">::</span><span class="n">Control</span><span class="p">]))</span>
    <span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">ctrl_c_pressed</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">enter_pressed</span> <span class="o">=</span> <span class="nn">InputEvent</span><span class="p">::</span><span class="nf">Keyboard</span><span class="p">((</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Enter</span><span class="p">,</span> <span class="nb">None</span><span class="p">));</span>
    <span class="n">enter_pressed</span><span class="nf">.pretty_print</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">mouse_pressed</span> <span class="o">=</span> <span class="nn">InputEvent</span><span class="p">::</span><span class="nf">Mouse</span><span class="p">(</span>
        <span class="nn">MouseEvent</span><span class="p">::</span><span class="nf">Press</span><span class="p">(</span><span class="nn">MouseButton</span><span class="p">::</span><span class="n">Left</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
    <span class="p">);</span>
    <span class="n">mouse_pressed</span><span class="nf">.pretty_print</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>The code for this example is
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/typestate-pattern/src/ex1.rs">here</a>.
Here‚Äôs the code for the real
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/terminal_lib_backends/input_event.rs"><code class="language-plaintext highlighter-rouge">InputEvent</code></a>.</p>
</blockquote>

<p>The main things to note about this code.</p>

<ul>
  <li>We have a bunch of enums that represent different types of input events.</li>
  <li>We have a method on the <code class="language-plaintext highlighter-rouge">InputEvent</code> enum that pretty prints the event for all variants.
We don‚Äôt have a way to restrict methods on a specific variant using this approach.</li>
</ul>

<p>When you run this code (using <code class="language-plaintext highlighter-rouge">cargo run --bin ex1</code>), it should produce the following
output:</p>

<pre class="pre-manual-highlight">$ cargo run --bin ex1
Keyboard((Char('a'), None))
Keyboard((Char('c'), Some([Control])))
Enter
Press(Left, 10, 20)
</pre>

<h3 id="example-2-slightly-more-complex-versions-are-where-one-type--data--another-type">Example 2: Slightly more complex versions are where one type + data = another type</h3>
<p><a id="markdown-example-2%3A-slightly-more-complex-versions-are-where-one-type-%2B-data-%3D-another-type" name="example-2%3A-slightly-more-complex-versions-are-where-one-type-%2B-data-%3D-another-type"></a></p>

<p>For this example, let‚Äôs add the following code to the <code class="language-plaintext highlighter-rouge">src/ex2.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">mod</span> <span class="n">ex1</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">ex1</span><span class="p">::</span><span class="n">InputEvent</span><span class="p">;</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">EditorEvent</span> <span class="p">{</span>
    <span class="nf">InsertChar</span><span class="p">(</span><span class="nb">char</span><span class="p">),</span>
    <span class="n">InsertNewLine</span><span class="p">,</span>
    <span class="n">Delete</span><span class="p">,</span>
    <span class="n">Backspace</span><span class="p">,</span>
    <span class="n">MoveCursorLeft</span><span class="p">,</span>
    <span class="n">MoveCursorRight</span><span class="p">,</span>
    <span class="n">MoveCursorUp</span><span class="p">,</span>
    <span class="n">MoveCursorDown</span><span class="p">,</span>
    <span class="nb">Copy</span><span class="p">,</span>
    <span class="n">Paste</span><span class="p">,</span>
    <span class="n">Cut</span><span class="p">,</span>
    <span class="n">Undo</span><span class="p">,</span>
    <span class="n">Redo</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">TryFrom</span><span class="o">&lt;</span><span class="n">InputEvent</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">EditorEvent</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Error</span> <span class="o">=</span> <span class="nb">String</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">try_from</span><span class="p">(</span><span class="n">input_event</span><span class="p">:</span> <span class="n">InputEvent</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">,</span> <span class="k">Self</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">input_event</span> <span class="p">{</span>
            <span class="nn">InputEvent</span><span class="p">::</span><span class="nf">Keyboard</span><span class="p">((</span><span class="n">keypress</span><span class="p">,</span> <span class="n">modifiers</span><span class="p">))</span> <span class="k">=&gt;</span>
                <span class="k">match</span> <span class="p">(</span><span class="n">keypress</span><span class="p">,</span> <span class="n">modifiers</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="nf">Char</span><span class="p">(</span><span class="n">ch</span><span class="p">),</span> <span class="nb">None</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span><span class="p">::</span><span class="nf">InsertChar</span><span class="p">(</span><span class="n">ch</span><span class="p">)),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="nf">Char</span><span class="p">(</span><span class="n">_</span><span class="p">),</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Enter</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span><span class="p">::</span><span class="n">InsertNewLine</span><span class="p">),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Enter</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Backspace</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Backspace</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Delete</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Delete</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Left</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Left</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Right</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Right</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Up</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Up</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Down</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Down</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Home</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Home</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">End</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">End</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">PageUp</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">PageUp</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">PageDown</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">PageDown</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Tab</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Tab</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="nf">F</span><span class="p">(</span><span class="n">_</span><span class="p">),</span> <span class="nb">None</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="nf">F</span><span class="p">(</span><span class="n">_</span><span class="p">),</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
            <span class="p">},</span>
            <span class="nn">InputEvent</span><span class="p">::</span><span class="nf">Resize</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
            <span class="nn">InputEvent</span><span class="p">::</span><span class="nf">Mouse</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">a_pressed</span> <span class="o">=</span> <span class="nn">InputEvent</span><span class="p">::</span><span class="nf">Keyboard</span><span class="p">((</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'a'</span><span class="p">),</span> <span class="nb">None</span><span class="p">));</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="nn">EditorEvent</span><span class="p">::</span><span class="nf">try_from</span><span class="p">(</span><span class="n">a_pressed</span><span class="p">));</span>

    <span class="k">let</span> <span class="n">enter_pressed</span> <span class="o">=</span> <span class="nn">InputEvent</span><span class="p">::</span><span class="nf">Keyboard</span><span class="p">((</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Enter</span><span class="p">,</span> <span class="nb">None</span><span class="p">));</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="nn">EditorEvent</span><span class="p">::</span><span class="nf">try_from</span><span class="p">(</span><span class="n">enter_pressed</span><span class="p">));</span>
<span class="p">}</span>

</code></pre></div></div>

<blockquote>
  <p>You can get the source code for this example
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/typestate-pattern/src/ex2.rs">here</a>.
Here‚Äôs the code for the real
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/editor/editor_component/editor_event.rs#L74"><code class="language-plaintext highlighter-rouge">EditorEvent</code></a>.</p>
</blockquote>

<p>Here are some notes on this code:</p>

<ul>
  <li>We have a new enum called <code class="language-plaintext highlighter-rouge">EditorEvent</code> that represents different types of events that
can happen in an editor.</li>
  <li>We have a <code class="language-plaintext highlighter-rouge">TryFrom</code> implementation for <code class="language-plaintext highlighter-rouge">InputEvent</code> that converts an <code class="language-plaintext highlighter-rouge">InputEvent</code> into
an <code class="language-plaintext highlighter-rouge">EditorEvent</code>. This is a way to restrict methods to specific variants of an enum by
converting it into a totally different type.</li>
  <li>We still don‚Äôt have a way to restrict methods to specific variants of the enum.</li>
</ul>

<p>When you run this code (using <code class="language-plaintext highlighter-rouge">cargo run --bin ex2</code>), it should produce the following:</p>

<pre class="pre-manual-highlight">$ cargo run --bin ex2
Ok(InsertChar('a'))
Ok(InsertNewLine)
</pre>

<h3 id="example-3-best-of-both-worlds-using-generics-and-struct--enum-with-a-marker-trait">Example 3: Best of both worlds, using generics and struct / enum with a marker trait</h3>
<p><a id="markdown-example-3%3A-best-of-both-worlds%2C-using-generics-and-struct-%2F-enum-with-a-marker-trait" name="example-3%3A-best-of-both-worlds%2C-using-generics-and-struct-%2F-enum-with-a-marker-trait"></a></p>

<p>Finally we have arrived at the typestate pattern in Rust. With this example:</p>
<ul>
  <li>You can now group all the states under a marker.</li>
  <li>You can have methods that are specific to a variant.</li>
  <li>You can specify methods that are common to all.</li>
  <li>It‚Äôs like a very sophisticated builder pattern if you‚Äôre already familiar with that.</li>
</ul>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">src/ex3.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="k">self</span><span class="p">::</span><span class="nn">type_state_builder</span><span class="p">::</span><span class="n">HttpResponse</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">crossterm</span><span class="p">::</span><span class="nn">style</span><span class="p">::</span><span class="n">Stylize</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="nb">String</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">response</span> <span class="o">=</span> <span class="nn">HttpResponse</span><span class="p">::</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"Start state"</span><span class="nf">.red</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">());</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"response: {:#?}"</span><span class="p">,</span> <span class="n">response</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"response size: {}"</span><span class="p">,</span>
        <span class="n">response</span><span class="nf">.get_size</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="c1">// Transition to HeaderAndBody state by calling `set_status_line`.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">response</span> <span class="o">=</span> <span class="n">response</span><span class="nf">.set_status_line</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="s">"OK"</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"response: {:#?}"</span><span class="p">,</span> <span class="n">response</span><span class="p">);</span>

    <span class="c1">// Status line is required.</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"HeaderAndBody state"</span><span class="nf">.red</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">());</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"response_code: {}"</span><span class="p">,</span> <span class="n">response</span><span class="nf">.get_response_code</span><span class="p">());</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"response body: {:#?}"</span><span class="p">,</span> <span class="n">response</span><span class="nf">.get_body</span><span class="p">());</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"response: {:#?}"</span><span class="p">,</span> <span class="n">response</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"response size: {}"</span><span class="p">,</span>
        <span class="n">response</span><span class="nf">.get_size</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="c1">// Body and headers are optional.</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"HeaderAndBody state # 2"</span><span class="nf">.red</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">());</span>
    <span class="n">response</span><span class="nf">.add_header</span><span class="p">(</span><span class="s">"Content-Type"</span><span class="p">,</span> <span class="s">"text/html"</span><span class="p">);</span>
    <span class="n">response</span><span class="nf">.set_body</span><span class="p">(</span><span class="s">"&lt;html&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt;"</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"response: {:#?}"</span><span class="p">,</span> <span class="n">response</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"response size: {}"</span><span class="p">,</span>
        <span class="n">response</span><span class="nf">.get_size</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="c1">// Final state.</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"Final state"</span><span class="nf">.red</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">());</span>
    <span class="k">let</span> <span class="n">response</span> <span class="o">=</span> <span class="n">response</span><span class="nf">.finish</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"response_code: {}"</span><span class="p">,</span> <span class="n">response</span><span class="nf">.get_response_code</span><span class="p">());</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"status_line: {}"</span><span class="p">,</span> <span class="n">response</span><span class="nf">.get_status_line</span><span class="p">());</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"headers: {:#?}"</span><span class="p">,</span> <span class="n">response</span><span class="nf">.get_headers</span><span class="p">());</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"body: {}"</span><span class="p">,</span> <span class="n">response</span><span class="nf">.get_body</span><span class="p">());</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"response: {:#?}"</span><span class="p">,</span> <span class="n">response</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"response size: {}"</span><span class="p">,</span>
        <span class="n">response</span><span class="nf">.get_size</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note the API that we have built here:</p>
<ul>
  <li>You can‚Äôt call <code class="language-plaintext highlighter-rouge">get_response_code</code> or <code class="language-plaintext highlighter-rouge">get_body</code> until you‚Äôve called <code class="language-plaintext highlighter-rouge">set_status_line</code>.</li>
  <li>You can‚Äôt call <code class="language-plaintext highlighter-rouge">add_header</code> or <code class="language-plaintext highlighter-rouge">set_body</code> until you‚Äôve called <code class="language-plaintext highlighter-rouge">set_status_line</code>.</li>
  <li>You can‚Äôt call <code class="language-plaintext highlighter-rouge">finish</code> until you‚Äôve called <code class="language-plaintext highlighter-rouge">set_status_line</code>.</li>
  <li>We have 3 states: <code class="language-plaintext highlighter-rouge">Start</code>, <code class="language-plaintext highlighter-rouge">HeaderAndBody</code>, and <code class="language-plaintext highlighter-rouge">Final</code>. These are meant to be used as
markers to restrict methods to specific states. Each is a struct with a marker trait.
And it may or may not contain data / fields.</li>
  <li>We have a <code class="language-plaintext highlighter-rouge">HttpResponse</code> struct that uses a generic type <code class="language-plaintext highlighter-rouge">T: Marker</code> to represent the
state. This is a way to restrict methods to specific states.</li>
  <li>We can transition between states by calling methods that consume the current state and
return a new state. These methods are specific to the state they transition from. And
they can be implemented via <code class="language-plaintext highlighter-rouge">impl HttpResponse&lt;T: Marker&gt; { ... }</code> blocks, where <code class="language-plaintext highlighter-rouge">T</code> is
the <code class="language-plaintext highlighter-rouge">Start</code>, <code class="language-plaintext highlighter-rouge">HeaderAndBody</code>, or <code class="language-plaintext highlighter-rouge">Final</code> state.</li>
  <li>We can even implement methods that are valid for a non-existent state using <code class="language-plaintext highlighter-rouge">impl
HttpResponse&lt;()&gt; { ... }</code>. This is the constructor.</li>
  <li>In the <code class="language-plaintext highlighter-rouge">Final</code> state, the data becomes immutable.</li>
</ul>

<p>Add the following code to desribe the different state structs.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">mod</span> <span class="n">state</span> <span class="p">{</span>
    <span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Default)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">Start</span> <span class="p">{}</span>

    <span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Default)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">HeaderAndBody</span> <span class="p">{</span>
        <span class="k">pub</span> <span class="n">response_code</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
        <span class="k">pub</span> <span class="n">status_line</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
        <span class="k">pub</span> <span class="n">headers</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span> <span class="nb">String</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">,</span>
        <span class="k">pub</span> <span class="n">body</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Default)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">Final</span> <span class="p">{</span>
        <span class="k">pub</span> <span class="n">response_code</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
        <span class="k">pub</span> <span class="n">status_line</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
        <span class="k">pub</span> <span class="n">headers</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span> <span class="nb">String</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="k">pub</span> <span class="n">body</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1">// The following marker trait is used to restrict the operations</span>
    <span class="c1">// that are available in each state. This isn't strictly necessary,</span>
    <span class="c1">// but it's a nice thing to use in a where clause to restrict types.</span>
    <span class="k">pub</span> <span class="k">trait</span> <span class="n">Marker</span> <span class="p">{}</span>
    <span class="k">impl</span> <span class="n">Marker</span> <span class="k">for</span> <span class="p">()</span> <span class="p">{}</span>
    <span class="k">impl</span> <span class="n">Marker</span> <span class="k">for</span> <span class="n">Start</span> <span class="p">{}</span>
    <span class="k">impl</span> <span class="n">Marker</span> <span class="k">for</span> <span class="n">HeaderAndBody</span> <span class="p">{}</span>
    <span class="k">impl</span> <span class="n">Marker</span> <span class="k">for</span> <span class="n">Final</span> <span class="p">{}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here is the code for the <code class="language-plaintext highlighter-rouge">HttpResponse</code> struct.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">mod</span> <span class="n">type_state_builder</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="nn">state</span><span class="p">::{</span><span class="n">Final</span><span class="p">,</span> <span class="n">HeaderAndBody</span><span class="p">,</span> <span class="n">Marker</span><span class="p">,</span> <span class="n">Start</span><span class="p">};</span>

    <span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Default)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="n">S</span><span class="p">:</span> <span class="n">Marker</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">pub</span> <span class="n">state</span><span class="p">:</span> <span class="n">S</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1">// Operations that are available in all states.</span>
    <span class="k">impl</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">S</span><span class="p">:</span> <span class="n">Marker</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_size</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">size_of_val</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>
            <span class="nd">format!</span><span class="p">(</span><span class="s">"{} bytes"</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Operations that are only valid in `()`.</span>
    <span class="k">impl</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="n">Start</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="n">HttpResponse</span> <span class="p">{</span> <span class="n">state</span><span class="p">:</span> <span class="n">Start</span> <span class="p">{}</span> <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Operations that are only valid in `Start`.</span>
    <span class="k">impl</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="n">Start</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">set_status_line</span><span class="p">(</span>
            <span class="k">self</span><span class="p">,</span>
            <span class="n">response_code</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
            <span class="n">message</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
        <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="n">HeaderAndBody</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="n">HttpResponse</span> <span class="p">{</span>
                <span class="n">state</span><span class="p">:</span> <span class="n">HeaderAndBody</span> <span class="p">{</span>
                    <span class="n">response_code</span><span class="p">,</span>
                    <span class="n">status_line</span><span class="p">:</span> <span class="nd">format!</span><span class="p">(</span>
                        <span class="s">"HTTP/1.1 {} {}"</span><span class="p">,</span> <span class="n">response_code</span><span class="p">,</span> <span class="n">message</span>
                    <span class="p">),</span>
                    <span class="o">..</span><span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">()</span>
                <span class="p">},</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Operations that are only valid in `HeaderAndBodyState`.</span>
    <span class="k">impl</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="n">HeaderAndBody</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// setter.</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">add_header</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">self</span><span class="py">.state.headers</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.state.headers</span><span class="nf">.replace</span><span class="p">(</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">());</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.state.headers</span><span class="nf">.as_mut</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">v</span><span class="nf">.push</span><span class="p">((</span><span class="n">key</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="n">value</span><span class="nf">.to_string</span><span class="p">()))</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// getter.</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_response_code</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u8</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.state.response_code</span>
        <span class="p">}</span>

        <span class="c1">// setter.</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">set_body</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">body</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.state.body</span><span class="nf">.replace</span><span class="p">(</span><span class="n">body</span><span class="nf">.to_string</span><span class="p">());</span>
        <span class="p">}</span>

        <span class="c1">// getter.</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_body</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.state.body</span><span class="nf">.as_deref</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="c1">// transition to Final state.</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">finish</span><span class="p">(</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="n">Final</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="n">HttpResponse</span> <span class="p">{</span>
                <span class="n">state</span><span class="p">:</span> <span class="n">Final</span> <span class="p">{</span>
                    <span class="n">response_code</span><span class="p">:</span> <span class="k">self</span><span class="py">.state.response_code</span><span class="p">,</span>
                    <span class="n">status_line</span><span class="p">:</span> <span class="k">self</span><span class="py">.state.status_line</span><span class="nf">.clone</span><span class="p">(),</span>
                    <span class="n">headers</span><span class="p">:</span> <span class="k">self</span><span class="py">.state.headers</span><span class="nf">.take</span><span class="p">()</span><span class="nf">.unwrap_or_default</span><span class="p">(),</span>
                    <span class="n">body</span><span class="p">:</span> <span class="k">self</span><span class="py">.state.body</span><span class="nf">.take</span><span class="p">()</span><span class="nf">.unwrap_or_default</span><span class="p">(),</span>
                <span class="p">},</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Operations that are only valid in `Final`.</span>
    <span class="k">impl</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="n">Final</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// getter.</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_headers</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span> <span class="nb">String</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="o">&amp;</span><span class="k">self</span><span class="py">.state.headers</span>
        <span class="p">}</span>

        <span class="c1">// getter.</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_body</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="p">{</span>
            <span class="o">&amp;</span><span class="k">self</span><span class="py">.state.body</span>
        <span class="p">}</span>

        <span class="c1">// getter.</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_response_code</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u8</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.state.response_code</span>
        <span class="p">}</span>

        <span class="c1">// getter.</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_status_line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="p">{</span>
            <span class="o">&amp;</span><span class="k">self</span><span class="py">.state.status_line</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When you run the code using <code class="language-plaintext highlighter-rouge">cargo run --bin ex3</code>, it should produce the following output.</p>

<pre class="pre-manual-highlight">$ cargo run --bin ex3
<span style="color:#BF616A"><u style="text-decoration-style:single"><b>Start state</b></u></span>
response: HttpResponse {
    state: Start,
}
response size: <span style="color:#81A1C1"><b>0 bytes</b></span>
response: HttpResponse {
    state: HeaderAndBody {
        response_code: 200,
        status_line: &quot;HTTP/1.1 200 OK&quot;,
        headers: None,
        body: None,
    },
}
<span style="color:#BF616A"><u style="text-decoration-style:single"><b>HeaderAndBody state</b></u></span>
response_code: 200
response body: None
response: HttpResponse {
    state: HeaderAndBody {
        response_code: 200,
        status_line: &quot;HTTP/1.1 200 OK&quot;,
        headers: None,
        body: None,
    },
}
response size: <span style="color:#81A1C1"><b>80 bytes</b></span>
<span style="color:#BF616A"><u style="text-decoration-style:single"><b>HeaderAndBody state # 2</b></u></span>
response: HttpResponse {
    state: HeaderAndBody {
        response_code: 200,
        status_line: &quot;HTTP/1.1 200 OK&quot;,
        headers: Some(
            [
                (
                    &quot;Content-Type&quot;,
                    &quot;text/html&quot;,
                ),
            ],
        ),
        body: Some(
            &quot;&lt;html&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt;&quot;,
        ),
    },
}
response size: <span style="color:#81A1C1"><b>80 bytes</b></span>
<span style="color:#BF616A"><u style="text-decoration-style:single"><b>Final state</b></u></span>
response_code: 200
status_line: HTTP/1.1 200 OK
headers: [
    (
        &quot;Content-Type&quot;,
        &quot;text/html&quot;,
    ),
]
body: &lt;html&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt;
response: HttpResponse {
    state: Final {
        response_code: 200,
        status_line: &quot;HTTP/1.1 200 OK&quot;,
        headers: [
            (
                &quot;Content-Type&quot;,
                &quot;text/html&quot;,
            ),
        ],
        body: &quot;&lt;html&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt;&quot;,
    },
}
response size: <span style="color:#81A1C1"><b>80 bytes</b></span>
</pre>

<h3 id="example-31-using-enum-and-phantomdata-instead-of-struct">Example 3.1: Using enum and PhantomData instead of struct</h3>

<ul>
  <li>You can use enums instead of structs if you have shared data (inner) that you move with
state transitions.</li>
  <li>And you have to use <code class="language-plaintext highlighter-rouge">PhantomData</code> here.</li>
</ul>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">src/ex3_1.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="k">self</span><span class="p">::</span><span class="nn">type_state_builder</span><span class="p">::</span><span class="n">HttpResponse</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">crossterm</span><span class="p">::</span><span class="nn">style</span><span class="p">::</span><span class="n">Stylize</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="nb">String</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">response</span> <span class="o">=</span> <span class="nn">HttpResponse</span><span class="p">::</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"Start state"</span><span class="nf">.red</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">());</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"response: {:#?}"</span><span class="p">,</span> <span class="n">response</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"response size: {}"</span><span class="p">,</span>
        <span class="n">response</span><span class="nf">.get_size</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="c1">// Status line is required.</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"HeaderAndBody state"</span><span class="nf">.red</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">());</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">response</span> <span class="o">=</span> <span class="n">response</span><span class="nf">.set_status_line</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="s">"OK"</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"response_code: {}"</span><span class="p">,</span> <span class="n">response</span><span class="nf">.get_response_code</span><span class="p">());</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"response body: {:#?}"</span><span class="p">,</span> <span class="n">response</span><span class="nf">.get_body</span><span class="p">());</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"response: {:#?}"</span><span class="p">,</span> <span class="n">response</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"response size: {}"</span><span class="p">,</span>
        <span class="n">response</span><span class="nf">.get_size</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="c1">// Body and headers are optional.</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"HeaderAndBody state # 2"</span><span class="nf">.red</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">());</span>
    <span class="n">response</span><span class="nf">.add_header</span><span class="p">(</span><span class="s">"Content-Type"</span><span class="p">,</span> <span class="s">"text/html"</span><span class="p">);</span>
    <span class="n">response</span><span class="nf">.set_body</span><span class="p">(</span><span class="s">"&lt;html&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt;"</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"response: {:#?}"</span><span class="p">,</span> <span class="n">response</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"response size: {}"</span><span class="p">,</span>
        <span class="n">response</span><span class="nf">.get_size</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="c1">// Final state.</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"Final state"</span><span class="nf">.red</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">());</span>
    <span class="k">let</span> <span class="n">response</span> <span class="o">=</span> <span class="n">response</span><span class="nf">.finish</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"response_code: {}"</span><span class="p">,</span> <span class="n">response</span><span class="nf">.get_response_code</span><span class="p">());</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"status_line: {}"</span><span class="p">,</span> <span class="n">response</span><span class="nf">.get_status_line</span><span class="p">());</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"headers: {:#?}"</span><span class="p">,</span> <span class="n">response</span><span class="nf">.get_headers</span><span class="p">());</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"body: {:#?}"</span><span class="p">,</span> <span class="n">response</span><span class="nf">.get_body</span><span class="p">());</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"response: {:#?}"</span><span class="p">,</span> <span class="n">response</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"response size: {}"</span><span class="p">,</span>
        <span class="n">response</span><span class="nf">.get_size</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note that this <code class="language-plaintext highlighter-rouge">main</code> function is the same as the one in the previous example.</p>

<p>The following code will be different. We are adding a new <code class="language-plaintext highlighter-rouge">data</code> module.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">mod</span> <span class="n">data</span> <span class="p">{</span>
    <span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Default)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">HttpResponseData</span> <span class="p">{</span>
        <span class="k">pub</span> <span class="n">response_code</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
        <span class="k">pub</span> <span class="n">status_line</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
        <span class="k">pub</span> <span class="n">headers</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span> <span class="nb">String</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">,</span>
        <span class="k">pub</span> <span class="n">body</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here‚Äôs the new <code class="language-plaintext highlighter-rouge">state</code> module. Note the use of enums and <code class="language-plaintext highlighter-rouge">PhantomData</code> instead of structs.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">mod</span> <span class="n">state</span> <span class="p">{</span>
    <span class="nd">#[derive(Debug,</span> <span class="nd">Clone)]</span>
    <span class="k">pub</span> <span class="k">enum</span> <span class="n">Start</span> <span class="p">{}</span>

    <span class="nd">#[derive(Debug,</span> <span class="nd">Clone)]</span>
    <span class="k">pub</span> <span class="k">enum</span> <span class="n">HeaderAndBody</span> <span class="p">{}</span>

    <span class="nd">#[derive(Debug,</span> <span class="nd">Clone)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">Final</span> <span class="p">{}</span>

    <span class="c1">// The following marker trait is used to restrict the operations</span>
    <span class="c1">// that are available in each state. This isn't strictly necessary,</span>
    <span class="c1">// but it's a nice thing to use in a where clause to restrict types.</span>
    <span class="k">pub</span> <span class="k">trait</span> <span class="n">Marker</span> <span class="p">{}</span>
    <span class="k">impl</span> <span class="n">Marker</span> <span class="k">for</span> <span class="p">()</span> <span class="p">{}</span>
    <span class="k">impl</span> <span class="n">Marker</span> <span class="k">for</span> <span class="n">Start</span> <span class="p">{}</span>
    <span class="k">impl</span> <span class="n">Marker</span> <span class="k">for</span> <span class="n">HeaderAndBody</span> <span class="p">{}</span>
    <span class="k">impl</span> <span class="n">Marker</span> <span class="k">for</span> <span class="n">Final</span> <span class="p">{}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here is the changed code for the <code class="language-plaintext highlighter-rouge">HttpResponse</code> struct.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">mod</span> <span class="n">type_state_builder</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::{</span>
        <span class="nn">data</span><span class="p">::</span><span class="n">HttpResponseData</span><span class="p">,</span>
        <span class="nn">state</span><span class="p">::{</span><span class="n">Final</span><span class="p">,</span> <span class="n">HeaderAndBody</span><span class="p">,</span> <span class="n">Marker</span><span class="p">,</span> <span class="n">Start</span><span class="p">},</span>
    <span class="p">};</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">marker</span><span class="p">::</span><span class="n">PhantomData</span><span class="p">;</span>

    <span class="nd">#[derive(Debug,</span> <span class="nd">Clone)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="n">S</span><span class="p">:</span> <span class="n">Marker</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">pub</span> <span class="n">data</span><span class="p">:</span> <span class="n">HttpResponseData</span><span class="p">,</span>
        <span class="k">pub</span> <span class="n">state</span><span class="p">:</span> <span class="n">PhantomData</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1">// Operations that are only valid in ().</span>
    <span class="k">impl</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="n">Start</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="n">HttpResponse</span> <span class="p">{</span>
                <span class="n">data</span><span class="p">:</span> <span class="nn">HttpResponseData</span><span class="p">::</span><span class="nf">default</span><span class="p">(),</span>
                <span class="n">state</span><span class="p">:</span> <span class="nn">PhantomData</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Start</span><span class="o">&gt;</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Operations that are only valid in Start.</span>
    <span class="k">impl</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="n">Start</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// setter.</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">set_status_line</span><span class="p">(</span>
            <span class="k">self</span><span class="p">,</span>
            <span class="n">response_code</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
            <span class="n">message</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
        <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="n">HeaderAndBody</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="n">HttpResponse</span> <span class="p">{</span>
                <span class="n">data</span><span class="p">:</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="k">mut</span> <span class="n">data</span> <span class="o">=</span> <span class="k">self</span><span class="py">.data</span><span class="p">;</span>
                    <span class="n">data</span><span class="py">.response_code</span> <span class="o">=</span> <span class="n">response_code</span><span class="p">;</span>
                    <span class="n">data</span><span class="py">.status_line</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span>
                        <span class="s">"HTTP/1.1 {} {}"</span><span class="p">,</span> <span class="n">response_code</span><span class="p">,</span> <span class="n">message</span>
                    <span class="p">);</span>
                    <span class="n">data</span>
                <span class="p">},</span>
                <span class="n">state</span><span class="p">:</span> <span class="nn">PhantomData</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HeaderAndBody</span><span class="o">&gt;</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Operations that are only valid in HeaderAndBodyState.</span>
    <span class="k">impl</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="n">HeaderAndBody</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// setter.</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">add_header</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">mut_data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.data</span><span class="p">;</span>
            <span class="k">if</span> <span class="n">mut_data</span><span class="py">.headers</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">mut_data</span><span class="py">.headers</span><span class="nf">.replace</span><span class="p">(</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">());</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">headers</span><span class="p">)</span> <span class="o">=</span> <span class="n">mut_data</span><span class="py">.headers</span><span class="nf">.as_mut</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">headers</span><span class="nf">.push</span><span class="p">((</span><span class="n">key</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="n">value</span><span class="nf">.to_string</span><span class="p">()))</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// getter.</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_response_code</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u8</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.data.response_code</span>
        <span class="p">}</span>

        <span class="c1">// setter.</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">set_body</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">body</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.data.body</span><span class="nf">.replace</span><span class="p">(</span><span class="n">body</span><span class="nf">.to_string</span><span class="p">());</span>
        <span class="p">}</span>

        <span class="c1">// getter.</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_body</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.data.body</span><span class="nf">.as_deref</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="c1">// transition to Final state.</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">finish</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="n">Final</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">data</span> <span class="o">=</span> <span class="k">self</span><span class="py">.data</span><span class="p">;</span>
            <span class="n">HttpResponse</span> <span class="p">{</span>
                <span class="n">data</span><span class="p">:</span> <span class="n">HttpResponseData</span> <span class="p">{</span>
                    <span class="n">response_code</span><span class="p">:</span> <span class="n">data</span><span class="py">.response_code</span><span class="p">,</span>
                    <span class="n">status_line</span><span class="p">:</span> <span class="n">data</span><span class="py">.status_line</span><span class="nf">.clone</span><span class="p">(),</span>
                    <span class="n">headers</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="n">data</span><span class="py">.headers</span><span class="nf">.take</span><span class="p">()</span><span class="nf">.unwrap_or_default</span><span class="p">()),</span>
                    <span class="n">body</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="n">data</span><span class="py">.body</span><span class="nf">.take</span><span class="p">()</span><span class="nf">.unwrap_or_default</span><span class="p">()),</span>
                <span class="p">},</span>
                <span class="n">state</span><span class="p">:</span> <span class="nn">PhantomData</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Final</span><span class="o">&gt;</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Operations that are only valid in FinalState.</span>
    <span class="k">impl</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="n">Final</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_headers</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span> <span class="nb">String</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
            <span class="o">&amp;</span><span class="k">self</span><span class="py">.data.headers</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_body</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="o">&amp;</span><span class="k">self</span><span class="py">.data.body</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_response_code</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u8</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.data.response_code</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_status_line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="p">{</span>
            <span class="o">&amp;</span><span class="k">self</span><span class="py">.data.status_line</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Operations that are available in all states.</span>
    <span class="k">impl</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">S</span><span class="p">:</span> <span class="n">Marker</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_size</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">size_of_val</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>
            <span class="nd">format!</span><span class="p">(</span><span class="s">"{} bytes"</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here‚Äôs the output when you run the code using <code class="language-plaintext highlighter-rouge">cargo run --bin ex3_1</code>.</p>

<pre class="pre-manual-highlight">$ cargo run --bin ex3_1
<span style="color:#BF616A"><u style="text-decoration-style:single"><b>Start state</b></u></span>
response: HttpResponse {
    data: HttpResponseData {
        response_code: 0,
        status_line: &quot;&quot;,
        headers: None,
        body: None,
    },
    state: PhantomData&lt;ex3_1::state::Start&gt;,
}
response size: <span style="color:#81A1C1"><b>80 bytes</b></span>
<span style="color:#BF616A"><u style="text-decoration-style:single"><b>HeaderAndBody state</b></u></span>
response_code: 200
response body: None
response: HttpResponse {
    data: HttpResponseData {
        response_code: 200,
        status_line: &quot;HTTP/1.1 200 OK&quot;,
        headers: None,
        body: None,
    },
    state: PhantomData&lt;ex3_1::state::HeaderAndBody&gt;,
}
response size: <span style="color:#81A1C1"><b>80 bytes</b></span>
<span style="color:#BF616A"><u style="text-decoration-style:single"><b>HeaderAndBody state # 2</b></u></span>
response: HttpResponse {
    data: HttpResponseData {
        response_code: 200,
        status_line: &quot;HTTP/1.1 200 OK&quot;,
        headers: Some(
            [
                (
                    &quot;Content-Type&quot;,
                    &quot;text/html&quot;,
                ),
            ],
        ),
        body: Some(
            &quot;&lt;html&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt;&quot;,
        ),
    },
    state: PhantomData&lt;ex3_1::state::HeaderAndBody&gt;,
}
response size: <span style="color:#81A1C1"><b>80 bytes</b></span>
<span style="color:#BF616A"><u style="text-decoration-style:single"><b>Final state</b></u></span>
response_code: 200
status_line: HTTP/1.1 200 OK
headers: Some(
    [
        (
            &quot;Content-Type&quot;,
            &quot;text/html&quot;,
        ),
    ],
)
body: Some(
    &quot;&lt;html&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt;&quot;,
)
response: HttpResponse {
    data: HttpResponseData {
        response_code: 200,
        status_line: &quot;HTTP/1.1 200 OK&quot;,
        headers: Some(
            [
                (
                    &quot;Content-Type&quot;,
                    &quot;text/html&quot;,
                ),
            ],
        ),
        body: Some(
            &quot;&lt;html&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt;&quot;,
        ),
    },
    state: PhantomData&lt;ex3_1::state::Final&gt;,
}
response size: <span style="color:#81A1C1"><b>80 bytes</b></span>
</pre>

<h3 id="parting-thoughts">Parting thoughts</h3>
<p><a id="markdown-parting-thoughts" name="parting-thoughts"></a></p>

<p>To get an experiential understanding of the typestate pattern, you should try to build
something using it. It‚Äôs a powerful pattern that can help you write more robust and
predictable code. And it‚Äôs a great way to leverage Rust‚Äôs type system to enforce state
transitions in your code. I encourage you to clone the repo and run the code to see how it
works. And make changes to it to see if you can make it behave differently and use it in
your own projects.</p>

<h2 id="build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</h2>
<p><a id="markdown-build-with-naz-video-series-on-developerlife.com-youtube-channel" name="build-with-naz-video-series-on-developerlife.com-youtube-channel"></a></p>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a></li>
  <li>Playlists
    <ul>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmza94sS7UmJnN9gSCHTVTfz">Build with Naz, fundamental effective Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmwO69E7eiQ-ewnMME8ydgQ5">Build with Naz, effective async Rust and tokio</a></li>
      <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><summary type="html"><![CDATA[The Typestate Pattern in Rust is a way to manage objects that go through different states in their lifecycle. It leverages Rust's powerful type system to enforce these states and transitions between them, making your code safer and more predictable. Learn all about it in this article and its video.]]></summary></entry><entry><title type="html">Build with Naz : Linux io_uring and tokio-uring exploration with Rust</title><link href="http://developerlife.com/2024/05/25/tokio-uring-exploration-rust/" rel="alternate" type="text/html" title="Build with Naz : Linux io_uring and tokio-uring exploration with Rust" /><published>2024-05-25T10:00:00-05:00</published><updated>2024-05-25T10:00:00-05:00</updated><id>http://developerlife.com/2024/05/25/tokio-uring-exploration-rust</id><content type="html" xml:base="http://developerlife.com/2024/05/25/tokio-uring-exploration-rust/"><![CDATA[<p><img class="post-hero-image" src="/assets/rust_tokio_uring.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#what-is-linux-io_uring">What is Linux io_uring?</a></li>
  <li><a href="#youtube-video-for-this-article">YouTube video for this article</a></li>
  <li><a href="#examples-of-using-tokio-uring-in-rust">Examples of using tokio-uring in Rust</a>
    <ul>
      <li><a href="#example-1-read-a-file-using-tokio-uring-and-async-non-blocking-io">Example 1: Read a file using tokio-uring and async, non-blocking IO</a></li>
      <li><a href="#example-2-building-a-tcp-echo-server-using-tokio-uring-that-also-uses-tokio">Example 2: Building a TCP echo server using tokio-uring that also uses tokio</a></li>
      <li><a href="#parting-thoughts">Parting thoughts</a></li>
    </ul>
  </li>
  <li><a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</a></li>
</ul>

<!-- /TOC -->

<h2 id="what-is-linux-io_uring">What is Linux io_uring?</h2>
<p><a id="markdown-what-is-linux-io_uring%3F" name="what-is-linux-io_uring%3F"></a></p>

<p>When using async Rust and <code class="language-plaintext highlighter-rouge">tokio</code>, you don‚Äôt get async file IO at the OS level. Here are
links from the official docs that discourage using <code class="language-plaintext highlighter-rouge">tokio</code> for file IO:</p>
<ul>
  <li><a href="https://tokio.rs/tokio/tutorial">Tokio tutorial, when not to use Tokio</a>.</li>
  <li><a href="https://users.rust-lang.org/t/tokio-copy-slower-than-std-io-copy/111242">Tokio::io::copy slower than std
io::copy</a>.</li>
</ul>

<p>This is because <code class="language-plaintext highlighter-rouge">tokio</code> uses the <code class="language-plaintext highlighter-rouge">mio</code> crate, which uses <code class="language-plaintext highlighter-rouge">epoll</code> on Linux. These are not
the most efficient ways to do async IO on Linux. The most efficient way to do async IO on
Linux is to use the <code class="language-plaintext highlighter-rouge">io_uring</code> syscall. This is a new syscall that was added to the Linux
kernel in version 5.1. It is a more efficient way to do async IO on Linux, and is used by
the <code class="language-plaintext highlighter-rouge">tokio-uring</code> crate. Here are some great links to learn more about <code class="language-plaintext highlighter-rouge">io_uring</code>:</p>
<ul>
  <li><a href="https://unixism.net/loti/what_is_io_uring.html#the-io-uring-interface">io_uring mental
model</a>.</li>
  <li><a href="https://www.scylladb.com/2020/05/05/how-io_uring-and-ebpf-will-revolutionize-programming-in-linux/0/">How io_uring and eBPF Will Revolutionize Programming in
Linux</a>.</li>
  <li><a href="https://lore.kernel.org/io-uring/4af91b50-4a9c-8a16-9470-a51430bd7733@kernel.dk/T/#u">io_uring and Intel Optane
stats</a>.</li>
  <li><a href="https://tokio.rs/blog/2021-07-tokio-uring">Announcing io_uring support for Tokio -
tokio-uring</a>.</li>
</ul>

<p>In this article, we will explore how to use <code class="language-plaintext highlighter-rouge">tokio-uring</code> to do async file IO at the OS
level, and how to use it to build a simple echo TCP server, for use with <code class="language-plaintext highlighter-rouge">netcat</code>.</p>

<h2 id="youtube-video-for-this-article">YouTube video for this article</h2>
<p><a id="markdown-youtube-video-for-this-article" name="youtube-video-for-this-article"></a></p>

<p>This blog post has short examples on how to use the <code class="language-plaintext highlighter-rouge">tokio-uring</code> crate. If you like to
learn via video, please watch the companion video on the <a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube
channel</a>.</p>

<!-- rust tokio-uring exploration-->
<iframe src="https://www.youtube.com/embed/VKL52XmY6Os?si=RgUKu-CZSXvKpJ7M" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<p><br /></p>

<h2 id="examples-of-using-tokio-uring-in-rust">Examples of using tokio-uring in Rust</h2>
<p><a id="markdown-examples-of-using-tokio-uring-in-rust" name="examples-of-using-tokio-uring-in-rust"></a></p>

<p>Let‚Äôs create some examples to illustrate how to use <code class="language-plaintext highlighter-rouge">tokio-uring</code>. You can run
<code class="language-plaintext highlighter-rouge">cargo new --bin tokio-uring</code> to create a new binary crate.</p>

<blockquote>
  <p>The code in the video and this tutorial are all in <a href="https://github.com/nazmulidris/rust-scratch/tree/main/tokio-uring">this GitHub
repo</a>.</p>
</blockquote>

<p>Then add the following to the <code class="language-plaintext highlighter-rouge">Cargo.toml</code> file that‚Äôs generated. These pull in all the
dependencies that we need for these examples.</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[package]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"tokio-uring"</span>
<span class="py">version</span> <span class="p">=</span> <span class="s">"0.1.0"</span>
<span class="py">edition</span> <span class="p">=</span> <span class="s">"2021"</span>

<span class="nn">[[bin]]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"readfile"</span>
<span class="py">path</span> <span class="p">=</span> <span class="s">"src/readfile.rs"</span>

<span class="nn">[[bin]]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"socketserver"</span>
<span class="py">path</span> <span class="p">=</span> <span class="s">"src/socketserver.rs"</span>

<span class="nn">[dependencies]</span>
<span class="py">tokio-uring</span> <span class="p">=</span> <span class="s">"0.4.0"</span>
<span class="py">tokio</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"1.37.0"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"full"</span><span class="p">,</span> <span class="s">"tracing"</span><span class="p">]</span> <span class="p">}</span>
<span class="py">tokio-util</span> <span class="p">=</span> <span class="s">"0.7.11"</span>
<span class="py">tracing</span> <span class="p">=</span> <span class="s">"0.1.40"</span>
<span class="py">tracing-subscriber</span> <span class="p">=</span> <span class="s">"0.3.18"</span>

<span class="py">ctrlc</span> <span class="p">=</span> <span class="s">"3.4.4"</span>
<span class="py">miette</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"7.2.0"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"fancy"</span><span class="p">]</span> <span class="p">}</span>

<span class="py">crossterm</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.27.0"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"event-stream"</span><span class="p">]</span> <span class="p">}</span>

<span class="py">r3bl_terminal_async</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.5.3"</span> <span class="p">}</span>
</code></pre></div></div>

<h3 id="example-1-read-a-file-using-tokio-uring-and-async-non-blocking-io">Example 1: Read a file using tokio-uring and async, non-blocking IO</h3>
<p><a id="markdown-example-1%3A-read-a-file-using-tokio-uring-and-async%2C-non-blocking-io" name="example-1%3A-read-a-file-using-tokio-uring-and-async%2C-non-blocking-io"></a></p>

<p>Then you can add the following code to the <code class="language-plaintext highlighter-rouge">src/readfile.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">crossterm</span><span class="p">::</span><span class="nn">style</span><span class="p">::</span><span class="n">Stylize</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">miette</span><span class="p">::</span><span class="n">IntoDiagnostic</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">path</span><span class="p">::</span><span class="n">Path</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nn">tokio_uring</span><span class="p">::</span><span class="nf">start</span><span class="p">(</span><span class="nf">read_file</span><span class="p">(</span><span class="s">"Cargo.toml"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">async</span> <span class="k">fn</span> <span class="nf">read_file</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="k">impl</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">file</span> <span class="o">=</span> <span class="nn">tokio_uring</span><span class="p">::</span><span class="nn">fs</span><span class="p">::</span><span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="k">.await</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">buf_move</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">4096</span><span class="p">];</span>

    <span class="c1">// Read some data, the buffer is passed by ownership and submitted</span>
    <span class="c1">// to the kernel. When the operation completes, we get the buffer</span>
    <span class="c1">// back.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">buf_from_kernel</span><span class="p">)</span> <span class="o">=</span> <span class="n">file</span><span class="nf">.read_at</span><span class="p">(</span><span class="n">buf_move</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">bytes_read</span> <span class="o">=</span> <span class="n">result</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"{}"</span><span class="p">,</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"Read {} bytes"</span><span class="p">,</span> <span class="n">bytes_read</span><span class="p">)</span>
            <span class="nf">.yellow</span><span class="p">()</span>
            <span class="nf">.underlined</span><span class="p">()</span>
            <span class="nf">.bold</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"{}</span><span class="se">\n</span><span class="s">{}"</span><span class="p">,</span>
        <span class="s">"Data (bytes):"</span><span class="nf">.yellow</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">(),</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf_from_kernel</span><span class="p">[</span><span class="o">..</span><span class="n">bytes_read</span><span class="p">])</span>
            <span class="nf">.blue</span><span class="p">()</span>
            <span class="nf">.bold</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"{}</span><span class="se">\n</span><span class="s">{}"</span><span class="p">,</span>
        <span class="s">"Data (string):"</span><span class="nf">.yellow</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">(),</span>
        <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_lossy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf_from_kernel</span><span class="p">[</span><span class="o">..</span><span class="n">bytes_read</span><span class="p">])</span>
            <span class="nf">.cyan</span><span class="p">()</span>
            <span class="nf">.bold</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>The code for this example is
<a href="https://github.com/nazmulidris/rust-scratch/tree/main/tokio-uring/src/readfile.rs">here</a>.</p>
</blockquote>

<p>The main things to note about this code.</p>

<ul>
  <li>We use the <code class="language-plaintext highlighter-rouge">tokio_uring::fs::File</code> struct to open a file.</li>
  <li>We use the <code class="language-plaintext highlighter-rouge">read_at</code> method to read from the file at a specific offset. The buffer is
passed by ownership to the kernel, and when the operation completes, we get the buffer
back. This is different than how it works with <code class="language-plaintext highlighter-rouge">tokio</code> and <code class="language-plaintext highlighter-rouge">std</code>.</li>
  <li>We print out the bytes that were read from the file, and the string representation of
those bytes.</li>
</ul>

<p>When you run this code (using <code class="language-plaintext highlighter-rouge">cargo run --bin readfile</code>), it should produce the following
output:</p>

<pre class="pre-manual-highlight">
<span style="color:#81A1C1"><u style="text-decoration-style:single">read file using tokio_uring: </u></span><span style="color:#BF616A"><u style="text-decoration-style:single"><b>Cargo.toml</b></u></span>
<span style="color:#81A1C1"><u style="text-decoration-style:single">read </u></span><span style="color:#EBCB8B"><u style="text-decoration-style:single"><b>604</b></u></span> bytes from file
<span style="color:#A3BE8C">file contents: [package]</span>
<span style="color:#A3BE8C">name = &quot;tokio-uring&quot;</span>
<span style="color:#A3BE8C">version = &quot;0.1.0&quot;</span>
<span style="color:#A3BE8C">edition = &quot;2021&quot;</span>

<span style="color:#A3BE8C">[[bin]]</span>
<span style="color:#A3BE8C">name = &quot;readfile&quot;</span>
<span style="color:#A3BE8C">path = &quot;src/readfile.rs&quot;</span>

<span style="color:#A3BE8C">[[bin]]</span>
<span style="color:#A3BE8C">name = &quot;socketserver&quot;</span>
<span style="color:#A3BE8C">path = &quot;src/socketserver.rs&quot;</span>

<span style="color:#A3BE8C">[dependencies]</span>
<span style="color:#A3BE8C">tokio-uring = &quot;0.4.0&quot;</span>
<span style="color:#A3BE8C">tokio = { version = &quot;1.37.0&quot;, features = [&quot;full&quot;, &quot;tracing&quot;] }</span>
<span style="color:#A3BE8C">tokio-util = &quot;0.7.11&quot;</span>
<span style="color:#A3BE8C">tracing = &quot;0.1.40&quot;</span>
<span style="color:#A3BE8C">tracing-subscriber = &quot;0.3.18&quot;</span>

<span style="color:#A3BE8C">ctrlc = &quot;3.4.4&quot;</span>

<span style="color:#A3BE8C">miette = { version = &quot;7.2.0&quot;, features = [&quot;fancy&quot;] }</span>

<span style="color:#A3BE8C">crossterm = { version = &quot;0.27.0&quot;, features = [&quot;event-stream&quot;] }</span>

<span style="color:#A3BE8C">r3bl_terminal_async = { version = &quot;0.5.3&quot; }</span>
<span style="color:#A3BE8C"># r3bl_terminal_async = { path = &quot;../../r3bl-open-core/terminal_async&quot; }</span>
</pre>

<h3 id="example-2-building-a-tcp-echo-server-using-tokio-uring-that-also-uses-tokio">Example 2: Building a TCP echo server using tokio-uring that also uses tokio</h3>
<p><a id="markdown-example-2%3A-building-a-tcp-echo-server-using-tokio-uring-that-also-uses-tokio" name="example-2%3A-building-a-tcp-echo-server-using-tokio-uring-that-also-uses-tokio"></a></p>

<p>For this example, let‚Äôs add the following code to the <code class="language-plaintext highlighter-rouge">src/socketserver.rs</code> file.</p>
<ul>
  <li>This will simply add the required imports to <code class="language-plaintext highlighter-rouge">tokio_uring</code> for <code class="language-plaintext highlighter-rouge">TcpListener</code> and
<code class="language-plaintext highlighter-rouge">TcpStream</code>.</li>
  <li>And we will also configure the <code class="language-plaintext highlighter-rouge">tracing_subscriber</code> to use the formatted subscriber, so
that we get pretty printed log output to stdout and we have information about what thread
generated that log event.</li>
  <li>We use the <code class="language-plaintext highlighter-rouge">tokio_uring::start</code> function to spawn the runtime. This runtime isn‚Äôt the
same as the one that we get from using <code class="language-plaintext highlighter-rouge">#[tokio::main]</code> and later in this example, we
will see how we can handle both.</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">crossterm</span><span class="p">::</span><span class="nn">style</span><span class="p">::</span><span class="n">Stylize</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">miette</span><span class="p">::</span><span class="n">IntoDiagnostic</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">r3bl_terminal_async</span><span class="p">::</span><span class="n">port_availability</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">net</span><span class="p">::</span><span class="n">SocketAddr</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">task</span><span class="p">::</span><span class="n">AbortHandle</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">tokio_uring</span><span class="p">::{</span>
    <span class="nn">buf</span><span class="p">::</span><span class="n">IoBuf</span><span class="p">,</span>
    <span class="nn">net</span><span class="p">::{</span><span class="n">TcpListener</span><span class="p">,</span> <span class="n">TcpStream</span><span class="p">},</span>
<span class="p">};</span>
<span class="k">use</span> <span class="nn">tokio_util</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="n">CancellationToken</span><span class="p">;</span>

<span class="cd">/// Run `netcat localhost:8080` to test this server (once you run this main function).</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Register tracing subscriber.</span>
    <span class="nn">tracing_subscriber</span><span class="p">::</span><span class="nf">fmt</span><span class="p">()</span>
        <span class="nf">.without_time</span><span class="p">()</span>
        <span class="nf">.compact</span><span class="p">()</span>
        <span class="nf">.with_target</span><span class="p">(</span><span class="k">false</span><span class="p">)</span>
        <span class="nf">.with_line_number</span><span class="p">(</span><span class="k">false</span><span class="p">)</span>
        <span class="nf">.with_thread_ids</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
        <span class="nf">.with_thread_names</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
        <span class="nf">.init</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">cancellation_token</span> <span class="o">=</span> <span class="nn">CancellationToken</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="c1">// TODO: Add ctrlc handler.</span>

    <span class="c1">// TODO: Add code to use the `tokio` runtime and run some futures on it.</span>

    <span class="nn">tokio_uring</span><span class="p">::</span><span class="nf">start</span><span class="p">(</span><span class="nf">start_server</span><span class="p">(</span><span class="n">cancellation_token</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>You can get the source code for this example
<a href="https://github.com/nazmulidris/rust-scratch/tree/main/tokio-uring/src/socketserver.rs">here</a>.</p>
</blockquote>

<p>Next, we will add the code to handle the server logic. The following code handles the
incoming connections (using <code class="language-plaintext highlighter-rouge">tokio_uring</code> structs). This code is very similar to what we
would write if we were using <code class="language-plaintext highlighter-rouge">tokio</code> directly.</p>

<ul>
  <li>The main difference is that we are checking for port availability before binding to the
address, and we are using <code class="language-plaintext highlighter-rouge">tokio_uring::spawn</code> to spawn the futures, to handle incoming
connections.</li>
  <li>We will also use <code class="language-plaintext highlighter-rouge">tokio::select!</code> to create the main event loop. Since <code class="language-plaintext highlighter-rouge">tokio_uring</code> is
in the same family as <code class="language-plaintext highlighter-rouge">tokio</code>, we can do that!</li>
  <li>The <code class="language-plaintext highlighter-rouge">port_availability</code> module comes from <code class="language-plaintext highlighter-rouge">r3bl_terminal_async</code> crate, which is a
dependency in the <code class="language-plaintext highlighter-rouge">Cargo.toml</code> file. It allows us to check whether a port is available
or not, and find a free port in a given port range.</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">fn</span> <span class="nf">start_server</span><span class="p">(</span><span class="n">cancellation_token</span><span class="p">:</span> <span class="n">CancellationToken</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">tcp_listener</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">addr</span><span class="p">:</span> <span class="n">SocketAddr</span> <span class="o">=</span> <span class="s">"0.0.0.0:8080"</span><span class="nf">.parse</span><span class="p">()</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
        <span class="c1">// You can bind to the same address repeatedly, and it won't return</span>
        <span class="c1">// an error! Might have to check to see whether the port is open or</span>
        <span class="c1">// not before binding to it!</span>
        <span class="k">match</span> <span class="nn">port_availability</span><span class="p">::</span><span class="nf">check</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span> <span class="p">{</span>
            <span class="nn">port_availability</span><span class="p">::</span><span class="nn">Status</span><span class="p">::</span><span class="n">Free</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"Port {} is available"</span><span class="p">,</span> <span class="n">addr</span><span class="nf">.port</span><span class="p">());</span>
            <span class="p">}</span>
            <span class="nn">port_availability</span><span class="p">::</span><span class="nn">Status</span><span class="p">::</span><span class="n">Occupied</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span>
                    <span class="s">"Port {} is NOT available, can't bind to it"</span><span class="p">,</span>
                    <span class="n">addr</span><span class="nf">.port</span><span class="p">()</span>
                <span class="p">);</span>
                <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">miette</span><span class="p">::</span><span class="nd">miette!</span><span class="p">(</span>
                    <span class="s">"Port {} is NOT available, can't bind to it"</span><span class="p">,</span>
                    <span class="n">addr</span><span class="nf">.port</span><span class="p">()</span>
                <span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nn">TcpListener</span><span class="p">::</span><span class="nf">bind</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span>
    <span class="p">};</span>

    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"server - started"</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.red</span><span class="p">()</span><span class="nf">.bold</span><span class="p">());</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">abort_handles</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">AbortHandle</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span> <span class="p">{</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">cancellation_token</span><span class="nf">.cancelled</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">abort_handles</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.for_each</span><span class="p">(|</span><span class="n">handle</span><span class="p">|</span> <span class="n">handle</span><span class="nf">.abort</span><span class="p">());</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">it</span> <span class="o">=</span> <span class="n">tcp_listener</span><span class="nf">.accept</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">tcp_stream</span><span class="p">,</span> <span class="n">_addr</span><span class="p">)</span> <span class="o">=</span> <span class="n">it</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
                <span class="k">let</span> <span class="n">join_handle</span> <span class="o">=</span> <span class="nn">tokio_uring</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span>
                    <span class="nf">handle_connection</span><span class="p">(</span><span class="n">tcp_stream</span><span class="p">)</span>
                <span class="p">);</span>
                <span class="n">abort_handles</span><span class="nf">.push</span><span class="p">(</span><span class="n">join_handle</span><span class="nf">.abort_handle</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"server - stopped"</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.red</span><span class="p">()</span><span class="nf">.bold</span><span class="p">());</span>
    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Add the following code to handle the echo logic. This code reads from the stream using
<code class="language-plaintext highlighter-rouge">tokio_uring</code> and its function signature is quite different from what we would write if we
were using <code class="language-plaintext highlighter-rouge">tokio</code> directly. It is similar to what happens with <code class="language-plaintext highlighter-rouge">read_at</code> in the previous
example, and it moves ownership to <code class="language-plaintext highlighter-rouge">read</code>. Which returns a tuple:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">Result</code> containing the number of bytes read.</li>
  <li>Buffer that was passed from the kernel.</li>
</ol>

<p>The <code class="language-plaintext highlighter-rouge">write_all</code> function also returns a tuple that is similar.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">fn</span> <span class="nf">handle_connection</span><span class="p">(</span><span class="n">stream</span><span class="p">:</span> <span class="n">TcpStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"handle_connection - start"</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">total_bytes_read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">buf</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0u8</span><span class="p">;</span> <span class="mi">10</span><span class="p">];</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="c1">// Read from the stream.</span>
        <span class="c1">// Read some data, the buffer is passed by ownership and submitted</span>
        <span class="c1">// to the kernel. When the operation completes, we get the buffer</span>
        <span class="c1">// back.</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">result_num_bytes_read</span><span class="p">,</span> <span class="n">return_buf</span><span class="p">)</span> <span class="o">=</span> <span class="n">stream</span><span class="nf">.read</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="n">return_buf</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">num_bytes_read</span> <span class="o">=</span> <span class="n">result_num_bytes_read</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

        <span class="c1">// Check for EOF.</span>
        <span class="k">if</span> <span class="n">num_bytes_read</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Write to the stream.</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">result_num_bytes_written</span><span class="p">,</span> <span class="n">slice</span><span class="p">)</span> <span class="o">=</span>
            <span class="n">stream</span><span class="nf">.write_all</span><span class="p">(</span><span class="n">buf</span><span class="nf">.slice</span><span class="p">(</span><span class="o">..</span><span class="n">num_bytes_read</span><span class="p">))</span><span class="k">.await</span><span class="p">;</span>
        <span class="n">result_num_bytes_written</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span> <span class="c1">// Make sure no errors.</span>

        <span class="c1">// Update the buffer.</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="n">slice</span><span class="nf">.into_inner</span><span class="p">();</span>
        <span class="n">total_bytes_read</span> <span class="o">+=</span> <span class="n">num_bytes_read</span><span class="p">;</span>

        <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span>
            <span class="s">"{}: {}"</span><span class="p">,</span>
            <span class="s">"handle_connection - num_bytes_read"</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.red</span><span class="p">(),</span>
            <span class="n">num_bytes_read</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span>
        <span class="s">"handle_connection - end, total_bytes_read: {}"</span><span class="p">,</span>
        <span class="n">total_bytes_read</span>
    <span class="p">);</span>
    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To test this, you can run the server using <code class="language-plaintext highlighter-rouge">cargo run --bin socketserver</code>. Then you can
connect to the server using <code class="language-plaintext highlighter-rouge">netcat</code> (or <code class="language-plaintext highlighter-rouge">nc</code>) by running <code class="language-plaintext highlighter-rouge">netcat localhost 8080</code>. You can
type some text and hit enter, and you should see the text echoed back to you.</p>

<p>This is what the output from <code class="language-plaintext highlighter-rouge">netcat</code> might look like:</p>

<pre class="pre-manual-highlight">netcat localhost 8080
echo echo echo
echo echo echo
</pre>

<p>This is what the output from the server might look like:</p>

<pre class="pre-manual-highlight"> cargo run --bin socketserver
<span style="color:#A3BE8C"> INFO</span> main ThreadId(01) Port is available
<span style="color:#A3BE8C"> INFO</span> main ThreadId(01) <span style="color:#BF616A"><b>server - started</b></span> - 0.0.0.0:8080
<span style="color:#A3BE8C"> INFO</span> main ThreadId(01) <span style="color:#BF616A"><b>handle_connection - start</b></span>
<span style="color:#A3BE8C"> INFO</span> main ThreadId(01) <span style="color:#BF616A">handle_connection - num_bytes_read</span>: 10
<span style="color:#A3BE8C"> INFO</span> main ThreadId(01) <span style="color:#BF616A">handle_connection - num_bytes_read</span>: 5
<span style="color:#A3BE8C"> INFO</span> main ThreadId(01) <span style="color:#BF616A"><b>handle_connection - end, total bytes read</b></span> : 15 bytes
</pre>

<p>There are two more bonus rounds that we can add to this example:</p>
<ol>
  <li>Add a <code class="language-plaintext highlighter-rouge">ctrlc</code> handler to gracefully shutdown the server, when the user types
<kbd>Ctrl+C</kbd>.</li>
  <li>Add code to use the <code class="language-plaintext highlighter-rouge">tokio</code> runtime and run some futures on it.</li>
</ol>

<p>In the <code class="language-plaintext highlighter-rouge">socketserver.rs</code> file, you can add the following code to replace
the comment <kbd>//TODO: Add ctrlc handler.</kbd>.
The following code will add a <code class="language-plaintext highlighter-rouge">ctrlc</code> handler to gracefully
shutdown the server, by cancelling the <code class="language-plaintext highlighter-rouge">cancellation_token</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">cancellation_token_clone</span> <span class="o">=</span> <span class="n">cancellation_token</span><span class="nf">.clone</span><span class="p">();</span>
<span class="nn">ctrlc</span><span class="p">::</span><span class="nf">set_handler</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"Received Ctrl+C!"</span><span class="p">);</span>
    <span class="n">cancellation_token_clone</span><span class="nf">.cancel</span><span class="p">();</span>
<span class="p">})</span>
<span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
</code></pre></div></div>

<p>And finally, the following code will replace the comment <kbd>// TODO: Add code to use the `tokio` runtime and run some futures on it.</kbd>.
This code will spawn a new OS thread (using <code class="language-plaintext highlighter-rouge">std</code>) and then create a new multi-threaded
<code class="language-plaintext highlighter-rouge">tokio</code> runtime on that thread. We will then run some futures on that runtime by passing an async
block to the <code class="language-plaintext highlighter-rouge">block_on</code> function of the runtime.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Can't use #[tokio::main] for `main()`, so we have to use the</span>
<span class="c1">// `tokio::runtime::Builder` API. However, we have to launch this in a separate</span>
<span class="c1">// thread, because we don't want it to collide with the `tokio_uring::start()`</span>
<span class="c1">// call.</span>
<span class="k">let</span> <span class="n">cancellation_token_clone</span> <span class="o">=</span> <span class="n">cancellation_token</span><span class="nf">.clone</span><span class="p">();</span>
<span class="nn">std</span><span class="p">::</span><span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
    <span class="c1">// If you use `Builder::new_current_thread()`, the runtime will</span>
    <span class="c1">// use the single / current thread scheduler.</span>
    <span class="c1">// `Builder::new_multi_thread()` will use a thread pool.</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nn">runtime</span><span class="p">::</span><span class="nn">Builder</span><span class="p">::</span><span class="nf">new_multi_thread</span><span class="p">()</span>
        <span class="nf">.enable_all</span><span class="p">()</span>
        <span class="nf">.worker_threads</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="nf">.build</span><span class="p">()</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span>
        <span class="nf">.unwrap</span><span class="p">()</span>
        <span class="nf">.block_on</span><span class="p">(</span><span class="nf">async_main</span><span class="p">(</span><span class="n">cancellation_token_clone</span><span class="p">))</span>
<span class="p">});</span>
</code></pre></div></div>

<p>Here‚Äôs the <code class="language-plaintext highlighter-rouge">async_main</code> function that we are calling in the code above. This function
simply runs some futures on the <code class="language-plaintext highlighter-rouge">tokio</code> runtime that we created in the code above. You can
see from the log output that the tasks are run in parallel (sometimes on the same thread
and sometimes on different threads), and are scheduled in a non-deterministic order.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">fn</span> <span class="nf">async_main</span><span class="p">(</span><span class="n">cancellation_token</span><span class="p">:</span> <span class="n">CancellationToken</span><span class="p">)</span> <span class="p">{</span>
    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"async_main - start"</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.magenta</span><span class="p">()</span><span class="nf">.bold</span><span class="p">());</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">interval</span> <span class="o">=</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">interval</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">2_500</span><span class="p">));</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span> <span class="p">{</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">interval</span><span class="nf">.tick</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span>
                    <span class="s">"{}"</span><span class="p">,</span>
                    <span class="s">"async_main - tick"</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.magenta</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span>
                    <span class="p">);</span>

                <span class="c1">// Notice in the output, that these tasks are NOT spawned</span>
                <span class="c1">// in the same order repeatedly. They are run in parallel</span>
                <span class="c1">// on different threads. And these are scheduled in a</span>
                <span class="c1">// non-deterministic order.</span>
                <span class="k">let</span> <span class="n">task_1</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="p">{</span>
                    <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span>
                        <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
                    <span class="p">)</span><span class="k">.await</span><span class="p">;</span>
                    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"async_main - tick {} - spawn"</span><span class="p">,</span> <span class="s">"#1"</span>
                        <span class="nf">.to_string</span><span class="p">()</span><span class="nf">.on_green</span><span class="p">()</span><span class="nf">.black</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span>
                    <span class="p">);</span>
                <span class="p">});</span>
                <span class="k">let</span> <span class="n">task_2</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="p">{</span>
                    <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span>
                        <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
                    <span class="p">)</span><span class="k">.await</span><span class="p">;</span>
                    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"async_main - tick {} - spawn"</span><span class="p">,</span> <span class="s">"#2"</span>
                        <span class="nf">.to_string</span><span class="p">()</span><span class="nf">.on_red</span><span class="p">()</span><span class="nf">.black</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span>
                    <span class="p">);</span>
                <span class="p">});</span>
                <span class="k">let</span> <span class="n">task_3</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="p">{</span>
                    <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span>
                        <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
                    <span class="p">)</span><span class="k">.await</span><span class="p">;</span>
                    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"async_main - tick {} - spawn"</span><span class="p">,</span> <span class="s">"#3"</span>
                        <span class="nf">.to_string</span><span class="p">()</span><span class="nf">.on_blue</span><span class="p">()</span><span class="nf">.black</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span>
                    <span class="p">);</span>
                <span class="p">});</span>
                <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nd">join!</span><span class="p">(</span><span class="n">task_1</span><span class="p">,</span> <span class="n">task_2</span><span class="p">,</span> <span class="n">task_3</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">cancellation_token</span><span class="nf">.cancelled</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"async_main - cancelled"</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"async_main - end"</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.magenta</span><span class="p">()</span><span class="nf">.bold</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here‚Äôs what the output from the server might look like, after adding the <code class="language-plaintext highlighter-rouge">ctrlc</code> handler and
the <code class="language-plaintext highlighter-rouge">tokio</code> runtime code and running it for about 10 seconds.</p>

<pre class="pre-manual-highlight"> cargo run --bin socketserver
<span style="color:#A3BE8C"> INFO</span> main ThreadId(01) Port is available
<span style="color:#A3BE8C"> INFO</span> ThreadId(03) <span style="color:#B48EAD"><b>async_main - start</b></span>
<span style="color:#A3BE8C"> INFO</span> main ThreadId(01) <span style="color:#BF616A"><b>server - started</b></span> - 0.0.0.0:8080
<span style="color:#A3BE8C"> INFO</span> ThreadId(03) <span style="color:#B48EAD"><b>async_main - tick</b></span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(04) async_main - tick <span style="background-color:#81A1C1"><span style="color:#3B4252"><b>#3</b></span></span> - spawn
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(06) async_main - tick <span style="background-color:#BF616A"><span style="color:#3B4252"><b>#2</b></span></span> - spawn
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) async_main - tick <span style="background-color:#A3BE8C"><span style="color:#3B4252"><b>#1</b></span></span> - spawn
<span style="color:#A3BE8C"> INFO</span> ThreadId(03) <span style="color:#B48EAD"><b>async_main - tick</b></span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(06) async_main - tick <span style="background-color:#BF616A"><span style="color:#3B4252"><b>#2</b></span></span> - spawn
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) async_main - tick <span style="background-color:#A3BE8C"><span style="color:#3B4252"><b>#1</b></span></span> - spawn
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(04) async_main - tick <span style="background-color:#81A1C1"><span style="color:#3B4252"><b>#3</b></span></span> - spawn
<span style="color:#A3BE8C"> INFO</span> ThreadId(03) <span style="color:#B48EAD"><b>async_main - tick</b></span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(06) async_main - tick <span style="background-color:#81A1C1"><span style="color:#3B4252"><b>#3</b></span></span> - spawn
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) async_main - tick <span style="background-color:#A3BE8C"><span style="color:#3B4252"><b>#1</b></span></span> - spawn
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(04) async_main - tick <span style="background-color:#BF616A"><span style="color:#3B4252"><b>#2</b></span></span> - spawn
<span style="color:#A3BE8C"> INFO</span> ThreadId(03) <span style="color:#B48EAD"><b>async_main - tick</b></span>
</pre>

<h3 id="parting-thoughts">Parting thoughts</h3>
<p><a id="markdown-parting-thoughts" name="parting-thoughts"></a></p>

<p>There are areas of improvement in this codebase, such as port binding issues, and
connection management issues.</p>
<ol>
  <li>If you run more than one instance of the process <code class="language-plaintext highlighter-rouge">cargo run --bin startserver</code> then the
log output is pretty strange. The 2nd process that‚Äôs started seems to trigger the
<code class="language-plaintext highlighter-rouge">handle_connection</code> function of the first process.</li>
  <li>When you run the server and connect a client to it using <code class="language-plaintext highlighter-rouge">netcat</code>, and then kill the
server process, using <kbd>Ctrl+C</kbd>, the client doesn‚Äôt drop the connection.</li>
</ol>

<p>If you can figure out how to fix these issues, please raise a PR on the <a href="https://github.com/nazmulidris/rust-scratch/issues">GitHub
repo</a>. I‚Äôd love to see how you solve
these problems!</p>

<h2 id="build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</h2>
<p><a id="markdown-build-with-naz-video-series-on-developerlife.com-youtube-channel" name="build-with-naz-video-series-on-developerlife.com-youtube-channel"></a></p>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a></li>
  <li>Playlists
    <ul>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmza94sS7UmJnN9gSCHTVTfz">Build with Naz, fundamental effective Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmwO69E7eiQ-ewnMME8ydgQ5">Build with Naz, effective async Rust and tokio</a></li>
      <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><summary type="html"><![CDATA[Explore the Linux io_uring syscall with the tokio-uring crate in Rust. This article and video will show you how to use the tokio-uring do async file IO at the OS level, and how to use it to build a simple echo TCP server, for use with netcat.]]></summary></entry><entry><title type="html">Build with Naz : Rust async, non-blocking, concurrent, parallel, event loops, cancellation safety</title><link href="http://developerlife.com/2024/05/19/effective-async-rust/" rel="alternate" type="text/html" title="Build with Naz : Rust async, non-blocking, concurrent, parallel, event loops, cancellation safety" /><published>2024-05-19T10:00:00-05:00</published><updated>2024-05-19T10:00:00-05:00</updated><id>http://developerlife.com/2024/05/19/effective-async-rust</id><content type="html" xml:base="http://developerlife.com/2024/05/19/effective-async-rust/"><![CDATA[<p><img class="post-hero-image" src="/assets/rust_async_event_loops.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#what-is-async-rust-sequential-vs-concurrent-code--parallelism-as-a-resource">What is async Rust? Sequential vs concurrent code &amp; parallelism as a resource</a></li>
  <li><a href="#what-async-rust-is-not">What async Rust is not</a></li>
  <li><a href="#youtube-video-for-this-article">YouTube video for this article</a></li>
  <li><a href="#effective-async-rust-patterns-by-example">Effective async Rust patterns by example</a>
    <ul>
      <li><a href="#example-1-build-a-timer-future-using-waker">Example 1: Build a timer future using Waker</a></li>
      <li><a href="#example-2-build-an-async-runtime-to-run-futures-to-completion">Example 2: Build an async runtime to run futures to completion</a></li>
      <li><a href="#example-3-running-async-code-concurrently-on-a-single-thread">Example 3: Running async code, concurrently, on a single thread</a></li>
      <li><a href="#example-4-join-select-spawn-control-flow-constructors">Example 4: join!, select, spawn control flow constructors</a></li>
      <li><a href="#example-5-async-streams">Example 5: async streams</a></li>
      <li><a href="#example-6-non-blocking-event-loops-channel-safety-and-safe-cancellation">Example 6: Non-blocking event loops, channel safety, and safe cancellation</a></li>
      <li><a href="#parting-thoughts">Parting thoughts</a></li>
    </ul>
  </li>
  <li><a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</a></li>
</ul>

<!-- /TOC -->

<h2 id="what-is-async-rust-sequential-vs-concurrent-code--parallelism-as-a-resource">What is async Rust? Sequential vs concurrent code &amp; parallelism as a resource</h2>
<p><a id="markdown-what-is-async-rust%3F-sequential-vs-concurrent-code-%26-parallelism-as-a-resource" name="what-is-async-rust%3F-sequential-vs-concurrent-code-%26-parallelism-as-a-resource"></a></p>

<p>In Rust, you can write sequential code, and concurrent code:</p>
<ul>
  <li>Sequential code can be run sequentially, or in parallel (using <code class="language-plaintext highlighter-rouge">thread::spawn()</code>).</li>
  <li>Concurrent code can be run on a single thread or multiple threads.</li>
</ul>

<p>Concurrency is a way to structure code into separate tasks. This does not define the
resources on a machine that will be used to run or execute tasks.</p>

<p>Parallelism is a way to specify what resources (CPU cores, or threads) will be used on a
machine‚Äôs operating system to run tasks.</p>

<p>These 2 concepts are not the same. They are related but not the same.</p>

<h2 id="what-async-rust-is-not">What async Rust is not</h2>
<p><a id="markdown-what-async-rust-is-not" name="what-async-rust-is-not"></a></p>

<p>Generally speaking, using async Rust is not just a matter of attaching <code class="language-plaintext highlighter-rouge">async</code> as a prefix
to a function, when you define it, and postfix <code class="language-plaintext highlighter-rouge">.await</code> when you call it. In fact, if you
don‚Äôt have at least one <code class="language-plaintext highlighter-rouge">.await</code> in your async function body, then it <a href="https://ryhl.io/blog/async-what-is-blocking/">might not need to
be async</a>. This article and video are a deep
dive into what async code is, what Rust <code class="language-plaintext highlighter-rouge">Future</code>s are, along with what async Runtimes are.
Along with some common patterns and anti-patterns when thinking in async Rust.</p>

<h2 id="youtube-video-for-this-article">YouTube video for this article</h2>
<p><a id="markdown-youtube-video-for-this-article" name="youtube-video-for-this-article"></a></p>

<p>This blog post only has short examples on how to use Rust async effectively. To see how
these ideas can be used in production code, with real-world examples, please watch the
following video on the <a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube
channel</a>.</p>

<!-- rust tokio tracing and otel for async rust & playlist -->
<iframe src="https://www.youtube.com/embed/qvIt8MF-pCM?si=S40pbhnvVDAohj-6" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<p><br /></p>

<h2 id="effective-async-rust-patterns-by-example">Effective async Rust patterns by example</h2>
<p><a id="markdown-effective-async-rust-patterns-by-example" name="effective-async-rust-patterns-by-example"></a></p>

<p>Let‚Äôs create some examples to illustrate how to use async Rust effectively. You can run
<code class="language-plaintext highlighter-rouge">cargo new --lib effective-async-rust</code> to create a new library crate.</p>

<blockquote>
  <p>The code in the video and this tutorial are all in this GitHub repo:
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/async_con_par/">https://github.com/nazmulidris/rust-scratch/blob/main/async_con_par/</a></p>
</blockquote>

<p>Then add the following to the <code class="language-plaintext highlighter-rouge">Cargo.toml</code> file that‚Äôs generated. These pull in all the
dependencies that we need for these examples.</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[package]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"effective-async-rust"</span>
<span class="py">version</span> <span class="p">=</span> <span class="s">"0.1.0"</span>
<span class="py">edition</span> <span class="p">=</span> <span class="s">"2021"</span>

<span class="nn">[dependencies]</span>
<span class="py">crossterm</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.27.0"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"event-stream"</span><span class="p">]</span> <span class="p">}</span>
<span class="py">tokio</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"1.37.0"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"full"</span><span class="p">,</span> <span class="s">"tracing"</span><span class="p">]</span> <span class="p">}</span>
<span class="py">tracing</span> <span class="p">=</span> <span class="s">"0.1.40"</span>
<span class="py">tracing-subscriber</span> <span class="p">=</span> <span class="s">"0.3.18"</span>
<span class="py">futures</span> <span class="p">=</span> <span class="s">"0.3.30"</span>
<span class="py">async-stream</span> <span class="p">=</span> <span class="s">"0.3.5"</span>
</code></pre></div></div>

<h3 id="example-1-build-a-timer-future-using-waker">Example 1: Build a timer future using Waker</h3>
<p><a id="markdown-example-1%3A-build-a-timer-future-using-waker" name="example-1%3A-build-a-timer-future-using-waker"></a></p>

<p>Then you can add the following code to the <code class="language-plaintext highlighter-rouge">src/lib.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="k">pub</span> <span class="k">mod</span> <span class="n">build_a_timer_future_using_waker</span><span class="p">;</span>
</code></pre></div></div>

<p>We will implement the <code class="language-plaintext highlighter-rouge">Future</code> trait manually, in this example. Typically any <code class="language-plaintext highlighter-rouge">async</code> code
block is converted into a finite state machine which implements the <code class="language-plaintext highlighter-rouge">Future</code> trait.
Progress on the future only occurs when it is polled by the runtime or executor (eg:
Tokio).</p>

<ul>
  <li>When a future is polled and it is <code class="language-plaintext highlighter-rouge">Ready</code> then the future is complete.</li>
  <li>If it is <code class="language-plaintext highlighter-rouge">Pending</code> then the future is not complete. And when it is ready (at some point
in the future, due to some event like network IO available via <code class="language-plaintext highlighter-rouge">epoll</code> or <code class="language-plaintext highlighter-rouge">io_uring</code>),
the runtime expects the future to wake up the, by calling <code class="language-plaintext highlighter-rouge">wake()</code> on the <code class="language-plaintext highlighter-rouge">Waker</code> that
is passed to this future by the runtime, via the <code class="language-plaintext highlighter-rouge">Context</code> object.</li>
</ul>

<p>Here are more details on this:</p>

<ol>
  <li><a href="https://rust-lang.github.io/async-book/01_getting_started/04_async_await_primer.html">Primer on async and await</a>.</li>
  <li><a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code class="language-plaintext highlighter-rouge">Future</code> trait</a>.</li>
  <li><a href="https://rust-lang.github.io/async-book/02_execution/03_wakeups.html">Timer example</a>.</li>
</ol>

<blockquote>
  <p>The code for this example is
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/async_con_par/src/build_a_timer_future_using_waker.rs">here</a>.</p>
</blockquote>

<p>Create a new file <code class="language-plaintext highlighter-rouge">src/build_a_timer_future_using_waker.rs</code>. In this file, we are going
to:</p>
<ul>
  <li>Build a timer that wakes up a task after a certain amount of time, to explore how
<code class="language-plaintext highlighter-rouge">Waker</code> works.</li>
  <li>We‚Äôll just spin up a new thread when the timer is created, sleep for the required time,
and then signal the timer future when the time window has elapsed.</li>
</ul>

<p>Add the following code to the file, to define a new struct that will implement the
<code class="language-plaintext highlighter-rouge">Future</code> trait. This struct will have a <code class="language-plaintext highlighter-rouge">SharedState</code> struct that will contain the state
of the future, and an optional <code class="language-plaintext highlighter-rouge">Waker</code> that will be used to wake up the future when the
timer has elapsed. This <code class="language-plaintext highlighter-rouge">Waker</code> is not available until the very first time the future is
polled by the runtime.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Default)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">TimerFuture</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">shared_state</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">SharedState</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Default)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">SharedState</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">completed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">waker</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Waker</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Add the following code to implement the <code class="language-plaintext highlighter-rouge">Future</code> trait for the <code class="language-plaintext highlighter-rouge">TimerFuture</code> struct.</p>
<ul>
  <li>This code will be used to poll the future, by the runtime, and check if the timer has
elapsed.</li>
  <li>If it has, then the future is complete, and the runtime can move on to the next task. If
the timer has not elapsed, then the future is not complete, and the runtime won‚Äôt do
anything further with this future. And will go on to the next task (top level <code class="language-plaintext highlighter-rouge">Future</code>)
that it can make progress on.</li>
</ul>

<p>Something has to wake up this future to let the runtime know that the timer has elapsed,
and that it needs to call <code class="language-plaintext highlighter-rouge">poll()</code> again on this <code class="language-plaintext highlighter-rouge">Future</code>. This is where the <code class="language-plaintext highlighter-rouge">Waker</code> comes
in.</p>
<ul>
  <li>The first time <code class="language-plaintext highlighter-rouge">poll()</code> is called on this future, the runtime passes in a <code class="language-plaintext highlighter-rouge">Waker</code> and we
save that to the <code class="language-plaintext highlighter-rouge">SharedState</code> struct.</li>
  <li>This will be used by the timer thread to wake up the future, when the timer has elapsed
(which we will do next).</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">Future</span> <span class="k">for</span> <span class="n">TimerFuture</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="p">();</span>

    <span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span><span class="k">self</span><span class="p">:</span> <span class="nb">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="k">Self</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">cx</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Context</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Poll</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Output</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">shared_state</span> <span class="o">=</span> <span class="k">self</span><span class="py">.shared_state</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="k">match</span> <span class="n">shared_state</span><span class="py">.completed</span> <span class="p">{</span>
            <span class="k">true</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"TimerFuture is completed"</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.green</span><span class="p">());</span>
                <span class="nn">Poll</span><span class="p">::</span><span class="nf">Ready</span><span class="p">(())</span>
            <span class="p">}</span>
            <span class="k">false</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"TimerFuture is not completed"</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.red</span><span class="p">());</span>
                <span class="c1">// Importantly, we have to update the Waker every time the</span>
                <span class="c1">// future is polled because the future may have moved to</span>
                <span class="c1">// a different task with a different Waker. This will happen</span>
                <span class="c1">// when futures are passed around between tasks after being</span>
                <span class="c1">// polled.</span>
                <span class="n">shared_state</span><span class="py">.waker</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">cx</span><span class="nf">.waker</span><span class="p">()</span><span class="nf">.clone</span><span class="p">());</span>
                <span class="nn">Poll</span><span class="p">::</span><span class="n">Pending</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Add the following code to create a new timer <code class="language-plaintext highlighter-rouge">Future</code>, and start a new thread that will
sleep for the required time, and then wake up the <code class="language-plaintext highlighter-rouge">Future</code> when the timer has elapsed, by
using the optional <code class="language-plaintext highlighter-rouge">Waker</code> that was saved in the <code class="language-plaintext highlighter-rouge">SharedState</code> struct (when <code class="language-plaintext highlighter-rouge">poll()</code> is
called on the <code class="language-plaintext highlighter-rouge">Future</code>, by the runtime).</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">TimerFuture</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">duration</span><span class="p">:</span> <span class="n">Duration</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">new_instance</span> <span class="o">=</span> <span class="nn">TimerFuture</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>

        <span class="k">let</span> <span class="n">shared_state_clone</span> <span class="o">=</span> <span class="n">new_instance</span><span class="py">.shared_state</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="nn">thread</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="n">duration</span><span class="p">);</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">shared_state</span> <span class="o">=</span> <span class="n">shared_state_clone</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="n">shared_state</span><span class="py">.completed</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="n">shared_state</span><span class="py">.waker</span><span class="nf">.take</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.wake</span><span class="p">();</span>
        <span class="p">});</span>

        <span class="n">new_instance</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Add the following test to run this code. The <code class="language-plaintext highlighter-rouge">#[tokio::test]</code> attribute macro generates
code to start a single threaded executor to run the test code.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[tokio::test]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">run_timer_future_with_tokio</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">timer_future</span> <span class="o">=</span> <span class="nn">TimerFuture</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
    <span class="k">let</span> <span class="n">shared_state</span> <span class="o">=</span> <span class="n">timer_future</span><span class="py">.shared_state</span><span class="nf">.clone</span><span class="p">();</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="o">!</span><span class="n">shared_state</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.completed</span><span class="p">);</span>
    <span class="n">timer_future</span><span class="k">.await</span><span class="p">;</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="n">shared_state</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.completed</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When you run this test, it should produce the following output:</p>

<pre class="pre-manual-highlight">
running 1 test
<span style="color:#BF616A">TimerFuture is not completed</span>
<span style="color:#A3BE8C">TimerFuture is completed</span>
test build_a_timer_future_using_waker::run_timer_future_with_tokio ... ok
</pre>

<h3 id="example-2-build-an-async-runtime-to-run-futures-to-completion">Example 2: Build an async runtime to run futures to completion</h3>
<p><a id="markdown-example-2%3A-build-an-async-runtime-to-run-futures-to-completion" name="example-2%3A-build-an-async-runtime-to-run-futures-to-completion"></a></p>

<p>For this example, let‚Äôs add the following code to the <code class="language-plaintext highlighter-rouge">src/lib.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="k">pub</span> <span class="k">mod</span> <span class="n">build_an_executor_to_run_future</span><span class="p">;</span>
</code></pre></div></div>

<p>In the example above, we use <code class="language-plaintext highlighter-rouge">tokio</code> to run the <code class="language-plaintext highlighter-rouge">TimerFuture</code> to completion. But in this
example, we will implement our own <em>simple</em> async runtime.</p>

<ul>
  <li>This is a very simple runtime that will run futures to completion, by polling them until
they are ready.</li>
  <li>It should highlight how the <code class="language-plaintext highlighter-rouge">Waker</code> and <code class="language-plaintext highlighter-rouge">Context</code> are supplied by the runtime to the
<code class="language-plaintext highlighter-rouge">Future</code>.</li>
</ul>

<blockquote>
  <p>You can get the source code for this example
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/async_con_par/src/build_an_executor_to_run_future.rs">here</a>.</p>
</blockquote>

<p>We will need a few things to implement this runtime:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">Task</code> struct that will contain the <code class="language-plaintext highlighter-rouge">Future</code> that needs to be run to completion.</li>
  <li><code class="language-plaintext highlighter-rouge">Task</code> queue that will contain all the tasks that need to be run. This will be a
<code class="language-plaintext highlighter-rouge">std::sync::mpsc::sync_channel</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">Waker</code> that will be used to wake up the runtime when a task is ready to be polled.
<code class="language-plaintext highlighter-rouge">Context</code> that will be used to pass the <code class="language-plaintext highlighter-rouge">Waker</code> to the <code class="language-plaintext highlighter-rouge">Future</code> that is being polled.</li>
  <li><code class="language-plaintext highlighter-rouge">Spawner</code> struct that will be used to spawn new tasks into the runtime.</li>
  <li><code class="language-plaintext highlighter-rouge">Executor</code> struct that will be used to run the runtime.</li>
</ol>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">src/build_an_executor_to_run_future.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">new_executor_and_spawner</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">Executor</span><span class="p">,</span> <span class="n">Spawner</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">MAX_TASKS</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">10_000</span><span class="p">;</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">task_sender</span><span class="p">,</span> <span class="n">task_receiver</span><span class="p">)</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">mpsc</span><span class="p">::</span><span class="nf">sync_channel</span><span class="p">(</span><span class="n">MAX_TASKS</span><span class="p">);</span>
    <span class="p">(</span><span class="n">Executor</span> <span class="p">{</span> <span class="n">task_receiver</span> <span class="p">},</span> <span class="n">Spawner</span> <span class="p">{</span> <span class="n">task_sender</span> <span class="p">})</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Executor</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">task_receiver</span><span class="p">:</span> <span class="n">Receiver</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Spawner</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">task_sender</span><span class="p">:</span> <span class="n">SyncSender</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Task</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">future</span><span class="p">:</span> <span class="n">Mutex</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">BoxFuture</span><span class="o">&lt;</span><span class="k">'static</span><span class="p">,</span> <span class="p">()</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">task_sender</span><span class="p">:</span> <span class="n">SyncSender</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">Spawner</code> struct to spawn new tasks into the runtime.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">Spawner</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">spawn</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">future</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Future</span><span class="o">&lt;</span><span class="n">Output</span> <span class="o">=</span> <span class="p">()</span><span class="o">&gt;</span> <span class="o">+</span> <span class="k">'static</span> <span class="o">+</span> <span class="nb">Send</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">pinned_boxed_future</span> <span class="o">=</span> <span class="n">future</span><span class="nf">.boxed</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">task</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Task</span> <span class="p">{</span>
            <span class="n">future</span><span class="p">:</span> <span class="nn">Mutex</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">pinned_boxed_future</span><span class="p">)),</span>
            <span class="n">task_sender</span><span class="p">:</span> <span class="k">self</span><span class="py">.task_sender</span><span class="nf">.clone</span><span class="p">(),</span>
        <span class="p">});</span>
        <span class="nd">eprintln!</span><span class="p">(</span>
            <span class="s">"{}"</span><span class="p">,</span>
            <span class="s">"sending task to executor, adding to channel"</span>
                <span class="nf">.to_string</span><span class="p">()</span>
                <span class="nf">.blue</span><span class="p">()</span>
        <span class="p">);</span>
        <span class="k">self</span><span class="py">.task_sender</span>
            <span class="nf">.send</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="nf">.expect</span><span class="p">(</span><span class="s">"too many tasks in channel"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">Executor</code> struct to run the runtime. This code will poll
the task queue, and block until it can get a task to run. Once it has a task, which it has
removed from the task channel or queue, it polls it (with the <code class="language-plaintext highlighter-rouge">Context</code> and <code class="language-plaintext highlighter-rouge">Waker</code>) to
check whether it is ready.</p>

<ul>
  <li>If it is ready, then it is done.</li>
  <li>If it is not ready, then it does not do anything further with it. When the task is ready
to be polled (eg: when the duration has passed in the <code class="language-plaintext highlighter-rouge">TimerFuture</code>‚Äôs thread), it will
use the <code class="language-plaintext highlighter-rouge">Waker</code> to wake up the task when it is ready to be polled). The <code class="language-plaintext highlighter-rouge">ArcWake</code>
implementation for the <code class="language-plaintext highlighter-rouge">Task</code> struct is used for this; all it does is send the task back
to the task channel, so that it can be polled again by the executor üéâ.</li>
  <li>Here‚Äôs what a real world implementation of <code class="language-plaintext highlighter-rouge">ArcWake</code> might look like using something
like Linux <code class="language-plaintext highlighter-rouge">epoll</code> or <code class="language-plaintext highlighter-rouge">io_uring</code>:
<a href="https://rust-lang.github.io/async-book/02_execution/05_io.html">https://rust-lang.github.io/async-book/02_execution/05_io.html</a>.</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">ArcWake</span> <span class="k">for</span> <span class="n">Task</span> <span class="p">{</span>
    <span class="cd">/// Implement `wake` by sending this task back onto the task</span>
    <span class="cd">/// channel so that it will be polled again by the executor,</span>
    <span class="cd">/// since it is now ready.</span>
    <span class="k">fn</span> <span class="nf">wake_by_ref</span><span class="p">(</span><span class="n">arc_self</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">cloned</span> <span class="o">=</span> <span class="n">arc_self</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="n">arc_self</span>
            <span class="py">.task_sender</span>
            <span class="nf">.send</span><span class="p">(</span><span class="n">cloned</span><span class="p">)</span>
            <span class="nf">.expect</span><span class="p">(</span><span class="s">"too many tasks in channel"</span><span class="p">);</span>
        <span class="nd">eprintln!</span><span class="p">(</span>
            <span class="s">"{}"</span><span class="p">,</span>
            <span class="s">"task woken up, added back to channel"</span>
                <span class="nf">.to_string</span><span class="p">()</span>
                <span class="nf">.underlined</span><span class="p">()</span>
                <span class="nf">.green</span><span class="p">()</span>
                <span class="nf">.bold</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Executor</span> <span class="p">{</span>
    <span class="nd">#[allow(clippy::while_let_loop)]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Remove task from receiver, or block if nothing available.</span>
        <span class="k">loop</span> <span class="p">{</span>
            <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"executor loop"</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.red</span><span class="p">());</span>
            <span class="c1">// Remove the task from the receiver.</span>
            <span class="c1">// If it is pending, then the ArcWaker</span>
            <span class="c1">// will add it back to the channel.</span>
            <span class="k">match</span> <span class="k">self</span><span class="py">.task_receiver</span><span class="nf">.recv</span><span class="p">()</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">arc_task</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">eprintln!</span><span class="p">(</span>
                        <span class="s">"{}"</span><span class="p">,</span>
                        <span class="s">"running task - start, got task from receiver"</span>
                            <span class="nf">.to_string</span><span class="p">()</span>
                            <span class="nf">.red</span><span class="p">()</span>
                    <span class="p">);</span>
                    <span class="k">let</span> <span class="k">mut</span> <span class="n">future_in_task</span> <span class="o">=</span> <span class="n">arc_task</span><span class="py">.future</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                    <span class="k">match</span> <span class="n">future_in_task</span><span class="nf">.take</span><span class="p">()</span> <span class="p">{</span>
                        <span class="nf">Some</span><span class="p">(</span><span class="k">mut</span> <span class="n">future</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                            <span class="k">let</span> <span class="n">waker</span> <span class="o">=</span> <span class="nf">waker_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arc_task</span><span class="p">);</span>
                            <span class="k">let</span> <span class="n">context</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">Context</span><span class="p">::</span><span class="nf">from_waker</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waker</span><span class="p">);</span>
                            <span class="k">let</span> <span class="n">poll_result</span> <span class="o">=</span> <span class="n">future</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.poll</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
                            <span class="nd">eprintln!</span><span class="p">(</span>
                                <span class="s">"{}"</span><span class="p">,</span>
                                <span class="nd">format!</span><span class="p">(</span>
                                  <span class="s">"poll_result: {:?}"</span><span class="p">,</span> <span class="n">poll_result</span><span class="p">)</span>
                                  <span class="nf">.to_string</span><span class="p">()</span><span class="nf">.red</span><span class="p">()</span>
                            <span class="p">);</span>
                            <span class="k">if</span> <span class="n">poll_result</span><span class="nf">.is_pending</span><span class="p">()</span> <span class="p">{</span>
                                <span class="c1">// We're not done processing the future, so put it</span>
                                <span class="c1">// back in its task to be run again in the future.</span>
                                <span class="o">*</span><span class="n">future_in_task</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">future</span><span class="p">);</span>
                                <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span>
                                  <span class="s">"putting task back in slot"</span>
                                  <span class="nf">.to_string</span><span class="p">()</span><span class="nf">.red</span><span class="p">()</span>
                                <span class="p">);</span>
                            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                                <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"task is done"</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.red</span><span class="p">());</span>
                            <span class="p">}</span>
                        <span class="p">}</span>
                        <span class="nb">None</span> <span class="k">=&gt;</span> <span class="p">{</span>
                            <span class="nd">panic!</span><span class="p">(</span><span class="s">"this never runs"</span><span class="p">);</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                    <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"running task - end"</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.red</span><span class="p">());</span>
                <span class="p">}</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"no more tasks to run, breaking out of loop"</span><span class="p">);</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And finally, add this test to run this code. Notice this code does not use <code class="language-plaintext highlighter-rouge">tokio</code> to run
the <code class="language-plaintext highlighter-rouge">TimerFuture</code> to completion. Instead, it uses the <code class="language-plaintext highlighter-rouge">Executor</code> and <code class="language-plaintext highlighter-rouge">Spawner</code> structs
that we implemented above.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">run_executor_and_spawner</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="nn">build_a_timer_future_using_waker</span><span class="p">::</span><span class="n">TimerFuture</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">results</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">Mutex</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">()));</span>

    <span class="k">let</span> <span class="p">(</span><span class="n">executor</span><span class="p">,</span> <span class="n">spawner</span><span class="p">)</span> <span class="o">=</span> <span class="nf">new_executor_and_spawner</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">results_clone</span> <span class="o">=</span> <span class="n">results</span><span class="nf">.clone</span><span class="p">();</span>
    <span class="n">spawner</span><span class="nf">.spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="n">results_clone</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.push</span><span class="p">(</span><span class="s">"hello, start timer!"</span><span class="p">);</span>
        <span class="nn">TimerFuture</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span><span class="k">.await</span><span class="p">;</span>
        <span class="n">results_clone</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.push</span><span class="p">(</span><span class="s">"bye, timer finished!"</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="nf">drop</span><span class="p">(</span><span class="n">spawner</span><span class="p">);</span>

    <span class="n">executor</span><span class="nf">.run</span><span class="p">();</span>

    <span class="nd">assert_eq!</span><span class="p">(</span>
        <span class="o">*</span><span class="n">results</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span>
        <span class="nd">vec!</span><span class="p">[</span><span class="s">"hello, start timer!"</span><span class="p">,</span> <span class="s">"bye, timer finished!"</span><span class="p">]</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This should produce the following output, which maps to the flow that we described above:</p>

<pre class="pre-manual-highlight">running 1 test
<span style="color:#81A1C1">sending task to executor, adding to channel</span>
<span style="color:#BF616A">executor loop</span>
<span style="color:#BF616A">running task - start, got task from receiver</span>
<span style="color:#BF616A">TimerFuture is not completed</span>
<span style="color:#BF616A">poll_result: Pending</span>
<span style="color:#BF616A">putting task back in slot</span>
<span style="color:#BF616A">running task - end</span>
<span style="color:#BF616A">executor loop</span>
<span style="color:#A3BE8C"><u style="text-decoration-style:single"><b>task woken up, added back to channel</b></u></span>
<span style="color:#BF616A">running task - start, got task from receiver</span>
<span style="color:#A3BE8C">TimerFuture is completed</span>
<span style="color:#BF616A">poll_result: Ready(())</span>
<span style="color:#BF616A">task is done</span>
<span style="color:#BF616A">running task - end</span>
<span style="color:#BF616A">executor loop</span>
no more tasks to run, breaking out of loop
test build_an_executor_to_run_future::run_executor_and_spawner ... ok
</pre>

<h3 id="example-3-running-async-code-concurrently-on-a-single-thread">Example 3: Running async code, concurrently, on a single thread</h3>
<p><a id="markdown-example-3%3A-running-async-code%2C-concurrently%2C-on-a-single-thread" name="example-3%3A-running-async-code%2C-concurrently%2C-on-a-single-thread"></a></p>

<p>For this example, let‚Äôs add the following code to the <code class="language-plaintext highlighter-rouge">src/lib.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="k">pub</span> <span class="k">mod</span> <span class="n">local_set</span><span class="p">;</span>
</code></pre></div></div>

<p>If you have async code, you can use a <code class="language-plaintext highlighter-rouge">LocalSet</code> to run the async code, in different
tasks, on a <em>single</em> thread. This ensures that any data that you have to pass between
these tasks can be <code class="language-plaintext highlighter-rouge">!Send</code>. Instead of wrapping the shared data in a <code class="language-plaintext highlighter-rouge">Arc</code> or
<code class="language-plaintext highlighter-rouge">Arc&lt;Mutex&gt;</code>, you can just wrap it in an <code class="language-plaintext highlighter-rouge">Rc</code>.</p>

<p>In this example, we will explore how to run async code concurrently, on a single thread.
This is an important concept to understand, as it is the basis for how async code can be
run concurrently, using non-blocking event loops.</p>

<blockquote>
  <p>The code for this example is
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/async_con_par/src/local_set.rs#L39">here</a>.</p>
</blockquote>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">src/local_set.rs</code> file.</p>
<ul>
  <li>It shows how you can create a <code class="language-plaintext highlighter-rouge">Future</code> that uses a <code class="language-plaintext highlighter-rouge">Rc</code> to share data concurrently,
running on a single thread.</li>
  <li>This is why the data is <code class="language-plaintext highlighter-rouge">!Send</code>, and we don‚Äôt need to use an <code class="language-plaintext highlighter-rouge">Arc</code> or <code class="language-plaintext highlighter-rouge">Arc&lt;Mutex&gt;</code> to
share it between tasks.</li>
  <li>Once the <code class="language-plaintext highlighter-rouge">LocalSet</code> is created, and <code class="language-plaintext highlighter-rouge">local_spawn()</code> is called, the task doesn‚Äôt actually
run until <code class="language-plaintext highlighter-rouge">local_set.run_until(..)</code> is called, or <code class="language-plaintext highlighter-rouge">local_set.await</code> is called.</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[tokio::test]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">run_local_set_and_spawn_local</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Can't send this data across threads (not wrapped in `Arc` or `Arc&lt;Mutex&gt;`).</span>
    <span class="k">let</span> <span class="n">non_send_data</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"!SEND DATA"</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">local_set</span> <span class="o">=</span> <span class="nn">LocalSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="c1">// Spawn a local task (bound to same thread) that uses the non-send data.</span>
    <span class="k">let</span> <span class="n">non_send_data_clone</span> <span class="o">=</span> <span class="n">non_send_data</span><span class="nf">.clone</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">async_block_1</span> <span class="o">=</span> <span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span>
            <span class="c1">// https://doc.rust-lang.org/std/fmt/index.html#fillalignment</span>
            <span class="s">"{:&lt;7} {}"</span><span class="p">,</span>
            <span class="s">"start"</span><span class="p">,</span>
            <span class="n">non_send_data_clone</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.yellow</span><span class="p">()</span><span class="nf">.bold</span><span class="p">(),</span>
        <span class="p">);</span>
    <span class="p">};</span>
    <span class="c1">// Does not run anything.</span>
    <span class="k">let</span> <span class="n">join_handle_1</span> <span class="o">=</span> <span class="n">local_set</span><span class="nf">.spawn_local</span><span class="p">(</span><span class="n">async_block_1</span><span class="p">);</span>

    <span class="c1">// This is required to run `async_block_1`.</span>
    <span class="k">let</span> <span class="n">_it</span> <span class="o">=</span> <span class="n">local_set</span><span class="nf">.run_until</span><span class="p">(</span><span class="n">join_handle_1</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
</code></pre></div></div>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">src/local_set.rs</code> file. This is just a different variant
(from the first example) of creating a new async block, and running it using the
<code class="language-plaintext highlighter-rouge">LocalSet</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// Create a 2nd async block.</span>
    <span class="k">let</span> <span class="n">non_send_data_clone</span> <span class="o">=</span> <span class="n">non_send_data</span><span class="nf">.clone</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">async_block_2</span> <span class="o">=</span> <span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="nf">sleep</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span><span class="k">.await</span><span class="p">;</span>
        <span class="nd">println!</span><span class="p">(</span>
            <span class="c1">// https://doc.rust-lang.org/std/fmt/index.html#fillalignment</span>
            <span class="s">"{:&lt;7} {}"</span><span class="p">,</span>
            <span class="s">"middle"</span><span class="p">,</span>
            <span class="n">non_send_data_clone</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.green</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">};</span>

    <span class="c1">// This is required to run `async_block_2`.</span>
    <span class="k">let</span> <span class="n">_it</span> <span class="o">=</span> <span class="n">local_set</span><span class="nf">.run_until</span><span class="p">(</span><span class="n">async_block_2</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
</code></pre></div></div>

<p>Finally add the following code to the <code class="language-plaintext highlighter-rouge">src/local_set.rs</code> file. This yet another way of how
you can create a new async block, and run it using the <code class="language-plaintext highlighter-rouge">LocalSet</code>. This one uses <code class="language-plaintext highlighter-rouge">local_set.await</code>
which runs all the futures that are associated with the <code class="language-plaintext highlighter-rouge">local_set</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// Spawn another local task (bound to same thread) that uses</span>
    <span class="c1">// the non-send data.</span>
    <span class="k">let</span> <span class="n">non_send_data_clone</span> <span class="o">=</span> <span class="n">non_send_data</span><span class="nf">.clone</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">async_block_3</span> <span class="o">=</span> <span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="nf">sleep</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span><span class="k">.await</span><span class="p">;</span>
        <span class="nd">println!</span><span class="p">(</span>
            <span class="c1">// https://doc.rust-lang.org/std/fmt/index.html#fillalignment</span>
            <span class="s">"{:&lt;7} {}"</span><span class="p">,</span>
            <span class="s">"end"</span><span class="p">,</span>
            <span class="n">non_send_data_clone</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.cyan</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">};</span>
    <span class="c1">// Does not run anything.</span>
    <span class="k">let</span> <span class="n">_join_handle_3</span> <span class="o">=</span> <span class="n">local_set</span><span class="nf">.spawn_local</span><span class="p">(</span><span class="n">async_block_3</span><span class="p">);</span>

    <span class="c1">// `async_block_3` won't run until this is called.</span>
    <span class="n">local_set</span><span class="k">.await</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here‚Äôs the output when you run this test:</p>

<pre class="pre-manual-highlight">running 1 test
start   <span style="color: #EBCB8B"><b>!SEND DATA</b></span>
middle  <span style="color: #A3BE8C"><b>!SEND DATA</b></span>
end     <span style="color: #8FBCBB"><b>!SEND DATA</b></span>
test local_set::run_local_set_and_spawn_local ... ok
</pre>

<h3 id="example-4-join-select-spawn-control-flow-constructors">Example 4: join!, select, spawn control flow constructors</h3>
<p><a id="markdown-example-4%3A-join!%2C-select%2C-spawn-control-flow-constructors" name="example-4%3A-join!%2C-select%2C-spawn-control-flow-constructors"></a></p>

<p>For this example, let‚Äôs add the following code to the <code class="language-plaintext highlighter-rouge">src/lib.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="k">pub</span> <span class="k">mod</span> <span class="n">demo_join_select_spawn</span><span class="p">;</span>
</code></pre></div></div>

<p>You can use <code class="language-plaintext highlighter-rouge">join!</code>, <code class="language-plaintext highlighter-rouge">select!</code>, and <code class="language-plaintext highlighter-rouge">spawn</code> to control the flow of async code. These are
macros that are provided by the <code class="language-plaintext highlighter-rouge">tokio</code> crate. They are used to run multiple futures
concurrent, in parallel, and wait for them to complete.</p>

<blockquote>
  <p>The code for this example is
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/async_con_par/src/demo_join_select_spawn.rs">here</a>.</p>
</blockquote>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">src/demo_join_select_spawn.rs</code> file. This code shows how
you can use <code class="language-plaintext highlighter-rouge">join!</code> to run multiple futures concurrently, and wait for them to complete.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">task_1</span><span class="p">(</span><span class="n">time</span><span class="p">:</span> <span class="nb">u64</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">sleep</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="n">time</span><span class="p">))</span><span class="k">.await</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"task_1"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">task_2</span><span class="p">(</span><span class="n">time</span><span class="p">:</span> <span class="nb">u64</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">sleep</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="n">time</span><span class="p">))</span><span class="k">.await</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"task_2"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">task_3</span><span class="p">(</span><span class="n">time</span><span class="p">:</span> <span class="nb">u64</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">sleep</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="n">time</span><span class="p">))</span><span class="k">.await</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"task_3"</span><span class="p">);</span>
<span class="p">}</span>

<span class="nd">#[tokio::test]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">test_join</span><span class="p">()</span> <span class="p">{</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nd">join!</span><span class="p">(</span><span class="nf">task_1</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="nf">task_2</span><span class="p">(</span><span class="mi">200</span><span class="p">),</span> <span class="nf">task_3</span><span class="p">(</span><span class="mi">300</span><span class="p">));</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"all tasks done"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here‚Äôs the output when you run this test:</p>
<pre class="pre-manual-highlight">running 1 test
task_1
task_2
task_3
all tasks done
test demo_join_select_spawn::test_join ... ok
</pre>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">src/demo_join_select_spawn.rs</code> file. This code shows how
you can use <code class="language-plaintext highlighter-rouge">select!</code> to run multiple futures concurrently, and wait for the first one to
complete.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[tokio::test]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">test_select</span><span class="p">()</span> <span class="p">{</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span> <span class="p">{</span>
        <span class="n">_</span> <span class="o">=</span> <span class="nf">task_1</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"task_1 done"</span><span class="p">),</span>
        <span class="n">_</span> <span class="o">=</span> <span class="nf">task_2</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"task_2 done"</span><span class="p">),</span>
        <span class="n">_</span> <span class="o">=</span> <span class="nf">task_3</span><span class="p">(</span><span class="mi">300</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"task_3 done"</span><span class="p">),</span>
    <span class="p">}</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"one task done"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here‚Äôs the output when you run this test:</p>
<pre class="pre-manual-highlight">running 1 test
task_1 done
one task done
test demo_join_select_spawn::test_select ... ok
</pre>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">src/demo_join_select_spawn.rs</code> file. This code shows how
you can use <code class="language-plaintext highlighter-rouge">spawn</code> to run multiple futures in parallel, and wait for them to complete. We
pass the following to the <code class="language-plaintext highlighter-rouge">#[tokio::test]</code> attribute macro: <code class="language-plaintext highlighter-rouge">flavor = "multi_thread",
worker_threads = 5</code> which tells it to run the test on multiple threads (max of 5).</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[tokio::test(flavor</span> <span class="nd">=</span> <span class="s">"multi_thread"</span><span class="nd">,</span> <span class="nd">worker_threads</span> <span class="nd">=</span> <span class="mi">5</span><span class="nd">)]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">test_spawn</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">handle_1</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="nf">task_1</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>
    <span class="k">let</span> <span class="n">handle_2</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="nf">task_2</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>
    <span class="k">let</span> <span class="n">handle_3</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="nf">task_3</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>

    <span class="n">handle_1</span><span class="k">.await</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="n">handle_2</span><span class="k">.await</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="n">handle_3</span><span class="k">.await</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"all tasks done"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When you run this test, it should produce the following output (the ordering of the tasks
which run first, second, and third, will vary):</p>

<pre class="pre-manual-highlight">running 1 test
task_3
task_1
task_2
all tasks done
test demo_join_select_spawn::test_spawn ... ok
</pre>

<h3 id="example-5-async-streams">Example 5: async streams</h3>
<p><a id="markdown-example-5%3A-async-streams" name="example-5%3A-async-streams"></a></p>

<p>For this example, let‚Äôs add the following code to the <code class="language-plaintext highlighter-rouge">src/lib.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="k">pub</span> <span class="k">mod</span> <span class="n">async_stream</span><span class="p">;</span>
</code></pre></div></div>

<p>You can use async streams to create a stream of values that are produced asynchronously.
This is useful for testing, for example in the <code class="language-plaintext highlighter-rouge">r3bl_terminal_async</code> crate <a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/terminal_async/src/readline_impl/readline.rs#L796">in
<code class="language-plaintext highlighter-rouge">readline.rs</code> in <code class="language-plaintext highlighter-rouge">test_streams</code>
module</a>.</p>

<blockquote>
  <p>The code for this example is
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/async_con_par/src/async_stream.rs">here</a>.</p>
</blockquote>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">src/async_stream.rs</code> file.</p>
<ul>
  <li>This code shows how you can use <code class="language-plaintext highlighter-rouge">async_stream</code> crate‚Äôs <code class="language-plaintext highlighter-rouge">stream!</code> macro to create a
stream of values that are generated from a vector of strings.</li>
  <li>This stream is then converted into a <code class="language-plaintext highlighter-rouge">PinnedInputStream</code> which is a <code class="language-plaintext highlighter-rouge">Pin&lt;Box&lt;dyn
Stream&lt;Item = Result&lt;String, String&gt;&gt;&gt;</code>.</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">type</span> <span class="n">PinnedInputStream</span> <span class="o">=</span> <span class="nb">Pin</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="nb">String</span><span class="o">&gt;&gt;&gt;&gt;</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">gen_input_stream</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">PinnedInputStream</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="nn">async_stream</span><span class="p">::</span><span class="nd">stream!</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">event</span> <span class="k">in</span> <span class="nf">get_input_vec</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">yield</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="nn">Box</span><span class="p">::</span><span class="nf">pin</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_input_vec</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">vec!</span><span class="p">[</span>
        <span class="s">"a"</span><span class="nf">.to_string</span><span class="p">(),</span>
        <span class="s">"b"</span><span class="nf">.to_string</span><span class="p">(),</span>
        <span class="s">"c"</span><span class="nf">.to_string</span><span class="p">(),</span>
        <span class="s">"d"</span><span class="nf">.to_string</span><span class="p">(),</span>
    <span class="p">]</span>
<span class="p">}</span>

<span class="nd">#[tokio::test]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">test_stream</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">it</span> <span class="o">=</span> <span class="nf">gen_input_stream</span><span class="p">();</span>
    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="o">=</span> <span class="n">it</span><span class="nf">.next</span><span class="p">()</span><span class="k">.await</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">lhs</span> <span class="o">=</span> <span class="n">event</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">rhs</span> <span class="o">=</span> <span class="nf">get_input_vec</span><span class="p">()[</span><span class="n">count</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="example-6-non-blocking-event-loops-channel-safety-and-safe-cancellation">Example 6: Non-blocking event loops, channel safety, and safe cancellation</h3>
<p><a id="markdown-example-6%3A-non-blocking-event-loops%2C-channel-safety%2C-and-safe-cancellation" name="example-6%3A-non-blocking-event-loops%2C-channel-safety%2C-and-safe-cancellation"></a></p>

<p>Let‚Äôs add the following code to the <code class="language-plaintext highlighter-rouge">src/lib.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="k">pub</span> <span class="k">mod</span> <span class="n">non_blocking_async_event_loops</span><span class="p">;</span>
</code></pre></div></div>

<p>You can use non-blocking event loops to create a loop that runs async code, and waits for
events to occur. This is useful for creating servers, clients, and other networked
applications. You can even use the same pattern to create
<a href="https://crates.io/crates/r3bl_terminal_async">CLI</a> and
<a href="https://crates.io/crates/r3bl_tui">TUI</a> applications that are non-blocking, and can
handle multiple events concurrently, such as when you‚Äôre creating an interactive async
REPL.</p>

<blockquote>
  <p>The source code for this example is
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/async_con_par/src/non_blocking_async_event_loops.rs">here</a>.</p>
</blockquote>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">src/non_blocking_async_event_loops.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[tokio::test(flavor</span> <span class="nd">=</span> <span class="s">"multi_thread"</span><span class="nd">,</span> <span class="nd">worker_threads</span> <span class="nd">=</span> <span class="mi">5</span><span class="nd">)]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">test_main_loop</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Register tracing subscriber.</span>
    <span class="nn">tracing_subscriber</span><span class="p">::</span><span class="nf">fmt</span><span class="p">()</span>
        <span class="nf">.without_time</span><span class="p">()</span>
        <span class="nf">.compact</span><span class="p">()</span>
        <span class="nf">.with_target</span><span class="p">(</span><span class="k">false</span><span class="p">)</span>
        <span class="nf">.with_line_number</span><span class="p">(</span><span class="k">false</span><span class="p">)</span>
        <span class="nf">.with_thread_ids</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
        <span class="nf">.with_thread_names</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
        <span class="nf">.init</span><span class="p">();</span>

    <span class="c1">// Create channels for events and shutdown signals.</span>
    <span class="k">let</span> <span class="n">event_channel</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">mpsc</span><span class="p">::</span><span class="nn">channel</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1_000</span><span class="p">);</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">event_sender</span><span class="p">,</span> <span class="k">mut</span> <span class="n">event_receiver</span><span class="p">)</span> <span class="o">=</span> <span class="n">event_channel</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">shutdown_channel</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">broadcast</span><span class="p">::</span><span class="nn">channel</span><span class="p">::</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1_000</span><span class="p">);</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">shutdown_sender</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">shutdown_channel</span><span class="p">;</span>

    <span class="c1">// Spawn the main event loop.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">shutdown_receiver</span> <span class="o">=</span> <span class="n">shutdown_sender</span><span class="nf">.subscribe</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">safe_count</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">safe_count_clone</span> <span class="o">=</span> <span class="n">safe_count</span><span class="nf">.clone</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">join_handle</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="k">loop</span> <span class="p">{</span>
            <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span> <span class="p">{</span>
                <span class="n">event</span> <span class="o">=</span> <span class="n">event_receiver</span><span class="nf">.recv</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="o">?</span><span class="n">event</span><span class="p">,</span> <span class="s">"task got event: event"</span><span class="p">);</span>
                    <span class="k">let</span> <span class="k">mut</span> <span class="n">count</span> <span class="o">=</span> <span class="n">safe_count_clone</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                    <span class="o">*</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">_</span> <span class="o">=</span> <span class="n">shutdown_receiver</span><span class="nf">.recv</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"task got shutdown signal"</span><span class="p">);</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">});</span>

    <span class="c1">// Send events, in parallel.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">handles</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">10</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">event_sender_clone</span> <span class="o">=</span> <span class="n">event_sender</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">join_handle</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
            <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s">"sending event"</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">event</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"event {}"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="n">event_sender_clone</span><span class="nf">.send</span><span class="p">(</span><span class="n">event</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
            <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span><span class="k">.await</span><span class="p">;</span>
        <span class="p">});</span>
        <span class="n">handles</span><span class="nf">.push</span><span class="p">(</span><span class="n">join_handle</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Wait for all events to be sent using tokio.</span>
    <span class="nn">futures</span><span class="p">::</span><span class="nn">future</span><span class="p">::</span><span class="nf">join_all</span><span class="p">(</span><span class="n">handles</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>

    <span class="c1">// Shutdown the event loops.</span>
    <span class="n">shutdown_sender</span><span class="nf">.send</span><span class="p">(())</span><span class="nf">.unwrap</span><span class="p">();</span>

    <span class="c1">// Wait for the event loop to shutdown.</span>
    <span class="n">join_handle</span><span class="k">.await</span><span class="nf">.unwrap</span><span class="p">();</span>

    <span class="c1">// Assertions.</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">shutdown_sender</span><span class="nf">.receiver_count</span><span class="p">(),</span> <span class="mi">1</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="o">*</span><span class="n">safe_count</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span> <span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here are key points to note about this code:</p>
<ul>
  <li>We use <code class="language-plaintext highlighter-rouge">tokio::sync::mpsc::channel</code> to create a channel for events, and
<code class="language-plaintext highlighter-rouge">tokio::sync::broadcast::channel</code> to create a channel for shutdown signals.</li>
  <li>We spawn the main event loop, which listens for events and shutdown signals, and updates
a shared counter.</li>
  <li>We spawn multiple tasks that send events to the event channel, in parallel.
    <ul>
      <li>The <code class="language-plaintext highlighter-rouge">#[tokio::test(flavor = "multi_thread", worker_threads = 5)]</code> attribute macro
tells <code class="language-plaintext highlighter-rouge">tokio</code> to run the test on multiple threads (max of 5).</li>
      <li>You can see this in the output when you run the test. By configuring Tokio <code class="language-plaintext highlighter-rouge">tracing</code>
subscriber, we can see the thread IDs and names in the output
(<code class="language-plaintext highlighter-rouge">.with_thread_ids(true)</code>, <code class="language-plaintext highlighter-rouge">.with_thread_names(true)</code>).</li>
      <li>We wait for all events to be sent using <code class="language-plaintext highlighter-rouge">futures::future::join_all(handles).await</code>.</li>
    </ul>
  </li>
  <li>We shutdown the event loop (using <code class="language-plaintext highlighter-rouge">shutdown_sender.send(())</code>), and wait for it to
shutdown using <code class="language-plaintext highlighter-rouge">join_handle.await</code>..</li>
</ul>

<p>When you run this test, it will produce the following output:</p>
<pre class="pre-manual-highlight">running 1 test
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) sending event <i>i</i><span style="color:#90949B">=2</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(04) sending event <i>i</i><span style="color:#90949B">=6</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(06) sending event <i>i</i><span style="color:#90949B">=0</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(07) sending event <i>i</i><span style="color:#90949B">=4</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(03) sending event <i>i</i><span style="color:#90949B">=7</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(04) sending event <i>i</i><span style="color:#90949B">=8</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(06) sending event <i>i</i><span style="color:#90949B">=1</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) task got event: event <i>event</i><span style="color:#90949B">=Some(&quot;event 2&quot;)</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(07) sending event <i>i</i><span style="color:#90949B">=5</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(03) sending event <i>i</i><span style="color:#90949B">=9</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) task got event: event <i>event</i><span style="color:#90949B">=Some(&quot;event 6&quot;)</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(04) sending event <i>i</i><span style="color:#90949B">=3</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) task got event: event <i>event</i><span style="color:#90949B">=Some(&quot;event 0&quot;)</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) task got event: event <i>event</i><span style="color:#90949B">=Some(&quot;event 4&quot;)</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) task got event: event <i>event</i><span style="color:#90949B">=Some(&quot;event 7&quot;)</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) task got event: event <i>event</i><span style="color:#90949B">=Some(&quot;event 8&quot;)</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) task got event: event <i>event</i><span style="color:#90949B">=Some(&quot;event 1&quot;)</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) task got event: event <i>event</i><span style="color:#90949B">=Some(&quot;event 5&quot;)</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) task got event: event <i>event</i><span style="color:#90949B">=Some(&quot;event 9&quot;)</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) task got event: event <i>event</i><span style="color:#90949B">=Some(&quot;event 3&quot;)</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) task got shutdown signal
test non_blocking_async_event_loops::test_main_loop ... ok
</pre>

<p>Interesting code links:</p>
<ul>
  <li>Testing async code: <a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/terminal_async/src/readline_impl/readline.rs#L612">https://github.com/r3bl-org/r3bl-open-core/blob/main/terminal_async/src/readline_impl/readline.rs#L612</a></li>
  <li>Using dependency injection and dealing with <code class="language-plaintext highlighter-rouge">dyn T</code> (trait objects): <a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/terminal_async/src/readline_impl/readline.rs#L344">https://github.com/r3bl-org/r3bl-open-core/blob/main/terminal_async/src/readline_impl/readline.rs#L344</a>.</li>
  <li>Event <code class="language-plaintext highlighter-rouge">loop</code>s and breaking out of them (lifecycle control mechanisms):
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/tcp-api-server/src/server_task.rs#L43">https://github.com/nazmulidris/rust-scratch/blob/main/tcp-api-server/src/server_task.rs#L43</a>
and
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/tcp-api-server/src/client_task.rs#L108">https://github.com/nazmulidris/rust-scratch/blob/main/tcp-api-server/src/client_task.rs#L108</a>.</li>
</ul>

<h3 id="parting-thoughts">Parting thoughts</h3>
<p><a id="markdown-parting-thoughts" name="parting-thoughts"></a></p>

<ul>
  <li>Try not to use cancellation token:
<a href="https://docs.rs/tokio-util/latest/tokio_util/sync/struct.CancellationToken.html">https://docs.rs/tokio-util/latest/tokio_util/sync/struct.CancellationToken.html</a>,
instead do this: <a href="https://github.com/nazmulidris/rust-scratch/pull/32">https://github.com/nazmulidris/rust-scratch/pull/32</a> and
<a href="https://github.com/nazmulidris/rust-scratch/commit/e129b0f681dd1eea1bcdd3372cd08a05081922ff">https://github.com/nazmulidris/rust-scratch/commit/e129b0f681dd1eea1bcdd3372cd08a05081922ff</a></li>
  <li>Do not use async or Tokio for underlying sync OS file copy:
<a href="https://users.rust-lang.org/t/tokio-copy-slower-than-std-io-copy/111242">https://users.rust-lang.org/t/tokio-copy-slower-than-std-io-copy/111242</a>.</li>
  <li>Using the right <code class="language-plaintext highlighter-rouge">Mutex</code> in conjunction with <code class="language-plaintext highlighter-rouge">Arc</code> and holding them across await points
from <a href="https://docs.rs/tokio/latest/tokio/sync/struct.Mutex.html#which-kind-of-mutex-should-you-use">tokio
docs</a>.</li>
  <li>Good videos:
    <ul>
      <li><a href="https://www.youtube.com/watch?v=1zOd52_tUWg&amp;t=2088s">Async Rust: the good, the bad, and the ugly - Steve Klabnik</a>.</li>
      <li><a href="https://www.youtube.com/watch?v=04gTQmLETFI">Nicholas Matsakis - Rust 2024 and beyond</a>.</li>
    </ul>
  </li>
</ul>

<h2 id="build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</h2>
<p><a id="markdown-build-with-naz-video-series-on-developerlife.com-youtube-channel" name="build-with-naz-video-series-on-developerlife.com-youtube-channel"></a></p>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a></li>
  <li>Playlists
    <ul>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmza94sS7UmJnN9gSCHTVTfz">Build with Naz, fundamental effective Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmwO69E7eiQ-ewnMME8ydgQ5">Build with Naz, effective async Rust and tokio</a></li>
      <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><summary type="html"><![CDATA[Learn effective async Rust using real world patterns that show up consistently when creating non blocking, async, event loops, using channels. Delve into implementing the Future trait and async executor manually. Also explore safe cancellation, when not to use async, and how to think about testing async code.]]></summary></entry><entry><title type="html">Build with Naz : tokio tracing &amp;amp; OTel and how to use it in Rust</title><link href="http://developerlife.com/2024/05/15/tokio-tracing-otel-rust/" rel="alternate" type="text/html" title="Build with Naz : tokio tracing &amp;amp; OTel and how to use it in Rust" /><published>2024-05-15T10:00:00-05:00</published><updated>2024-05-15T10:00:00-05:00</updated><id>http://developerlife.com/2024/05/15/tokio-tracing-otel-rust</id><content type="html" xml:base="http://developerlife.com/2024/05/15/tokio-tracing-otel-rust/"><![CDATA[<p><img class="post-hero-image" src="/assets/tracing_otel_rust.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#why-use-observability-in-async-rust">Why use observability in async Rust?</a></li>
  <li><a href="#tokio-tracing-usage">Tokio tracing usage</a></li>
  <li><a href="#video-of-this-in-action-in-the-real-world">Video of this in action in the real world</a></li>
  <li><a href="#short-example-to-illustrate-the-use-of-tracing-and-otel-in-rust">Short example to illustrate the use of tracing and OTel in Rust</a></li>
  <li><a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</a></li>
</ul>

<!-- /TOC -->

<h2 id="why-use-observability-in-async-rust">Why use observability in async Rust?</h2>
<p><a id="markdown-why-use-observability-in-async-rust%3F" name="why-use-observability-in-async-rust%3F"></a></p>

<p>In synchronous systems, it‚Äôs often easy to understand the flow of execution by looking at
log messages. For example, if a thread walking through a single function ends up calling a whole
host of other functions, and they all emit log messages, you can often piece together what
happened by looking at the log messages in order.</p>

<p>However, in asynchronous systems, this is challenging. When using Tokio, for example,
different threads might be executing the same task, as it goes from being parked, to being
woken up, to being parked again. Both temporality (when a log event happened) and
causality (what caused the event) get muddled. This is where observability comes in,
provided by Tokio <code class="language-plaintext highlighter-rouge">tracing</code> crate and OpenTelemetry (OTel) crates.</p>

<p>The <code class="language-plaintext highlighter-rouge">tracing</code> crate expands upon logging-style diagnostics by allowing libraries and
applications to record structured events with additional information about temporality and
causality. Unlike a log message, a <code class="language-plaintext highlighter-rouge">Span</code> in tracing has a beginning and end time, may be
entered and exited by the flow of execution, and may exist within a nested tree of similar
spans.</p>

<p>For representing things that occur at a single moment in time, tracing provides the
complementary concept of events. Both <code class="language-plaintext highlighter-rouge">Spans</code> and <code class="language-plaintext highlighter-rouge">Events</code> are structured, with the ability to
record typed data as well as textual messages.</p>

<h2 id="tokio-tracing-usage">Tokio tracing usage</h2>
<p><a id="markdown-tokio-tracing-usage" name="tokio-tracing-usage"></a></p>

<p>Code:</p>
<ul>
  <li><a href="https://github.com/nazmulidris/rust-scratch/tree/main/tcp-api-server"><code class="language-plaintext highlighter-rouge">tcp-api-server</code> crate is the sample project that uses <code class="language-plaintext highlighter-rouge">tracing</code> and OTel and the
modules below (provided by the <code class="language-plaintext highlighter-rouge">r3bl_terminal_async</code>
crate</a>.</li>
  <li><a href="https://github.com/r3bl-org/r3bl-open-core/blob/nazmulidris/otel/terminal_async/src/public_api/tracing_setup.rs"><code class="language-plaintext highlighter-rouge">r3bl_terminal_async</code> Tokio <code class="language-plaintext highlighter-rouge">tracing</code>
setup</a>.</li>
  <li><a href="https://github.com/r3bl-org/r3bl-open-core/blob/nazmulidris/otel/terminal_async/src/public_api/jaeger_setup.rs#L1"><code class="language-plaintext highlighter-rouge">r3bl_terminal_async</code> Jaeger &amp; OTel
setup</a>.</li>
</ul>

<p>Here‚Äôs an example of using the <code class="language-plaintext highlighter-rouge">tracing</code> crate. Some key symbols to note are::</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">#[instrument]</code> attribute is used to create a span.</li>
  <li><code class="language-plaintext highlighter-rouge">Span::current().record()</code> is used to add fields to the span (when the function is
running, and this information is not known statically beforehand).</li>
  <li><code class="language-plaintext highlighter-rouge">info!</code>, <code class="language-plaintext highlighter-rouge">error!</code>, etc are used to emit log or tracing events. However, these are not
used to create spans; they are used to emit events within a span.</li>
  <li><code class="language-plaintext highlighter-rouge">#[tokio::main]</code> is used to run the async main function.</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">tracing</span><span class="p">::{</span><span class="n">info</span><span class="p">,</span> <span class="n">instrument</span><span class="p">,</span> <span class="n">Span</span><span class="p">};</span>

<span class="nd">#[tokio::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Set up the tracing subscriber, so you can see the output of log events in stdout.</span>
    <span class="c1">// https://docs.rs/tracing-subscriber/latest/tracing_subscriber/fmt/fn.fmt.html</span>
    <span class="nn">tracing_subscriber</span><span class="p">::</span><span class="nf">fmt</span><span class="p">()</span>
        <span class="nf">.with_test_writer</span><span class="p">()</span>
        <span class="nf">.with_env_filter</span><span class="p">(</span><span class="s">"info"</span><span class="p">)</span>
        <span class="nf">.init</span><span class="p">();</span>

    <span class="c1">// Call the entry point function.</span>
    <span class="nn">client_task</span><span class="p">::</span><span class="nf">entry_point</span><span class="p">(</span><span class="mi">1234</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">mod</span> <span class="n">client_task</span> <span class="p">{</span>
    <span class="nd">#[instrument(name</span> <span class="nd">=</span> <span class="s">"caller"</span><span class="nd">,</span> <span class="nd">skip_all,</span> <span class="nd">fields(</span><span class="err">?</span><span class="nd">client_id))]</span>
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">entry_point</span><span class="p">(</span><span class="n">client_id</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">info!</span><span class="p">(</span><span class="s">"entry point"</span><span class="p">);</span>
        <span class="nf">more_context</span><span class="p">(</span><span class="s">"bar"</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
        <span class="nf">handle_message</span><span class="p">(</span><span class="n">client_id</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
        <span class="nf">no_instrument</span><span class="p">(</span><span class="s">"baz"</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nd">#[instrument(name</span> <span class="nd">=</span> <span class="s">"callee"</span><span class="nd">,</span> <span class="nd">skip_all,</span> <span class="nd">fields(</span><span class="err">%</span><span class="nd">message))]</span>
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">handle_message</span><span class="p">(</span><span class="n">client_id</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">info!</span><span class="p">(</span><span class="s">"handling message"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">#[instrument(fields(extra))]</span>
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">more_context</span><span class="p">(</span><span class="n">extra</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="nn">CurrentSpan</span><span class="p">::</span><span class="nf">current</span><span class="p">()</span><span class="nf">.record</span><span class="p">(</span><span class="s">"extra"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">extra</span><span class="p">);</span>
        <span class="nd">info!</span><span class="p">(</span><span class="s">"more context"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">no_instrument</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">info!</span><span class="p">(</span><span class="s">"no instrument fn"</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<p>Here are some key points to remember when using <code class="language-plaintext highlighter-rouge">tracing</code> from the code above:</p>

<ul>
  <li>
    <p>You have to be careful about recording the same field multiple times, in an async call
chain. In the example above, <code class="language-plaintext highlighter-rouge">client_task::entry_point()</code> is the entry point, and is the
only function that should log the <code class="language-plaintext highlighter-rouge">?client_id</code>; <code class="language-plaintext highlighter-rouge">?</code> means debug. And not any other
functions that it calls, like <code class="language-plaintext highlighter-rouge">handle_message()</code>.</p>
  </li>
  <li>
    <p>When you call <code class="language-plaintext highlighter-rouge">entry_point()</code>, it will call <code class="language-plaintext highlighter-rouge">handle_message()</code>, and the span that is
generated by <code class="language-plaintext highlighter-rouge">handle_message()</code> will have the <code class="language-plaintext highlighter-rouge">client_id</code> field added to it, because of
the call chain. So the output of <code class="language-plaintext highlighter-rouge">info!("handling message")</code> will have the <code class="language-plaintext highlighter-rouge">client_id</code>
included in it (for free). It will also have the <code class="language-plaintext highlighter-rouge">%message</code> field in it; <code class="language-plaintext highlighter-rouge">%</code> means
display. You don‚Äôt have to explicitly add either of these fields to the <code class="language-plaintext highlighter-rouge">info!()</code> call üéâ.</p>
  </li>
  <li>
    <p>If you use the <code class="language-plaintext highlighter-rouge">client_id</code> field in multiple <code class="language-plaintext highlighter-rouge">#[instrument..]</code> attributes in functions
(that are in the call chain), then this will show up multiple times in the log output
(when using <code class="language-plaintext highlighter-rouge">info!</code>, <code class="language-plaintext highlighter-rouge">debug!</code>, etc) of the leaf function in the call chain. So when you
see the same fields showing up multiple times in the output from <code class="language-plaintext highlighter-rouge">info!</code>, <code class="language-plaintext highlighter-rouge">debug!</code>, etc,
then you know that you have to remove that field from the <code class="language-plaintext highlighter-rouge">#[instrument..]</code> attribute
somewhere in the call chain (that the span covers).</p>
  </li>
  <li>
    <p>You have to be careful about how to use
<a href="https://docs.rs/tracing/latest/tracing/attr.instrument.html"><code class="language-plaintext highlighter-rouge">[#instrument]</code></a> attribute
with <code class="language-plaintext highlighter-rouge">tracing::Span::record</code>. You have to call
<code class="language-plaintext highlighter-rouge">tracing::Span::current().record("foo","bar")</code> in the same function where the
<code class="language-plaintext highlighter-rouge">#[instrument(fields(foo))]</code> attribute is used.</p>
  </li>
  <li>
    <p>When a function is called that isn‚Äôt instrumented, by another one, which is, any log
events generated in the un-instrumented function will be associated with the span of the
instrumented function. In the <code class="language-plaintext highlighter-rouge">no_instrument</code> function‚Äôs log output, you will see
addition context from the <code class="language-plaintext highlighter-rouge">entry_point</code> function that looks something like <code class="language-plaintext highlighter-rouge">INFO
caller{client_id=1234}: no instrument fn</code>.</p>
  </li>
</ul>

<p>Here are some helpful links to learn more about this topic:</p>

<ul>
  <li><a href="https://tokio.rs/tokio/topics/tracing">Tokio tracing docs</a>.</li>
  <li><a href="https://gemini.google.com/app/5b106a8100c4dcf4">Difference between <code class="language-plaintext highlighter-rouge">#[instrument]</code> (create spans) and emitting events (eg: <code class="language-plaintext highlighter-rouge">info!</code>, <code class="language-plaintext highlighter-rouge">debug!</code>, etc:</a>.</li>
  <li><a href="https://tokio.rs/tokio/topics/tracing-next-steps">Tokio and OTel integration docs</a>.</li>
  <li><a href="https://github.com/tokio-rs/tracing-opentelemetry">Tokio tracing and OTel integration crate</a>.</li>
  <li><a href="https://broch.tech/posts/rust-tracing-opentelemetry/">Blog post to connect tracing and OTel</a>.</li>
  <li><a href="https://github.com/open-telemetry/opentelemetry-rust/blob/main/examples/tracing-jaeger/src/main.rs">Code examples for using Jaeger with tracing</a>.</li>
  <li><a href="https://opentelemetry.io/docs/concepts/observability-primer/#spans">OTel primer</a>.</li>
  <li><a href="https://www.jaegertracing.io/docs/1.57/getting-started/">Jaeger docs</a>.</li>
</ul>

<h2 id="video-of-this-in-action-in-the-real-world">Video of this in action in the real world</h2>
<p><a id="markdown-video-of-this-in-action-in-the-real-world" name="video-of-this-in-action-in-the-real-world"></a></p>

<p>This blog post only has a short example to illustrate how to use Rust tracing and OTel
with Jaeger. To see how these ideas can be used in production code, with real-world
examples, please watch the following video on the <a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube
channel</a>.</p>

<!-- rust tokio tracing and otel for async rust & playlist -->
<iframe src="https://www.youtube.com/embed/Wf8JrLgBuKI?si=cmLaUWs-pbJ39lLc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<p>Here‚Äôs the code for this real world example:</p>

<ul>
  <li><a href="https://github.com/nazmulidris/rust-scratch/tree/main/tcp-api-server">Repo for the <code class="language-plaintext highlighter-rouge">tcp-api-server</code> crate, which is an example of creating a TCP server and
client that are observable using <code class="language-plaintext highlighter-rouge">tracing</code> and
OTel</a>.
    <ul>
      <li>It uses the <code class="language-plaintext highlighter-rouge">r3bl_terminal_async</code> crate to allow async, non-blocking readline
functionality, along with <code class="language-plaintext highlighter-rouge">stdout</code> and <code class="language-plaintext highlighter-rouge">stderr</code> that are also async.</li>
      <li>This crate is also used to configure Jaeger and tracing subscribers for file, stdout
logging.</li>
    </ul>
  </li>
  <li>
    <p><a href="https://github.com/nazmulidris/rust-scratch/tree/main/tcp-api-server#tokio-tracing-usage">README for <code class="language-plaintext highlighter-rouge">tcp-api-server</code> crate, which shows how to use Jaeger, and configure file
logging and stdout
logging</a>.</p>
  </li>
  <li>
    <p><a href="https://github.com/r3bl-org/r3bl-open-core/blob/nazmulidris/refactor-tokio-tracing/terminal_async/src/public_api/tracing_setup.rs">How to build up tracing subscribers using layers (type erasure, decl macros,
etc)</a>.</p>
  </li>
  <li>
    <p><a href="https://github.com/nazmulidris/rust-scratch/pull/34">How to add an OTel layer to a
subscriber</a>.</p>
  </li>
  <li><a href="https://github.com/r3bl-org/r3bl-open-core/pull/326">How the subscriber is configured with custom layers in <code class="language-plaintext highlighter-rouge">r3bl_terminal_async</code>
crate</a>.</li>
</ul>

<h2 id="short-example-to-illustrate-the-use-of-tracing-and-otel-in-rust">Short example to illustrate the use of tracing and OTel in Rust</h2>
<p><a id="markdown-short-example-to-illustrate-the-use-of-tracing-and-otel-in-rust" name="short-example-to-illustrate-the-use-of-tracing-and-otel-in-rust"></a></p>

<p>Let‚Äôs look a single example (that fits in one file) that illustrates the use of tracing
in Rust. You can run <code class="language-plaintext highlighter-rouge">cargo new --lib tracing-otel</code> to create a new library crate, and then run
the following:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo add miette <span class="nt">--features</span> fancy
cargo add tracing tracing-subscriber
cargo add tokio <span class="nt">--features</span> full
</code></pre></div></div>

<p>Then you can add the following code to the <code class="language-plaintext highlighter-rouge">src/main.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">miette</span><span class="p">::</span><span class="n">IntoDiagnostic</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">tracing</span><span class="p">::</span><span class="n">Span</span><span class="p">;</span>

<span class="nd">#[tokio::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">subscriber</span> <span class="o">=</span> <span class="nn">tracing_subscriber</span><span class="p">::</span><span class="nf">fmt</span><span class="p">()</span>
        <span class="nf">.without_time</span><span class="p">()</span>
        <span class="nf">.pretty</span><span class="p">()</span>
        <span class="nf">.with_max_level</span><span class="p">(</span><span class="nn">tracing</span><span class="p">::</span><span class="nn">Level</span><span class="p">::</span><span class="n">DEBUG</span><span class="p">)</span>
        <span class="nf">.finish</span><span class="p">();</span>

    <span class="nn">tracing</span><span class="p">::</span><span class="nn">subscriber</span><span class="p">::</span><span class="nf">set_global_default</span><span class="p">(</span><span class="n">subscriber</span><span class="p">)</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">print_message</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The first part of the code sets up the tracing subscriber. In this case we are using a formatting
subscriber that prints logs to the console. This subscriber is configured to not print the time of
the log message, to pretty print the logs, and to print logs at the <code class="language-plaintext highlighter-rouge">DEBUG</code> level or higher.</p>

<p>When you use <code class="language-plaintext highlighter-rouge">#[attribute]</code> along with <code class="language-plaintext highlighter-rouge">info!</code>, <code class="language-plaintext highlighter-rouge">debug!</code>, etc, Tokio will emit log events
that are associated with a span. This is the ‚Äúemitter‚Äù side of the process. The other side
is the ‚Äúsubscriber‚Äù side, which is where the logs are actually printed to the console, or
sent to a file, or sent to an OTel collector service like Jaeger (using OTLP protocol over
gRPC).</p>

<p>Tokio <code class="language-plaintext highlighter-rouge">tracing</code> allows us to use this simple default subscriber, or create our own custom
subscribers. It even allows a subscriber to be composed from layers. We can create our own
custom layers, or use some default ones (like the level filter layer).</p>

<p>OTel is itself a tracing layer. In the video &amp; <code class="language-plaintext highlighter-rouge">tcp-api-server</code> repo, you will see how to
use OTel with Jaeger, and how to configure the OTel layer with a custom layer.</p>

<p>Next you can add the following code to the <code class="language-plaintext highlighter-rouge">src/main.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[tracing::instrument(fields(arg</span> <span class="nd">=</span> <span class="err">?</span><span class="nd">arg,</span> <span class="nd">client_id),</span> <span class="nd">ret)]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">print_message</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"log message one"</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">prepare_message</span><span class="p">()</span><span class="k">.await</span><span class="p">);</span>

    <span class="nn">Span</span><span class="p">::</span><span class="nf">current</span><span class="p">()</span><span class="nf">.record</span><span class="p">(</span><span class="s">"client_id"</span><span class="p">,</span> <span class="mi">1234</span><span class="p">);</span>

    <span class="nn">tracing</span><span class="p">::</span><span class="nd">warn!</span><span class="p">(</span><span class="s">"log message two"</span><span class="p">);</span>
<span class="p">}</span>

<span class="nd">#[tracing::instrument(ret)]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">prepare_message</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="nn">tracing</span><span class="p">::</span><span class="nd">debug!</span><span class="p">(</span><span class="s">"preparing message"</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="s">"Hello, world!"</span><span class="nf">.to_string</span><span class="p">();</span>
    <span class="nn">tracing</span><span class="p">::</span><span class="nd">debug!</span><span class="p">(</span><span class="s">"message prepared"</span><span class="p">);</span>
    <span class="n">it</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">print_message</code> function is annotated with the <code class="language-plaintext highlighter-rouge">#[tracing::instrument]</code> attribute.
This attribute creates a span for the function, and adds the <code class="language-plaintext highlighter-rouge">arg</code> field to the span along
with the <code class="language-plaintext highlighter-rouge">client_id</code> field. In all the log events are emitted within the span, the <code class="language-plaintext highlighter-rouge">arg</code>
and <code class="language-plaintext highlighter-rouge">client_id</code> field will be included in the log output. This additional context is
provided by a span. And you don‚Äôt have to write any code to the <code class="language-plaintext highlighter-rouge">info!</code>, <code class="language-plaintext highlighter-rouge">warn!</code>, etc
calls to include these fields in the log output.</p>

<p>You can run the code using <code class="language-plaintext highlighter-rouge">cargo run</code>. The code will produce the following output.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   INFO tracing_otel: log message one
    at src/main.rs:38
    in tracing_otel::print_message with arg: "foo"

  DEBUG tracing_otel: preparing message
    at src/main.rs:48
    in tracing_otel::prepare_message
    in tracing_otel::print_message with arg: "foo"

  DEBUG tracing_otel: message prepared
    at src/main.rs:50
    in tracing_otel::prepare_message
    in tracing_otel::print_message with arg: "foo"

   INFO tracing_otel: return: "Hello, world!"
    at src/main.rs:46
    in tracing_otel::prepare_message
    in tracing_otel::print_message with arg: "foo"

Hello, world!

   WARN tracing_otel: log message two
    at src/main.rs:43
    in tracing_otel::print_message with arg: "foo", client_id: 1234

   INFO tracing_otel: return: ()
    at src/main.rs:36
    in tracing_otel::print_message with arg: "foo", client_id: 1234
</code></pre></div></div>

<p>Beyond this simple example, to dive deeper, please check out the video and the
<code class="language-plaintext highlighter-rouge">tcp-api-server</code> repo to get a sense of how this can all be used in a real world example
that has lots of moving parts and pieces. Observability here can tell the story of what
happened in the system, so it can be another way of getting an understanding of the
system‚Äôs behavior.</p>

<h2 id="build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</h2>
<p><a id="markdown-build-with-naz-video-series-on-developerlife.com-youtube-channel" name="build-with-naz-video-series-on-developerlife.com-youtube-channel"></a></p>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a></li>
  <li>Playlists
    <ul>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmza94sS7UmJnN9gSCHTVTfz">Build with Naz, fundamental effective Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmwO69E7eiQ-ewnMME8ydgQ5">Build with Naz, effective async Rust and tokio</a></li>
      <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><summary type="html"><![CDATA[Learn how to use tokio tracing and OpenTelemetry (with Jaeger) in async Rust to instrument your code and collect telemetry data for observability.]]></summary></entry><entry><title type="html">Build with Naz : Rust Polymorphism, dyn, impl, using existing traits, trait objects for testing and extensibility</title><link href="http://developerlife.com/2024/04/28/rust-polymorphism-dyn-impl-trait-objects-for-testing-and-extensibiity/" rel="alternate" type="text/html" title="Build with Naz : Rust Polymorphism, dyn, impl, using existing traits, trait objects for testing and extensibility" /><published>2024-04-28T10:00:00-05:00</published><updated>2024-04-28T10:00:00-05:00</updated><id>http://developerlife.com/2024/04/28/rust-polymorphism-dyn-impl-trait-objects-for-testing-and-extensibiity</id><content type="html" xml:base="http://developerlife.com/2024/04/28/rust-polymorphism-dyn-impl-trait-objects-for-testing-and-extensibiity/"><![CDATA[<p><img class="post-hero-image" src="/assets/rust_polymorphism.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#why-use-polymorphism-in-rust">Why use polymorphism in Rust?</a></li>
  <li><a href="#short-example-to-illustrate-both-approaches">Short example to illustrate both approaches</a></li>
  <li><a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</a></li>
</ul>

<!-- /TOC -->

<h2 id="why-use-polymorphism-in-rust">Why use polymorphism in Rust?</h2>
<p><a id="markdown-why-use-polymorphism-in-rust%3F" name="why-use-polymorphism-in-rust%3F"></a></p>

<p>When it comes to polymorphism in Rust, which means that you want to be intentionally ‚Äúvague‚Äù about
what arguments a function can receive or what values it can return, there are roughly two
approaches: static dispatch and dynamic dispatch. They are both tightly related to the notion of
sidedness in Rust.</p>

<p>There are many legitimate reasons to be intentionally vague about the types of arguments a function
can receive or the values it can return. Here are a few:</p>

<ul>
  <li>Testing: You want swap out the implementation of a function with a test mock or test fixture, so
that you can test the function in isolation.</li>
  <li>Extensibility: You want to accommodate integrations with other code that you don‚Äôt control, and
you want to be able to use dependency injection to provide the intended behaviors (from) systems
that you don‚Äôt control.</li>
  <li>Reuse: You want to reuse the same code in multiple places, since they only operate on on aspect
(or trait) of the data.</li>
</ul>

<p>Here are the two approaches to polymorphism in Rust:</p>

<table>
  <thead>
    <tr>
      <th>static</th>
      <th>dynamic</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>receive</td>
      <td>receive</td>
    </tr>
    <tr>
      <td>return</td>
      <td>return</td>
    </tr>
  </tbody>
</table>

<p>There are pros and cons to each approach:</p>

<table>
  <thead>
    <tr>
      <th>approach</th>
      <th>pros</th>
      <th>cons</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>static</td>
      <td>Compile time checks and dispatch. No runtime overhead.</td>
      <td>Code is more difficult to read and write since generics and their often verbose trait bounds have to be spread to the caller.</td>
    </tr>
    <tr>
      <td>dynamic</td>
      <td>Code is more concise and easier to read and write since the trait objects are localized to the function that accepts or returns them.</td>
      <td>Runtime overhead due to dynamic dispatch. Vtable lookup is required due to type erasure.</td>
    </tr>
  </tbody>
</table>

<p>Here are some helpful links to learn more about this topic:</p>

<ul>
  <li><a href="https://www.youtube.com/watch?v=xcygqF5LVmM&amp;t=1162s">Great Crust of Rust video on monomorphization, generics, vtables, fat pointers, static dispatch, and dynamic dispatch</a></li>
  <li><a href="https://developerlife.com/2022/03/12/rust-redux/#of-things-and-their-managers">Vtables</a></li>
  <li><a href="https://developerlife.com/assets/rust-container-cheat-sheet.svg">Diagram of sizes</a></li>
  <li><a href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/sizedness-in-rust.md">Sizedness</a></li>
  <li><a href="https://gemini.google.com/app/157980ca7d9b588c">Difference between using <code class="language-plaintext highlighter-rouge">Arc</code> and <code class="language-plaintext highlighter-rouge">Box</code> with <code class="language-plaintext highlighter-rouge">dyn</code></a></li>
  <li><a href="https://rust-unofficial.github.io/too-many-lists/index.html">Book on <code class="language-plaintext highlighter-rouge">dyn</code> and <code class="language-plaintext highlighter-rouge">Box</code></a></li>
</ul>

<h2 id="video-of-this-in-action-in-the-real-world">Video of this in action in the real world</h2>
<p><a id="markdown-video-of-this-in-action-in-the-real-world" name="video-of-this-in-action-in-the-real-world"></a></p>

<p>This blog post only has a short example to illustrate both approaches to polymorphism in
Rust. To see how these ideas can be used in production code, with real-world examples,
please watch the following video on the <a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube
channel</a>.</p>

<!-- video on rust polymorphism (no playlist) -->
<iframe src="https://www.youtube.com/embed/kYTgGtJjSro?si=XmW-_CAvCfB5e269" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<h2 id="short-example-to-illustrate-both-approaches">Short example to illustrate both approaches</h2>
<p><a id="markdown-short-example-to-illustrate-both-approaches" name="short-example-to-illustrate-both-approaches"></a></p>

<p>The code for this example lives
<a href="https://github.com/nazmulidris/rust-scratch/tree/main/dyn-dispatch/src">here</a>.</p>

<p>Let‚Äôs look a single example (that fits in one file) that illustrates both approaches to polymorphism
in Rust. You can run <code class="language-plaintext highlighter-rouge">cargo new --lib dyn-dispatch</code> to create a new library crate, and then run
<code class="language-plaintext highlighter-rouge">cargo add rand</code>. Then you can add the following code to the <code class="language-plaintext highlighter-rouge">src/lib.rs</code> file.</p>

<p>This first part is the setup for this example. We have two structs, each of which
implements the <a href="https://doc.rust-lang.org/std/io/struct.Error.html"><code class="language-plaintext highlighter-rouge">Error</code></a> trait. We
want to be able to use both structs in functions that can receive or return
<a href="https://doc.rust-lang.org/std/io/struct.Error.html"><code class="language-plaintext highlighter-rouge">Error</code></a> trait objects.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span><span class="p">;</span>

<span class="c1">// ErrorOne.</span>
<span class="k">mod</span> <span class="n">error_one</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="nd">#[derive(Debug)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">ErrorOne</span><span class="p">;</span>

    <span class="k">impl</span> <span class="n">Display</span> <span class="k">for</span> <span class="n">ErrorOne</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"ErrorOne"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">impl</span> <span class="n">Error</span> <span class="k">for</span> <span class="n">ErrorOne</span> <span class="p">{}</span>
<span class="p">}</span>
<span class="k">use</span> <span class="nn">error_one</span><span class="p">::</span><span class="n">ErrorOne</span><span class="p">;</span>

<span class="c1">// ErrorTwo.</span>
<span class="k">mod</span> <span class="n">error_two</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="nd">#[derive(Debug)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">ErrorTwo</span><span class="p">;</span>

    <span class="k">impl</span> <span class="n">Display</span> <span class="k">for</span> <span class="n">ErrorTwo</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"ErrorTwo"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">impl</span> <span class="n">Error</span> <span class="k">for</span> <span class="n">ErrorTwo</span> <span class="p">{}</span>
<span class="p">}</span>
<span class="k">use</span> <span class="nn">error_two</span><span class="p">::</span><span class="n">ErrorTwo</span><span class="p">;</span>
</code></pre></div></div>

<p>In some of the code we will need to make a random decision, so we‚Äôll use the <code class="language-plaintext highlighter-rouge">rand</code> crate to
generate random booleans.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Random boolean generator.</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">random_bool</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="nn">rand</span><span class="p">::</span><span class="nf">random</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here‚Äôs the code for the static dispatch approach, using generics, trait bounds, and compiler
monomorphisation.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Static dispatch.</span>
<span class="k">mod</span> <span class="n">static_dispatch</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">mod</span> <span class="n">receives</span> <span class="p">{</span>
        <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="n">accept_error</span><span class="o">&lt;</span><span class="n">E</span><span class="p">:</span> <span class="n">Error</span><span class="o">&gt;</span><span class="p">(</span><span class="n">error</span><span class="p">:</span> <span class="n">E</span><span class="p">)</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Handling ErrorOne Debug: {:?}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Handling ErrorOne Display: {}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">accept_error_with_syntactic_sugar</span><span class="p">(</span><span class="n">error</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Error</span><span class="p">)</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Handling ErrorOne Debug: {:?}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Handling ErrorOne Display: {}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">mod</span> <span class="n">returns</span> <span class="p">{</span>
        <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">return_error_one</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">ErrorOne</span> <span class="p">{</span>
            <span class="n">ErrorOne</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">return_error_two</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">ErrorTwo</span> <span class="p">{</span>
            <span class="n">ErrorTwo</span>
        <span class="p">}</span>

        <span class="c1">// üö® DOES NOT WORK! Need dynamic dispatch.</span>
        <span class="c1">// pub fn return_single_error() -&gt; impl Error {</span>
        <span class="c1">//     if random_bool() {</span>
        <span class="c1">//         ErrorOne</span>
        <span class="c1">//     } else {</span>
        <span class="c1">//         ErrorTwo</span>
        <span class="c1">//     }</span>
        <span class="c1">// }</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">return_single_error</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="n">Error</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">ErrorOne</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Finally, here‚Äôs the code for the dynamic dispatch approach, using trait objects and vtables to
enable runtime polymorphism.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Dynamic dispatch.</span>
<span class="k">mod</span> <span class="n">dynamic_dispatch</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">mod</span> <span class="n">receives</span> <span class="p">{</span>
        <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">recieve_error_by_ref</span><span class="p">(</span><span class="n">error</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">dyn</span> <span class="n">Error</span><span class="p">)</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Handling Error Debug: {:?}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Handling Error Display: {}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">example_1</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">error_one</span> <span class="o">=</span> <span class="n">ErrorOne</span><span class="p">;</span>
            <span class="nf">recieve_error_by_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">error_one</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">error_two</span> <span class="o">=</span> <span class="n">ErrorTwo</span><span class="p">;</span>
            <span class="nf">recieve_error_by_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">error_two</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">receive_error_by_box</span><span class="p">(</span><span class="n">error</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">Error</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Handling Error Debug: {:?}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Handling Error Display: {}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">example_2</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">error_one</span> <span class="o">=</span> <span class="n">ErrorOne</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">error_one</span><span class="p">);</span>
            <span class="nf">receive_error_by_box</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">error_two</span> <span class="o">=</span> <span class="n">ErrorTwo</span><span class="p">;</span>
            <span class="nf">receive_error_by_box</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">error_two</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">receive_slice_of_errors</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="o">&amp;</span><span class="k">dyn</span> <span class="n">Error</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">for</span> <span class="n">error</span> <span class="k">in</span> <span class="n">arg</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"Handling Error Debug: {:?}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"Handling Error Display: {}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">mod</span> <span class="n">returns</span> <span class="p">{</span>
        <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">return_one_of_two_errors</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nf">random_bool</span><span class="p">()</span> <span class="p">{</span>
                <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">ErrorOne</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">ErrorTwo</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">return_one_of_two_errors_with_arc</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nf">random_bool</span><span class="p">()</span> <span class="p">{</span>
                <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">ErrorOne</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">ErrorTwo</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">return_slice_of_errors</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="k">'static</span> <span class="k">dyn</span> <span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">errors</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="k">dyn</span> <span class="n">Error</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
            <span class="k">if</span> <span class="nf">random_bool</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">errors</span><span class="nf">.push</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ErrorOne</span><span class="p">));</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">errors</span><span class="nf">.push</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ErrorTwo</span><span class="p">));</span>
            <span class="p">}</span>
            <span class="n">errors</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">mut_vec_containing_different_types_of_errors</span><span class="p">(</span><span class="n">mut_vec</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="k">dyn</span> <span class="n">Error</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">mut_vec</span><span class="nf">.push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ErrorOne</span><span class="p">);</span>
            <span class="n">mut_vec</span><span class="nf">.push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ErrorTwo</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</h2>
<p><a id="markdown-build-with-naz-video-series-on-developerlife.com-youtube-channel" name="build-with-naz-video-series-on-developerlife.com-youtube-channel"></a></p>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a>
    <ul>
      <li><a href="https://youtu.be/6LhVx0xM86c">Part 1: Why?</a></li>
      <li><a href="https://youtu.be/3vQJguti02I">Part 2: What?</a></li>
      <li><a href="https://youtu.be/uxgyZzOmVIw">Part 3: Do the refactor and rename the crate</a></li>
      <li><a href="https://www.youtube.com/watch?v=fcb6rstRniI">Part 4: Build the spinner</a></li>
      <li><a href="https://www.youtube.com/watch?v=_QjsGDds270">Part 5: Add color gradient animation to spinner</a></li>
      <li><a href="https://youtu.be/X5wDVaZENOo">Part 6: Publish the crate and overview</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Testing playlist</a>
        <ul>
          <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk">Part 1: Intro</a></li>
          <li><a href="https://www.youtube.com/watch?v=4iM9t5dgvU4">Part 2: Deep dive</a></li>
          <li><a href="https://www.youtube.com/watch?v=kYTgGtJjSro">Part 3: Polymorphism, static and dynamic dispatch</a></li>
          <li>Playlists
            <ul>
              <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmza94sS7UmJnN9gSCHTVTfz">Build with Naz, fundamental effective Rust</a></li>
              <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmwO69E7eiQ-ewnMME8ydgQ5">Build with Naz, effective async Rust and tokio</a></li>
              <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
              <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><summary type="html"><![CDATA[Learn how to implement effective Rust polymorphism, using `dyn`, `impl`, existing traits, and trait objects for testing and extensibility, in real world projects.]]></summary></entry><entry><title type="html">Build with Naz : Build interactive and non blocking CLI apps with ease in Rust using r3bl_terminal_async</title><link href="http://developerlife.com/2024/04/21/build-async-interactive-cli-apps-in-rust/" rel="alternate" type="text/html" title="Build with Naz : Build interactive and non blocking CLI apps with ease in Rust using r3bl_terminal_async" /><published>2024-04-21T10:00:00-05:00</published><updated>2024-04-21T10:00:00-05:00</updated><id>http://developerlife.com/2024/04/21/build-async-interactive-cli-apps-in-rust</id><content type="html" xml:base="http://developerlife.com/2024/04/21/build-async-interactive-cli-apps-in-rust/"><![CDATA[<p><img class="post-hero-image" src="/assets/r3bl_terminal_async-hero.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#why-use-this-crate">Why use this crate</a></li>
  <li><a href="#demo-of-this-in-action">Demo of this in action</a></li>
  <li><a href="#example-of-using-this-crate">Example of using this crate</a></li>
  <li><a href="#video-series-on-developerlifecom-youtube-channel-on-building-this-crate-with-naz">Video series on developerlife.com YouTube channel on building this crate with Naz</a></li>
</ul>

<!-- /TOC -->

<p>The <code class="language-plaintext highlighter-rouge">r3bl_terminal_async</code> library lets your CLI program be asynchronous and interactive without
blocking the main thread. Your spawned tasks can use it to concurrently write to the display output,
pause and resume it. You can also display of colorful animated spinners ‚åõüåà for long running tasks.
With it, you can create beautiful, powerful, and interactive REPLs (read execute print loops) with
ease.</p>

<h2 id="why-use-this-crate">Why use this crate</h2>

<p><a id="markdown-why-use-this-crate" name="why-use-this-crate"></a></p>

<ul>
  <li>Because <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line">read_line()</a> is
blocking. And there is no way to terminate an OS thread that is blocking in Rust. To do this you
have to exit the process (who‚Äôs thread is blocked in <code class="language-plaintext highlighter-rouge">read_line()</code>).</li>
  <li>Another annoyance is that when a thread is blocked in <code class="language-plaintext highlighter-rouge">read_line()</code>, and you have to display
output to stdout concurrently, this poses some challenges.</li>
</ul>

<h2 id="demo-of-this-in-action">Demo of this in action</h2>

<p><a id="markdown-demo-of-this-in-action" name="demo-of-this-in-action"></a></p>

<p>Here‚Äôs a screen capture of the types of interactive REPLs that you can expect to build in Rust,
using this crate.</p>

<p><img src="https://github.com/r3bl-org/r3bl-open-core/blob/main/terminal_async/docs/r3bl_terminal_async_clip_ffmpeg.gif?raw=true" alt="" /></p>

<p>A couple of things to note about this demo:</p>

<ol>
  <li>You can use up, down to access history in the multi-line editor.</li>
  <li>You can use left, right, ctrl+left, ctrl+right, to jump around in the multi-line editor.</li>
  <li>You can edit content in this multi-line editor without blocking the main thread, and while other
tasks (started via <code class="language-plaintext highlighter-rouge">tokio::spawn</code> are concurrently producing output to the display.</li>
  <li>You can pause the output while spinners are being displayed, and these spinners support many
different kinds of animations!</li>
</ol>

<h2 id="example-of-using-this-crate">Example of using this crate</h2>

<p><a id="markdown-example-of-using-this-crate" name="example-of-using-this-crate"></a></p>

<p>There are great examples in the <code class="language-plaintext highlighter-rouge">examples</code> folder of the repo
<a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/terminal_async/examples">here</a>. Let‚Äôs walk
through a simple example of using this crate. Let‚Äôs create a new example using the following
commands:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo new <span class="nt">--bin</span> async-cli
<span class="nb">cd </span>async-cli
cargo add r3bl_terminal_async
cargo add miette <span class="nt">--features</span> fancy
cargo add tokio <span class="nt">--features</span> full
</code></pre></div></div>

<p>Now, let‚Äôs add a <code class="language-plaintext highlighter-rouge">main.rs</code> file in the <code class="language-plaintext highlighter-rouge">src</code> folder.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="n">Duration</span><span class="p">;</span>

<span class="k">use</span> <span class="nn">r3bl_terminal_async</span><span class="p">::{</span><span class="n">tracing_setup</span><span class="p">,</span> <span class="n">TerminalAsync</span><span class="p">,</span> <span class="n">TracingConfig</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="n">interval</span><span class="p">;</span>

<span class="nd">#[tokio::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">maybe_terminal_async</span> <span class="o">=</span> <span class="nn">TerminalAsync</span><span class="p">::</span><span class="nf">try_new</span><span class="p">(</span><span class="s">"&gt; "</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// If the terminal is not fully interactive, then return early.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">terminal_async</span> <span class="o">=</span> <span class="k">match</span> <span class="n">maybe_terminal_async</span> <span class="p">{</span>
        <span class="nb">None</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nf">Ok</span><span class="p">(()),</span>
        <span class="n">_</span> <span class="k">=&gt;</span> <span class="n">maybe_terminal_async</span><span class="nf">.unwrap</span><span class="p">(),</span>
    <span class="p">};</span>

    <span class="c1">// Initialize tracing w/ the "async stdout".</span>
    <span class="nn">tracing_setup</span><span class="p">::</span><span class="nf">init</span><span class="p">(</span><span class="nn">TracingConfig</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span>
        <span class="n">terminal_async</span><span class="nf">.clone_shared_writer</span><span class="p">(),</span>
    <span class="p">)))</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Start tasks.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">interval_1_task</span> <span class="o">=</span> <span class="nf">interval</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">interval_2_task</span> <span class="o">=</span> <span class="nf">interval</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>

    <span class="n">terminal_async</span>
        <span class="nf">.println</span><span class="p">(</span><span class="s">"Welcome to your async repl! press Ctrl+D or Ctrl+C to exit."</span><span class="p">)</span>
        <span class="k">.await</span><span class="p">;</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span> <span class="p">{</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">interval_1_task</span><span class="nf">.tick</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">terminal_async</span><span class="nf">.println</span><span class="p">(</span><span class="s">"interval_1_task ticked"</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
            <span class="p">},</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">interval_2_task</span><span class="nf">.tick</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">terminal_async</span><span class="nf">.println</span><span class="p">(</span><span class="s">"interval_1_task ticked"</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
            <span class="p">},</span>
            <span class="n">user_input</span> <span class="o">=</span> <span class="n">terminal_async</span><span class="nf">.get_readline_event</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="k">match</span> <span class="n">user_input</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">readline_event</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">match</span> <span class="n">readline_event</span> <span class="p">{</span>
                        <span class="nn">r3bl_terminal_async</span><span class="p">::</span><span class="nn">ReadlineEvent</span><span class="p">::</span><span class="n">Eof</span> <span class="k">=&gt;</span> <span class="k">break</span><span class="p">,</span>
                        <span class="nn">r3bl_terminal_async</span><span class="p">::</span><span class="nn">ReadlineEvent</span><span class="p">::</span><span class="n">Interrupted</span> <span class="k">=&gt;</span> <span class="k">break</span><span class="p">,</span>
                        <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">(),</span>
                    <span class="p">}</span>

                    <span class="k">let</span> <span class="n">msg</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">readline_event</span><span class="p">);</span>
                    <span class="n">terminal_async</span><span class="nf">.println</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
                <span class="p">},</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">msg</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"Received err: {:?}. Exiting."</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
                    <span class="n">terminal_async</span><span class="nf">.println</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">},</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Flush all writers to stdout</span>
    <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="n">terminal_async</span><span class="nf">.flush</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>You can then run this program using <code class="language-plaintext highlighter-rouge">cargo run</code>. Play with it to get a sense of the asynchronous and
non blocking nature of the REPL. Press Ctrl+C, or Ctrl+D to exit this program.</p>

<h2 id="video-series-on-developerlifecom-youtube-channel-on-building-this-crate-with-naz">Video series on developerlife.com YouTube channel on building this crate with Naz</h2>

<p><a id="markdown-video-series-on-developerlife.com-youtube-channel-on-building-this-crate-with-naz" name="video-series-on-developerlife.com-youtube-channel-on-building-this-crate-with-naz"></a></p>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<p>Here‚Äôs the video that is tied to this blog post:</p>

<iframe src="https://www.youtube.com/embed/X5wDVaZENOo?si=yYfXuCxSilWh4Gd5" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a>
    <ul>
      <li><a href="https://youtu.be/6LhVx0xM86c">Part 1: Why?</a></li>
      <li><a href="https://youtu.be/3vQJguti02I">Part 2: What?</a></li>
      <li><a href="https://youtu.be/uxgyZzOmVIw">Part 3: Do the refactor and rename the crate</a></li>
      <li><a href="https://www.youtube.com/watch?v=fcb6rstRniI">Part 4: Build the spinner</a></li>
      <li><a href="https://www.youtube.com/watch?v=_QjsGDds270">Part 5: Add color gradient animation to spinner</a></li>
      <li><a href="https://youtu.be/X5wDVaZENOo">Part 6: Publish the crate and overview</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Testing playlist</a>
        <ul>
          <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk">Part 1: Intro</a></li>
          <li><a href="https://www.youtube.com/watch?v=4iM9t5dgvU4">Part 2: Deep dive</a></li>
        </ul>
      </li>
      <li>Playlists
        <ul>
          <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmza94sS7UmJnN9gSCHTVTfz">Build with Naz, fundamental effective Rust</a></li>
          <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmwO69E7eiQ-ewnMME8ydgQ5">Build with Naz, effective async Rust and tokio</a></li>
          <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
          <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><summary type="html"><![CDATA[The r3bl_terminal_async library lets your CLI program be asynchronous and interactive without blocking the main thread. Your spawned tasks can use it to concurrently write to the display output, pause and resume it. You can also display of colorful animated spinners ‚åõüåà for long running tasks. With it, you can create beautiful, powerful, and interactive REPLs (read execute print loops) with ease.]]></summary></entry><entry><title type="html">Write a simple TCP chat server in Rust</title><link href="http://developerlife.com/2024/01/13/write-simple-chat-server-in-rust/" rel="alternate" type="text/html" title="Write a simple TCP chat server in Rust" /><published>2024-01-13T09:00:00-06:00</published><updated>2024-01-13T09:00:00-06:00</updated><id>http://developerlife.com/2024/01/13/write-simple-chat-server-in-rust</id><content type="html" xml:base="http://developerlife.com/2024/01/13/write-simple-chat-server-in-rust/"><![CDATA[<p><img class="post-hero-image" src="/assets/chatserver-hero.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#build-a-chat-server-using-tokio">Build a chat server using Tokio</a></li>
  <li><a href="#the-chat-server-comprises-all-these-pieces">The chat server comprises all these pieces</a></li>
  <li><a href="#add-dependencies-to-cargotoml">Add dependencies to Cargo.toml</a></li>
  <li><a href="#main-function">Main function</a>
    <ul>
      <li><a href="#tokiospawn-does-not-spawn-a-new-thread-so-what-does-it-actually-do">tokio::spawn does not spawn a new thread, so what does it actually do?</a></li>
    </ul>
  </li>
  <li><a href="#handle-client-task-function">Handle client task function</a>
    <ul>
      <li><a href="#two-concurrent-tasks-in-the-tokioselect-block">Two concurrent tasks in the tokio::select! block</a></li>
      <li><a href="#handle-read-from-broadcast-channel-function">Handle read from broadcast channel function</a></li>
      <li><a href="#handle-socket-read-function">Handle socket read function</a></li>
    </ul>
  </li>
  <li><a href="#next-steps">Next steps</a></li>
</ul>

<!-- /TOC -->

<h2 id="build-a-chat-server-using-tokio">Build a chat server using Tokio</h2>
<p><a id="markdown-build-a-chat-server-using-tokio" name="build-a-chat-server-using-tokio"></a></p>

<p>In this tutorial we will build a simple chat server using Tokio. The server will be able
to handle multiple clients, and each client will be able to send messages to the server,
which will then broadcast the message to all other connected clients.</p>

<ul>
  <li>We will use Tokio‚Äôs <code class="language-plaintext highlighter-rouge">tokio::net::TcpListener</code> and <code class="language-plaintext highlighter-rouge">tokio::net::TcpStream</code> to create a
TCP server that listens for incoming connections and handles them concurrently.</li>
  <li>We will also use Tokio‚Äôs <code class="language-plaintext highlighter-rouge">tokio::sync::broadcast</code> to broadcast messages to all connected
clients.</li>
</ul>

<p>Read <a href="/2024/01/13/write-simple-netcat-in-rust/">this tutorial</a> to
learn more about the basics of TCP client and server programming in Rust (without using
Tokio).</p>

<!--
simple-netcat-in-rust video
Source: https://github.com/nazmulidris/developerlife.com/issues/4
-->
<blockquote>
  <p>Here‚Äôs a video of the app that we are going to build in action.</p>
  <video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/14ce32ce-0988-4853-acd5-1174b1864d57" type="video/mp4" />
</video>
</blockquote>
<blockquote>

üëÄ Watch Rust ü¶Ä live coding videos on our <a href="https://www.youtube.com/@developerlifecom">YouTube Channel</a>.

<br />
<br />

<!-- video on rust polymorphism (no playlist) -->
<iframe src="https://www.youtube.com/embed/kYTgGtJjSro?si=XmW-_CAvCfB5e269" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<br />
<br />

üì¶ Install our useful Rust command line apps using <code>cargo install r3bl-cmdr</code>
(they are from the <a href="https://github.com/r3bl-org/r3bl-open-core">r3bl-open-core</a>
project):
<ul>
  <li>üê±<code>giti</code>: run interactive git commands with confidence in your terminal</li>
  <li>ü¶ú<code>edi</code>: edit Markdown with style in your terminal</li>
</ul>

<p>
<kbd>giti in action</kbd>
<video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/262f59d1-a95c-4af3-accf-c3d6cac6e586" type="video/mp4" />
</video>
</p>

<p>
<kbd>edi in action</kbd>
<video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/f2c4b07d-b5a2-4f41-af7a-06d1b6660c41" type="video/mp4" />
</video>
</p>

</blockquote>
<blockquote>
  <p>You can find the finished source code for this tutorial
<a href="https://github.com/nazmulidris/rust-scratch/tree/main/tcp-server-netcat-client">here</a>.</p>
</blockquote>

<h2 id="the-chat-server-comprises-all-these-pieces">The chat server comprises all these pieces</h2>
<p><a id="markdown-the-chat-server-comprises-all-these-pieces" name="the-chat-server-comprises-all-these-pieces"></a></p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   ‚îå‚îÄCLIENT-1‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄCLIENT‚îÄ2‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄCLIENT‚îÄ3‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ                ‚îÇ      ‚îÇ                ‚îÇ        ‚îÇ               ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ                      ‚îÇ                        ‚îÇ
‚îå‚îÄSERVER‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ          ‚îÇ                      ‚îÇ                        ‚îÇ            ‚îÇ
‚îÇ                                                                       ‚îÇ
‚îÇ handle_client_task()   handle_client_task()    handle_client_task()   ‚îÇ
‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ  ‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ ‚îÇ
‚îÇ ‚îÇ   ‚îÇ TX ‚îÇ ‚îÇ RX ‚îÇ   ‚îÇ ‚îÇ   ‚îÇ TX ‚îÇ ‚îÇ RX ‚îÇ    ‚îÇ  ‚îÇ    ‚îÇ TX ‚îÇ ‚îÇ RX ‚îÇ    ‚îÇ ‚îÇ
‚îÇ ‚îÇ   ‚îî‚îÄ‚î¨‚îÄ‚îÄ‚îò ‚îî‚îÄ‚ñ≤‚îÄ‚îÄ‚îò   ‚îÇ ‚îÇ   ‚îî‚îÄ‚î¨‚îÄ‚îÄ‚îò ‚îî‚îÄ‚ñ≤‚îÄ‚îÄ‚îò    ‚îÇ  ‚îÇ    ‚îî‚îÄ‚î¨‚îÄ‚îÄ‚îò ‚îî‚îÄ‚ñ≤‚îÄ‚îÄ‚îò    ‚îÇ ‚îÇ
‚îÇ ‚îÇ     ‚îÇ      ‚îÇ      ‚îÇ ‚îÇ     ‚îÇ      ‚îÇ       ‚îÇ  ‚îÇ      ‚îÇ      ‚îÇ       ‚îÇ ‚îÇ
‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ       ‚îÇ      ‚îÇ              ‚îÇ      ‚îÇ                 ‚îÇ      ‚îÇ         ‚îÇ
‚îÇ       ‚îÇ      ‚îÇ              ‚îÇ      ‚îÇ                 ‚îÇ      ‚îÇ         ‚îÇ
‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ ‚îÇ                    (TX, RX) = channel::broadcast()                ‚îÇ ‚îÇ
‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre></div></div>

<!-- Diagram source
https://asciiflow.com/#/share/eJztVs1Kw0AQfpVlTy1E0ApiA54kB0E8xCI5LJTYBhRjhDZCSylIzh56CCXP4TlP0ydxwzbtbnY2bdL1p9VhApOdmW9mv0yWneDAffawGbz6voF9d%2BwNsIknBI8INtvnxwbBY2q1ztrUCr1RSF8IRpks4pTq5fWVddM5OmFvsqKlLOL3RfzGoqnRog%2BkM0X8qSqekCDvBhVEqB7J3qjcexjIAqCMzbcAoRf8B4RfQ9dAMTSLqWJGmSa7ZeedA2QUpcSV%2BSgS286tZd9Zdj0q9kXZZvUQp%2BRSmVRTeOAHN%2Bj7XrfnP3pB2A3d4VOjyaKUHnUKD6yFXpQf1LvpTBtMcYsl3xI4QZfeaIPzZ4oA7IMfRCwu8TqDlgpNVU6CmkUdZ2XaDoKbi1gUM22Ho4RrZkNQBabmH2VMxeJBnORLWVa%2BJDVXMQmYnVUzwijx86OKiLYI%2BC%2F45QU1naP8tSAVf7aSRV4TbTDCFpGSDrSNV%2B389iIC7XOtdw2NaHWh5M3KJGbS6DgGPUeb6AL16GUh8HzTvB%2B8uP2eOwzzuwLArvax%2F7UKzKY22WPgP6gET%2FH0Ex1Q3VY%3D)
-->

<p>The server has a <code class="language-plaintext highlighter-rouge">main</code> function that creates a <code class="language-plaintext highlighter-rouge">tokio::net::TcpListener</code> and listens for
incoming connections. When a new connection is received, it spawns a new task to handle
the connection using <code class="language-plaintext highlighter-rouge">tokio::spawn()</code>.</p>

<p>Using <code class="language-plaintext highlighter-rouge">tokio::select!</code>, the task tries to do the following concurrently, and waits until
one of them completes:</p>
<ol>
  <li>The task reads messages from its client and broadcasts them to all other connected
clients. It also echoes the message back to its client.</li>
  <li>The task listens for messages from other clients and sends them to its client.</li>
</ol>

<p>When one task above completes, the other is dropped. Then the code path with the completed
task executes. Then the code returns to the infinite loop, if it hasn‚Äôt returned already.</p>

<p>A client can be any TCP client, such as <code class="language-plaintext highlighter-rouge">telnet</code>, <code class="language-plaintext highlighter-rouge">nc</code>, or PuTTY.</p>

<h2 id="add-dependencies-to-cargotoml">Add dependencies to Cargo.toml</h2>
<p><a id="markdown-add-dependencies-to-cargo.toml" name="add-dependencies-to-cargo.toml"></a></p>

<p>Let‚Äôs create a new project by running <code class="language-plaintext highlighter-rouge">cargo create --bin tcp-server-netcat-client</code>. Then
we will add the following dependencies to our <code class="language-plaintext highlighter-rouge">Cargo.toml</code> file.</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># tokio.</span>
<span class="py">tokio</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"1.35.1"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"full"</span><span class="p">]</span> <span class="p">}</span>

<span class="c"># stdout logging.</span>
<span class="py">femme</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"2.2.1"</span> <span class="p">}</span>
<span class="py">log</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.4.20"</span> <span class="p">}</span>

<span class="c"># r3bl_rs_utils_core - friendly name generator.</span>
<span class="py">r3bl_rs_utils_core</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.9.12"</span> <span class="p">}</span>
<span class="py">r3bl_tui</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.5.1"</span> <span class="p">}</span>
</code></pre></div></div>

<h2 id="main-function">Main function</h2>
<p><a id="markdown-main-function" name="main-function"></a></p>

<p>We will implement the following algorithm for our server in our main function:</p>
<ol>
  <li>Create a broadcast channel. It will be shared by all the client tasks.</li>
  <li>Create <code class="language-plaintext highlighter-rouge">TcpListener</code> and bind to an address &amp; port.</li>
  <li>Loop:
    <ul>
      <li>Accept socket connection, and get its <code class="language-plaintext highlighter-rouge">TCPStream</code>.</li>
      <li>Use <code class="language-plaintext highlighter-rouge">tokio::spawn()</code> to spawn a task to handle this client connection and its
<code class="language-plaintext highlighter-rouge">TCPStream</code>.</li>
    </ul>
  </li>
</ol>

<p>In the task that handles the connection:</p>
<ol>
  <li>Get <code class="language-plaintext highlighter-rouge">BufReader</code> &amp; <code class="language-plaintext highlighter-rouge">BufWriter</code> from the <code class="language-plaintext highlighter-rouge">TCPStream</code>. The reader and writer allow us to
read data from and write data to the client socket.</li>
  <li>Loop:
    <ul>
      <li>Use <code class="language-plaintext highlighter-rouge">tokio::select!</code> to concurrently:
        <ul>
          <li>Read from broadcast channel (via <code class="language-plaintext highlighter-rouge">recv()</code>):
            <ul>
              <li>Send the message to the client (only if it is from a different client) over the
socket (use <code class="language-plaintext highlighter-rouge">BufWriter</code> to write the message).</li>
            </ul>
          </li>
          <li>Read from socket (via <code class="language-plaintext highlighter-rouge">BufReader::read_line()</code>):
            <ul>
              <li>Read <code class="language-plaintext highlighter-rouge">incoming</code> from reader.</li>
              <li>Call <code class="language-plaintext highlighter-rouge">process(incoming)</code> and generate <code class="language-plaintext highlighter-rouge">outgoing</code>. This colorizes the <code class="language-plaintext highlighter-rouge">incoming</code>
message with a lolcat effect to generate the <code class="language-plaintext highlighter-rouge">outgoing</code> message.</li>
              <li>Send <code class="language-plaintext highlighter-rouge">incoming</code> message to other connected clients (via the broadcast channel).</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<blockquote>
  <p>You can find the finished source code for this tutorial
<a href="https://github.com/nazmulidris/rust-scratch/tree/main/tcp-server-netcat-client">here</a>.</p>
</blockquote>

<p>Here‚Äôs the code for the main function, and some supporting type aliases and structs:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">type</span> <span class="n">IOResult</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">MsgType</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">socket_addr</span><span class="p">:</span> <span class="n">SocketAddr</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">payload</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">from_id</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[tokio::main]</span>
<span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">IOResult</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">addr</span> <span class="o">=</span> <span class="s">"127.0.0.1:3000"</span><span class="p">;</span>

    <span class="c1">// Start logging.</span>
    <span class="nn">femme</span><span class="p">::</span><span class="nf">start</span><span class="p">();</span>

    <span class="c1">// Create TCP listener.</span>
    <span class="k">let</span> <span class="n">tcp_listener</span> <span class="o">=</span> <span class="nn">TcpListener</span><span class="p">::</span><span class="nf">bind</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
    <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"Server is ready to accept connections on {}"</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

    <span class="c1">// Create channel shared among all clients that connect to the server loop.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="nn">broadcast</span><span class="p">::</span><span class="nn">channel</span><span class="p">::</span><span class="o">&lt;</span><span class="n">MsgType</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

    <span class="c1">// Server loop.</span>
    <span class="k">loop</span> <span class="p">{</span>
        <span class="c1">// Accept incoming socket connections.</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">tcp_stream</span><span class="p">,</span> <span class="n">socket_addr</span><span class="p">)</span> <span class="o">=</span> <span class="n">tcp_listener</span><span class="nf">.accept</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">tx</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">handle_client_task</span><span class="p">(</span><span class="n">tcp_stream</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="n">socket_addr</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
            <span class="k">match</span> <span class="n">result</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"handle_client_task() terminated gracefully"</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">log</span><span class="p">::</span><span class="nd">error!</span><span class="p">(</span><span class="s">"handle_client_task() encountered error: {}"</span><span class="p">,</span> <span class="n">error</span><span class="p">),</span>
            <span class="p">}</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To run the server, you can run <code class="language-plaintext highlighter-rouge">cargo run</code>. There are no command line arguments to pass or
parse.</p>

<h3 id="tokiospawn-does-not-spawn-a-new-thread-so-what-does-it-actually-do">tokio::spawn does not spawn a new thread, so what does it actually do?</h3>
<p><a id="markdown-tokio%3A%3Aspawn-does-not-spawn-a-new-thread%2C-so-what-does-it-actually-do%3F" name="tokio%3A%3Aspawn-does-not-spawn-a-new-thread%2C-so-what-does-it-actually-do%3F"></a></p>

<p>Since <code class="language-plaintext highlighter-rouge">tokio::spawn</code> sounds similar to <code class="language-plaintext highlighter-rouge">thread::spawn</code> it might be easy to assume that
<code class="language-plaintext highlighter-rouge">tokio::spawn</code> creates a new thread. This would go against the idea of even using tokio
(which is all about concurrency and non blocking IO), since handling one connection per
thread isn‚Äôt <a href="https://g.co/bard/share/74f433bad400">scalable</a>, which is what we did in
this tutorial: <a href="/2024/01/13/write-simple-netcat-in-rust/">Write a simple TCP chat server in Rust</a>.</p>

<p><code class="language-plaintext highlighter-rouge">tokio::spawn</code> does not create a thread; it creates a Tokio task, which is a
co-operatively scheduled entity that Tokio knows how to schedule on the Tokio runtime (in
turn, the Tokio runtime can have as many worker threads as you want - from 1 upwards).</p>

<p>By using <code class="language-plaintext highlighter-rouge">tokio::spawn</code>, you allow the Tokio runtime to switch to another task at points
in the task where it has a <code class="language-plaintext highlighter-rouge">.await</code>, and only those points. Your alternative, if you don‚Äôt
want multiple tasks, is to use things like <code class="language-plaintext highlighter-rouge">select!</code>, <code class="language-plaintext highlighter-rouge">join!</code> and functions with <code class="language-plaintext highlighter-rouge">select</code>
or ` join` in their name to have concurrent I/O in a single task.</p>

<p>The point of spawning in Tokio is twofold:</p>

<ol>
  <li>If your runtime has multiple threads, then two tasks can execute in parallel on
different threads, reducing latency.</li>
  <li>It is almost always easier to understand a complex program in terms of different tasks
doing their work, than in terms of a single large task doing lots of work concurrently
(e.g. using <code class="language-plaintext highlighter-rouge">select</code> to wait for one of many options, or <code class="language-plaintext highlighter-rouge">join</code> to wait for all options
to finish).</li>
</ol>

<p>More information:</p>
<ol>
  <li>You can get more info on this topic
 <a href="https://users.rust-lang.org/t/socket-per-thread-in-tokio/83712/7">here</a>.</li>
  <li>For an even deeper dive into how Tokio tasks themselves are implemented for intra-task
concurrency, please take a look at this <a href="https://without.boats/blog/let-futures-be-futures/">excellent
article</a>.</li>
</ol>

<h2 id="handle-client-task-function">Handle client task function</h2>
<p><a id="markdown-handle-client-task-function" name="handle-client-task-function"></a></p>

<p>The <code class="language-plaintext highlighter-rouge">handle_client_task</code> function is where all the magic happens.</p>
<ol>
  <li>It reads messages from its client (over TCP socket) and broadcasts them to all other
connected clients.</li>
  <li>It processes the message from its client and echoes it back to its client (over TCP
socket).</li>
  <li>It reads messages from other clients (over broadcast channel) and sends them to its
client (over socket).</li>
</ol>

<p>Here‚Äôs the code for the <code class="language-plaintext highlighter-rouge">handle_client_task()</code> function:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">fn</span> <span class="nf">handle_client_task</span><span class="p">(</span>
    <span class="k">mut</span> <span class="n">tcp_stream</span><span class="p">:</span> <span class="n">TcpStream</span><span class="p">,</span>
    <span class="n">tx</span><span class="p">:</span> <span class="n">Sender</span><span class="o">&lt;</span><span class="n">MsgType</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">socket_addr</span><span class="p">:</span> <span class="n">SocketAddr</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IOResult</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"Handle socket connection from client"</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">id</span> <span class="o">=</span> <span class="nn">friendly_random_id</span><span class="p">::</span><span class="nf">generate_friendly_random_id</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">tx</span><span class="nf">.subscribe</span><span class="p">();</span>

    <span class="c1">// Set up buf reader and writer.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="n">writer</span><span class="p">)</span> <span class="o">=</span> <span class="n">tcp_stream</span><span class="nf">.split</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">reader</span> <span class="o">=</span> <span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">reader</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">writer</span> <span class="o">=</span> <span class="nn">BufWriter</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">writer</span><span class="p">);</span>

    <span class="c1">// Send welcome message to client w/ ids.</span>
    <span class="k">let</span> <span class="n">welcome_msg_for_client</span> <span class="o">=</span>
        <span class="nn">ColorWheel</span><span class="p">::</span><span class="nf">lolcat_into_string</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span><span class="s">"addr: {}, id: {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">socket_addr</span><span class="p">,</span> <span class="n">id</span><span class="p">));</span>
    <span class="n">writer</span><span class="nf">.write</span><span class="p">(</span><span class="n">welcome_msg_for_client</span><span class="nf">.as_bytes</span><span class="p">())</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
    <span class="n">writer</span><span class="nf">.flush</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">incoming</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">tx</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span> <span class="p">{</span>
            <span class="c1">// Read from broadcast channel.</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">rx</span><span class="nf">.recv</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nf">read_from_broadcast_channel</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">socket_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">writer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// Read from socket.</span>
            <span class="n">network_read_result</span> <span class="o">=</span> <span class="n">reader</span><span class="nf">.read_line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">incoming</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">num_bytes_read</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="n">network_read_result</span><span class="o">?</span><span class="p">;</span>
                <span class="c1">// EOF check.</span>
                <span class="k">if</span> <span class="n">num_bytes_read</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="nf">handle_socket_read</span><span class="p">(</span><span class="n">num_bytes_read</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">incoming</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">writer</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="n">socket_addr</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
                <span class="n">incoming</span><span class="nf">.clear</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="two-concurrent-tasks-in-the-tokioselect-block">Two concurrent tasks in the tokio::select! block</h3>
<p><a id="markdown-two-concurrent-tasks-in-the-tokio%3A%3Aselect!-block" name="two-concurrent-tasks-in-the-tokio%3A%3Aselect!-block"></a></p>

<ol>
  <li>Read from broadcast channel. The function <code class="language-plaintext highlighter-rouge">read_from_broadcast_channel()</code> does this work.</li>
  <li>Read from socket. The function <code class="language-plaintext highlighter-rouge">handle_socket_read()</code> does this work.</li>
</ol>

<p>Whichever task completes first, the <code class="language-plaintext highlighter-rouge">tokio::select!</code> block will go down that code path,
and drop the other task.</p>

<h3 id="handle-read-from-broadcast-channel-function">Handle read from broadcast channel function</h3>
<p><a id="markdown-handle-read-from-broadcast-channel-function" name="handle-read-from-broadcast-channel-function"></a></p>

<p>Here‚Äôs the code for the <code class="language-plaintext highlighter-rouge">read_from_broadcast_channel()</code> function:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">fn</span> <span class="nf">read_from_broadcast_channel</span><span class="p">(</span>
    <span class="n">result</span><span class="p">:</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">MsgType</span><span class="p">,</span> <span class="n">RecvError</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">socket_addr</span><span class="p">:</span> <span class="n">SocketAddr</span><span class="p">,</span>
    <span class="n">writer</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">BufWriter</span><span class="o">&lt;</span><span class="n">WriteHalf</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">id</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IOResult</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">result</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">msg</span><span class="p">:</span> <span class="n">MsgType</span> <span class="o">=</span> <span class="n">it</span><span class="p">;</span>
            <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"[{}]: channel: {:?}"</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
            <span class="k">if</span> <span class="n">msg</span><span class="py">.socket_addr</span> <span class="o">!=</span> <span class="n">socket_addr</span> <span class="p">{</span>
                <span class="n">writer</span><span class="nf">.write</span><span class="p">(</span><span class="n">msg</span><span class="py">.payload</span><span class="nf">.as_bytes</span><span class="p">())</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
                <span class="n">writer</span><span class="nf">.flush</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nf">Err</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">log</span><span class="p">::</span><span class="nd">error!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="handle-socket-read-function">Handle socket read function</h3>
<p><a id="markdown-handle-socket-read-function" name="handle-socket-read-function"></a></p>

<p>Here‚Äôs the code for the <code class="language-plaintext highlighter-rouge">handle_socket_read()</code> function:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">fn</span> <span class="nf">handle_socket_read</span><span class="p">(</span>
    <span class="n">num_bytes_read</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">id</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
    <span class="n">incoming</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
    <span class="n">writer</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">BufWriter</span><span class="o">&lt;</span><span class="n">WriteHalf</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">tx</span><span class="p">:</span> <span class="n">Sender</span><span class="o">&lt;</span><span class="n">MsgType</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">socket_addr</span><span class="p">:</span> <span class="n">SocketAddr</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IOResult</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span>
        <span class="s">"[{}]: incoming: {}, size: {}"</span><span class="p">,</span>
        <span class="n">id</span><span class="p">,</span>
        <span class="n">incoming</span><span class="nf">.trim</span><span class="p">(),</span>
        <span class="n">num_bytes_read</span>
    <span class="p">);</span>

    <span class="c1">// Process incoming -&gt; outgoing.</span>
    <span class="k">let</span> <span class="n">outgoing</span> <span class="o">=</span> <span class="nf">process</span><span class="p">(</span><span class="o">&amp;</span><span class="n">incoming</span><span class="p">);</span>

    <span class="c1">// outgoing -&gt; Writer.</span>
    <span class="n">writer</span><span class="nf">.write</span><span class="p">(</span><span class="n">outgoing</span><span class="nf">.as_bytes</span><span class="p">())</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
    <span class="n">writer</span><span class="nf">.flush</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Broadcast outgoing to the channel.</span>
    <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="n">tx</span><span class="nf">.send</span><span class="p">(</span><span class="n">MsgType</span> <span class="p">{</span>
        <span class="n">socket_addr</span><span class="p">,</span>
        <span class="n">payload</span><span class="p">:</span> <span class="n">incoming</span><span class="nf">.to_string</span><span class="p">(),</span>
        <span class="n">from_id</span><span class="p">:</span> <span class="n">id</span><span class="nf">.to_string</span><span class="p">(),</span>
    <span class="p">});</span>

    <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span>
        <span class="s">"[{}]: outgoing: {}, size: {}"</span><span class="p">,</span>
        <span class="n">id</span><span class="p">,</span>
        <span class="n">outgoing</span><span class="nf">.trim</span><span class="p">(),</span>
        <span class="n">num_bytes_read</span>
    <span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">process</span><span class="p">(</span><span class="n">incoming</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="c1">// Remove new line from incoming.</span>
    <span class="k">let</span> <span class="n">incoming_trimmed</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">incoming</span><span class="nf">.trim</span><span class="p">());</span>
    <span class="c1">// Colorize it.</span>
    <span class="k">let</span> <span class="n">outgoing</span> <span class="o">=</span> <span class="nn">ColorWheel</span><span class="p">::</span><span class="nf">lolcat_into_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">incoming_trimmed</span><span class="p">);</span>
    <span class="c1">// Add new line back to outgoing.</span>
    <span class="nd">format!</span><span class="p">(</span><span class="s">"{}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">outgoing</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="next-steps">Next steps</h2>
<p><a id="markdown-next-steps" name="next-steps"></a></p>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><summary type="html"><![CDATA[A guide on how to create write a simple TCP chat server in Rust using Tokio]]></summary></entry><entry><title type="html">Write a simple netcat client and server in Rust</title><link href="http://developerlife.com/2024/01/13/write-simple-netcat-in-rust/" rel="alternate" type="text/html" title="Write a simple netcat client and server in Rust" /><published>2024-01-13T09:00:00-06:00</published><updated>2024-01-13T09:00:00-06:00</updated><id>http://developerlife.com/2024/01/13/write-simple-netcat-in-rust</id><content type="html" xml:base="http://developerlife.com/2024/01/13/write-simple-netcat-in-rust/"><![CDATA[<p><img class="post-hero-image" src="/assets/netcat-hero.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#build-a-swiss-army-knife-for-networking">Build a Swiss Army knife for networking</a></li>
  <li><a href="#add-dependencies-to-cargotoml">Add dependencies to Cargo.toml</a></li>
  <li><a href="#configure-clap-to-parse-command-line-arguments">Configure clap to parse command line arguments</a></li>
  <li><a href="#create-the-client">Create the client</a></li>
  <li><a href="#create-the-server">Create the server</a></li>
  <li><a href="#next-steps">Next steps</a></li>
</ul>

<!-- /TOC -->

<h2 id="build-a-swiss-army-knife-for-networking">Build a Swiss Army knife for networking</h2>
<p><a id="markdown-build-a-swiss-army-knife-for-networking" name="build-a-swiss-army-knife-for-networking"></a></p>

<p>In this tutorial we will learn how to use Rust to write a simple netcat client and server
using the standard library only. A netcat client is like a Swiss Army knife for
networking. It is similar to PuTTY and telnet. You can use it to connect to a server and
send and receive data. We will create an app that can behave both as a client and server.</p>

<ol>
  <li>Our client will allow the user to type a message and send it to any TCP socket server,
and display the response from the server, in an endless loop.</li>
  <li>Our server will listen for incoming TCP connections from clients, and display the
message from the client, and send a response back to the client.</li>
</ol>

<!--
simple-netcat-in-rust video
Source: https://github.com/nazmulidris/developerlife.com/issues/3
-->
<blockquote>
  <p>Here‚Äôs a video of the app that we are going to build in action.</p>
  <video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/ffe83b3e-6997-4afc-bdf3-5d867f995611" type="video/mp4" />
</video>
</blockquote>
<blockquote>

üëÄ Watch Rust ü¶Ä live coding videos on our <a href="https://www.youtube.com/@developerlifecom">YouTube Channel</a>.

<br />
<br />

<!-- video on rust polymorphism (no playlist) -->
<iframe src="https://www.youtube.com/embed/kYTgGtJjSro?si=XmW-_CAvCfB5e269" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<br />
<br />

üì¶ Install our useful Rust command line apps using <code>cargo install r3bl-cmdr</code>
(they are from the <a href="https://github.com/r3bl-org/r3bl-open-core">r3bl-open-core</a>
project):
<ul>
  <li>üê±<code>giti</code>: run interactive git commands with confidence in your terminal</li>
  <li>ü¶ú<code>edi</code>: edit Markdown with style in your terminal</li>
</ul>

<p>
<kbd>giti in action</kbd>
<video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/262f59d1-a95c-4af3-accf-c3d6cac6e586" type="video/mp4" />
</video>
</p>

<p>
<kbd>edi in action</kbd>
<video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/f2c4b07d-b5a2-4f41-af7a-06d1b6660c41" type="video/mp4" />
</video>
</p>

</blockquote>
<blockquote>
  <p>You can find the finished source code for this tutorial
<a href="https://github.com/nazmulidris/rust-scratch/tree/main/rtelnet">here</a>.</p>
</blockquote>

<h2 id="add-dependencies-to-cargotoml">Add dependencies to Cargo.toml</h2>
<p><a id="markdown-add-dependencies-to-cargo.toml" name="add-dependencies-to-cargo.toml"></a></p>

<p>Let‚Äôs create a new project by running <code class="language-plaintext highlighter-rouge">cargo create --bin rtelnet</code>. Then we will add the
following dependencies to our <code class="language-plaintext highlighter-rouge">Cargo.toml</code> file.</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Command line argument parsing.</span>
<span class="py">clap</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"4.4.13"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"derive"</span><span class="p">]</span> <span class="p">}</span>

<span class="c"># Pretty logging.</span>
<span class="py">femme</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"2.2.1"</span> <span class="p">}</span>
<span class="py">log</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.4.20"</span> <span class="p">}</span>

<span class="c"># Colorization and ANSI escape sequence codes.</span>
<span class="py">r3bl_tui</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.5.1"</span> <span class="p">}</span>
<span class="py">r3bl_ansi_color</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.6.9"</span> <span class="p">}</span>
</code></pre></div></div>

<h2 id="configure-clap-to-parse-command-line-arguments">Configure clap to parse command line arguments</h2>
<p><a id="markdown-configure-clap-to-parse-command-line-arguments" name="configure-clap-to-parse-command-line-arguments"></a></p>

<p>This Rust app has a single binary, and depending on the command line arguments, it will behave
either as a client or server. We will use the <code class="language-plaintext highlighter-rouge">clap</code> crate to parse the command line arguments.</p>

<p>We will configure <code class="language-plaintext highlighter-rouge">clap</code> so that the following commands will work:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo run server
cargo run client
</code></pre></div></div>

<p>We want to allow the user to specify the following options and chose their own address and
port. If the user does not specify any options, we will use the default values. The
default value for <code class="language-plaintext highlighter-rouge">--address</code> is <code class="language-plaintext highlighter-rouge">127.0.0.1</code>, and the default value for <code class="language-plaintext highlighter-rouge">--port</code> is
<code class="language-plaintext highlighter-rouge">3000</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo run server <span class="nt">--address</span> 127.0.0.1 <span class="nt">--port</span> 8080
cargo run server <span class="nt">--address</span> 127.0.0.1
cargo run server <span class="nt">--port</span> 8080

cargo run client <span class="nt">--address</span> 127.0.0.1 <span class="nt">--port</span> 8080
cargo run client <span class="nt">--address</span> 127.0.0.1
cargo run client <span class="nt">--port</span> 8080
</code></pre></div></div>

<p>Let‚Äôs also add an option that we can use to disable log output to stdout. By default, we
will log to stdout. But if the user specifies the <code class="language-plaintext highlighter-rouge">--log-disable</code> flag, then we disable
all log output.</p>

<p>Here‚Äôs the clap configuration that gives us this behavior.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">clap</span><span class="p">::{</span><span class="n">Parser</span><span class="p">,</span> <span class="n">Subcommand</span><span class="p">};</span>

<span class="k">pub</span> <span class="k">use</span> <span class="nn">defaults</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
<span class="k">mod</span> <span class="n">defaults</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">pub</span> <span class="k">const</span> <span class="n">DEFAULT_PORT</span><span class="p">:</span> <span class="nb">u16</span> <span class="o">=</span> <span class="mi">3000</span><span class="p">;</span>
    <span class="k">pub</span> <span class="k">const</span> <span class="n">DEFAULT_ADDRESS</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">"127.0.0.1"</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">use</span> <span class="nn">clap_config</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
<span class="k">mod</span> <span class="n">clap_config</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="nd">#[derive(Parser,</span> <span class="nd">Debug)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">CLIArg</span> <span class="p">{</span>
        <span class="cd">/// IP Address to connect to or start a server on</span>
        <span class="nd">#[clap(long,</span> <span class="nd">short,</span> <span class="nd">default_value</span> <span class="nd">=</span> <span class="nd">DEFAULT_ADDRESS,</span> <span class="nd">global</span> <span class="nd">=</span> <span class="kc">true</span><span class="nd">)]</span>
        <span class="k">pub</span> <span class="n">address</span><span class="p">:</span> <span class="n">IpAddr</span><span class="p">,</span>

        <span class="cd">/// TCP Port to connect to or start a server on</span>
        <span class="nd">#[clap(long,</span> <span class="nd">short,</span> <span class="nd">default_value_t</span> <span class="nd">=</span> <span class="nd">DEFAULT_PORT,</span> <span class="nd">global</span> <span class="nd">=</span> <span class="kc">true</span><span class="nd">)]</span>
        <span class="k">pub</span> <span class="n">port</span><span class="p">:</span> <span class="nb">u16</span><span class="p">,</span>

        <span class="cd">/// Logs to stdout by default, set this flag to disable it</span>
        <span class="nd">#[clap(long,</span> <span class="nd">short</span> <span class="nd">=</span> <span class="sc">'d'</span><span class="nd">,</span> <span class="nd">global</span> <span class="nd">=</span> <span class="kc">true</span><span class="nd">)]</span>
        <span class="k">pub</span> <span class="n">log_disable</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>

        <span class="cd">/// The subcommand to run</span>
        <span class="nd">#[clap(subcommand)]</span>
        <span class="k">pub</span> <span class="n">subcommand</span><span class="p">:</span> <span class="n">CLISubcommand</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="nd">#[derive(Subcommand,</span> <span class="nd">Debug)]</span>
    <span class="k">pub</span> <span class="k">enum</span> <span class="n">CLISubcommand</span> <span class="p">{</span>
        <span class="cd">/// Start a server on the given address and port</span>
        <span class="n">Server</span><span class="p">,</span>
        <span class="cd">/// Connect to a server running on the given address and port</span>
        <span class="n">Client</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="create-the-client">Create the client</h2>
<p><a id="markdown-create-the-client" name="create-the-client"></a></p>

<p>Let‚Äôs start with the simpler of the two, the client. We will use <code class="language-plaintext highlighter-rouge">std::net::TcpStream</code> to
create a TCP socket client. We will need an IP address and port in order to make a TCP
connection. And to run the client we will need to run the following command:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo run client
</code></pre></div></div>

<p>Here‚Äôs what the main function of our app looks like:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Welcome to rtelnet"</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">cli_arg</span> <span class="o">=</span> <span class="nn">CLIArg</span><span class="p">::</span><span class="nf">parse</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">address</span> <span class="o">=</span> <span class="n">cli_arg</span><span class="py">.address</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">port</span> <span class="o">=</span> <span class="n">cli_arg</span><span class="py">.port</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">socket_address</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{}:{}"</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>

    <span class="k">if</span> <span class="o">!</span><span class="n">cli_arg</span><span class="py">.log_disable</span> <span class="p">{</span>
        <span class="nn">femme</span><span class="p">::</span><span class="nf">start</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">match</span> <span class="k">match</span> <span class="n">cli_arg</span><span class="py">.subcommand</span> <span class="p">{</span>
        <span class="nn">CLISubcommand</span><span class="p">::</span><span class="n">Server</span> <span class="k">=&gt;</span> <span class="nf">start_server</span><span class="p">(</span><span class="n">socket_address</span><span class="p">),</span>
        <span class="nn">CLISubcommand</span><span class="p">::</span><span class="n">Client</span> <span class="k">=&gt;</span> <span class="nf">start_client</span><span class="p">(</span><span class="n">socket_address</span><span class="p">),</span>
    <span class="p">}</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Program exited successfully"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nf">Err</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Program exited with an error: {}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The function that performs the client logic looks like this.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">start_client</span><span class="p">(</span><span class="n">socket_address</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IOResult</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"Start client connection"</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">tcp_stream</span> <span class="o">=</span> <span class="nn">TcpStream</span><span class="p">::</span><span class="nf">connect</span><span class="p">(</span><span class="n">socket_address</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="p">(</span><span class="k">mut</span> <span class="n">reader</span><span class="p">,</span> <span class="k">mut</span> <span class="n">writer</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_stream</span><span class="p">),</span> <span class="nn">BufWriter</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_stream</span><span class="p">));</span>

    <span class="c1">// Client loop.</span>
    <span class="k">loop</span> <span class="p">{</span>
        <span class="c1">// Read user input.</span>
        <span class="k">let</span> <span class="n">outgoing</span> <span class="o">=</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">it</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="nf">stdin</span><span class="p">()</span><span class="nf">.read_line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">it</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="n">it</span><span class="nf">.as_bytes</span><span class="p">()</span><span class="nf">.to_vec</span><span class="p">()</span>
        <span class="p">};</span>

        <span class="c1">// Tx user input to writer.</span>
        <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="n">writer</span><span class="nf">.write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">outgoing</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="n">writer</span><span class="nf">.flush</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

        <span class="c1">// Rx response from reader.</span>
        <span class="k">let</span> <span class="n">incoming</span> <span class="o">=</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">it</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
            <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="n">reader</span><span class="nf">.read_until</span><span class="p">(</span><span class="sc">b'\n'</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">it</span><span class="p">);</span>
            <span class="n">it</span>
        <span class="p">};</span>

        <span class="k">let</span> <span class="n">display_msg</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_lossy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">incoming</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">display_msg</span> <span class="o">=</span> <span class="n">display_msg</span><span class="nf">.trim</span><span class="p">();</span>

        <span class="k">let</span> <span class="n">reset</span> <span class="o">=</span> <span class="nn">SgrCode</span><span class="p">::</span><span class="n">Reset</span><span class="nf">.to_string</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">display_msg</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{}{}"</span><span class="p">,</span> <span class="n">display_msg</span><span class="p">,</span> <span class="n">reset</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">display_msg</span><span class="p">);</span>

        <span class="c1">// Print debug.</span>
        <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span>
            <span class="s">"-&gt; Tx: '{}', size: {} bytes{}"</span><span class="p">,</span>
            <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_lossy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">outgoing</span><span class="p">)</span><span class="nf">.trim</span><span class="p">(),</span>
            <span class="n">outgoing</span><span class="nf">.len</span><span class="p">(),</span>
            <span class="n">reset</span><span class="p">,</span>
        <span class="p">);</span>
        <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span>
            <span class="s">"&lt;- Rx: '{}', size: {} bytes{}"</span><span class="p">,</span>
            <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_lossy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">incoming</span><span class="p">)</span><span class="nf">.trim</span><span class="p">(),</span>
            <span class="n">incoming</span><span class="nf">.len</span><span class="p">(),</span>
            <span class="n">reset</span><span class="p">,</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here are a few things to note about the client code:</p>
<ul>
  <li>We create a <code class="language-plaintext highlighter-rouge">BufReader</code> and <code class="language-plaintext highlighter-rouge">BufWriter</code> for the <code class="language-plaintext highlighter-rouge">TcpStream</code> that we get from
<code class="language-plaintext highlighter-rouge">TcpStream::connect()</code>. This is because we want to read and write data in chunks, and
not one byte at a time, for performance reasons, and to simplify the logic. These two
structs allow us to read and write data very easily in chunks that are delimited by new
lines (<code class="language-plaintext highlighter-rouge">\n</code>).</li>
  <li>There‚Äôs a client loop that runs forever. This is because we want to keep the client
running forever, so that the user can type a message and send it to the server, and
receive a response from the server.</li>
  <li>How do we exit this infinite client loop? Only when the user presses <code class="language-plaintext highlighter-rouge">Ctrl+C</code> will the
client exit. The <a href="https://g.co/bard/share/ac5d3480eb37">default behavior</a> for Rust is to
exit the process when this happens. This drops the TCP connection causing the server to exit as
well.</li>
  <li>When we read data from user input, it too uses a stream, not a <code class="language-plaintext highlighter-rouge">TcpStream</code>, but the
<code class="language-plaintext highlighter-rouge">stdin()</code> stream. This behaves very similarly to the <code class="language-plaintext highlighter-rouge">TcpStream</code> stream. We can read
data from it in chunks delimited by new lines (<code class="language-plaintext highlighter-rouge">\n</code>). Once the user types a message and
presses enter that message, eg: <code class="language-plaintext highlighter-rouge">"hi"</code>, and the new line are stored in the <code class="language-plaintext highlighter-rouge">it</code>
variable, eg: <code class="language-plaintext highlighter-rouge">"hi\n"</code>. We then convert the String into a byte array, eg: <code class="language-plaintext highlighter-rouge">[104, 105,
10]</code>, and then convert it into a <code class="language-plaintext highlighter-rouge">Vec&lt;u8&gt;</code>. We then send it to the server. We must call
<code class="language-plaintext highlighter-rouge">flush()</code> since <code class="language-plaintext highlighter-rouge">BufWriter</code> buffers the data and does not send it to the server until we
call <code class="language-plaintext highlighter-rouge">flush()</code> for IO performance reasons. It queue‚Äôs up the data and sends it in
chunks, instead of sending it one byte at a time.</li>
  <li>Reading there response from the server is similar to reading it from <code class="language-plaintext highlighter-rouge">stdin()</code> as we
have already seen. The main thread blocks until there is some data that can be read from
the server. Or if the TCP connection errors out in any way (timeout or closed by various
means). If there is an error, then this function returns an error, and the main thread
exits. Note that the <code class="language-plaintext highlighter-rouge">start_client()</code> function itself returns an <code class="language-plaintext highlighter-rouge">IOResult</code>, which is
just a type alias for <code class="language-plaintext highlighter-rouge">pub type IOResult&lt;T&gt; = std::io::Result&lt;T&gt;;</code>. The error handling
is quite simple. If there is an error, we print it out and exit the program.</li>
  <li>We read the data from the server into the <code class="language-plaintext highlighter-rouge">incoming</code> variable using
<code class="language-plaintext highlighter-rouge">reader.read_until(b'\n', &amp;mut it);)</code>. This is because we expect the server to send us
data that is terminated by a new line (<code class="language-plaintext highlighter-rouge">\n</code>). So we read the data until we encounter a
new line. This is a blocking call, so the main thread blocks until there is some data
that can be read from the server. Note that the <code class="language-plaintext highlighter-rouge">\n</code> is included in <code class="language-plaintext highlighter-rouge">incoming</code> variable,
much like it is in <code class="language-plaintext highlighter-rouge">stdin()</code>.
    <ul>
      <li>We use this function <code class="language-plaintext highlighter-rouge">String::from_utf8_lossy(&amp;incoming);</code> to convert this <code class="language-plaintext highlighter-rouge">incoming:
Vec&lt;u8&gt;</code> into a <code class="language-plaintext highlighter-rouge">String</code>. We call <code class="language-plaintext highlighter-rouge">.trim()</code> on the String, so that the trailing <code class="language-plaintext highlighter-rouge">\n</code>
is removed.</li>
      <li>Note that <code class="language-plaintext highlighter-rouge">trim()</code> returns a <code class="language-plaintext highlighter-rouge">&amp;str</code>, so if you want to turn it into a String, you have
to run in through this expression <code class="language-plaintext highlighter-rouge">format!("{}",
String::from_utf8_lossy(&amp;incoming).trim())</code> function.</li>
    </ul>
  </li>
  <li>This is a pedagogical example and this algorithm is somewhat contrived to demonstrate
how to send bytes back and forth between client and server and have them interpret the
bytes in a certain way. A more formalized version of this ‚Äúdance‚Äù is called a
‚Äúprotocol‚Äù, eg: HTTP, SMTP, etc.</li>
  <li>In the final step of the <code class="language-plaintext highlighter-rouge">loop</code>, after the incoming data has been read from the server,
we print it out to the terminal. Since the server will send us ANSI escape sequence
codes that colorize the text that we print to the terminal, we want to reset the color
after we print the text, so it does not pollute our <code class="language-plaintext highlighter-rouge">stdout()</code> output stream. We use the
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/ansi_color/src/ansi_escape_codes.rs#L23"><code class="language-plaintext highlighter-rouge">SgrCode::Reset</code> code to reset the
color</a>
of the text that we print to the terminal.</li>
</ul>

<h2 id="create-the-server">Create the server</h2>
<p><a id="markdown-create-the-server" name="create-the-server"></a></p>

<p>Now let‚Äôs create the server. We will use <code class="language-plaintext highlighter-rouge">std::net::TcpListener</code> to create a TCP socket
server. We will need an IP address and port in order to make a TCP connection. To run the
server we will need to run the following command:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo run server
</code></pre></div></div>

<p>The server code is very similar to the client code. We need a server loop that runs
forever, and we need to first read (blocking until there is any data available) and then
write data in chunks delimited by new lines (<code class="language-plaintext highlighter-rouge">\n</code>). When there is no data available to
read <code class="language-plaintext highlighter-rouge">EOF</code> is reached on the reader (aka, input TCP stream) then we break out of this loop
and exit. When data comes in (delimited by <code class="language-plaintext highlighter-rouge">\n</code>) we process it and send a response back to
the client. We process this data by applying a <a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/color_wheel/color_wheel_struct.rs#L457">lolcat
effect</a>
on it, so the client will get a very colorful version of whatever text message that they
sent to the server.</p>

<p>One more thing we will see when implementing the server is having to spawn multiple
threads to handle each incoming client connection. While the client is a single threaded
app, the server is a multi-threaded app. The client is only concerned w/ a single TCP
connection, but the server is concerned with multiple TCP connections, each connection
emanating from a different client process running the <code class="language-plaintext highlighter-rouge">cargo run client</code> and creating a
new OS process. Fortunately Rust is built for fearless concurrency and parallelism from
the ground up.</p>

<p>Here‚Äôs the main function of our server app:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">start_server</span><span class="p">(</span><span class="n">socket_address</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IOResult</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">tcp_listener</span> <span class="o">=</span> <span class="nn">TcpListener</span><span class="p">::</span><span class="nf">bind</span><span class="p">(</span><span class="n">socket_address</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="c1">// Server connection accept loop.</span>
    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"Waiting for a incoming connection..."</span><span class="p">);</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">tcp_stream</span><span class="p">,</span> <span class="o">..</span><span class="p">)</span> <span class="o">=</span> <span class="n">tcp_listener</span><span class="nf">.accept</span><span class="p">()</span><span class="o">?</span><span class="p">;</span> <span class="c1">// This is a blocking call.</span>

        <span class="c1">// Spawn a new thread to handle this connection.</span>
        <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(||</span> <span class="k">match</span> <span class="nf">handle_connection</span><span class="p">(</span><span class="n">tcp_stream</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"Successfully closed connection to client..."</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">log</span><span class="p">::</span><span class="nd">error!</span><span class="p">(</span><span class="s">"Problem with client connection..."</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here are a few things to note about the server code:</p>
<ul>
  <li>We are using <code class="language-plaintext highlighter-rouge">IOResult</code> just like the client code. There are frequent calls to the <code class="language-plaintext highlighter-rouge">?</code>
operator, which is shorthand for matching on the <code class="language-plaintext highlighter-rouge">Result</code> and returning early if there‚Äôs
an error. This is rudimentary error handling, and its good enough for this pedagogical
example. Note that even in this pedagogical example, we don‚Äôt use the <code class="language-plaintext highlighter-rouge">unwrap()</code> method
which will induce a panic if there‚Äôs an error. We always use the <code class="language-plaintext highlighter-rouge">?</code> operator, which
will return early if there‚Äôs an error. It isn‚Äôt a good idea to get into the habit of
using <code class="language-plaintext highlighter-rouge">unwrap()</code> outside of tests. These habits are hard to break once they‚Äôre formed.
You can even add the following
<a href="https://rust-lang.github.io/rust-clippy/master/index.html#/unwrap_used"><code class="language-plaintext highlighter-rouge">#![warn(clippy::unwrap_in_result)]</code></a>
in the top level module of your project to have the compiler warn you if you use
<code class="language-plaintext highlighter-rouge">unwrap()</code> outside of tests. Here‚Äôs an
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/ansi_color/src/lib.rs#L171">example</a>.</li>
  <li>The first thing the server has to do is reserve a port on the given address. This is called
binding, and we do it using <code class="language-plaintext highlighter-rouge">TcpListener::bind(socket_address)?;</code>. This does not start a server
yet. It just reserves a port on the given address, assuming that it is available. If some other
process has already bound to that port, then this will return an error.</li>
  <li>Once we have a <code class="language-plaintext highlighter-rouge">TcpListener</code> instance, we can call <code class="language-plaintext highlighter-rouge">accept()</code> on it to start listening
for incoming connections. This is a blocking call, so the main thread blocks until there
is an incoming connection. Once there is an incoming connection, we get a <code class="language-plaintext highlighter-rouge">TcpStream</code>
instance, which we can use to read and write data to the client. This is a blocking
call. Which means that the main thread won‚Äôt be able to do anything else, like process
other incoming connections, while it is waiting here, for a connection to come in.</li>
  <li>This is why we use <code class="language-plaintext highlighter-rouge">thread::spawn()</code> to create a new thread and have it handle the
incoming connection. We spawn a new thread for each incoming connection. This is <a href="https://g.co/bard/share/74f433bad400">not a
scalable solution</a>, but it is good enough for this
pedagogical example. We will learn about more scalable solutions in a the <a href="/2024/01/13/write-simple-chat-server-in-rust/">Write a
simple TCP chat server in Rust</a> tutorial.</li>
</ul>

<p>Now, let‚Äôs look at the <code class="language-plaintext highlighter-rouge">handle_connection()</code> function that is called by the spawned
thread. This is the function that handles the incoming connection from the client. And it
defines our ‚Äúprotocol‚Äù, along with the client code. We aren‚Äôt using any formalized
protocol like HTTP or SMTP. We are just sending bytes back and forth between the client
and server, and interpreting them in a certain way, which is our informal protocol. This
code is very similar to the client side code, including the <code class="language-plaintext highlighter-rouge">loop</code> and the <code class="language-plaintext highlighter-rouge">BufReader</code> and
<code class="language-plaintext highlighter-rouge">BufWriter</code> structs. And even looking for <code class="language-plaintext highlighter-rouge">EOF</code> to break out of the loop. Except that we
don‚Äôt block on <code class="language-plaintext highlighter-rouge">stdin()</code> for input here.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">handle_connection</span><span class="p">(</span><span class="n">tcp_stream</span><span class="p">:</span> <span class="n">TcpStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IOResult</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"Start handle connection"</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">reader</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_stream</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">write</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">BufWriter</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_stream</span><span class="p">);</span>

    <span class="c1">// Process client connection loop.</span>
    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">incoming</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="c1">// Read from reader.</span>
        <span class="k">let</span> <span class="n">num_bytes_read</span> <span class="o">=</span> <span class="n">reader</span><span class="nf">.read_until</span><span class="p">(</span><span class="sc">b'\n'</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">incoming</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="c1">// Check for EOF. The stream is closed.</span>
        <span class="k">if</span> <span class="n">num_bytes_read</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Process.</span>
        <span class="k">let</span> <span class="n">outgoing</span> <span class="o">=</span> <span class="nf">process</span><span class="p">(</span><span class="o">&amp;</span><span class="n">incoming</span><span class="p">);</span>

        <span class="c1">// Write to writer.</span>
        <span class="n">write</span><span class="nf">.write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">outgoing</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="n">write</span><span class="nf">.flush</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

        <span class="c1">// Print debug.</span>
        <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"-&gt; Rx(bytes) : {:?}"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">incoming</span><span class="p">);</span>
        <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span>
            <span class="s">"-&gt; Rx(string): '{}', size: {} bytes"</span><span class="p">,</span>
            <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_lossy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">incoming</span><span class="p">)</span><span class="nf">.trim</span><span class="p">(),</span>
            <span class="n">incoming</span><span class="nf">.len</span><span class="p">(),</span>
        <span class="p">);</span>
        <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span>
            <span class="s">"&lt;- Tx(string): '{}', size: {} bytes"</span><span class="p">,</span>
            <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_lossy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">outgoing</span><span class="p">)</span><span class="nf">.trim</span><span class="p">(),</span>
            <span class="n">outgoing</span><span class="nf">.len</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"End handle connection - connection closed"</span><span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Finally, let‚Äôs look at the <code class="language-plaintext highlighter-rouge">process()</code> function that takes the incoming bytes to the
outgoing bytes. This is where we add some fun and color and flair to our app. We colorize
the incoming bytes using a lolcat effect and send it back to the client.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">r3bl_tui</span><span class="p">::</span><span class="n">ColorWheel</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">process</span><span class="p">(</span><span class="n">incoming</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Convert incoming to String, and remove any trailing whitespace (includes newline).</span>
    <span class="k">let</span> <span class="n">incoming</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_lossy</span><span class="p">(</span><span class="n">incoming</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">incoming</span> <span class="o">=</span> <span class="n">incoming</span><span class="nf">.trim</span><span class="p">();</span>

    <span class="c1">// Prepare outgoing payload.</span>
    <span class="k">let</span> <span class="n">outgoing</span> <span class="o">=</span> <span class="n">incoming</span><span class="nf">.to_string</span><span class="p">();</span>

    <span class="c1">// Colorize it w/ a gradient.</span>
    <span class="k">let</span> <span class="n">outgoing</span> <span class="o">=</span> <span class="nn">ColorWheel</span><span class="p">::</span><span class="nf">lolcat_into_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">outgoing</span><span class="p">);</span>

    <span class="c1">// Generate outgoing response. Add newline to the end of output (so client can process it).</span>
    <span class="k">let</span> <span class="n">outgoing</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">outgoing</span><span class="p">);</span>

    <span class="c1">// Return outgoing payload.</span>
    <span class="n">outgoing</span><span class="nf">.as_bytes</span><span class="p">()</span><span class="nf">.to_vec</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="next-steps">Next steps</h2>
<p><a id="markdown-next-steps" name="next-steps"></a></p>

<p>Now that you have a handle on the basics of writing a simple netcat client and server, you
can read <a href="/2024/01/13/write-simple-chat-server-in-rust/">this tutorial</a> to learn more about creating a more advanced TCP server that netcat,
telnet, or PuTTY clients can connect to, in order to have multiple client apps chat with
each other.</p>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><summary type="html"><![CDATA[A guide on how to a simple Rust netcat client and server]]></summary></entry></feed>