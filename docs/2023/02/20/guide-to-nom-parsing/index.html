<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" /><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Build with Naz : Comprehensive guide to nom parsing | developerlife.com</title>
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="Build with Naz : Comprehensive guide to nom parsing" />
<meta name="author" content="Nazmul Idris" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This tutorial is a comprehensive guide to parsing with nom. It covers the basics of parsing and how to use nom to parse a string into a data structure. It also covers more complex topics like human readable error reporting, and building up complex parsers. We will cover a variety of different examples ranging from parsing simple CSS like syntax to a full blown Markdown parser." />
<meta property="og:description" content="This tutorial is a comprehensive guide to parsing with nom. It covers the basics of parsing and how to use nom to parse a string into a data structure. It also covers more complex topics like human readable error reporting, and building up complex parsers. We will cover a variety of different examples ranging from parsing simple CSS like syntax to a full blown Markdown parser." />
<link rel="canonical" href="http://developerlife.com/2023/02/20/guide-to-nom-parsing/" />
<meta property="og:url" content="http://developerlife.com/2023/02/20/guide-to-nom-parsing/" />
<meta property="og:site_name" content="developerlife.com" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-02-20T09:00:00-06:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Build with Naz : Comprehensive guide to nom parsing" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Nazmul Idris"},"dateModified":"2023-02-20T09:00:00-06:00","datePublished":"2023-02-20T09:00:00-06:00","description":"This tutorial is a comprehensive guide to parsing with nom. It covers the basics of parsing and how to use nom to parse a string into a data structure. It also covers more complex topics like human readable error reporting, and building up complex parsers. We will cover a variety of different examples ranging from parsing simple CSS like syntax to a full blown Markdown parser.","headline":"Build with Naz : Comprehensive guide to nom parsing","mainEntityOfPage":{"@type":"WebPage","@id":"http://developerlife.com/2023/02/20/guide-to-nom-parsing/"},"url":"http://developerlife.com/2023/02/20/guide-to-nom-parsing/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css" />

  <!-- Add favicon -->
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />

  <!-- Add font awesome -->
  <link
    rel="stylesheet"
    href="https://use.fontawesome.com/releases/v5.2.0/css/all.css"
    integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ"
    crossorigin="anonymous"
  />

  <!-- Add Google fonts-->
  <link
    href="https://fonts.googleapis.com/css?family=Spline+Sans|Work+Sans|Fira+Mono|Fira+Sans|Google+Sans|Lexend+Deca&display=swap"
    rel="stylesheet"
  /><link type="application/atom+xml" rel="alternate" href="http://developerlife.com/feed.xml" title="developerlife.com" /><!-- https://developers.google.com/analytics/devguides/collection/gtagjs -->
<script async
        src="https://www.googletagmanager.com/gtag/js?id=G-NQY9ECC58H"></script>
<script>
  window.dataLayer = window.dataLayer || []

  function gtag() {
    window.dataLayer.push(arguments)
  }

  gtag("js", new Date())
  gtag("config", "G-NQY9ECC58H")
</script>
<!-- https://us14.admin.mailchimp.com/account/connected-sites/site-detail/ -->

<script id="mcjs">
  !(function (c, h, i, m, p) {
    ;(m = c.createElement(h)),
      (p = c.getElementsByTagName(h)[0]),
      (m.async = 1),
      (m.src = i),
      p.parentNode.insertBefore(m, p)
  })(
    document,
    "script",
    "https://chimpstatic.com/mcjs-connected/js/users/c2470ddfa863eb8ace707651b/2bb3bcad193ef862398700457.js"
  )
</script>
</head>
<body><!-- https://github.com/mermaid-js/mermaid/blob/develop/docs/n00b-gettingStarted.md -->
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>

<script>
  // https://mermaid-js.github.io/mermaid/#/theming
  mermaid.initialize({
    startOnLoad: true,
    theme: "dark",
    themeVariables: {
      fontFamily: "Fira Code",
      fontSize: "0.95rem",
      darkMode: true,
      primaryColor: "#2f9ece",
      mainBkg: "#303439",
    },
  })
</script>
<header class="site-header" role="banner">

    <div class="wrapper header-wrapper"><div class="logo-container">
        <div class="logo-image">
          <a class="site-title"
             rel="author"
             href="/">
              <!-- This is the logo image placeholder. -->
                <picture>
                  <source srcset="/assets/dl-logo-icon-dark.svg" media="(max-width: 600px)"/>
                  <img  src="/assets/dl-logo-icon-and-text-dark.svg" />
                </picture>
          </a>
        </div>
      </div><nav class="site-nav">
            <input type="checkbox" id="nav-trigger" class="nav-trigger"/>
            <label for="nav-trigger">
          <span class="menu-icon">
              <svg class="svg-icon">
              <use xlink:href="/assets/minima-social-icons.svg#menu">
              </use>
            </svg>
          </span>
            </label>

            <div class="trigger"><!--
    Iterate over all the pages in the site, where page_cursor holds the current
    page for each pass of the for loop.
    Note that page is the currently loaded page itself.
--><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Android/"> Android </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/CC/"> Concurrency </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/CLI/"> CLI </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/CS/"> CS </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/DB/"> Database </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/DI/"> DI </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/FE/"> Frontend </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Hardware/"> Hardware </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/IJ/"> IntelliJ </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/KT/"> Kotlin </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Linux/"> Linux </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/MP/"> MP </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Misc/"> Misc </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Node/"> Node </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Productivity/"> Productivity </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/RN/"> React-Native </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/React/"> React </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Rust/"> Rust </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Server/"> Server </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/State/"> State-Management </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Stories/"> Stories </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/TDD/"> Testing </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/TS/"> TypeScript </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/TUI/"> TUI </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Web/"> Web </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/about-me/"> Nazmul Idris </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/about-site/"> About Us </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/authors/"> Authors </a></div>
        </nav></div>
</header>

<!-- Debug to show the value of page.title and page.category variables -->
<!--<pre>page_cursor.exclude = nil</pre>-->
<!--<pre>page.exclude = nil</pre>-->
<!--<pre>page.title = &quot;Build with Naz : Comprehensive guide to nom parsing&quot;</pre>-->
<!--<pre>page.category = nil</pre>-->
<!--<pre>page.title (json) = Build with Naz : Comprehensive guide to nom parsing</pre>-->
<!--<pre>page.category (json) = </pre>-->
<div class="page-and-sidebar-wrapper">
      <main class="page-content" aria-label="Content">
        <div class="wrapper"><article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting"><header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Build with Naz : Comprehensive guide to nom parsing</h1>

    <!-- Create all the variables needed for this page (and all the includes) -->
    

    <div class="post-meta">
        <p>
            <!-- Date -->Feb 20, 2023

            <!--Author-->
            ‚àô <a href="/about-me">Nazmul Idris</a>

            <!-- One line social blurb --><ul class="contact-list">
    <li class="p-name">Hi, I'm
            <a href="/about-me">Nazmul</a>,
            an ex-Googler, <a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/tui" target="_blank">r3bl_tui maintainer</a>, SWE, entrepreneur, designer, leader,
            TaiChi-er, racer, storyteller.
            <!-- This is font awesome icon -->
            I <i class="fas fa-heart"></i>
            leadership, authenticity, empowerment, lifelong learning,
            <i class="fas fa-code"></i>,
            <i class="fas fa-terminal"></i>, &
            <i class="fas fa-coffee"></i>,
            üòÉ.</li>
</ul>
</p>
    </div><div class="social-media-container">
  <!-- <iframe
    src="https://github.com/sponsors/nazmulidris/button"
    title="Sponsor nazmulidris"
    height="35"
    width="116"
    style="border: 0; padding-right: 6px"
  ></iframe> -->

  <a href="/subscribe.html" target="_blank"
    ><kbd>Subscribe for updates</kbd></a
  ><p class="social-media-item">
    <a
      href="https://www.linkedin.com/in/nazmulidris"
      target="_blank"
    >
      <svg class="svg-icon">
        <use xlink:href="/assets/minima-social-icons.svg#linkedin"></use>
      </svg>
    </a>
  </p><p class="social-media-item">
    <a href="https://www.youtube.com/channel/UCMcsxfCwzwDevc3NRqFgfEg" target="_blank">
      <svg class="svg-icon">
        <use xlink:href="/assets/minima-social-icons.svg#youtube"></use>
      </svg>
    </a>
  </p><p class="social-media-item">
    <a href="https://www.github.com/nazmulidris" target="_blank">
      <svg class="svg-icon">
        <use xlink:href="/assets/minima-social-icons.svg#github"></use>
      </svg>
    </a>
  </p><p class="social-media-item">
    <a href="/feed.xml" target="_blank">
      <svg class="svg-icon">
        <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
      </svg>
    </a>
  </p></div>
</header>
<div class="post-content e-content" itemprop="articleBody">
        <blockquote>
  üëÄ Watch Rust ü¶Ä live coding videos on our
  <a href="https://www.youtube.com/@developerlifecom">YouTube Channel</a>.

  <br />

  <!-- effective async rust video & async rust playlist -->
  <iframe src="https://www.youtube.com/embed/qvIt8MF-pCM?si=hDVrz64pLbTLYe_m"
    title="YouTube video player"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    referrerpolicy="strict-origin-when-cross-origin" allowfullscreen>
  </iframe>

  <!-- video on rust polymorphism (no playlist) -->
  <!-- <iframe
      src="https://www.youtube.com/embed/kYTgGtJjSro?si=XmW-_CAvCfB5e269"
      title="YouTube video player" frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
      referrerpolicy="strict-origin-when-cross-origin"
      allowfullscreen
      >
  </iframe> -->

  <!-- video on intro to testing (with playlist) -->
  <!-- <iframe
    src="https://www.youtube.com/embed/videoseries?si=7gmhXY5DVYJG7OdU&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8"
    title="YouTube video player"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    referrerpolicy="strict-origin-when-cross-origin"
    allowfullscreen
  >
  </iframe> -->

</blockquote>
        <!-- If a page has a hero-image defined in it, then show it here -->


        <p><img class="post-hero-image" src="/assets/rust-nom-comprehensive.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#getting-to-know-nom-using-lots-of-examples">Getting to know nom using lots of examples</a></li>
  <li><a href="#related-video">Related video</a></li>
  <li><a href="#hex-color-code-parser">Hex color code parser</a>
    <ul>
      <li><a href="#what-does-this-code-do-how-does-it-work">What does this code do, how does it work?</a>
        <ul>
          <li><a href="#the-parser-trait-and-iresult">The Parser trait and IResult</a></li>
          <li><a href="#main-parser-function-that-calls-all-the-other-parsers">Main parser function that calls all the other parsers</a></li>
          <li><a href="#the-hex-segment-parser-comprised-of-nom-combinator-functions-and-iresult">The hex segment parser, comprised of nom combinator functions, and IResult</a></li>
        </ul>
      </li>
      <li><a href="#generalized-workflow">Generalized workflow</a></li>
      <li><a href="#why-cant-we-parse-2f14df">Why can‚Äôt we parse ‚ÄúüîÖ#2F14DF‚Äù?</a></li>
      <li><a href="#better-error-reporting-when-things-go-wrong">Better error reporting when things go wrong</a></li>
    </ul>
  </li>
  <li><a href="#other-examples">Other examples</a>
    <ul>
      <li><a href="#simple-css-syntax-parser">Simple CSS syntax parser</a></li>
      <li><a href="#simple-natural-language-parser">Simple natural language parser</a></li>
    </ul>
  </li>
  <li><a href="#markdown-parser">Markdown parser</a></li>
  <li><a href="#references">References</a></li>
</ul>

<!-- /TOC -->
      <h2 id="introduction">
        
        
          Introduction <a href="#introduction">#</a>
        
        
      </h2>
    
<p><a id="markdown-introduction" name="introduction"></a></p>

<p>This tutorial is a comprehensive guide to parsing with nom. It covers the basics of parsing and
how to use nom to parse a string into a data structure. It also covers more complex topics like
human readable error reporting, and building up complex parsers. We will cover a variety of different
examples ranging from parsing simple CSS like syntax to a full blown Markdown parser.</p>
<blockquote>

üëÄ Watch Rust ü¶Ä live coding videos on our <a href="https://www.youtube.com/@developerlifecom">YouTube Channel</a>.

<br />
<br />

<!-- video on rust polymorphism (no playlist) -->
<iframe src="https://www.youtube.com/embed/kYTgGtJjSro?si=XmW-_CAvCfB5e269" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<br />
<br />

üì¶ Install our useful Rust command line apps using <code>cargo install r3bl-cmdr</code>
(they are from the <a href="https://github.com/r3bl-org/r3bl-open-core">r3bl-open-core</a>
project):
<ul>
  <li>üê±<code>giti</code>: run interactive git commands with confidence in your terminal</li>
  <li>ü¶ú<code>edi</code>: edit Markdown with style in your terminal</li>
</ul>

<p>
<kbd>giti in action</kbd>
<video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/262f59d1-a95c-4af3-accf-c3d6cac6e586" type="video/mp4" />
</video>
</p>

<p>
<kbd>edi in action</kbd>
<video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/f2c4b07d-b5a2-4f41-af7a-06d1b6660c41" type="video/mp4" />
</video>
</p>

</blockquote>
<blockquote>
  <p>For more information on general Rust type system design (functional approach rather than
object oriented), please take a look at this <a href="https://arxiv.org/pdf/2307.07069.pdf">paper</a>
by Will Crichton demonstrating Typed Design Patterns with Rust.</p>
</blockquote>
      <h2 id="getting-to-know-nom-using-lots-of-examples">
        
        
          Getting to know nom using lots of examples <a href="#getting-to-know-nom-using-lots-of-examples">#</a>
        
        
      </h2>
    
<p><a id="markdown-getting-to-know-nom-using-lots-of-examples" name="getting-to-know-nom-using-lots-of-examples"></a></p>

<p><a href="https://crates.io/crates/nom"><code class="language-plaintext highlighter-rouge">nom</code></a> is a parser combinator library for Rust. You can write small
functions that parse a specific part of your input, and then combine them to build a parser that
parses the whole input. <code class="language-plaintext highlighter-rouge">nom</code> is very efficient and fast, it does not allocate memory when parsing if
it doesn‚Äôt have to, and it makes it very easy for you to do the same. <code class="language-plaintext highlighter-rouge">nom</code> uses streaming mode or
complete mode, and in this tutorial &amp; code examples provided we will be using complete mode.</p>

<p>Roughly the way it works is that you tell <code class="language-plaintext highlighter-rouge">nom</code> how to parse a bunch of bytes in a way that matches
some pattern that is valid for your data. It will try to parse as much as it can from the input, and
the rest of the input will be returned to you.</p>

<p>You express the pattern that you‚Äôre looking for by combining parsers. <code class="language-plaintext highlighter-rouge">nom</code> has a whole bunch of these
that come out of the box. And a huge part of learning <code class="language-plaintext highlighter-rouge">nom</code> is figuring out what these built in
parsers are and how to combine them to build a parser that does what you want.</p>

<p>Errors are a key part of it being able to apply a variety of different parsers to the same input. If
a parser fails, <code class="language-plaintext highlighter-rouge">nom</code> will return an error, and the rest of the input will be returned to you. This
allows you to combine parsers in a way that you can try to parse a bunch of different things, and if
one of them fails, you can try the next one. This is very useful when you are trying to parse a
bunch of different things, and you don‚Äôt know which one you are going to get.</p>
      <h2 id="related-video">
        
        
          Related video <a href="#related-video">#</a>
        
        
      </h2>
    
<p><a id="markdown-related-video" name="related-video"></a></p>

<p>If you like to consume content via video, then you can watch this video that covers the same content
as this article, but in a live coding format.</p>

<!-- video on nom -->
<iframe src="https://www.youtube.com/embed/v3tMwr_ysPg?si=rDXomVWgE1GBlGm-" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<blockquote>
  <p>You can get the source code for the examples in this
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/nom">repo</a>.</p>
</blockquote>
      <h2 id="hex-color-code-parser">
        
        
          Hex color code parser <a href="#hex-color-code-parser">#</a>
        
        
      </h2>
    
<p><a id="markdown-hex-color-code-parser" name="hex-color-code-parser"></a></p>

<p>Let‚Äôs dive into <code class="language-plaintext highlighter-rouge">nom</code> using a simple example of parsing
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color">hex color codes</a>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">//! This module contains a parser that parses a hex color</span>
<span class="cd">//! string into a [Color] struct.</span>
<span class="cd">//! The hex color string can be in the following format `#RRGGBB`.</span>
<span class="cd">//! For example, `#FF0000` is red.</span>

<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">num</span><span class="p">::</span><span class="n">ParseIntError</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">nom</span><span class="p">::{</span>
    <span class="nn">bytes</span><span class="p">::</span><span class="nn">complete</span><span class="p">::</span><span class="o">*</span><span class="p">,</span> <span class="nn">combinator</span><span class="p">::</span><span class="o">*</span><span class="p">,</span> <span class="nn">error</span><span class="p">::</span><span class="o">*</span><span class="p">,</span> <span class="nn">sequence</span><span class="p">::</span><span class="o">*</span><span class="p">,</span> <span class="n">IResult</span><span class="p">,</span> <span class="n">Parser</span>
<span class="p">};</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Color</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">red</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">green</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">blue</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Color</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">red</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">green</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">blue</span><span class="p">:</span> <span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cd">/// Helper functions to match and parse hex digits. These are not</span>
<span class="cd">/// [Parser] implementations.</span>
<span class="k">mod</span> <span class="n">helper_fns</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="cd">/// This function is used by [map_res] and it returns a [Result]</span>
    <span class="cd">/// not [IResult].</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">parse_str_to_hex_num</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span>
        <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="nn">std</span><span class="p">::</span><span class="nn">num</span><span class="p">::</span><span class="n">ParseIntError</span><span class="o">&gt;</span>
    <span class="p">{</span>
        <span class="nn">u8</span><span class="p">::</span><span class="nf">from_str_radix</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="cd">/// This function is used by [take_while_m_n] and as long as it</span>
    <span class="cd">/// returns `true` items will be taken from the input.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">match_is_hex_digit</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="nb">char</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="n">c</span><span class="nf">.is_ascii_hexdigit</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">parse_hex_seg</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IResult</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="nb">u8</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">map_res</span><span class="p">(</span>
            <span class="nf">take_while_m_n</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">match_is_hex_digit</span><span class="p">),</span>
            <span class="n">parse_str_to_hex_num</span><span class="p">,</span>
        <span class="p">)(</span><span class="n">input</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cd">/// These are [Parser] implementations that are used by</span>
<span class="cd">/// [hex_color_no_alpha].</span>
<span class="k">mod</span> <span class="n">intermediate_parsers</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="cd">/// Call this to return function that implements the [Parser] trait.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">gen_hex_seg_parser_fn</span><span class="o">&lt;</span><span class="nv">'input</span><span class="p">,</span> <span class="n">E</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">-&gt;</span>
        <span class="k">impl</span> <span class="n">Parser</span><span class="o">&lt;&amp;</span><span class="nv">'input</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">E</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">E</span><span class="p">:</span> <span class="n">FromExternalError</span><span class="o">&lt;&amp;</span><span class="nv">'input</span> <span class="nb">str</span><span class="p">,</span> <span class="n">ParseIntError</span><span class="o">&gt;</span> <span class="o">+</span>
           <span class="n">ParseError</span><span class="o">&lt;&amp;</span><span class="nv">'input</span> <span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nf">map_res</span><span class="p">(</span>
            <span class="nf">take_while_m_n</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nn">helper_fns</span><span class="p">::</span><span class="n">match_is_hex_digit</span><span class="p">),</span>
            <span class="nn">helper_fns</span><span class="p">::</span><span class="n">parse_str_to_hex_num</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cd">/// This is the "main" function that is called by the tests.</span>
<span class="k">fn</span> <span class="nf">hex_color_no_alpha</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IResult</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">Color</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// This tuple contains 3 ways to do the same thing.</span>
    <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="p">(</span>
        <span class="nn">helper_fns</span><span class="p">::</span><span class="n">parse_hex_seg</span><span class="p">,</span>
        <span class="nn">intermediate_parsers</span><span class="p">::</span><span class="nf">gen_hex_seg_parser_fn</span><span class="p">(),</span>
        <span class="nf">map_res</span><span class="p">(</span>
            <span class="nf">take_while_m_n</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nn">helper_fns</span><span class="p">::</span><span class="n">match_is_hex_digit</span><span class="p">),</span>
            <span class="nn">helper_fns</span><span class="p">::</span><span class="n">parse_str_to_hex_num</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">);</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="nf">tag</span><span class="p">(</span><span class="s">"#"</span><span class="p">)(</span><span class="n">input</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="p">(</span><span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span><span class="p">))</span> <span class="o">=</span>
        <span class="nf">tuple</span><span class="p">(</span><span class="n">it</span><span class="p">)(</span><span class="n">input</span><span class="p">)</span><span class="o">?</span><span class="p">;</span> <span class="c1">// same as `it.parse(input)?`</span>
    <span class="nf">Ok</span><span class="p">((</span><span class="n">input</span><span class="p">,</span> <span class="n">Color</span> <span class="p">{</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="p">}))</span>
<span class="p">}</span>

<span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">parse_valid_color</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">input</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="n">input</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"#2F14DF"</span><span class="p">);</span>
        <span class="n">input</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'üîÖ'</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nd">dbg!</span><span class="p">(</span><span class="nf">hex_color_no_alpha</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input</span><span class="p">));</span>

        <span class="k">let</span> <span class="nf">Ok</span><span class="p">((</span><span class="n">remainder</span><span class="p">,</span> <span class="n">color</span><span class="p">))</span> <span class="o">=</span> <span class="n">result</span> <span class="k">else</span> <span class="p">{</span> <span class="nd">panic!</span><span class="p">();</span> <span class="p">};</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">remainder</span><span class="p">,</span> <span class="s">"üîÖ"</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="nn">Color</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">47</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">223</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">parse_invalid_color</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nd">dbg!</span><span class="p">(</span><span class="nf">hex_color_no_alpha</span><span class="p">(</span><span class="s">"üîÖ#2F14DF"</span><span class="p">));</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">result</span><span class="nf">.is_err</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>You can get the source code for the examples in this
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/nom">repo</a>.</p>
</blockquote>
      <h3 id="what-does-this-code-do-how-does-it-work">
        
        
          What does this code do, how does it work? <a href="#what-does-this-code-do-how-does-it-work">#</a>
        
        
      </h3>
    
<p><a id="markdown-what-does-this-code-do%2C-how-does-it-work%3F" name="what-does-this-code-do%2C-how-does-it-work%3F"></a></p>

<p>Please note that:</p>

<ul>
  <li>This string can be parsed: <code class="language-plaintext highlighter-rouge">#2F14DFüîÖ</code> ‚úÖ.</li>
  <li>However, this string can‚Äôt <code class="language-plaintext highlighter-rouge">üîÖ#2F14DF</code> ü§î.</li>
</ul>

<p>So what is going on in the source code above?</p>
      <h4 id="the-parser-trait-and-iresult">
        
        
          The Parser trait and IResult <a href="#the-parser-trait-and-iresult">#</a>
        
        
      </h4>
    
<p><a id="markdown-the-parser-trait-and-iresult" name="the-parser-trait-and-iresult"></a></p>

<p>The key concept in <code class="language-plaintext highlighter-rouge">nom</code> is the <code class="language-plaintext highlighter-rouge">Parser</code> trait which is implemented for any <code class="language-plaintext highlighter-rouge">FnMut</code> that accepts an
input and returns an <code class="language-plaintext highlighter-rouge">IResult&lt;Input, Output, Error&gt;</code>.</p>

<ul>
  <li>If you write a simple function w/ the signature
<code class="language-plaintext highlighter-rouge">fn(input: Input) -&gt; IResult&lt;Input, Output, Error&gt;</code> then you are good to go! You just need to
call <code class="language-plaintext highlighter-rouge">parse()</code> on the <code class="language-plaintext highlighter-rouge">Input</code> type and this will kick off the parsing.</li>
  <li>Alternatively, you can just call the <code class="language-plaintext highlighter-rouge">nom</code> <code class="language-plaintext highlighter-rouge">tuple</code> function directly via
<code class="language-plaintext highlighter-rouge">nom::sequence::tuple(...)(input)?</code>. Or you can just call the <code class="language-plaintext highlighter-rouge">parse()</code> method on the tuple
since this is an extension function on tuples provided by <code class="language-plaintext highlighter-rouge">nom</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">IResult</code> is a very important type alias. It encapsulates 3 key types that are related to
parsing:
    <ol>
      <li>The <code class="language-plaintext highlighter-rouge">Input</code> type is the type of the input that is being parsed. For example, if you are
parsing a string, then the <code class="language-plaintext highlighter-rouge">Input</code> type is <code class="language-plaintext highlighter-rouge">&amp;str</code>.</li>
      <li>The <code class="language-plaintext highlighter-rouge">Output</code> type is the type of the output that is returned by the parser. For example, if
you are parsing a string and you want to return a <code class="language-plaintext highlighter-rouge">Color</code> struct, then the <code class="language-plaintext highlighter-rouge">Output</code> type is
<code class="language-plaintext highlighter-rouge">Color</code>.</li>
      <li>The <code class="language-plaintext highlighter-rouge">Error</code> type is the type of the error that is returned by the parser. For example, if
you are parsing a string and you want to return a <code class="language-plaintext highlighter-rouge">nom::Err::Error</code> error, then the <code class="language-plaintext highlighter-rouge">Error</code>
type is <code class="language-plaintext highlighter-rouge">nom::Err::Error</code>. This is very useful when you are developing your parser
combinators and you run into errors and have to debug them.</li>
      <li>
        <p>Typically we are dealing with complete parsers which are character based. These are reflected
in the functions that we import from <code class="language-plaintext highlighter-rouge">nom</code>. It is pretty common to see the <code class="language-plaintext highlighter-rouge">'input</code> lifetime
parameter used in functions that are parsers. This way slices of the input can be returned
from the parser without having to <code class="language-plaintext highlighter-rouge">Clone</code> or allocate memory.</p>

        <p>Here‚Äôs an example of this:</p>
        <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="n">parse_hex_seg</span><span class="o">&lt;</span><span class="nv">'input</span><span class="p">,</span> <span class="n">E</span> <span class="cm">/* thread this generic type down */</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'input</span> <span class="nb">str</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IResult</span><span class="o">&lt;&amp;</span><span class="nv">'input</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">E</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">E</span><span class="p">:</span> <span class="n">ParseError</span><span class="o">&lt;&amp;</span><span class="nv">'input</span> <span class="nb">str</span><span class="o">&gt;</span> <span class="o">+</span> <span class="n">ContextError</span><span class="o">&lt;&amp;</span><span class="nv">'input</span> <span class="nb">str</span><span class="o">&gt;</span>
<span class="p">{</span> <span class="cm">/* code */</span> <span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ol>
  </li>
</ul>
      <h4 id="main-parser-function-that-calls-all-the-other-parsers">
        
        
          Main parser function that calls all the other parsers <a href="#main-parser-function-that-calls-all-the-other-parsers">#</a>
        
        
      </h4>
    
<p><a id="markdown-main-parser-function-that-calls-all-the-other-parsers" name="main-parser-function-that-calls-all-the-other-parsers"></a></p>

<p>The <code class="language-plaintext highlighter-rouge">intermediate_parsers::hex_color_no_alpha()</code> function is the main function that
orchestrates all the other functions to parse an <code class="language-plaintext highlighter-rouge">input: &amp;str</code> and turn it into a
<code class="language-plaintext highlighter-rouge">(&amp;str, Color)</code>.</p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">tag</code> combinator function is used to match the <code class="language-plaintext highlighter-rouge">#</code> character. This means that if the input
doesn‚Äôt start with <code class="language-plaintext highlighter-rouge">#</code>, the parser will fail (which is why <code class="language-plaintext highlighter-rouge">üîÖ#2F14DF</code> fails). It returns the
remaining input after <code class="language-plaintext highlighter-rouge">#</code>. And the output is <code class="language-plaintext highlighter-rouge">#</code> which we throw away.</li>
  <li>A <code class="language-plaintext highlighter-rouge">tuple</code> is created that takes 3 parsers, which all do the same exact thing, but are written
in 3 different ways just to demonstrate how these can be written.
    <ol>
      <li>The <code class="language-plaintext highlighter-rouge">helper_fns::parse_hex_seg()</code> function is added to a tuple.</li>
      <li>The higher order function <code class="language-plaintext highlighter-rouge">intermediate_parsers::gen_hex_seg_parser_fn()</code> is added to the
  tuple.</li>
      <li>Finally, the <code class="language-plaintext highlighter-rouge">map_res</code> combinator is directly added to the tuple.</li>
    </ol>
  </li>
  <li>An extension function on this tuple called <code class="language-plaintext highlighter-rouge">parse()</code> is called w/ the <code class="language-plaintext highlighter-rouge">input</code> (thus far). This
is used to parse the input hex number.
    <ul>
      <li>It returns the remaining input after the hex number which is why <code class="language-plaintext highlighter-rouge">#2F14DFüîÖ</code> returns <code class="language-plaintext highlighter-rouge">üîÖ</code> as
the first item in the tuple.</li>
      <li>The second item in the tuple is the parsed color string turned into a <code class="language-plaintext highlighter-rouge">Color</code> struct.</li>
    </ul>
  </li>
</ul>
      <h4 id="the-hex-segment-parser-comprised-of-nom-combinator-functions-and-iresult">
        
        
          The hex segment parser, comprised of nom combinator functions, and IResult <a href="#the-hex-segment-parser-comprised-of-nom-combinator-functions-and-iresult">#</a>
        
        
      </h4>
    
<p><a id="markdown-the-hex-segment-parser%2C-comprised-of-nom-combinator-functions%2C-and-iresult" name="the-hex-segment-parser%2C-comprised-of-nom-combinator-functions%2C-and-iresult"></a></p>

<p>Let‚Äôs look at the <code class="language-plaintext highlighter-rouge">helper_fns::parse_hex_seg</code> (the other 2 ways shown above do the same exact
thing). The signature of this function tells <code class="language-plaintext highlighter-rouge">nom</code> that you can call the function w/ <code class="language-plaintext highlighter-rouge">input</code>
argument and it will return <code class="language-plaintext highlighter-rouge">IResult&lt;Input, Output, Error&gt;</code>. This signature is the pattern that
we will end up using to figure out how to chain combinators together. Here‚Äôs how the <code class="language-plaintext highlighter-rouge">map_res</code>
combinator is used by <code class="language-plaintext highlighter-rouge">parse_hex_seg()</code> to actually do the parsing:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">take_while_m_n</code>: This combinator takes a range of characters (<code class="language-plaintext highlighter-rouge">2, 2</code>) and applies the
  function <code class="language-plaintext highlighter-rouge">match_is_hex_digit</code> to determine whether the <code class="language-plaintext highlighter-rouge">char</code> is a hex digit (using
  <code class="language-plaintext highlighter-rouge">is_ascii_hexdigit()</code> on the <code class="language-plaintext highlighter-rouge">char</code>). This is used to match a valid hex digit. It returns a
  <code class="language-plaintext highlighter-rouge">&amp;str</code> slice of the matched characters. Which is then passed to the next combinator.</li>
  <li><code class="language-plaintext highlighter-rouge">parse_str_to_hex_num</code>: This parser is used on the string slice returned from above. It simply
  takes string slice and turns it into a <code class="language-plaintext highlighter-rouge">Result&lt;u8&gt;, std::num::ParseIntError&gt;</code>. The error is
  important, since if the string slice is not a valid hex digit, then we want to return this
  error.</li>
</ol>
      <h3 id="generalized-workflow">
        
        
          Generalized workflow <a href="#generalized-workflow">#</a>
        
        
      </h3>
    
<p><a id="markdown-generalized-workflow" name="generalized-workflow"></a></p>

<p>After the really complicated walk through above, we could have just written the entire thing
concisely like so:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">parse_hex_seg</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IResult</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="nb">u8</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nf">map_res</span><span class="p">(</span>
    <span class="nf">take_while_m_n</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">|</span><span class="n">it</span><span class="p">:</span> <span class="nb">char</span><span class="p">|</span> <span class="n">it</span><span class="nf">.is_ascii_hexdigit</span><span class="p">()),</span>
    <span class="p">|</span><span class="n">it</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">|</span> <span class="nn">u8</span><span class="p">::</span><span class="nf">from_str_radix</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span>
  <span class="p">)(</span><span class="n">input</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">hex_color_no_alpha</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IResult</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">Color</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">let</span> <span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="nf">tag</span><span class="p">(</span><span class="s">"#"</span><span class="p">)(</span><span class="n">input</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
  <span class="k">let</span> <span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="p">(</span><span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span><span class="p">))</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">((</span>
    <span class="nn">helper_fns</span><span class="p">::</span><span class="n">parse_hex_seg</span><span class="p">,</span>
    <span class="nn">helper_fns</span><span class="p">::</span><span class="n">parse_hex_seg</span><span class="p">,</span>
    <span class="nn">helper_fns</span><span class="p">::</span><span class="n">parse_hex_seg</span><span class="p">,</span>
  <span class="p">))(</span><span class="n">input</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
  <span class="nf">Ok</span><span class="p">((</span><span class="n">input</span><span class="p">,</span> <span class="n">Color</span> <span class="p">{</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="p">}))</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This is a very simple example, but it shows how you can combine parsers together to create more
complex parsers. You start w/ the simplest one first, and then build up from there.</p>

<ul>
  <li>In this case the simplest one is <code class="language-plaintext highlighter-rouge">parse_hex_seg()</code> which is used to parse a single hex segment.
Inside this function we call <code class="language-plaintext highlighter-rouge">map_res()</code> w/ the supplied <code class="language-plaintext highlighter-rouge">input</code> and simply return the result.
This is also a very common thing to do, is to wrap calls to other parsers in functions and then
re-use them in other parsers.</li>
  <li>Finally, the <code class="language-plaintext highlighter-rouge">hex_color_no_alpha()</code> function is used to parse a hex color w/o an alpha channel.
    <ul>
      <li>The <code class="language-plaintext highlighter-rouge">tag()</code> combinator is used to match the <code class="language-plaintext highlighter-rouge">#</code> character.</li>
      <li>The <code class="language-plaintext highlighter-rouge">tuple()</code> combinator is used to match the 3 hex segments.</li>
      <li>The <code class="language-plaintext highlighter-rouge">?</code> operator is used to return the error if there is one.</li>
      <li>The <code class="language-plaintext highlighter-rouge">Ok()</code> is used to return the parsed <code class="language-plaintext highlighter-rouge">Color</code> struct and the remaining input.</li>
    </ul>
  </li>
</ul>
      <h3 id="why-cant-we-parse-2f14df">
        
        
          Why can‚Äôt we parse ‚ÄúüîÖ#2F14DF‚Äù? <a href="#why-cant-we-parse-2f14df">#</a>
        
        
      </h3>
    
<p><a id="markdown-why-can't-we-parse-%22%F0%9F%94%85%232f14df%22%3F" name="why-can't-we-parse-%22%F0%9F%94%85%232f14df%22%3F"></a></p>

<p>The reason we can‚Äôt parse <code class="language-plaintext highlighter-rouge">üîÖ#2F14DF</code> is because the <code class="language-plaintext highlighter-rouge">tag("#")</code> combinator is used to
match the <code class="language-plaintext highlighter-rouge">#</code> character at the very start of our input. Remember that the parser will try
to eat the bytes from the start of the input to the end. This means that if the input
doesn‚Äôt start with <code class="language-plaintext highlighter-rouge">#</code>, the parser will fail.</p>

<p>If we have the requirement to parse a hex color code that doesn‚Äôt start with <code class="language-plaintext highlighter-rouge">#</code>, then we
can modify the parser to handle this case. Here‚Äôs one way in which we can do this.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// This is the "main" function that is called by the tests.</span>
<span class="k">fn</span> <span class="nf">hex_color_no_alpha</span><span class="p">(</span>
    <span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IResult</span><span class="o">&lt;</span>
    <span class="p">(</span>
        <span class="cm">/* start remainder */</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
        <span class="cm">/* end remainder */</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="n">Color</span><span class="p">,</span>
<span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">root_fn</span> <span class="o">=</span> <span class="nf">preceded</span><span class="p">(</span>
        <span class="cm">/* throw away "#" */</span>
        <span class="nf">tag</span><span class="p">(</span><span class="s">"#"</span><span class="p">),</span>
        <span class="cm">/* return color */</span>
        <span class="nf">tuple</span><span class="p">((</span>
            <span class="nn">helper_fns</span><span class="p">::</span><span class="n">parse_hex_seg</span><span class="p">,</span>
            <span class="nn">helper_fns</span><span class="p">::</span><span class="n">parse_hex_seg</span><span class="p">,</span>
            <span class="nn">helper_fns</span><span class="p">::</span><span class="n">parse_hex_seg</span><span class="p">,</span>
        <span class="p">)),</span>
    <span class="p">);</span>

    <span class="c1">// Get chars before "#".</span>
    <span class="k">let</span> <span class="n">pre_root_fn</span> <span class="o">=</span> <span class="nn">take_until</span><span class="p">::</span><span class="o">&lt;</span>
        <span class="cm">/* input after "#" */</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
        <span class="cm">/* start remainder */</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
        <span class="cm">/* error type */</span> <span class="nn">nom</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">VerboseError</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="o">&gt;</span><span class="p">(</span><span class="s">"#"</span><span class="p">);</span>

    <span class="k">if</span> <span class="k">let</span> <span class="nf">Ok</span><span class="p">((</span><span class="n">input_after_hash</span><span class="p">,</span> <span class="n">start_remainder</span><span class="p">))</span> <span class="o">=</span> <span class="nf">pre_root_fn</span><span class="p">(</span><span class="n">input</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Ok</span><span class="p">((</span><span class="n">end_remainder</span><span class="p">,</span> <span class="p">(</span><span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span><span class="p">)))</span> <span class="o">=</span>
            <span class="nf">root_fn</span><span class="p">(</span><span class="n">input_after_hash</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">((</span>
                <span class="p">(</span><span class="n">start_remainder</span><span class="p">,</span> <span class="n">end_remainder</span><span class="p">),</span>
                <span class="nn">Color</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span><span class="p">),</span>
            <span class="p">))</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">Err</span><span class="p">(</span><span class="nn">nom</span><span class="p">::</span><span class="nn">Err</span><span class="p">::</span><span class="nf">Error</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span>
                <span class="p">(</span><span class="n">input_after_hash</span><span class="p">,</span> <span class="s">""</span><span class="p">),</span>
                <span class="nn">ErrorKind</span><span class="p">::</span><span class="n">Fail</span><span class="p">,</span>
            <span class="p">)))</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nf">Err</span><span class="p">(</span><span class="nn">nom</span><span class="p">::</span><span class="nn">Err</span><span class="p">::</span><span class="nf">Error</span><span class="p">(</span><span class="nn">Error</span><span class="p">::</span><span class="nf">new</span><span class="p">((</span><span class="n">input</span><span class="p">,</span> <span class="s">""</span><span class="p">),</span> <span class="nn">ErrorKind</span><span class="p">::</span><span class="n">Fail</span><span class="p">)))</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And this is what the tests would look like:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">parse_valid_color</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">input</span> <span class="o">=</span> <span class="s">"</span><span class="se">\n</span><span class="s">üåú</span><span class="se">\n</span><span class="s">#2F14DF</span><span class="se">\n</span><span class="s">üîÖ</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nd">dbg!</span><span class="p">(</span><span class="nf">hex_color_no_alpha</span><span class="p">(</span><span class="n">input</span><span class="p">));</span>
    <span class="k">let</span> <span class="nf">Ok</span><span class="p">((</span><span class="n">remainder</span><span class="p">,</span> <span class="n">color</span><span class="p">))</span> <span class="o">=</span> <span class="n">result</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nd">panic!</span><span class="p">();</span>
    <span class="p">};</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">remainder</span><span class="p">,</span> <span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">üåú</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="s">"</span><span class="se">\n</span><span class="s">üîÖ</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="nn">Color</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">47</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">223</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>
      <h3 id="better-error-reporting-when-things-go-wrong">
        
        
          Better error reporting when things go wrong <a href="#better-error-reporting-when-things-go-wrong">#</a>
        
        
      </h3>
    
<p><a id="markdown-better-error-reporting-when-things-go-wrong" name="better-error-reporting-when-things-go-wrong"></a></p>

<p>We can use the <code class="language-plaintext highlighter-rouge">context</code> combinator to provide better error reporting. This is a very useful
combinator that you can use to provide better error messages when parsing fails. However, when
using it, we need to:</p>

<ol>
  <li>Be careful of expressing the <code class="language-plaintext highlighter-rouge">nom</code> error types as generic arguments to the parser
functions, by  using the <code class="language-plaintext highlighter-rouge">nom::error::VerboseError</code> type to get more detailed error
messages which are used by <code class="language-plaintext highlighter-rouge">nom::error::convert_error</code>.</li>
  <li>This type needs to be passed as a generic argument to each parser that uses the
<code class="language-plaintext highlighter-rouge">context</code> combinator.</li>
  <li>In the example below, we call <code class="language-plaintext highlighter-rouge">u8::from_str_radix</code>. This might throw a
<code class="language-plaintext highlighter-rouge">core::num::ParseIntError</code> error. However, this error is never thrown in the code. Even
if <code class="language-plaintext highlighter-rouge">core::num::ParseIntError</code> were to be thrown, it would be <em>consumed</em>, and a higher
level <code class="language-plaintext highlighter-rouge">nom</code> error would be returned for the <code class="language-plaintext highlighter-rouge">map_res</code> combinator.</li>
</ol>

<p>Here‚Äôs an example of this.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">nom</span><span class="p">::{</span>
    <span class="nn">bytes</span><span class="p">::</span><span class="nn">complete</span><span class="p">::{</span><span class="n">tag</span><span class="p">,</span> <span class="n">take_while_m_n</span><span class="p">},</span>
    <span class="nn">combinator</span><span class="p">::</span><span class="n">map_res</span><span class="p">,</span>
    <span class="nn">error</span><span class="p">::{</span><span class="n">context</span><span class="p">,</span> <span class="n">convert_error</span><span class="p">},</span>
    <span class="nn">sequence</span><span class="p">::</span><span class="n">Tuple</span><span class="p">,</span>
    <span class="n">IResult</span><span class="p">,</span> <span class="n">Parser</span><span class="p">,</span>
<span class="p">};</span>

<span class="cd">/// `nom` is used to parse the hex digits from string. Then</span>
<span class="cd">/// [u8::from_str_radix] is used to convert the hex string into a</span>
<span class="cd">/// number. This can't fail, even though in the function signature,</span>
<span class="cd">/// that may return a [core::num::ParseIntError], which never</span>
<span class="cd">/// happens. Note the use of [nom::error::VerboseError] to get more</span>
<span class="cd">/// detailed error  messages that are passed to</span>
<span class="cd">/// [nom::error::convert_error].</span>
<span class="cd">///</span>
<span class="cd">/// Even if [core::num::ParseIntError] were to be thrown, it would</span>
<span class="cd">/// be consumed, and a higher level `nom` error would be returned</span>
<span class="cd">/// for the `map_res` combinator.</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">parse_hex_seg</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IResult</span><span class="o">&lt;</span>
    <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
    <span class="nb">u8</span><span class="p">,</span>
    <span class="nn">nom</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">VerboseError</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="o">&gt;</span>
<span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">map_res</span><span class="p">(</span>
        <span class="nf">take_while_m_n</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">|</span><span class="n">it</span><span class="p">:</span> <span class="nb">char</span><span class="p">|</span> <span class="n">it</span><span class="nf">.is_ascii_hexdigit</span><span class="p">()),</span>
        <span class="p">|</span><span class="n">it</span><span class="p">|</span> <span class="nn">u8</span><span class="p">::</span><span class="nf">from_str_radix</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="nf">.parse</span><span class="p">(</span><span class="n">input</span><span class="p">)</span>
<span class="p">}</span>

<span class="cd">/// Note the use of [nom::error::VerboseError] to get more detailed</span>
<span class="cd">/// error messages that are passed to [nom::error::convert_error].</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">root</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IResult</span><span class="o">&lt;</span>
    <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
    <span class="p">(</span><span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">u8</span><span class="p">),</span>
    <span class="nn">nom</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">VerboseError</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="o">&gt;</span>
<span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">remainder</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span><span class="p">))</span> <span class="o">=</span> <span class="p">(</span>
        <span class="nf">context</span><span class="p">(</span><span class="s">"start of hex color"</span><span class="p">,</span> <span class="nf">tag</span><span class="p">(</span><span class="s">"#"</span><span class="p">)),</span>
        <span class="nf">context</span><span class="p">(</span><span class="s">"hex seg 1"</span><span class="p">,</span> <span class="n">parse_hex_seg</span><span class="p">),</span>
        <span class="nf">context</span><span class="p">(</span><span class="s">"hex seg 2"</span><span class="p">,</span> <span class="n">parse_hex_seg</span><span class="p">),</span>
        <span class="nf">context</span><span class="p">(</span><span class="s">"hex seg 3"</span><span class="p">,</span> <span class="n">parse_hex_seg</span><span class="p">),</span>
    <span class="p">)</span>
        <span class="nf">.parse</span><span class="p">(</span><span class="n">input</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">((</span><span class="n">remainder</span><span class="p">,</span> <span class="p">(</span><span class="s">""</span><span class="p">,</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span><span class="p">)))</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This just sets up our code to use <code class="language-plaintext highlighter-rouge">context</code>, but we still have to format the output of the
error in a human readable way to <code class="language-plaintext highlighter-rouge">stdout</code>. This is where <code class="language-plaintext highlighter-rouge">convert_error</code> comes in. Here‚Äôs
how you can use it.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">test_root_1</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">input</span> <span class="o">=</span> <span class="s">"x#FF0000"</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">root</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="n">result</span><span class="nf">.is_err</span><span class="p">());</span>

    <span class="k">match</span> <span class="n">result</span> <span class="p">{</span>
        <span class="nf">Err</span><span class="p">(</span><span class="nn">nom</span><span class="p">::</span><span class="nn">Err</span><span class="p">::</span><span class="nf">Error</span><span class="p">(</span><span class="n">e</span><span class="p">))</span> <span class="p">|</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">nom</span><span class="p">::</span><span class="nn">Err</span><span class="p">::</span><span class="nf">Failure</span><span class="p">(</span><span class="n">e</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span>
                <span class="s">"Could not parse because ... {}"</span><span class="p">,</span>
                <span class="nf">convert_error</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="cm">/* do nothing for nom::Err::Incomplete(_) */</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here‚Äôs the output of the test.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Err(Error(VerboseError { errors: [("x#FF0000", Nom(Tag)), ("x#FF0000", Context("start of hex color"))] }))
Could not parse because ... 0: at line 1, in Tag:
x#FF0000
^

1: at line 1, in start of hex color:
x#FF0000
^
</code></pre></div></div>

<p>Here‚Äôs another test to see even more detailed error messages.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">test_root_2</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">input</span> <span class="o">=</span> <span class="s">"#FF_000"</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">root</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="n">result</span><span class="nf">.is_err</span><span class="p">());</span>

    <span class="k">match</span> <span class="n">result</span> <span class="p">{</span>
        <span class="nf">Err</span><span class="p">(</span><span class="nn">nom</span><span class="p">::</span><span class="nn">Err</span><span class="p">::</span><span class="nf">Error</span><span class="p">(</span><span class="n">e</span><span class="p">))</span> <span class="p">|</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">nom</span><span class="p">::</span><span class="nn">Err</span><span class="p">::</span><span class="nf">Failure</span><span class="p">(</span><span class="n">e</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span>
                <span class="s">"Could not parse because ... {}"</span><span class="p">,</span>
                <span class="nf">convert_error</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="cm">/* do nothing for nom::Err::Incomplete(_) */</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here‚Äôs the output of this test.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Err(Error(VerboseError { errors: [("_000", Nom(TakeWhileMN)), ("_000", Context("hex seg 2"))] }))
Could not parse because ... 0: at line 1, in TakeWhileMN:
#FF_000
   ^

1: at line 1, in hex seg 2:
#FF_000
   ^
</code></pre></div></div>
      <h2 id="other-examples">
        
        
          Other examples <a href="#other-examples">#</a>
        
        
      </h2>
    
<p><a id="markdown-other-examples" name="other-examples"></a></p>
      <h3 id="simple-css-syntax-parser">
        
        
          Simple CSS syntax parser <a href="#simple-css-syntax-parser">#</a>
        
        
      </h3>
    
<p><a id="markdown-simple-css-syntax-parser" name="simple-css-syntax-parser"></a></p>

<p>Here‚Äôs a snippet from the <a href="https://github.com/nazmulidris/rust-scratch/blob/main/nom/src/parser_simple_css.rs">simple CSS parser
code</a>,
that allows <code class="language-plaintext highlighter-rouge">nom</code> to parse a simple CSS like syntax. The hex color string can be in the
following formats:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">#RRGGBB</code>, eg: <code class="language-plaintext highlighter-rouge">#FF0000</code> for red.</li>
  <li><code class="language-plaintext highlighter-rouge">#RRGGBBAA</code>, eg: <code class="language-plaintext highlighter-rouge">#FF0000FF</code> for red with alpha.</li>
</ol>

<p>Here are some examples of valid input strings:</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>style = {
    fg_color: #FF0000;
    bg_color: #FF0000FF;
}
</code></pre></div></div>

<ol>
  <li>The <code class="language-plaintext highlighter-rouge">fg_color</code> and <code class="language-plaintext highlighter-rouge">bg_color</code> are both optional.</li>
  <li>The <code class="language-plaintext highlighter-rouge">style = {</code> and <code class="language-plaintext highlighter-rouge">}</code> are required.</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Type alias for [nom::error::VerboseError] to make the code more</span>
<span class="cd">/// readable.</span>
<span class="k">type</span> <span class="n">VError</span><span class="o">&lt;</span><span class="nv">'input</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">nom</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">VerboseError</span><span class="o">&lt;&amp;</span><span class="nv">'input</span> <span class="nb">str</span><span class="o">&gt;</span><span class="p">;</span>

<span class="cd">/// Parser functions for a single hex segment &amp; `#RRGGBB` &amp;</span>
<span class="cd">/// `#RRGGBBAA`.</span>
<span class="k">mod</span> <span class="n">hex_color_parser_helper_fns</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">parse_single_hex_segment</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IResult</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">VError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">map_res</span><span class="p">(</span>
            <span class="nf">take_while_m_n</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">|</span><span class="n">it</span><span class="p">:</span> <span class="nb">char</span><span class="p">|</span> <span class="n">it</span><span class="nf">.is_ascii_hexdigit</span><span class="p">()),</span>
            <span class="p">|</span><span class="n">it</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">|</span> <span class="nn">u8</span><span class="p">::</span><span class="nf">from_str_radix</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span>
        <span class="p">)(</span><span class="n">input</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">parse_hex_color_no_alpha</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IResult</span><span class="o">&lt;</span>
        <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">Color</span><span class="p">,</span> <span class="n">VError</span>
    <span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="nf">tag</span><span class="p">(</span><span class="s">"#"</span><span class="p">)(</span><span class="n">input</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="p">(</span><span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span><span class="p">))</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">((</span>
            <span class="n">parse_single_hex_segment</span><span class="p">,</span>
            <span class="n">parse_single_hex_segment</span><span class="p">,</span>
            <span class="n">parse_single_hex_segment</span><span class="p">,</span>
        <span class="p">))(</span><span class="n">input</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="nf">Ok</span><span class="p">((</span><span class="n">input</span><span class="p">,</span> <span class="nn">Color</span><span class="p">::</span><span class="nf">NoAlpha</span><span class="p">(</span><span class="nn">ColorNoAlpha</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span><span class="p">))))</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">parse_hex_color_with_alpha</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IResult</span><span class="o">&lt;</span>
        <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">Color</span><span class="p">,</span> <span class="n">VError</span>
    <span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="nf">tag</span><span class="p">(</span><span class="s">"#"</span><span class="p">)(</span><span class="n">input</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="p">(</span><span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span><span class="p">,</span> <span class="n">alpha</span><span class="p">))</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">((</span>
            <span class="n">parse_single_hex_segment</span><span class="p">,</span>
            <span class="n">parse_single_hex_segment</span><span class="p">,</span>
            <span class="n">parse_single_hex_segment</span><span class="p">,</span>
            <span class="n">parse_single_hex_segment</span><span class="p">,</span>
        <span class="p">))(</span><span class="n">input</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="nf">Ok</span><span class="p">((</span>
            <span class="n">input</span><span class="p">,</span>
            <span class="nn">Color</span><span class="p">::</span><span class="nf">WithAlpha</span><span class="p">(</span>
                <span class="nn">ColorWithAlpha</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
            <span class="p">),</span>
        <span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cd">/// Parser functions for a style multiline string.</span>
<span class="k">mod</span> <span class="n">style_parser_helper_fns</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="cd">/// Parse `style = { bg_color: .. , fg_color: .. }` parser.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">parse_style</span><span class="p">(</span>
        <span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IResult</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">ColorKind</span><span class="p">,</span> <span class="n">Color</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">VError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// Parse `style = {`.</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">((</span>
            <span class="nf">tag</span><span class="p">(</span><span class="s">"style"</span><span class="p">),</span>
            <span class="n">multispace0</span><span class="p">,</span>
            <span class="nn">nom</span><span class="p">::</span><span class="nn">character</span><span class="p">::</span><span class="nn">complete</span><span class="p">::</span><span class="nf">char</span><span class="p">(</span><span class="sc">'='</span><span class="p">),</span>
            <span class="n">multispace0</span><span class="p">,</span>
            <span class="nf">tag</span><span class="p">(</span><span class="s">"{"</span><span class="p">),</span>
            <span class="n">multispace0</span><span class="p">,</span>
        <span class="p">))(</span><span class="n">input</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="c1">// Parse `bg_color: ..` or `fg_color: ..`.</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span> <span class="o">=</span> <span class="nf">many0</span><span class="p">(</span><span class="n">parse_color_key_value</span><span class="p">)(</span><span class="n">input</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="c1">// Parse `}`.</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">((</span><span class="n">multispace0</span><span class="p">,</span> <span class="nf">tag</span><span class="p">(</span><span class="s">"}"</span><span class="p">),</span> <span class="n">multispace0</span><span class="p">))(</span><span class="n">input</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">output</span> <span class="o">=</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">it</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">ColorKind</span><span class="p">,</span> <span class="n">Color</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">color_kind</span><span class="p">,</span> <span class="n">color</span><span class="p">)</span> <span class="k">in</span> <span class="n">output</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">it</span><span class="nf">.insert</span><span class="p">(</span><span class="o">*</span><span class="n">color_kind</span><span class="p">,</span> <span class="o">*</span><span class="n">color</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">it</span>
        <span class="p">};</span>

        <span class="nf">Ok</span><span class="p">((</span><span class="n">input</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">output</span><span class="p">)))</span>
    <span class="p">}</span>

    <span class="cd">/// Parse `&lt;key&gt;: #&lt;val&gt;`, where:</span>
    <span class="cd">/// 1. `&lt;key&gt;` can be `fg_color` or `bg_color`.</span>
    <span class="cd">/// 2. `&lt;val&gt;` can be `#RRGGBB` or `#RRGGBBAA`.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">parse_color_key_value</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IResult</span><span class="o">&lt;</span>
        <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="p">(</span><span class="n">ColorKind</span><span class="p">,</span> <span class="n">Color</span><span class="p">),</span> <span class="n">VError</span>
    <span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// Parse `fg_color` or `bg_color`.</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">key_str</span><span class="p">)</span> <span class="o">=</span> <span class="nf">alt</span><span class="p">((</span><span class="nf">tag</span><span class="p">(</span><span class="s">"fg_color"</span><span class="p">),</span> <span class="nf">tag</span><span class="p">(</span><span class="s">"bg_color"</span><span class="p">)))(</span><span class="n">input</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="c1">// Parse `: #RRGGBBAA;` or `: #RRGGBB;`.</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">))</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">((</span>
            <span class="n">multispace0</span><span class="p">,</span>
            <span class="nf">tag</span><span class="p">(</span><span class="s">":"</span><span class="p">),</span>
            <span class="n">multispace0</span><span class="p">,</span>
            <span class="c1">// The order in which these functions are called matters: first,</span>
            <span class="c1">// try to parse `#RRGGBBAA` &amp; if it fails then try to parse</span>
            <span class="c1">// `#RRGGBB`.</span>
            <span class="nf">alt</span><span class="p">((</span><span class="n">parse_hex_color_with_alpha</span><span class="p">,</span> <span class="n">parse_hex_color_no_alpha</span><span class="p">)),</span>
            <span class="n">multispace0</span><span class="p">,</span>
            <span class="nf">tag</span><span class="p">(</span><span class="s">";"</span><span class="p">),</span>
            <span class="n">multispace0</span><span class="p">,</span>
        <span class="p">))(</span><span class="n">input</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="nf">Ok</span><span class="p">((</span><span class="n">input</span><span class="p">,</span> <span class="p">(</span><span class="nn">ColorKind</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">key_str</span><span class="p">),</span> <span class="n">output</span><span class="p">)))</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
      <h3 id="simple-natural-language-parser">
        
        
          Simple natural language parser <a href="#simple-natural-language-parser">#</a>
        
        
      </h3>
    
<p><a id="markdown-simple-natural-language-parser" name="simple-natural-language-parser"></a></p>

<p>Here‚Äôs a snippet from the <a href="https://github.com/nazmulidris/rust-scratch/blob/main/nom/src/parse_natural_lang.rs">Simple natural language parser
code</a>
that parses natural language sentences.</p>

<p>The sentences are in this form:</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hello, [my name is &lt;name&gt;] and [i am &lt;age&gt; years old] and [i like &lt;language&gt;]
</code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">and</code> is optional; it can be omitted or replaced w/ a <code class="language-plaintext highlighter-rouge">,</code>.</p>

<p>Here are examples of valid sentences:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">"Hello, my name is Tommaso and i am 32 years old and I like Rust"</code></li>
  <li><code class="language-plaintext highlighter-rouge">"Hello, my name is Roberto and i like Python, I am 44 years old"</code></li>
  <li><code class="language-plaintext highlighter-rouge">"Hello, I like JavaScript my name is Luciano i am 35 years old"</code></li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Functions that can be composed to parse the sentence.</span>
<span class="k">mod</span> <span class="n">parse_sentence</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="cd">/// Sentence starts w/ "hello". Then optional whitespace.</span>
    <span class="cd">/// Then optional ",". Then optional whitespace.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">root</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IResult</span><span class="o">&lt;</span><span class="cm">/* remainder */</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sentence</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">rem</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">((</span>
            <span class="nf">tag_no_case</span><span class="p">(</span><span class="s">"hello"</span><span class="p">),</span>
            <span class="n">multispace0</span><span class="p">,</span>
            <span class="nf">opt</span><span class="p">(</span><span class="nf">tag</span><span class="p">(</span><span class="s">","</span><span class="p">)),</span> <span class="cm">/* cut() also works instead of opt() */</span>
            <span class="n">multispace0</span><span class="p">,</span>
        <span class="p">))(</span><span class="n">input</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="c1">// Name, age, and language show up next in any order.</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">rem</span><span class="p">,</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">,</span> <span class="n">language</span><span class="p">))</span> <span class="o">=</span>
            <span class="nf">permutation</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">,</span> <span class="n">language</span><span class="p">))(</span><span class="n">rem</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="nf">Ok</span><span class="p">((</span>
            <span class="n">rem</span><span class="p">,</span>
            <span class="n">Sentence</span> <span class="p">{</span>
                <span class="n">name</span><span class="p">,</span>
                <span class="n">age</span><span class="p">,</span>
                <span class="n">language</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">))</span>
    <span class="p">}</span>

    <span class="cd">/// Optional whitespace. Then optional "and" or optional ",". Then optional</span>
    <span class="cd">/// whitespace.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">optional_prefix</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IResult</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">rem</span><span class="p">,</span> <span class="n">_spaces</span><span class="p">)</span> <span class="o">=</span> <span class="nf">multispace0</span><span class="p">(</span><span class="n">input</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">rem</span><span class="p">,</span> <span class="n">_prefix</span><span class="p">)</span> <span class="o">=</span> <span class="nf">opt</span><span class="p">(</span>
            <span class="nf">alt</span><span class="p">((</span>
                <span class="nf">tag_no_case</span><span class="p">(</span><span class="s">"and"</span><span class="p">),</span>
                <span class="nf">tag</span><span class="p">(</span><span class="s">","</span><span class="p">)</span>
            <span class="p">))</span>
        <span class="p">)(</span><span class="n">rem</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">rem</span><span class="p">,</span> <span class="n">_spaces</span><span class="p">)</span> <span class="o">=</span> <span class="nf">multispace0</span><span class="p">(</span><span class="n">rem</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="nf">Ok</span><span class="p">((</span><span class="n">rem</span><span class="p">,</span> <span class="p">()))</span>
    <span class="p">}</span>

    <span class="cd">/// Age starts w/ optional "and" or ",". Then "i am". Then optional</span>
    <span class="cd">/// whitespace. Then age (number).</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">age</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IResult</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="nb">u8</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">rem</span><span class="p">,</span> <span class="n">_prefix</span><span class="p">)</span> <span class="o">=</span> <span class="nf">optional_prefix</span><span class="p">(</span><span class="n">input</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">rem</span><span class="p">,</span> <span class="n">_i_am_with_spaces</span><span class="p">)</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">((</span>
            <span class="nf">tag_no_case</span><span class="p">(</span><span class="s">"i am"</span><span class="p">),</span>
            <span class="n">multispace0</span>
        <span class="p">))(</span><span class="n">rem</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">rem</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span> <span class="o">=</span> <span class="nf">map_res</span><span class="p">(</span><span class="n">digit1</span><span class="p">,</span> <span class="p">|</span><span class="n">age</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">|</span> <span class="n">age</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">())(</span><span class="n">rem</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">rem</span><span class="p">,</span> <span class="n">_suffix</span><span class="p">)</span> <span class="o">=</span> <span class="nf">tag_no_case</span><span class="p">(</span><span class="s">" years old"</span><span class="p">)(</span><span class="n">rem</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="nf">Ok</span><span class="p">((</span><span class="n">rem</span><span class="p">,</span> <span class="n">age</span><span class="p">))</span>
    <span class="p">}</span>

    <span class="cd">/// Name starts w/ optional "and" or ",". Then "my name is". Then optional</span>
    <span class="cd">/// whitespace. Then name.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">name</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IResult</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="nb">str</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">rem</span><span class="p">,</span> <span class="n">_prefix</span><span class="p">)</span> <span class="o">=</span> <span class="nf">optional_prefix</span><span class="p">(</span><span class="n">input</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">rem</span><span class="p">,</span> <span class="n">_my_name_is_with_spaces</span><span class="p">)</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">((</span>
            <span class="n">multispace0</span><span class="p">,</span>
            <span class="nf">tag_no_case</span><span class="p">(</span><span class="s">"my name is"</span><span class="p">),</span>
            <span class="n">multispace0</span>
        <span class="p">))(</span><span class="n">rem</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">rem</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">=</span> <span class="nf">alpha1</span><span class="p">(</span><span class="n">rem</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="nf">Ok</span><span class="p">((</span><span class="n">rem</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
    <span class="p">}</span>

    <span class="cd">/// Language starts w/ optional "and" or ",". Then "i like". Then optional</span>
    <span class="cd">/// whitespace. Then language.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">language</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IResult</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="nb">str</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">rem</span><span class="p">,</span> <span class="n">_prefix</span><span class="p">)</span> <span class="o">=</span> <span class="nf">optional_prefix</span><span class="p">(</span><span class="n">input</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">rem</span><span class="p">,</span> <span class="n">_i_like_with_spaces</span><span class="p">)</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">((</span>
            <span class="nf">tag_no_case</span><span class="p">(</span><span class="s">"i like"</span><span class="p">),</span>
            <span class="n">multispace0</span>
        <span class="p">))(</span><span class="n">rem</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">rem</span><span class="p">,</span> <span class="n">language</span><span class="p">)</span> <span class="o">=</span> <span class="nf">alpha1</span><span class="p">(</span><span class="n">rem</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="nf">Ok</span><span class="p">((</span><span class="n">rem</span><span class="p">,</span> <span class="n">language</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
      <h2 id="markdown-parser">
        
        
          Markdown parser <a href="#markdown-parser">#</a>
        
        
      </h2>
    
<p><a id="markdown-markdown-parser" name="markdown-parser"></a></p>

<p>You can find a simplified version of the Markdown parser in this
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/nom/src/md_parser/parser.rs">repo</a>. This may
be useful to learn the basics of Markdown parsing before delving into the more complex parser that is
used in <code class="language-plaintext highlighter-rouge">r3bl_tui</code>.</p>

<blockquote>
  <p>üí° You can get the source code for the production Markdown parser used in <code class="language-plaintext highlighter-rouge">r3bl_tui</code> from the
<a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/tui/src/tui/md_parser"><code class="language-plaintext highlighter-rouge">r3bl-open-core</code></a>
repo.</p>

  <p>üåü Please star this repo on github if you like it üôè.</p>
</blockquote>

<p>The production
<a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/tui/src/tui/md_parser"><code class="language-plaintext highlighter-rouge">md_parser</code></a>
module in the <code class="language-plaintext highlighter-rouge">r3bl-open-core</code> repo contains a fully functional Markdown parser (and isn‚Äôt
written as a test but a real module that you can use in your projects that need a Markdown
parser). This parser supports standard Markdown syntax as well as some extensions that are
added to make it work w/ R3BL products. It makes a great starting point to study how a
relatively complex parser is written. There are lots of tests that you can follow along to
understand what the code is doing.</p>

<p>Here are some entry points into the codebase.</p>

<ol>
  <li>
    <p>The main function
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/parser.rs"><code class="language-plaintext highlighter-rouge">parse_markdown()</code></a>
that does the parsing of a string slice into a
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/types.rs"><code class="language-plaintext highlighter-rouge">Document</code></a>.
The tests are provided alongside the code itself. And you can follow along to see how other
smaller parsers are used to build up this big one that parses the whole of the Markdown document.</p>

    <ol>
      <li>All the parsers related to parsing metadata specific for R3BL applications which are not
standard Markdown can be found in
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/parser_impl_metadata.rs"><code class="language-plaintext highlighter-rouge">parser_impl_metadata</code></a>.</li>
      <li>All the parsers that are related to parsing the main ‚Äúblocks‚Äù of Markdown, such as order
lists, unordered lists, code blocks, text blocks, heading blocks, can be found
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/parser_impl_block.rs"><code class="language-plaintext highlighter-rouge">parser_impl_block</code></a></li>
      <li>All the parsers that are related to parsing a single line of Markdown text, such as links,
bold, italic, etc. can be found
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/parser_impl_element.rs"><code class="language-plaintext highlighter-rouge">parser_impl_element</code></a></li>
    </ol>
  </li>
  <li>
    <p>The <a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/types.rs">types</a>
that are used to represent the Markdown document model
(<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/types.rs"><code class="language-plaintext highlighter-rouge">Document</code></a>)
and all the other intermediate types (<code class="language-plaintext highlighter-rouge">Fragment</code>, <code class="language-plaintext highlighter-rouge">Block</code>, etc) &amp; enums required for parsing.</p>
  </li>
</ol>
      <h2 id="references">
        
        
          References <a href="#references">#</a>
        
        
      </h2>
    
<p><a id="markdown-references" name="references"></a></p>

<p><code class="language-plaintext highlighter-rouge">nom</code> is a huge topic. This tutorial takes a hands on approach to learning <code class="language-plaintext highlighter-rouge">nom</code>. However, the resources
listed below are very useful for learning <code class="language-plaintext highlighter-rouge">nom</code>. Think of them as a reference guide and deep dive into
how the <code class="language-plaintext highlighter-rouge">nom</code> library works.</p>

<ul>
  <li>Useful:
    <ul>
      <li>Source code examples (fantastic way to learn <code class="language-plaintext highlighter-rouge">nom</code>):
        <ul>
          <li><a href="https://github.com/dimfeld/export-logseq-notes/tree/master/src">export-logseq-notes repo</a></li>
        </ul>
      </li>
      <li>Videos:
        <ul>
          <li><a href="https://youtu.be/EXEMm5173SM">Intro from the author 7yrs old</a></li>
          <li><code class="language-plaintext highlighter-rouge">nom</code> 7 deep dive videos:
            <ul>
              <li><a href="https://youtu.be/Igajh2Vliog">Parsing name, age, and preference from natural language input</a></li>
              <li><a href="https://youtu.be/Xm4jrjohDN8">Parsing number ranges</a></li>
              <li><a href="https://youtu.be/6b2ymQWldoE">Parsing lines of text</a></li>
            </ul>
          </li>
          <li><code class="language-plaintext highlighter-rouge">nom</code> 6 videos (deep dive into how nom combinators themselves are constructed):
            <ul>
              <li><a href="https://youtu.be/zHF6j1LvngA">Deep dive, Part 1</a></li>
              <li><a href="https://youtu.be/9GLFJcSO08Y">Deep dive, Part 2</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Tutorials:
        <ul>
          <li><a href="https://codeandbitters.com/lets-build-a-parser/">Build a JSON parser using <code class="language-plaintext highlighter-rouge">nom</code> 7</a></li>
          <li><a href="https://github.com/benkay86/nom-tutorial">Excellent beginner to advanced</a></li>
          <li><a href="https://github.com/rust-bakery/nom/blob/main/doc/making_a_new_parser_from_scratch.md">Write a parser from scratch</a></li>
        </ul>
      </li>
      <li>Reference docs:
        <ul>
          <li><a href="https://tfpk.github.io/nominomicon/introduction.html">nominomicon</a></li>
          <li><a href="https://github.com/rust-bakery/nom/blob/main/doc/choosing_a_combinator.md">What combinator or parser to use?</a></li>
          <li><a href="https://docs.rs/nom/7.1.3/nom/">docs.rs</a></li>
          <li><a href="https://github.com/rust-bakery/nom/blob/main/doc/upgrading_to_nom_5.md">Upgrading to <code class="language-plaintext highlighter-rouge">nom</code> 5.0</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Less useful:
    <ul>
      <li><a href="https://github.com/rust-bakery/nom">README</a></li>
      <li><a href="https://crates.io/crates/nom"><code class="language-plaintext highlighter-rouge">nom</code> crate</a></li>
    </ul>
  </li>
</ul>

        <!--
    Display all the categories for this page
    More info:
    - Tutorial - http://tinyurl.com/yc6fq6zx
    - Liquid language reference - http://tinyurl.com/y8s4qpwo
-->
<div class="categories-block">
    
    
    <span class="category">
            <a href="/category/Rust">
                #rust</a>
        </span>
    
</div>

        
<blockquote>

üì¶ Install our useful Rust command line apps using <code>cargo install r3bl-cmdr</code>
(they are from the <a href="https://github.com/r3bl-org/r3bl-open-core">r3bl-open-core</a>
project):
<ul>
  <li>üê±<code>giti</code>: run interactive git commands with confidence in your terminal</li>
  <li>ü¶ú<code>edi</code>: edit Markdown with style in your terminal</li>
</ul>

<p>
<kbd>giti in action</kbd>
<video width="100%" controls>
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/262f59d1-a95c-4af3-accf-c3d6cac6e586" type="video/mp4"/>
</video>
</p>

<p>
<kbd>edi in action</kbd>
<video width="100%" controls>
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/f2c4b07d-b5a2-4f41-af7a-06d1b6660c41" type="video/mp4"/>
</video>
</p>

</blockquote>

        <!--
    Display related posts (by category)
    More info:
    - Tutorial - http://tinyurl.com/j5tevq7
    - Liquid language reference - http://tinyurl.com/y9ru5msq
-->
<div class="related-post-block">

    <h3>Related Posts</h3>

    <!-- Get all the related posts into the string `postsString`-->
    
    
    

    <!--
        At this point `postsString` string might look like:
        Post 3|Post 1|Post 3|Post 2|Post 1|Post 3|Post 2|
    -->

    <!-- Remove all the dupes from the `postsString` string, and split it into an array -->
    

    <ul>
        
            
                
                <li>
                    <a class="post-list" href="/2024/06/10/rust-miette-error-handling/">
                        Rust error handling with miette
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/05/28/typestate-pattern-rust/">
                        Build with Naz : Rust typestate pattern
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/05/25/tokio-uring-exploration-rust/">
                        Build with Naz : Linux io_uring and tokio-uring exploration with Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/05/19/effective-async-rust/">
                        Build with Naz : Rust async, non-blocking, concurrent, parallel, event loops, cancellation safety
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/05/15/tokio-tracing-otel-rust/">
                        Build with Naz : tokio tracing &amp; OTel and how to use it in Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/04/28/rust-polymorphism-dyn-impl-trait-objects-for-testing-and-extensibiity/">
                        Build with Naz : Rust Polymorphism, dyn, impl, using existing traits, trait objects for testing and extensibility
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/04/21/build-async-interactive-cli-apps-in-rust/">
                        Build with Naz : Build interactive and non blocking CLI apps with ease in Rust using r3bl_terminal_async
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/01/13/write-simple-netcat-in-rust/">
                        Write a simple netcat client and server in Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/01/13/write-simple-chat-server-in-rust/">
                        Write a simple TCP chat server in Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2023/09/17/tuify-clap/">
                        tuify your clap CLI apps and make them more interactive
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2023/08/28/justfile/">
                        Use just to manage project specific commands
                    </a>
                </li>
            
        
            
        
            
                
                <li>
                    <a class="post-list" href="/2022/08/04/rust-dsl-part-1/">
                        Create a simple DSL for CSS like syntax for TUIs
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2022/03/30/rust-proc-macro/">
                        Guide to Rust procedural macros
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2022/03/12/rust-redux/">
                        Write a Redux library in Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2022/03/12/rust-tokio/">
                        Write code using async/await in Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2022/03/02/rust-grep-cli-app/">
                        Build a grep CLI app in Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2022/02/24/rust-non-binary-tree/">
                        Build a non-binary tree that is thread safe using Rust
                    </a>
                </li>
            
        
    </ul>

</div>

        <a class="u-url" href="/2023/02/20/guide-to-nom-parsing/" hidden></a>
    </div></article>
</div>
      </main><div>
  <section class="sidebar">
    <h2 class="star-us-github-heading">
      Subscribe to our Rust live coding
      <a href="https://www.youtube.com/@developerlifecom">YouTube Channel</a
      ><span class="heading-emoji"> ü¶Ä</span>
    </h2>

    <!-- video on intro to testing (with playlist) -->
    <!-- <iframe
      src="https://www.youtube.com/embed/videoseries?si=7gmhXY5DVYJG7OdU&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
      referrerpolicy="strict-origin-when-cross-origin"
      allowfullscreen
    >
    </iframe> -->

    <!-- rust async readline and spinner & playlist -->
    <!-- <iframe
      src="https://www.youtube.com/embed/videoseries?si=i37Ei9nCfvslOoaI&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
      referrerpolicy="strict-origin-when-cross-origin"
      allowfullscreen
    >
    </iframe> -->

  <!-- rust tokio tracing and otel for async rust & playlist -->
  <iframe
    src="https://www.youtube.com/embed/Wf8JrLgBuKI?si=cmLaUWs-pbJ39lLc"
    title="YouTube video player"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    referrerpolicy="strict-origin-when-cross-origin"
    allowfullscreen>
  </iframe>

    <br />
    <br />

    <h2 class="star-us-github-heading">
      Use our extensions, apps, binary and library crates<span class="heading-emoji"> üì¶</span>
    </h2>

    <ul class="sidebar-ul">
      <li class="app-container">
        <a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/cmdr" target="_blank">
          <img class="star-icon-img" src="/assets/r3bl-apps.svg" />
          <div class="sidebar-list-item">
            <p class="p-tag">INSTALL & USE OUR APPS (giti, edi)</p>
            <h3 class="sidebar-h3"><code>r3bl-cmdr</code></h3>
          </div>
        </a>
      </li>
      <li class="app-container">
        <a href="https://github.com/r3bl-org/shortlink" target="_blank">
          <img class="star-icon-img" src="/assets/r3bl-shortlink.svg" />
          <div class="sidebar-list-item">
            <p class="p-tag">SHORTLINK browser extension</p>
            <h3 class="sidebar-h3"><code>shortlink</code></h3>
          </div>
        </a>
      </li>
      <li class="app-container">
        <a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/tui" target="_blank">
          <img class="star-icon-img" src="/assets/crate.png" />
          <div class="sidebar-list-item">
            <p class="p-tag">R3BL TUI LIB</p>
            <h3 class="sidebar-h3"><code>r3bl_tui</code></h3>
          </div>
        </a>
      </li>
      <li class="app-container">
        <a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/tuify" target="_blank">
          <img class="star-icon-img" src="/assets/crate.png" />
          <div class="sidebar-list-item">
            <p class="p-tag">R3BL TUIFY LIB</p>
            <h3 class="sidebar-h3"><code>r3bl_tuify</code></h3>
          </div>
        </a>
      </li>
      <li class="app-container">
        <a
          href="https://github.com/r3bl-org/r3bl-open-core/tree/main/terminal_async"
          target="_blank"
        >
          <img class="star-icon-img" src="/assets/crate.png" />
          <div class="sidebar-list-item">
            <p class="p-tag">R3BL TERMINAL ASYNC LIB</p>
            <h3 class="sidebar-h3"><code>r3bl_terminal_async</code></h3>
          </div>
        </a>
      </li>
    </ul>

    <br />

    <h2 class="star-us-github-heading">
      Join our <a href="https://discord.gg/PhuF4qFpcA">Discord</a>
      <span class="heading-emoji"> üí¨</span>
    </h2>
  </section>
</div>
</div><footer class="site-footer h-card">

    <div class="wrapper">

        <div class="footer-col-wrapper">

            <div class="footer-col"><!-- <p>
    developerlife.com site was started in Nov 1998 with coverage for
    topics related to Java, XML, and web and desktop technologies.
    Today it covers Kotlin, TypeScript, Node.js, React, Android, JDK,
    Web, Cloud technologies, User Experience Engineering (UXE)
    and design topics. ¬© Nazmul Idris 2022. All rights reserved.
</p> -->
<div>
  <p class="footer-p">
    developerlife.com site was started in Nov 1998 by <a href="https://developerlife.com/about-me/">Nazmul Idris</a>, with coverage for topics related to Java, XML,
    and web and desktop technologies. Today it covers Rust, TUI, CLI, Kotlin, TypeScript, Node.js, React, Android,
    JDK, Web, Cloud technologies, User Experience Engineering (UXE) and design topics. ¬© Nazmul
    Idris 2022. All rights reserved.
  </p>
  <div class="footer-container">
    <!-- element 1 -->
    <kbd>
      <a class="footer-elem-1" href="/subscribe.html" target="_blank"
        >Subscribe for updates</a
      >
    </kbd>

    <!-- element 2 -->
    <kbd>
      <a class="footer-elem-2" href="https://r3bl.com" target="_blank">Sponsored by R3BL</a>
    </kbd>
  </div>
</div>
</div>

        </div>

    </div>

</footer>
<script>
//open external links in a new window
function external_new_window() {
    for(var c = document.getElementsByTagName("a"), a = 0;a < c.length;a++) {
    var b = c[a];
    b.getAttribute("href") && b.hostname !== location.hostname && (b.target = "_blank")
    }
}
//open PDF links in a new window
function pdf_new_window ()
{
    if (!document.getElementsByTagName) return false;
    var links = document.getElementsByTagName("a");
    for (var eleLink=0; eleLink < links.length; eleLink ++) {
    if ((links[eleLink].href.indexOf('.pdf') !== -1)||(links[eleLink].href.indexOf('.doc') !== -1)||(links[eleLink].href.indexOf('.docx') !== -1)) {
        links[eleLink].onclick =
        function() {
            window.open(this.href);
            return false;
        }
    }
    }
} 
pdf_new_window()
external_new_window();
</script></body>
</html>
