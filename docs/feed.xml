<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://developerlife.com/feed.xml" rel="self" type="application/atom+xml" /><link href="http://developerlife.com/" rel="alternate" type="text/html" /><updated>2024-05-15T12:21:31-05:00</updated><id>http://developerlife.com/feed.xml</id><title type="html">developerlife.com</title><subtitle>Rust, TUI, Android, Web, Desktop, Cloud technologies, and UX engineering and design tutorials.</subtitle><author><name>Nazmul Idris</name></author><entry><title type="html">Build with Naz : tokio tracing &amp;amp; OTel and how to use it in Rust</title><link href="http://developerlife.com/2024/05/15/tokio-tracing-otel-rust/" rel="alternate" type="text/html" title="Build with Naz : tokio tracing &amp;amp; OTel and how to use it in Rust" /><published>2024-05-15T10:00:00-05:00</published><updated>2024-05-15T10:00:00-05:00</updated><id>http://developerlife.com/2024/05/15/tokio-tracing-otel-rust</id><content type="html" xml:base="http://developerlife.com/2024/05/15/tokio-tracing-otel-rust/"><![CDATA[<p><img class="post-hero-image" src="/assets/tracing_otel_rust.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#why-use-observability-in-async-rust">Why use observability in async Rust?</a></li>
  <li><a href="#tokio-tracing-usage">Tokio tracing usage</a></li>
  <li><a href="#video-of-this-in-action-in-the-real-world">Video of this in action in the real world</a></li>
  <li><a href="#short-example-to-illustrate-the-use-of-tracing-and-otel-in-rust">Short example to illustrate the use of tracing and OTel in Rust</a></li>
  <li><a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</a></li>
</ul>

<!-- /TOC -->

<h2 id="why-use-observability-in-async-rust">Why use observability in async Rust?</h2>
<p><a id="markdown-why-use-observability-in-async-rust%3F" name="why-use-observability-in-async-rust%3F"></a></p>

<p>In synchronous systems, it‚Äôs often easy to understand the flow of execution by looking at
log messages. For example, if a thread walking through a single function ends up calling a whole
host of other functions, and they all emit log messages, you can often piece together what
happened by looking at the log messages in order.</p>

<p>However, in asynchronous systems, this is challenging. When using Tokio, for example,
different threads might be executing the same task, as it goes from being parked, to being
woken up, to being parked again. Both temporality (when a log event happened) and
causality (what caused the event) get muddled. This is where observability comes in,
provided by Tokio <code class="language-plaintext highlighter-rouge">tracing</code> crate and OpenTelemetry (OTel) crates.</p>

<p>The <code class="language-plaintext highlighter-rouge">tracing</code> crate expands upon logging-style diagnostics by allowing libraries and
applications to record structured events with additional information about temporality and
causality. Unlike a log message, a <code class="language-plaintext highlighter-rouge">Span</code> in tracing has a beginning and end time, may be
entered and exited by the flow of execution, and may exist within a nested tree of similar
spans.</p>

<p>For representing things that occur at a single moment in time, tracing provides the
complementary concept of events. Both <code class="language-plaintext highlighter-rouge">Spans</code> and <code class="language-plaintext highlighter-rouge">Events</code> are structured, with the ability to
record typed data as well as textual messages.</p>

<h2 id="tokio-tracing-usage">Tokio tracing usage</h2>
<p><a id="markdown-tokio-tracing-usage" name="tokio-tracing-usage"></a></p>

<p>Code:</p>
<ul>
  <li><a href="https://github.com/nazmulidris/rust-scratch/tree/main/tcp-api-server"><code class="language-plaintext highlighter-rouge">tcp-api-server</code> crate is the sample project that uses <code class="language-plaintext highlighter-rouge">tracing</code> and OTel and the
modules below (provided by the <code class="language-plaintext highlighter-rouge">r3bl_terminal_async</code>
crate</a>.</li>
  <li><a href="https://github.com/r3bl-org/r3bl-open-core/blob/nazmulidris/otel/terminal_async/src/public_api/tracing_setup.rs"><code class="language-plaintext highlighter-rouge">r3bl_terminal_async</code> Tokio <code class="language-plaintext highlighter-rouge">tracing</code>
setup</a>.</li>
  <li><a href="https://github.com/r3bl-org/r3bl-open-core/blob/nazmulidris/otel/terminal_async/src/public_api/jaeger_setup.rs#L1"><code class="language-plaintext highlighter-rouge">r3bl_terminal_async</code> Jaeger &amp; OTel
setup</a>.</li>
</ul>

<p>Here‚Äôs an example of using the <code class="language-plaintext highlighter-rouge">tracing</code> crate. Some key symbols to note are::</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">#[instrument]</code> attribute is used to create a span.</li>
  <li><code class="language-plaintext highlighter-rouge">Span::current().record()</code> is used to add fields to the span (when the function is
running, and this information is not known statically beforehand).</li>
  <li><code class="language-plaintext highlighter-rouge">info!</code>, <code class="language-plaintext highlighter-rouge">error!</code>, etc are used to emit log or tracing events. However, these are not
used to create spans; they are used to emit events within a span.</li>
  <li><code class="language-plaintext highlighter-rouge">#[tokio::main]</code> is used to run the async main function.</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">tracing</span><span class="p">::{</span><span class="n">info</span><span class="p">,</span> <span class="n">instrument</span><span class="p">,</span> <span class="n">Span</span><span class="p">};</span>

<span class="nd">#[tokio::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nn">client_task</span><span class="p">::</span><span class="nf">entry_point</span><span class="p">(</span><span class="mi">1234</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">mod</span> <span class="n">client_task</span> <span class="p">{</span>
    <span class="nd">#[instrument(name</span> <span class="nd">=</span> <span class="s">"caller"</span><span class="nd">,</span> <span class="nd">skip_all,</span> <span class="nd">fields(</span><span class="err">?</span><span class="nd">client_id))]</span>
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">entry_point</span><span class="p">(</span><span class="n">client_id</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">info!</span><span class="p">(</span><span class="s">"entry point"</span><span class="p">);</span>
        <span class="nf">more_context</span><span class="p">(</span><span class="s">"bar"</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
        <span class="nf">handle_message</span><span class="p">(</span><span class="n">client_id</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nd">#[instrument(name</span> <span class="nd">=</span> <span class="s">"callee"</span><span class="nd">,</span> <span class="nd">skip_all,</span> <span class="nd">fields(</span><span class="err">%</span><span class="nd">message))]</span>
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">handle_message</span><span class="p">(</span><span class="n">client_id</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">info!</span><span class="p">(</span><span class="s">"handling message"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">#[instrument(fields(extra))]</span>
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">more_context</span><span class="p">(</span><span class="n">extra</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="nn">CurrentSpan</span><span class="p">::</span><span class="nf">current</span><span class="p">()</span><span class="nf">.record</span><span class="p">(</span><span class="s">"extra"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">extra</span><span class="p">);</span>
        <span class="nd">info!</span><span class="p">(</span><span class="s">"more context"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here are some key points to remember when using <code class="language-plaintext highlighter-rouge">tracing</code> from the code above:</p>

<ul>
  <li>
    <p>You have to be careful about recording the same field multiple times, in an async call
chain. In the example above, <code class="language-plaintext highlighter-rouge">client_task::entry_point()</code> is the entry point, and is the
only function that should log the <code class="language-plaintext highlighter-rouge">?client_id</code>; <code class="language-plaintext highlighter-rouge">?</code> means debug. And not any other
functions that it calls, like <code class="language-plaintext highlighter-rouge">handle_message()</code>.</p>
  </li>
  <li>
    <p>When you call <code class="language-plaintext highlighter-rouge">entry_point()</code>, it will call <code class="language-plaintext highlighter-rouge">handle_message()</code>, and the span that is
generated by <code class="language-plaintext highlighter-rouge">handle_message()</code> will have the <code class="language-plaintext highlighter-rouge">client_id</code> field added to it, because of
the call chain. So the output of <code class="language-plaintext highlighter-rouge">info!("handling message")</code> will have the <code class="language-plaintext highlighter-rouge">client_id</code>
included in it (for free). It will also have the <code class="language-plaintext highlighter-rouge">%message</code> field in it; <code class="language-plaintext highlighter-rouge">%</code> means
display. You don‚Äôt have to explicitly add either of these fields to the <code class="language-plaintext highlighter-rouge">info!()</code> call üéâ.</p>
  </li>
  <li>
    <p>If you use the <code class="language-plaintext highlighter-rouge">client_id</code> field in multiple <code class="language-plaintext highlighter-rouge">#[instrument..]</code> attributes in functions
(that are in the call chain), then this will show up multiple times in the log output
(when using <code class="language-plaintext highlighter-rouge">info!</code>, <code class="language-plaintext highlighter-rouge">debug!</code>, etc) of the leaf function in the call chain. So when you
see the same fields showing up multiple times in the output from <code class="language-plaintext highlighter-rouge">info!</code>, <code class="language-plaintext highlighter-rouge">debug!</code>, etc,
then you know that you have to remove that field from the <code class="language-plaintext highlighter-rouge">#[instrument..]</code> attribute
somewhere in the call chain (that the span covers).</p>
  </li>
  <li>
    <p>You have to be careful about how to use
<a href="https://docs.rs/tracing/latest/tracing/attr.instrument.html"><code class="language-plaintext highlighter-rouge">[#instrument]</code></a> attribute
with <code class="language-plaintext highlighter-rouge">tracing::Span::record</code>. You have to call
<code class="language-plaintext highlighter-rouge">tracing::Span::current().record("foo","bar")</code> in the same function where the
<code class="language-plaintext highlighter-rouge">#[instrument(fields(foo))]</code> attribute is used.</p>
  </li>
</ul>

<p>Here are some helpful links to learn more about this topic:</p>

<ul>
  <li><a href="https://tokio.rs/tokio/topics/tracing">Tokio tracing docs</a>.</li>
  <li><a href="https://gemini.google.com/app/5b106a8100c4dcf4">Difference between <code class="language-plaintext highlighter-rouge">#[instrument]</code> (create spans) and emitting events (eg: <code class="language-plaintext highlighter-rouge">info!</code>, <code class="language-plaintext highlighter-rouge">debug!</code>, etc:</a>.</li>
  <li><a href="https://tokio.rs/tokio/topics/tracing-next-steps">Tokio and OTel integration docs</a>.</li>
  <li><a href="https://github.com/tokio-rs/tracing-opentelemetry">Tokio tracing and OTel integration crate</a>.</li>
  <li><a href="https://broch.tech/posts/rust-tracing-opentelemetry/">Blog post to connect tracing and OTel</a>.</li>
  <li><a href="https://github.com/open-telemetry/opentelemetry-rust/blob/main/examples/tracing-jaeger/src/main.rs">Code examples for using Jaeger with tracing</a>.</li>
  <li><a href="https://opentelemetry.io/docs/concepts/observability-primer/#spans">OTel primer</a>.</li>
  <li><a href="https://www.jaegertracing.io/docs/1.57/getting-started/">Jaeger docs</a>.</li>
</ul>

<h2 id="video-of-this-in-action-in-the-real-world">Video of this in action in the real world</h2>
<p><a id="markdown-video-of-this-in-action-in-the-real-world" name="video-of-this-in-action-in-the-real-world"></a></p>

<p>This blog post only has a short example to illustrate how to use Rust tracing and OTel
with Jaeger. To see how these ideas can be used in production code, with real-world
examples, please watch the following video on the <a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube
channel</a>.</p>

<!-- rust tokio tracing and otel for async rust & playlist -->
<iframe src="https://www.youtube.com/embed/Wf8JrLgBuKI?si=cmLaUWs-pbJ39lLc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<p>Here‚Äôs the code for this real world example:</p>

<ul>
  <li><a href="https://github.com/nazmulidris/rust-scratch/tree/main/tcp-api-server">Repo for the <code class="language-plaintext highlighter-rouge">tcp-api-server</code> crate, which is an example of creating a TCP server and
client that are observable using <code class="language-plaintext highlighter-rouge">tracing</code> and
OTel</a>.
    <ul>
      <li>It uses the <code class="language-plaintext highlighter-rouge">r3bl_terminal_async</code> crate to allow async, non-blocking readline
functionality, along with <code class="language-plaintext highlighter-rouge">stdout</code> and <code class="language-plaintext highlighter-rouge">stderr</code> that are also async.</li>
      <li>This crate is also used to configure Jaeger and tracing subscribers for file, stdout
logging.</li>
    </ul>
  </li>
  <li>
    <p><a href="https://github.com/nazmulidris/rust-scratch/tree/main/tcp-api-server#tokio-tracing-usage">README for <code class="language-plaintext highlighter-rouge">tcp-api-server</code> crate, which shows how to use Jaeger, and configure file
logging and stdout
logging</a>.</p>
  </li>
  <li>
    <p><a href="https://github.com/r3bl-org/r3bl-open-core/blob/nazmulidris/refactor-tokio-tracing/terminal_async/src/public_api/tracing_setup.rs">How to build up tracing subscribers using layers (type erasure, decl macros,
etc)</a>.</p>
  </li>
  <li>
    <p><a href="https://github.com/nazmulidris/rust-scratch/pull/34">How to add an OTel layer to a
subscriber</a>.</p>
  </li>
  <li><a href="https://github.com/r3bl-org/r3bl-open-core/pull/326">How the subscriber is configured with custom layers in <code class="language-plaintext highlighter-rouge">r3bl_terminal_async</code>
crate</a>.</li>
</ul>

<h2 id="short-example-to-illustrate-the-use-of-tracing-and-otel-in-rust">Short example to illustrate the use of tracing and OTel in Rust</h2>
<p><a id="markdown-short-example-to-illustrate-the-use-of-tracing-and-otel-in-rust" name="short-example-to-illustrate-the-use-of-tracing-and-otel-in-rust"></a></p>

<p>Let‚Äôs look a single example (that fits in one file) that illustrates the use of tracing
in Rust. You can run <code class="language-plaintext highlighter-rouge">cargo new --lib tracing-otel</code> to create a new library crate, and then run
the following:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo add miette <span class="nt">--features</span> fancy
cargo add tracing tracing-subscriber
cargo add tokio <span class="nt">--features</span> full
</code></pre></div></div>

<p>Then you can add the following code to the <code class="language-plaintext highlighter-rouge">src/main.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">miette</span><span class="p">::</span><span class="n">IntoDiagnostic</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">tracing</span><span class="p">::</span><span class="n">Span</span><span class="p">;</span>

<span class="nd">#[tokio::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">subscriber</span> <span class="o">=</span> <span class="nn">tracing_subscriber</span><span class="p">::</span><span class="nf">fmt</span><span class="p">()</span>
        <span class="nf">.without_time</span><span class="p">()</span>
        <span class="nf">.pretty</span><span class="p">()</span>
        <span class="nf">.with_max_level</span><span class="p">(</span><span class="nn">tracing</span><span class="p">::</span><span class="nn">Level</span><span class="p">::</span><span class="n">DEBUG</span><span class="p">)</span>
        <span class="nf">.finish</span><span class="p">();</span>

    <span class="nn">tracing</span><span class="p">::</span><span class="nn">subscriber</span><span class="p">::</span><span class="nf">set_global_default</span><span class="p">(</span><span class="n">subscriber</span><span class="p">)</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">print_message</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The first part of the code sets up the tracing subscriber. In this case we are using a formatting
subscriber that prints logs to the console. This subscriber is configured to not print the time of
the log message, to pretty print the logs, and to print logs at the <code class="language-plaintext highlighter-rouge">DEBUG</code> level or higher.</p>

<p>When you use <code class="language-plaintext highlighter-rouge">#[attribute]</code> along with <code class="language-plaintext highlighter-rouge">info!</code>, <code class="language-plaintext highlighter-rouge">debug!</code>, etc, Tokio will emit log events
that are associated with a span. This is the ‚Äúemitter‚Äù side of the process. The other side
is the ‚Äúsubscriber‚Äù side, which is where the logs are actually printed to the console, or
sent to a file, or sent to an OTel collector service like Jaeger (using OTLP protocol over
gRPC).</p>

<p>Tokio <code class="language-plaintext highlighter-rouge">tracing</code> allows us to use this simple default subscriber, or create our own custom
subscribers. It even allows a subscriber to be composed from layers. We can create our own
custom layers, or use some default ones (like the level filter layer).</p>

<p>OTel is itself a tracing layer. In the video &amp; <code class="language-plaintext highlighter-rouge">tcp-api-server</code> repo, you will see how to
use OTel with Jaeger, and how to configure the OTel layer with a custom layer.</p>

<p>Next you can add the following code to the <code class="language-plaintext highlighter-rouge">src/main.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[tracing::instrument(fields(arg</span> <span class="nd">=</span> <span class="err">?</span><span class="nd">arg,</span> <span class="nd">client_id),</span> <span class="nd">ret)]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">print_message</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"log message one"</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">prepare_message</span><span class="p">()</span><span class="k">.await</span><span class="p">);</span>

    <span class="nn">Span</span><span class="p">::</span><span class="nf">current</span><span class="p">()</span><span class="nf">.record</span><span class="p">(</span><span class="s">"client_id"</span><span class="p">,</span> <span class="mi">1234</span><span class="p">);</span>

    <span class="nn">tracing</span><span class="p">::</span><span class="nd">warn!</span><span class="p">(</span><span class="s">"log message two"</span><span class="p">);</span>
<span class="p">}</span>

<span class="nd">#[tracing::instrument(ret)]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">prepare_message</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="nn">tracing</span><span class="p">::</span><span class="nd">debug!</span><span class="p">(</span><span class="s">"preparing message"</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="s">"Hello, world!"</span><span class="nf">.to_string</span><span class="p">();</span>
    <span class="nn">tracing</span><span class="p">::</span><span class="nd">debug!</span><span class="p">(</span><span class="s">"message prepared"</span><span class="p">);</span>
    <span class="n">it</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">print_message</code> function is annotated with the <code class="language-plaintext highlighter-rouge">#[tracing::instrument]</code> attribute.
This attribute creates a span for the function, and adds the <code class="language-plaintext highlighter-rouge">arg</code> field to the span along
with the <code class="language-plaintext highlighter-rouge">client_id</code> field. In all the log events are emitted within the span, the <code class="language-plaintext highlighter-rouge">arg</code>
and <code class="language-plaintext highlighter-rouge">client_id</code> field will be included in the log output. This additional context is
provided by a span. And you don‚Äôt have to write any code to the <code class="language-plaintext highlighter-rouge">info!</code>, <code class="language-plaintext highlighter-rouge">warn!</code>, etc
calls to include these fields in the log output.</p>

<p>You can run the code using <code class="language-plaintext highlighter-rouge">cargo run</code>. The code will produce the following output.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   INFO tracing_otel: log message one
    at src/main.rs:38
    in tracing_otel::print_message with arg: "foo"

  DEBUG tracing_otel: preparing message
    at src/main.rs:48
    in tracing_otel::prepare_message
    in tracing_otel::print_message with arg: "foo"

  DEBUG tracing_otel: message prepared
    at src/main.rs:50
    in tracing_otel::prepare_message
    in tracing_otel::print_message with arg: "foo"

   INFO tracing_otel: return: "Hello, world!"
    at src/main.rs:46
    in tracing_otel::prepare_message
    in tracing_otel::print_message with arg: "foo"

Hello, world!

   WARN tracing_otel: log message two
    at src/main.rs:43
    in tracing_otel::print_message with arg: "foo", client_id: 1234

   INFO tracing_otel: return: ()
    at src/main.rs:36
    in tracing_otel::print_message with arg: "foo", client_id: 1234
</code></pre></div></div>

<p>Beyond this simple example, to get started, please check out the video and the
<code class="language-plaintext highlighter-rouge">tcp-api-server</code> repo to get a sense of how this can all be used in a real world example
that has lots of moving parts and pieces. Observability here can tell the story of what
happened in the system, so it can be another way of getting an understanding of the
system‚Äôs behavior.</p>

<h2 id="build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</h2>
<p><a id="markdown-build-with-naz-video-series-on-developerlife.com-youtube-channel" name="build-with-naz-video-series-on-developerlife.com-youtube-channel"></a></p>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a></li>
  <li>Playlists
    <ul>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmwO69E7eiQ-ewnMME8ydgQ5">Build with Naz, async Rust and tokio</a></li>
      <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><summary type="html"><![CDATA[Learn how to use tokio tracing and OpenTelemetry (with Jaeger) in async Rust to instrument your code and collect telemetry data for observability.]]></summary></entry><entry><title type="html">Build with Naz : Rust Polymorphism, dyn, impl, using existing traits, trait objects for testing and extensibility</title><link href="http://developerlife.com/2024/04/28/rust-polymorphism-dyn-impl-trait-objects-for-testing-and-extensibiity/" rel="alternate" type="text/html" title="Build with Naz : Rust Polymorphism, dyn, impl, using existing traits, trait objects for testing and extensibility" /><published>2024-04-28T10:00:00-05:00</published><updated>2024-04-28T10:00:00-05:00</updated><id>http://developerlife.com/2024/04/28/rust-polymorphism-dyn-impl-trait-objects-for-testing-and-extensibiity</id><content type="html" xml:base="http://developerlife.com/2024/04/28/rust-polymorphism-dyn-impl-trait-objects-for-testing-and-extensibiity/"><![CDATA[<p><img class="post-hero-image" src="/assets/rust_polymorphism.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#why-use-polymorphism-in-rust">Why use polymorphism in Rust?</a></li>
  <li><a href="#short-example-to-illustrate-both-approaches">Short example to illustrate both approaches</a></li>
  <li><a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</a></li>
</ul>

<!-- /TOC -->

<h2 id="why-use-polymorphism-in-rust">Why use polymorphism in Rust?</h2>
<p><a id="markdown-why-use-polymorphism-in-rust%3F" name="why-use-polymorphism-in-rust%3F"></a></p>

<p>When it comes to polymorphism in Rust, which means that you want to be intentionally ‚Äúvague‚Äù about
what arguments a function can receive or what values it can return, there are roughly two
approaches: static dispatch and dynamic dispatch. They are both tightly related to the notion of
sidedness in Rust.</p>

<p>There are many legitimate reasons to be intentionally vague about the types of arguments a function
can receive or the values it can return. Here are a few:</p>

<ul>
  <li>Testing: You want swap out the implementation of a function with a test mock or test fixture, so
that you can test the function in isolation.</li>
  <li>Extensibility: You want to accommodate integrations with other code that you don‚Äôt control, and
you want to be able to use dependency injection to provide the intended behaviors (from) systems
that you don‚Äôt control.</li>
  <li>Reuse: You want to reuse the same code in multiple places, since they only operate on on aspect
(or trait) of the data.</li>
</ul>

<p>Here are the two approaches to polymorphism in Rust:</p>

<table>
  <thead>
    <tr>
      <th>static</th>
      <th>dynamic</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>receive</td>
      <td>receive</td>
    </tr>
    <tr>
      <td>return</td>
      <td>return</td>
    </tr>
  </tbody>
</table>

<p>There are pros and cons to each approach:</p>

<table>
  <thead>
    <tr>
      <th>approach</th>
      <th>pros</th>
      <th>cons</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>static</td>
      <td>Compile time checks and dispatch. No runtime overhead.</td>
      <td>Code is more difficult to read and write since generics and their often verbose trait bounds have to be spread to the caller.</td>
    </tr>
    <tr>
      <td>dynamic</td>
      <td>Code is more concise and easier to read and write since the trait objects are localized to the function that accepts or returns them.</td>
      <td>Runtime overhead due to dynamic dispatch. Vtable lookup is required due to type erasure.</td>
    </tr>
  </tbody>
</table>

<p>Here are some helpful links to learn more about this topic:</p>

<ul>
  <li><a href="https://www.youtube.com/watch?v=xcygqF5LVmM&amp;t=1162s">Great Crust of Rust video on monomorphization, generics, vtables, fat pointers, static dispatch, and dynamic dispatch</a></li>
  <li><a href="https://developerlife.com/2022/03/12/rust-redux/#of-things-and-their-managers">Vtables</a></li>
  <li><a href="https://developerlife.com/assets/rust-container-cheat-sheet.svg">Diagram of sizes</a></li>
  <li><a href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/sizedness-in-rust.md">Sizedness</a></li>
  <li><a href="https://gemini.google.com/app/157980ca7d9b588c">Difference between using <code class="language-plaintext highlighter-rouge">Arc</code> and <code class="language-plaintext highlighter-rouge">Box</code> with <code class="language-plaintext highlighter-rouge">dyn</code></a></li>
  <li><a href="https://rust-unofficial.github.io/too-many-lists/index.html">Book on <code class="language-plaintext highlighter-rouge">dyn</code> and <code class="language-plaintext highlighter-rouge">Box</code></a></li>
</ul>

<h2 id="video-of-this-in-action-in-the-real-world">Video of this in action in the real world</h2>
<p><a id="markdown-video-of-this-in-action-in-the-real-world" name="video-of-this-in-action-in-the-real-world"></a></p>

<p>This blog post only has a short example to illustrate both approaches to polymorphism in
Rust. To see how these ideas can be used in production code, with real-world examples,
please watch the following video on the <a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube
channel</a>.</p>

<!-- video on rust polymorphism (no playlist) -->
<iframe src="https://www.youtube.com/embed/kYTgGtJjSro?si=XmW-_CAvCfB5e269" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<h2 id="short-example-to-illustrate-both-approaches">Short example to illustrate both approaches</h2>
<p><a id="markdown-short-example-to-illustrate-both-approaches" name="short-example-to-illustrate-both-approaches"></a></p>

<p>The code for this example lives
<a href="https://github.com/nazmulidris/rust-scratch/tree/main/dyn-dispatch/src">here</a>.</p>

<p>Let‚Äôs look a single example (that fits in one file) that illustrates both approaches to polymorphism
in Rust. You can run <code class="language-plaintext highlighter-rouge">cargo new --lib dyn-dispatch</code> to create a new library crate, and then run
<code class="language-plaintext highlighter-rouge">cargo add rand</code>. Then you can add the following code to the <code class="language-plaintext highlighter-rouge">src/lib.rs</code> file.</p>

<p>This first part is the setup for this example. We have two structs, each of which
implements the <a href="https://doc.rust-lang.org/std/io/struct.Error.html"><code class="language-plaintext highlighter-rouge">Error</code></a> trait. We
want to be able to use both structs in functions that can receive or return
<a href="https://doc.rust-lang.org/std/io/struct.Error.html"><code class="language-plaintext highlighter-rouge">Error</code></a> trait objects.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span><span class="p">;</span>

<span class="c1">// ErrorOne.</span>
<span class="k">mod</span> <span class="n">error_one</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="nd">#[derive(Debug)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">ErrorOne</span><span class="p">;</span>

    <span class="k">impl</span> <span class="n">Display</span> <span class="k">for</span> <span class="n">ErrorOne</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"ErrorOne"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">impl</span> <span class="n">Error</span> <span class="k">for</span> <span class="n">ErrorOne</span> <span class="p">{}</span>
<span class="p">}</span>
<span class="k">use</span> <span class="nn">error_one</span><span class="p">::</span><span class="n">ErrorOne</span><span class="p">;</span>

<span class="c1">// ErrorTwo.</span>
<span class="k">mod</span> <span class="n">error_two</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="nd">#[derive(Debug)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">ErrorTwo</span><span class="p">;</span>

    <span class="k">impl</span> <span class="n">Display</span> <span class="k">for</span> <span class="n">ErrorTwo</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"ErrorTwo"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">impl</span> <span class="n">Error</span> <span class="k">for</span> <span class="n">ErrorTwo</span> <span class="p">{}</span>
<span class="p">}</span>
<span class="k">use</span> <span class="nn">error_two</span><span class="p">::</span><span class="n">ErrorTwo</span><span class="p">;</span>
</code></pre></div></div>

<p>In some of the code we will need to make a random decision, so we‚Äôll use the <code class="language-plaintext highlighter-rouge">rand</code> crate to
generate random booleans.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Random boolean generator.</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">random_bool</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="nn">rand</span><span class="p">::</span><span class="nf">random</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here‚Äôs the code for the static dispatch approach, using generics, trait bounds, and compiler
monomorphisation.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Static dispatch.</span>
<span class="k">mod</span> <span class="n">static_dispatch</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">mod</span> <span class="n">receives</span> <span class="p">{</span>
        <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="n">accept_error</span><span class="o">&lt;</span><span class="n">E</span><span class="p">:</span> <span class="n">Error</span><span class="o">&gt;</span><span class="p">(</span><span class="n">error</span><span class="p">:</span> <span class="n">E</span><span class="p">)</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Handling ErrorOne Debug: {:?}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Handling ErrorOne Display: {}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">accept_error_with_syntactic_sugar</span><span class="p">(</span><span class="n">error</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Error</span><span class="p">)</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Handling ErrorOne Debug: {:?}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Handling ErrorOne Display: {}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">mod</span> <span class="n">returns</span> <span class="p">{</span>
        <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">return_error_one</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">ErrorOne</span> <span class="p">{</span>
            <span class="n">ErrorOne</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">return_error_two</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">ErrorTwo</span> <span class="p">{</span>
            <span class="n">ErrorTwo</span>
        <span class="p">}</span>

        <span class="c1">// üö® DOES NOT WORK! Need dynamic dispatch.</span>
        <span class="c1">// pub fn return_single_error() -&gt; impl Error {</span>
        <span class="c1">//     if random_bool() {</span>
        <span class="c1">//         ErrorOne</span>
        <span class="c1">//     } else {</span>
        <span class="c1">//         ErrorTwo</span>
        <span class="c1">//     }</span>
        <span class="c1">// }</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">return_single_error</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="n">Error</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">ErrorOne</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Finally, here‚Äôs the code for the dynamic dispatch approach, using trait objects and vtables to
enable runtime polymorphism.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Dynamic dispatch.</span>
<span class="k">mod</span> <span class="n">dynamic_dispatch</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">mod</span> <span class="n">receives</span> <span class="p">{</span>
        <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">recieve_error_by_ref</span><span class="p">(</span><span class="n">error</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">dyn</span> <span class="n">Error</span><span class="p">)</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Handling Error Debug: {:?}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Handling Error Display: {}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">example_1</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">error_one</span> <span class="o">=</span> <span class="n">ErrorOne</span><span class="p">;</span>
            <span class="nf">recieve_error_by_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">error_one</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">error_two</span> <span class="o">=</span> <span class="n">ErrorTwo</span><span class="p">;</span>
            <span class="nf">recieve_error_by_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">error_two</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">receive_error_by_box</span><span class="p">(</span><span class="n">error</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">Error</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Handling Error Debug: {:?}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Handling Error Display: {}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">example_2</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">error_one</span> <span class="o">=</span> <span class="n">ErrorOne</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">error_one</span><span class="p">);</span>
            <span class="nf">receive_error_by_box</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">error_two</span> <span class="o">=</span> <span class="n">ErrorTwo</span><span class="p">;</span>
            <span class="nf">receive_error_by_box</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">error_two</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">receive_slice_of_errors</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="o">&amp;</span><span class="k">dyn</span> <span class="n">Error</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">for</span> <span class="n">error</span> <span class="k">in</span> <span class="n">arg</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"Handling Error Debug: {:?}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"Handling Error Display: {}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">mod</span> <span class="n">returns</span> <span class="p">{</span>
        <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">return_one_of_two_errors</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nf">random_bool</span><span class="p">()</span> <span class="p">{</span>
                <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">ErrorOne</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">ErrorTwo</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">return_one_of_two_errors_with_arc</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nf">random_bool</span><span class="p">()</span> <span class="p">{</span>
                <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">ErrorOne</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">ErrorTwo</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">return_slice_of_errors</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="k">'static</span> <span class="k">dyn</span> <span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">errors</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="k">dyn</span> <span class="n">Error</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
            <span class="k">if</span> <span class="nf">random_bool</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">errors</span><span class="nf">.push</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ErrorOne</span><span class="p">));</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">errors</span><span class="nf">.push</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ErrorTwo</span><span class="p">));</span>
            <span class="p">}</span>
            <span class="n">errors</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">mut_vec_containing_different_types_of_errors</span><span class="p">(</span><span class="n">mut_vec</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="k">dyn</span> <span class="n">Error</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">mut_vec</span><span class="nf">.push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ErrorOne</span><span class="p">);</span>
            <span class="n">mut_vec</span><span class="nf">.push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ErrorTwo</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</h2>
<p><a id="markdown-build-with-naz-video-series-on-developerlife.com-youtube-channel" name="build-with-naz-video-series-on-developerlife.com-youtube-channel"></a></p>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a>
    <ul>
      <li><a href="https://youtu.be/6LhVx0xM86c">Part 1: Why?</a></li>
      <li><a href="https://youtu.be/3vQJguti02I">Part 2: What?</a></li>
      <li><a href="https://youtu.be/uxgyZzOmVIw">Part 3: Do the refactor and rename the crate</a></li>
      <li><a href="https://www.youtube.com/watch?v=fcb6rstRniI">Part 4: Build the spinner</a></li>
      <li><a href="https://www.youtube.com/watch?v=_QjsGDds270">Part 5: Add color gradient animation to spinner</a></li>
      <li><a href="https://youtu.be/X5wDVaZENOo">Part 6: Publish the crate and overview</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Testing playlist</a>
        <ul>
          <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk">Part 1: Intro</a></li>
          <li><a href="https://www.youtube.com/watch?v=4iM9t5dgvU4">Part 2: Deep dive</a></li>
          <li><a href="https://www.youtube.com/watch?v=kYTgGtJjSro">Part 3: Polymorphism, static and dynamic dispatch</a></li>
        </ul>
      </li>
      <li>Playlists
        <ul>
          <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
          <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><summary type="html"><![CDATA[Learn how to implement effective Rust polymorphism, using `dyn`, `impl`, existing traits, and trait objects for testing and extensibility, in real world projects.]]></summary></entry><entry><title type="html">Build with Naz : Build interactive and non blocking CLI apps with ease in Rust using r3bl_terminal_async</title><link href="http://developerlife.com/2024/04/21/build-async-interactive-cli-apps-in-rust/" rel="alternate" type="text/html" title="Build with Naz : Build interactive and non blocking CLI apps with ease in Rust using r3bl_terminal_async" /><published>2024-04-21T10:00:00-05:00</published><updated>2024-04-21T10:00:00-05:00</updated><id>http://developerlife.com/2024/04/21/build-async-interactive-cli-apps-in-rust</id><content type="html" xml:base="http://developerlife.com/2024/04/21/build-async-interactive-cli-apps-in-rust/"><![CDATA[<p><img class="post-hero-image" src="/assets/r3bl_terminal_async-hero.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#why-use-this-crate">Why use this crate</a></li>
  <li><a href="#demo-of-this-in-action">Demo of this in action</a></li>
  <li><a href="#example-of-using-this-crate">Example of using this crate</a></li>
  <li><a href="#video-series-on-developerlifecom-youtube-channel-on-building-this-crate-with-naz">Video series on developerlife.com YouTube channel on building this crate with Naz</a></li>
</ul>

<!-- /TOC -->

<p>The <code class="language-plaintext highlighter-rouge">r3bl_terminal_async</code> library lets your CLI program be asynchronous and interactive without
blocking the main thread. Your spawned tasks can use it to concurrently write to the display output,
pause and resume it. You can also display of colorful animated spinners ‚åõüåà for long running tasks.
With it, you can create beautiful, powerful, and interactive REPLs (read execute print loops) with
ease.</p>

<h2 id="why-use-this-crate">Why use this crate</h2>

<p><a id="markdown-why-use-this-crate" name="why-use-this-crate"></a></p>

<ul>
  <li>Because <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line">read_line()</a> is
blocking. And there is no way to terminate an OS thread that is blocking in Rust. To do this you
have to exit the process (who‚Äôs thread is blocked in <code class="language-plaintext highlighter-rouge">read_line()</code>).</li>
  <li>Another annoyance is that when a thread is blocked in <code class="language-plaintext highlighter-rouge">read_line()</code>, and you have to display
output to stdout concurrently, this poses some challenges.</li>
</ul>

<h2 id="demo-of-this-in-action">Demo of this in action</h2>

<p><a id="markdown-demo-of-this-in-action" name="demo-of-this-in-action"></a></p>

<p>Here‚Äôs a screen capture of the types of interactive REPLs that you can expect to build in Rust,
using this crate.</p>

<p><img src="https://github.com/r3bl-org/r3bl-open-core/blob/main/terminal_async/docs/r3bl_terminal_async_clip_ffmpeg.gif?raw=true" alt="" /></p>

<p>A couple of things to note about this demo:</p>

<ol>
  <li>You can use up, down to access history in the multi-line editor.</li>
  <li>You can use left, right, ctrl+left, ctrl+right, to jump around in the multi-line editor.</li>
  <li>You can edit content in this multi-line editor without blocking the main thread, and while other
tasks (started via <code class="language-plaintext highlighter-rouge">tokio::spawn</code> are concurrently producing output to the display.</li>
  <li>You can pause the output while spinners are being displayed, and these spinners support many
different kinds of animations!</li>
</ol>

<h2 id="example-of-using-this-crate">Example of using this crate</h2>

<p><a id="markdown-example-of-using-this-crate" name="example-of-using-this-crate"></a></p>

<p>There are great examples in the <code class="language-plaintext highlighter-rouge">examples</code> folder of the repo
<a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/terminal_async/examples">here</a>. Let‚Äôs walk
through a simple example of using this crate. Let‚Äôs create a new example using the following
commands:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo new <span class="nt">--bin</span> async-cli
<span class="nb">cd </span>async-cli
cargo add r3bl_terminal_async
cargo add miette <span class="nt">--features</span> fancy
cargo add tokio <span class="nt">--features</span> full
</code></pre></div></div>

<p>Now, let‚Äôs add a <code class="language-plaintext highlighter-rouge">main.rs</code> file in the <code class="language-plaintext highlighter-rouge">src</code> folder.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="n">Duration</span><span class="p">;</span>

<span class="k">use</span> <span class="nn">r3bl_terminal_async</span><span class="p">::{</span><span class="n">tracing_setup</span><span class="p">,</span> <span class="n">TerminalAsync</span><span class="p">,</span> <span class="n">TracingConfig</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="n">interval</span><span class="p">;</span>

<span class="nd">#[tokio::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">maybe_terminal_async</span> <span class="o">=</span> <span class="nn">TerminalAsync</span><span class="p">::</span><span class="nf">try_new</span><span class="p">(</span><span class="s">"&gt; "</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// If the terminal is not fully interactive, then return early.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">terminal_async</span> <span class="o">=</span> <span class="k">match</span> <span class="n">maybe_terminal_async</span> <span class="p">{</span>
        <span class="nb">None</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nf">Ok</span><span class="p">(()),</span>
        <span class="n">_</span> <span class="k">=&gt;</span> <span class="n">maybe_terminal_async</span><span class="nf">.unwrap</span><span class="p">(),</span>
    <span class="p">};</span>

    <span class="c1">// Initialize tracing w/ the "async stdout".</span>
    <span class="nn">tracing_setup</span><span class="p">::</span><span class="nf">init</span><span class="p">(</span><span class="nn">TracingConfig</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span>
        <span class="n">terminal_async</span><span class="nf">.clone_shared_writer</span><span class="p">(),</span>
    <span class="p">)))</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Start tasks.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">interval_1_task</span> <span class="o">=</span> <span class="nf">interval</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">interval_2_task</span> <span class="o">=</span> <span class="nf">interval</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>

    <span class="n">terminal_async</span>
        <span class="nf">.println</span><span class="p">(</span><span class="s">"Welcome to your async repl! press Ctrl+D or Ctrl+C to exit."</span><span class="p">)</span>
        <span class="k">.await</span><span class="p">;</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span> <span class="p">{</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">interval_1_task</span><span class="nf">.tick</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">terminal_async</span><span class="nf">.println</span><span class="p">(</span><span class="s">"interval_1_task ticked"</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
            <span class="p">},</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">interval_2_task</span><span class="nf">.tick</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">terminal_async</span><span class="nf">.println</span><span class="p">(</span><span class="s">"interval_1_task ticked"</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
            <span class="p">},</span>
            <span class="n">user_input</span> <span class="o">=</span> <span class="n">terminal_async</span><span class="nf">.get_readline_event</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="k">match</span> <span class="n">user_input</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">readline_event</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">match</span> <span class="n">readline_event</span> <span class="p">{</span>
                        <span class="nn">r3bl_terminal_async</span><span class="p">::</span><span class="nn">ReadlineEvent</span><span class="p">::</span><span class="n">Eof</span> <span class="k">=&gt;</span> <span class="k">break</span><span class="p">,</span>
                        <span class="nn">r3bl_terminal_async</span><span class="p">::</span><span class="nn">ReadlineEvent</span><span class="p">::</span><span class="n">Interrupted</span> <span class="k">=&gt;</span> <span class="k">break</span><span class="p">,</span>
                        <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">(),</span>
                    <span class="p">}</span>

                    <span class="k">let</span> <span class="n">msg</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">readline_event</span><span class="p">);</span>
                    <span class="n">terminal_async</span><span class="nf">.println</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
                <span class="p">},</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">msg</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"Received err: {:?}. Exiting."</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
                    <span class="n">terminal_async</span><span class="nf">.println</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">},</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Flush all writers to stdout</span>
    <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="n">terminal_async</span><span class="nf">.flush</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>You can then run this program using <code class="language-plaintext highlighter-rouge">cargo run</code>. Play with it to get a sense of the asynchronous and
non blocking nature of the REPL. Press Ctrl+C, or Ctrl+D to exit this program.</p>

<h2 id="video-series-on-developerlifecom-youtube-channel-on-building-this-crate-with-naz">Video series on developerlife.com YouTube channel on building this crate with Naz</h2>

<p><a id="markdown-video-series-on-developerlife.com-youtube-channel-on-building-this-crate-with-naz" name="video-series-on-developerlife.com-youtube-channel-on-building-this-crate-with-naz"></a></p>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<p>Here‚Äôs the video that is tied to this blog post:</p>

<iframe src="https://www.youtube.com/embed/X5wDVaZENOo?si=yYfXuCxSilWh4Gd5" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a>
    <ul>
      <li><a href="https://youtu.be/6LhVx0xM86c">Part 1: Why?</a></li>
      <li><a href="https://youtu.be/3vQJguti02I">Part 2: What?</a></li>
      <li><a href="https://youtu.be/uxgyZzOmVIw">Part 3: Do the refactor and rename the crate</a></li>
      <li><a href="https://www.youtube.com/watch?v=fcb6rstRniI">Part 4: Build the spinner</a></li>
      <li><a href="https://www.youtube.com/watch?v=_QjsGDds270">Part 5: Add color gradient animation to spinner</a></li>
      <li><a href="https://youtu.be/X5wDVaZENOo">Part 6: Publish the crate and overview</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Testing playlist</a>
        <ul>
          <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk">Part 1: Intro</a></li>
          <li><a href="https://www.youtube.com/watch?v=4iM9t5dgvU4">Part 2: Deep dive</a></li>
        </ul>
      </li>
      <li>Playlists
        <ul>
          <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
          <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><summary type="html"><![CDATA[The r3bl_terminal_async library lets your CLI program be asynchronous and interactive without blocking the main thread. Your spawned tasks can use it to concurrently write to the display output, pause and resume it. You can also display of colorful animated spinners ‚åõüåà for long running tasks. With it, you can create beautiful, powerful, and interactive REPLs (read execute print loops) with ease.]]></summary></entry><entry><title type="html">Write a simple TCP chat server in Rust</title><link href="http://developerlife.com/2024/01/13/write-simple-chat-server-in-rust/" rel="alternate" type="text/html" title="Write a simple TCP chat server in Rust" /><published>2024-01-13T09:00:00-06:00</published><updated>2024-01-13T09:00:00-06:00</updated><id>http://developerlife.com/2024/01/13/write-simple-chat-server-in-rust</id><content type="html" xml:base="http://developerlife.com/2024/01/13/write-simple-chat-server-in-rust/"><![CDATA[<p><img class="post-hero-image" src="/assets/chatserver-hero.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#build-a-chat-server-using-tokio">Build a chat server using Tokio</a></li>
  <li><a href="#the-chat-server-comprises-all-these-pieces">The chat server comprises all these pieces</a></li>
  <li><a href="#add-dependencies-to-cargotoml">Add dependencies to Cargo.toml</a></li>
  <li><a href="#main-function">Main function</a>
    <ul>
      <li><a href="#tokiospawn-does-not-spawn-a-new-thread-so-what-does-it-actually-do">tokio::spawn does not spawn a new thread, so what does it actually do?</a></li>
    </ul>
  </li>
  <li><a href="#handle-client-task-function">Handle client task function</a>
    <ul>
      <li><a href="#two-concurrent-tasks-in-the-tokioselect-block">Two concurrent tasks in the tokio::select! block</a></li>
      <li><a href="#handle-read-from-broadcast-channel-function">Handle read from broadcast channel function</a></li>
      <li><a href="#handle-socket-read-function">Handle socket read function</a></li>
    </ul>
  </li>
  <li><a href="#next-steps">Next steps</a></li>
</ul>

<!-- /TOC -->

<h2 id="build-a-chat-server-using-tokio">Build a chat server using Tokio</h2>
<p><a id="markdown-build-a-chat-server-using-tokio" name="build-a-chat-server-using-tokio"></a></p>

<p>In this tutorial we will build a simple chat server using Tokio. The server will be able
to handle multiple clients, and each client will be able to send messages to the server,
which will then broadcast the message to all other connected clients.</p>

<ul>
  <li>We will use Tokio‚Äôs <code class="language-plaintext highlighter-rouge">tokio::net::TcpListener</code> and <code class="language-plaintext highlighter-rouge">tokio::net::TcpStream</code> to create a
TCP server that listens for incoming connections and handles them concurrently.</li>
  <li>We will also use Tokio‚Äôs <code class="language-plaintext highlighter-rouge">tokio::sync::broadcast</code> to broadcast messages to all connected
clients.</li>
</ul>

<p>Read <a href="/2024/01/13/write-simple-netcat-in-rust/">this tutorial</a> to
learn more about the basics of TCP client and server programming in Rust (without using
Tokio).</p>

<!--
simple-netcat-in-rust video
Source: https://github.com/nazmulidris/developerlife.com/issues/4
-->
<blockquote>
  <p>Here‚Äôs a video of the app that we are going to build in action.</p>
  <video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/14ce32ce-0988-4853-acd5-1174b1864d57" type="video/mp4" />
</video>
</blockquote>
<blockquote>

üëÄ Watch Rust ü¶Ä live coding videos on our <a href="https://www.youtube.com/@developerlifecom">YouTube Channel</a>.

<br />
<br />

<!-- video on rust polymorphism (no playlist) -->
<iframe src="https://www.youtube.com/embed/kYTgGtJjSro?si=XmW-_CAvCfB5e269" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<br />
<br />

üì¶ Install our useful Rust command line apps using <code>cargo install r3bl-cmdr</code>
(they are from the <a href="https://github.com/r3bl-org/r3bl-open-core">r3bl-open-core</a>
project):
<ul>
  <li>üê±<code>giti</code>: run interactive git commands with confidence in your terminal</li>
  <li>ü¶ú<code>edi</code>: edit Markdown with style in your terminal</li>
</ul>

<p>
<kbd>giti in action</kbd>
<video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/262f59d1-a95c-4af3-accf-c3d6cac6e586" type="video/mp4" />
</video>
</p>

<p>
<kbd>edi in action</kbd>
<video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/f2c4b07d-b5a2-4f41-af7a-06d1b6660c41" type="video/mp4" />
</video>
</p>

</blockquote>
<blockquote>
  <p>You can find the finished source code for this tutorial
<a href="https://github.com/nazmulidris/rust-scratch/tree/main/tcp-server-netcat-client">here</a>.</p>
</blockquote>

<h2 id="the-chat-server-comprises-all-these-pieces">The chat server comprises all these pieces</h2>
<p><a id="markdown-the-chat-server-comprises-all-these-pieces" name="the-chat-server-comprises-all-these-pieces"></a></p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   ‚îå‚îÄCLIENT-1‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄCLIENT‚îÄ2‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄCLIENT‚îÄ3‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ                ‚îÇ      ‚îÇ                ‚îÇ        ‚îÇ               ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ                      ‚îÇ                        ‚îÇ
‚îå‚îÄSERVER‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ          ‚îÇ                      ‚îÇ                        ‚îÇ            ‚îÇ
‚îÇ                                                                       ‚îÇ
‚îÇ handle_client_task()   handle_client_task()    handle_client_task()   ‚îÇ
‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ  ‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ ‚îÇ
‚îÇ ‚îÇ   ‚îÇ TX ‚îÇ ‚îÇ RX ‚îÇ   ‚îÇ ‚îÇ   ‚îÇ TX ‚îÇ ‚îÇ RX ‚îÇ    ‚îÇ  ‚îÇ    ‚îÇ TX ‚îÇ ‚îÇ RX ‚îÇ    ‚îÇ ‚îÇ
‚îÇ ‚îÇ   ‚îî‚îÄ‚î¨‚îÄ‚îÄ‚îò ‚îî‚îÄ‚ñ≤‚îÄ‚îÄ‚îò   ‚îÇ ‚îÇ   ‚îî‚îÄ‚î¨‚îÄ‚îÄ‚îò ‚îî‚îÄ‚ñ≤‚îÄ‚îÄ‚îò    ‚îÇ  ‚îÇ    ‚îî‚îÄ‚î¨‚îÄ‚îÄ‚îò ‚îî‚îÄ‚ñ≤‚îÄ‚îÄ‚îò    ‚îÇ ‚îÇ
‚îÇ ‚îÇ     ‚îÇ      ‚îÇ      ‚îÇ ‚îÇ     ‚îÇ      ‚îÇ       ‚îÇ  ‚îÇ      ‚îÇ      ‚îÇ       ‚îÇ ‚îÇ
‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ       ‚îÇ      ‚îÇ              ‚îÇ      ‚îÇ                 ‚îÇ      ‚îÇ         ‚îÇ
‚îÇ       ‚îÇ      ‚îÇ              ‚îÇ      ‚îÇ                 ‚îÇ      ‚îÇ         ‚îÇ
‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ ‚îÇ                    (TX, RX) = channel::broadcast()                ‚îÇ ‚îÇ
‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre></div></div>

<!-- Diagram source
https://asciiflow.com/#/share/eJztVs1Kw0AQfpVlTy1E0ApiA54kB0E8xCI5LJTYBhRjhDZCSylIzh56CCXP4TlP0ydxwzbtbnY2bdL1p9VhApOdmW9mv0yWneDAffawGbz6voF9d%2BwNsIknBI8INtvnxwbBY2q1ztrUCr1RSF8IRpks4pTq5fWVddM5OmFvsqKlLOL3RfzGoqnRog%2BkM0X8qSqekCDvBhVEqB7J3qjcexjIAqCMzbcAoRf8B4RfQ9dAMTSLqWJGmSa7ZeedA2QUpcSV%2BSgS286tZd9Zdj0q9kXZZvUQp%2BRSmVRTeOAHN%2Bj7XrfnP3pB2A3d4VOjyaKUHnUKD6yFXpQf1LvpTBtMcYsl3xI4QZfeaIPzZ4oA7IMfRCwu8TqDlgpNVU6CmkUdZ2XaDoKbi1gUM22Ho4RrZkNQBabmH2VMxeJBnORLWVa%2BJDVXMQmYnVUzwijx86OKiLYI%2BC%2F45QU1naP8tSAVf7aSRV4TbTDCFpGSDrSNV%2B389iIC7XOtdw2NaHWh5M3KJGbS6DgGPUeb6AL16GUh8HzTvB%2B8uP2eOwzzuwLArvax%2F7UKzKY22WPgP6gET%2FH0Ex1Q3VY%3D)
-->

<p>The server has a <code class="language-plaintext highlighter-rouge">main</code> function that creates a <code class="language-plaintext highlighter-rouge">tokio::net::TcpListener</code> and listens for
incoming connections. When a new connection is received, it spawns a new task to handle
the connection using <code class="language-plaintext highlighter-rouge">tokio::spawn()</code>.</p>

<p>Using <code class="language-plaintext highlighter-rouge">tokio::select!</code>, the task tries to do the following concurrently, and waits until
one of them completes:</p>
<ol>
  <li>The task reads messages from its client and broadcasts them to all other connected
clients. It also echoes the message back to its client.</li>
  <li>The task listens for messages from other clients and sends them to its client.</li>
</ol>

<p>When one task above completes, the other is dropped. Then the code path with the completed
task executes. Then the code returns to the infinite loop, if it hasn‚Äôt returned already.</p>

<p>A client can be any TCP client, such as <code class="language-plaintext highlighter-rouge">telnet</code>, <code class="language-plaintext highlighter-rouge">nc</code>, or PuTTY.</p>

<h2 id="add-dependencies-to-cargotoml">Add dependencies to Cargo.toml</h2>
<p><a id="markdown-add-dependencies-to-cargo.toml" name="add-dependencies-to-cargo.toml"></a></p>

<p>Let‚Äôs create a new project by running <code class="language-plaintext highlighter-rouge">cargo create --bin tcp-server-netcat-client</code>. Then
we will add the following dependencies to our <code class="language-plaintext highlighter-rouge">Cargo.toml</code> file.</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># tokio.</span>
<span class="py">tokio</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"1.35.1"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"full"</span><span class="p">]</span> <span class="p">}</span>

<span class="c"># stdout logging.</span>
<span class="py">femme</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"2.2.1"</span> <span class="p">}</span>
<span class="py">log</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.4.20"</span> <span class="p">}</span>

<span class="c"># r3bl_rs_utils_core - friendly name generator.</span>
<span class="py">r3bl_rs_utils_core</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.9.12"</span> <span class="p">}</span>
<span class="py">r3bl_tui</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.5.1"</span> <span class="p">}</span>
</code></pre></div></div>

<h2 id="main-function">Main function</h2>
<p><a id="markdown-main-function" name="main-function"></a></p>

<p>We will implement the following algorithm for our server in our main function:</p>
<ol>
  <li>Create a broadcast channel. It will be shared by all the client tasks.</li>
  <li>Create <code class="language-plaintext highlighter-rouge">TcpListener</code> and bind to an address &amp; port.</li>
  <li>Loop:
    <ul>
      <li>Accept socket connection, and get its <code class="language-plaintext highlighter-rouge">TCPStream</code>.</li>
      <li>Use <code class="language-plaintext highlighter-rouge">tokio::spawn()</code> to spawn a task to handle this client connection and its
<code class="language-plaintext highlighter-rouge">TCPStream</code>.</li>
    </ul>
  </li>
</ol>

<p>In the task that handles the connection:</p>
<ol>
  <li>Get <code class="language-plaintext highlighter-rouge">BufReader</code> &amp; <code class="language-plaintext highlighter-rouge">BufWriter</code> from the <code class="language-plaintext highlighter-rouge">TCPStream</code>. The reader and writer allow us to
read data from and write data to the client socket.</li>
  <li>Loop:
    <ul>
      <li>Use <code class="language-plaintext highlighter-rouge">tokio::select!</code> to concurrently:
        <ul>
          <li>Read from broadcast channel (via <code class="language-plaintext highlighter-rouge">recv()</code>):
            <ul>
              <li>Send the message to the client (only if it is from a different client) over the
socket (use <code class="language-plaintext highlighter-rouge">BufWriter</code> to write the message).</li>
            </ul>
          </li>
          <li>Read from socket (via <code class="language-plaintext highlighter-rouge">BufReader::read_line()</code>):
            <ul>
              <li>Read <code class="language-plaintext highlighter-rouge">incoming</code> from reader.</li>
              <li>Call <code class="language-plaintext highlighter-rouge">process(incoming)</code> and generate <code class="language-plaintext highlighter-rouge">outgoing</code>. This colorizes the <code class="language-plaintext highlighter-rouge">incoming</code>
message with a lolcat effect to generate the <code class="language-plaintext highlighter-rouge">outgoing</code> message.</li>
              <li>Send <code class="language-plaintext highlighter-rouge">incoming</code> message to other connected clients (via the broadcast channel).</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<blockquote>
  <p>You can find the finished source code for this tutorial
<a href="https://github.com/nazmulidris/rust-scratch/tree/main/tcp-server-netcat-client">here</a>.</p>
</blockquote>

<p>Here‚Äôs the code for the main function, and some supporting type aliases and structs:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">type</span> <span class="n">IOResult</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">MsgType</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">socket_addr</span><span class="p">:</span> <span class="n">SocketAddr</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">payload</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">from_id</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[tokio::main]</span>
<span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">IOResult</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">addr</span> <span class="o">=</span> <span class="s">"127.0.0.1:3000"</span><span class="p">;</span>

    <span class="c1">// Start logging.</span>
    <span class="nn">femme</span><span class="p">::</span><span class="nf">start</span><span class="p">();</span>

    <span class="c1">// Create TCP listener.</span>
    <span class="k">let</span> <span class="n">tcp_listener</span> <span class="o">=</span> <span class="nn">TcpListener</span><span class="p">::</span><span class="nf">bind</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
    <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"Server is ready to accept connections on {}"</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

    <span class="c1">// Create channel shared among all clients that connect to the server loop.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="nn">broadcast</span><span class="p">::</span><span class="nn">channel</span><span class="p">::</span><span class="o">&lt;</span><span class="n">MsgType</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

    <span class="c1">// Server loop.</span>
    <span class="k">loop</span> <span class="p">{</span>
        <span class="c1">// Accept incoming socket connections.</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">tcp_stream</span><span class="p">,</span> <span class="n">socket_addr</span><span class="p">)</span> <span class="o">=</span> <span class="n">tcp_listener</span><span class="nf">.accept</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">tx</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">handle_client_task</span><span class="p">(</span><span class="n">tcp_stream</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="n">socket_addr</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
            <span class="k">match</span> <span class="n">result</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"handle_client_task() terminated gracefully"</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">log</span><span class="p">::</span><span class="nd">error!</span><span class="p">(</span><span class="s">"handle_client_task() encountered error: {}"</span><span class="p">,</span> <span class="n">error</span><span class="p">),</span>
            <span class="p">}</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To run the server, you can run <code class="language-plaintext highlighter-rouge">cargo run</code>. There are no command line arguments to pass or
parse.</p>

<h3 id="tokiospawn-does-not-spawn-a-new-thread-so-what-does-it-actually-do">tokio::spawn does not spawn a new thread, so what does it actually do?</h3>
<p><a id="markdown-tokio%3A%3Aspawn-does-not-spawn-a-new-thread%2C-so-what-does-it-actually-do%3F" name="tokio%3A%3Aspawn-does-not-spawn-a-new-thread%2C-so-what-does-it-actually-do%3F"></a></p>

<p>Since <code class="language-plaintext highlighter-rouge">tokio::spawn</code> sounds similar to <code class="language-plaintext highlighter-rouge">thread::spawn</code> it might be easy to assume that
<code class="language-plaintext highlighter-rouge">tokio::spawn</code> creates a new thread. This would go against the idea of even using tokio
(which is all about concurrency and non blocking IO), since handling one connection per
thread isn‚Äôt <a href="https://g.co/bard/share/74f433bad400">scalable</a>, which is what we did in
this tutorial: <a href="/2024/01/13/write-simple-netcat-in-rust/">Write a simple TCP chat server in Rust</a>.</p>

<p><code class="language-plaintext highlighter-rouge">tokio::spawn</code> does not create a thread; it creates a Tokio task, which is a
co-operatively scheduled entity that Tokio knows how to schedule on the Tokio runtime (in
turn, the Tokio runtime can have as many worker threads as you want - from 1 upwards).</p>

<p>By using <code class="language-plaintext highlighter-rouge">tokio::spawn</code>, you allow the Tokio runtime to switch to another task at points
in the task where it has a <code class="language-plaintext highlighter-rouge">.await</code>, and only those points. Your alternative, if you don‚Äôt
want multiple tasks, is to use things like <code class="language-plaintext highlighter-rouge">select!</code>, <code class="language-plaintext highlighter-rouge">join!</code> and functions with <code class="language-plaintext highlighter-rouge">select</code>
or ` join` in their name to have concurrent I/O in a single task.</p>

<p>The point of spawning in Tokio is twofold:</p>

<ol>
  <li>If your runtime has multiple threads, then two tasks can execute in parallel on
different threads, reducing latency.</li>
  <li>It is almost always easier to understand a complex program in terms of different tasks
doing their work, than in terms of a single large task doing lots of work concurrently
(e.g. using <code class="language-plaintext highlighter-rouge">select</code> to wait for one of many options, or <code class="language-plaintext highlighter-rouge">join</code> to wait for all options
to finish).</li>
</ol>

<p>More information:</p>
<ol>
  <li>You can get more info on this topic
 <a href="https://users.rust-lang.org/t/socket-per-thread-in-tokio/83712/7">here</a>.</li>
  <li>For an even deeper dive into how Tokio tasks themselves are implemented for intra-task
concurrency, please take a look at this <a href="https://without.boats/blog/let-futures-be-futures/">excellent
article</a>.</li>
</ol>

<h2 id="handle-client-task-function">Handle client task function</h2>
<p><a id="markdown-handle-client-task-function" name="handle-client-task-function"></a></p>

<p>The <code class="language-plaintext highlighter-rouge">handle_client_task</code> function is where all the magic happens.</p>
<ol>
  <li>It reads messages from its client (over TCP socket) and broadcasts them to all other
connected clients.</li>
  <li>It processes the message from its client and echoes it back to its client (over TCP
socket).</li>
  <li>It reads messages from other clients (over broadcast channel) and sends them to its
client (over socket).</li>
</ol>

<p>Here‚Äôs the code for the <code class="language-plaintext highlighter-rouge">handle_client_task()</code> function:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">fn</span> <span class="nf">handle_client_task</span><span class="p">(</span>
    <span class="k">mut</span> <span class="n">tcp_stream</span><span class="p">:</span> <span class="n">TcpStream</span><span class="p">,</span>
    <span class="n">tx</span><span class="p">:</span> <span class="n">Sender</span><span class="o">&lt;</span><span class="n">MsgType</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">socket_addr</span><span class="p">:</span> <span class="n">SocketAddr</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IOResult</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"Handle socket connection from client"</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">id</span> <span class="o">=</span> <span class="nn">friendly_random_id</span><span class="p">::</span><span class="nf">generate_friendly_random_id</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">tx</span><span class="nf">.subscribe</span><span class="p">();</span>

    <span class="c1">// Set up buf reader and writer.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="n">writer</span><span class="p">)</span> <span class="o">=</span> <span class="n">tcp_stream</span><span class="nf">.split</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">reader</span> <span class="o">=</span> <span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">reader</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">writer</span> <span class="o">=</span> <span class="nn">BufWriter</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">writer</span><span class="p">);</span>

    <span class="c1">// Send welcome message to client w/ ids.</span>
    <span class="k">let</span> <span class="n">welcome_msg_for_client</span> <span class="o">=</span>
        <span class="nn">ColorWheel</span><span class="p">::</span><span class="nf">lolcat_into_string</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span><span class="s">"addr: {}, id: {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">socket_addr</span><span class="p">,</span> <span class="n">id</span><span class="p">));</span>
    <span class="n">writer</span><span class="nf">.write</span><span class="p">(</span><span class="n">welcome_msg_for_client</span><span class="nf">.as_bytes</span><span class="p">())</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
    <span class="n">writer</span><span class="nf">.flush</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">incoming</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">tx</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span> <span class="p">{</span>
            <span class="c1">// Read from broadcast channel.</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">rx</span><span class="nf">.recv</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nf">read_from_broadcast_channel</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">socket_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">writer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// Read from socket.</span>
            <span class="n">network_read_result</span> <span class="o">=</span> <span class="n">reader</span><span class="nf">.read_line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">incoming</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">num_bytes_read</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="n">network_read_result</span><span class="o">?</span><span class="p">;</span>
                <span class="c1">// EOF check.</span>
                <span class="k">if</span> <span class="n">num_bytes_read</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="nf">handle_socket_read</span><span class="p">(</span><span class="n">num_bytes_read</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">incoming</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">writer</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="n">socket_addr</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
                <span class="n">incoming</span><span class="nf">.clear</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="two-concurrent-tasks-in-the-tokioselect-block">Two concurrent tasks in the tokio::select! block</h3>
<p><a id="markdown-two-concurrent-tasks-in-the-tokio%3A%3Aselect!-block" name="two-concurrent-tasks-in-the-tokio%3A%3Aselect!-block"></a></p>

<ol>
  <li>Read from broadcast channel. The function <code class="language-plaintext highlighter-rouge">read_from_broadcast_channel()</code> does this work.</li>
  <li>Read from socket. The function <code class="language-plaintext highlighter-rouge">handle_socket_read()</code> does this work.</li>
</ol>

<p>Whichever task completes first, the <code class="language-plaintext highlighter-rouge">tokio::select!</code> block will go down that code path,
and drop the other task.</p>

<h3 id="handle-read-from-broadcast-channel-function">Handle read from broadcast channel function</h3>
<p><a id="markdown-handle-read-from-broadcast-channel-function" name="handle-read-from-broadcast-channel-function"></a></p>

<p>Here‚Äôs the code for the <code class="language-plaintext highlighter-rouge">read_from_broadcast_channel()</code> function:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">fn</span> <span class="nf">read_from_broadcast_channel</span><span class="p">(</span>
    <span class="n">result</span><span class="p">:</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">MsgType</span><span class="p">,</span> <span class="n">RecvError</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">socket_addr</span><span class="p">:</span> <span class="n">SocketAddr</span><span class="p">,</span>
    <span class="n">writer</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">BufWriter</span><span class="o">&lt;</span><span class="n">WriteHalf</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">id</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IOResult</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">result</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">msg</span><span class="p">:</span> <span class="n">MsgType</span> <span class="o">=</span> <span class="n">it</span><span class="p">;</span>
            <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"[{}]: channel: {:?}"</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
            <span class="k">if</span> <span class="n">msg</span><span class="py">.socket_addr</span> <span class="o">!=</span> <span class="n">socket_addr</span> <span class="p">{</span>
                <span class="n">writer</span><span class="nf">.write</span><span class="p">(</span><span class="n">msg</span><span class="py">.payload</span><span class="nf">.as_bytes</span><span class="p">())</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
                <span class="n">writer</span><span class="nf">.flush</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nf">Err</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">log</span><span class="p">::</span><span class="nd">error!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="handle-socket-read-function">Handle socket read function</h3>
<p><a id="markdown-handle-socket-read-function" name="handle-socket-read-function"></a></p>

<p>Here‚Äôs the code for the <code class="language-plaintext highlighter-rouge">handle_socket_read()</code> function:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">fn</span> <span class="nf">handle_socket_read</span><span class="p">(</span>
    <span class="n">num_bytes_read</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">id</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
    <span class="n">incoming</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
    <span class="n">writer</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">BufWriter</span><span class="o">&lt;</span><span class="n">WriteHalf</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">tx</span><span class="p">:</span> <span class="n">Sender</span><span class="o">&lt;</span><span class="n">MsgType</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">socket_addr</span><span class="p">:</span> <span class="n">SocketAddr</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IOResult</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span>
        <span class="s">"[{}]: incoming: {}, size: {}"</span><span class="p">,</span>
        <span class="n">id</span><span class="p">,</span>
        <span class="n">incoming</span><span class="nf">.trim</span><span class="p">(),</span>
        <span class="n">num_bytes_read</span>
    <span class="p">);</span>

    <span class="c1">// Process incoming -&gt; outgoing.</span>
    <span class="k">let</span> <span class="n">outgoing</span> <span class="o">=</span> <span class="nf">process</span><span class="p">(</span><span class="o">&amp;</span><span class="n">incoming</span><span class="p">);</span>

    <span class="c1">// outgoing -&gt; Writer.</span>
    <span class="n">writer</span><span class="nf">.write</span><span class="p">(</span><span class="n">outgoing</span><span class="nf">.as_bytes</span><span class="p">())</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
    <span class="n">writer</span><span class="nf">.flush</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Broadcast outgoing to the channel.</span>
    <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="n">tx</span><span class="nf">.send</span><span class="p">(</span><span class="n">MsgType</span> <span class="p">{</span>
        <span class="n">socket_addr</span><span class="p">,</span>
        <span class="n">payload</span><span class="p">:</span> <span class="n">incoming</span><span class="nf">.to_string</span><span class="p">(),</span>
        <span class="n">from_id</span><span class="p">:</span> <span class="n">id</span><span class="nf">.to_string</span><span class="p">(),</span>
    <span class="p">});</span>

    <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span>
        <span class="s">"[{}]: outgoing: {}, size: {}"</span><span class="p">,</span>
        <span class="n">id</span><span class="p">,</span>
        <span class="n">outgoing</span><span class="nf">.trim</span><span class="p">(),</span>
        <span class="n">num_bytes_read</span>
    <span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">process</span><span class="p">(</span><span class="n">incoming</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="c1">// Remove new line from incoming.</span>
    <span class="k">let</span> <span class="n">incoming_trimmed</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">incoming</span><span class="nf">.trim</span><span class="p">());</span>
    <span class="c1">// Colorize it.</span>
    <span class="k">let</span> <span class="n">outgoing</span> <span class="o">=</span> <span class="nn">ColorWheel</span><span class="p">::</span><span class="nf">lolcat_into_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">incoming_trimmed</span><span class="p">);</span>
    <span class="c1">// Add new line back to outgoing.</span>
    <span class="nd">format!</span><span class="p">(</span><span class="s">"{}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">outgoing</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="next-steps">Next steps</h2>
<p><a id="markdown-next-steps" name="next-steps"></a></p>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><summary type="html"><![CDATA[A guide on how to create write a simple TCP chat server in Rust using Tokio]]></summary></entry><entry><title type="html">Write a simple netcat client and server in Rust</title><link href="http://developerlife.com/2024/01/13/write-simple-netcat-in-rust/" rel="alternate" type="text/html" title="Write a simple netcat client and server in Rust" /><published>2024-01-13T09:00:00-06:00</published><updated>2024-01-13T09:00:00-06:00</updated><id>http://developerlife.com/2024/01/13/write-simple-netcat-in-rust</id><content type="html" xml:base="http://developerlife.com/2024/01/13/write-simple-netcat-in-rust/"><![CDATA[<p><img class="post-hero-image" src="/assets/netcat-hero.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#build-a-swiss-army-knife-for-networking">Build a Swiss Army knife for networking</a></li>
  <li><a href="#add-dependencies-to-cargotoml">Add dependencies to Cargo.toml</a></li>
  <li><a href="#configure-clap-to-parse-command-line-arguments">Configure clap to parse command line arguments</a></li>
  <li><a href="#create-the-client">Create the client</a></li>
  <li><a href="#create-the-server">Create the server</a></li>
  <li><a href="#next-steps">Next steps</a></li>
</ul>

<!-- /TOC -->

<h2 id="build-a-swiss-army-knife-for-networking">Build a Swiss Army knife for networking</h2>
<p><a id="markdown-build-a-swiss-army-knife-for-networking" name="build-a-swiss-army-knife-for-networking"></a></p>

<p>In this tutorial we will learn how to use Rust to write a simple netcat client and server
using the standard library only. A netcat client is like a Swiss Army knife for
networking. It is similar to PuTTY and telnet. You can use it to connect to a server and
send and receive data. We will create an app that can behave both as a client and server.</p>

<ol>
  <li>Our client will allow the user to type a message and send it to any TCP socket server,
and display the response from the server, in an endless loop.</li>
  <li>Our server will listen for incoming TCP connections from clients, and display the
message from the client, and send a response back to the client.</li>
</ol>

<!--
simple-netcat-in-rust video
Source: https://github.com/nazmulidris/developerlife.com/issues/3
-->
<blockquote>
  <p>Here‚Äôs a video of the app that we are going to build in action.</p>
  <video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/ffe83b3e-6997-4afc-bdf3-5d867f995611" type="video/mp4" />
</video>
</blockquote>
<blockquote>

üëÄ Watch Rust ü¶Ä live coding videos on our <a href="https://www.youtube.com/@developerlifecom">YouTube Channel</a>.

<br />
<br />

<!-- video on rust polymorphism (no playlist) -->
<iframe src="https://www.youtube.com/embed/kYTgGtJjSro?si=XmW-_CAvCfB5e269" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<br />
<br />

üì¶ Install our useful Rust command line apps using <code>cargo install r3bl-cmdr</code>
(they are from the <a href="https://github.com/r3bl-org/r3bl-open-core">r3bl-open-core</a>
project):
<ul>
  <li>üê±<code>giti</code>: run interactive git commands with confidence in your terminal</li>
  <li>ü¶ú<code>edi</code>: edit Markdown with style in your terminal</li>
</ul>

<p>
<kbd>giti in action</kbd>
<video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/262f59d1-a95c-4af3-accf-c3d6cac6e586" type="video/mp4" />
</video>
</p>

<p>
<kbd>edi in action</kbd>
<video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/f2c4b07d-b5a2-4f41-af7a-06d1b6660c41" type="video/mp4" />
</video>
</p>

</blockquote>
<blockquote>
  <p>You can find the finished source code for this tutorial
<a href="https://github.com/nazmulidris/rust-scratch/tree/main/rtelnet">here</a>.</p>
</blockquote>

<h2 id="add-dependencies-to-cargotoml">Add dependencies to Cargo.toml</h2>
<p><a id="markdown-add-dependencies-to-cargo.toml" name="add-dependencies-to-cargo.toml"></a></p>

<p>Let‚Äôs create a new project by running <code class="language-plaintext highlighter-rouge">cargo create --bin rtelnet</code>. Then we will add the
following dependencies to our <code class="language-plaintext highlighter-rouge">Cargo.toml</code> file.</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Command line argument parsing.</span>
<span class="py">clap</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"4.4.13"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"derive"</span><span class="p">]</span> <span class="p">}</span>

<span class="c"># Pretty logging.</span>
<span class="py">femme</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"2.2.1"</span> <span class="p">}</span>
<span class="py">log</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.4.20"</span> <span class="p">}</span>

<span class="c"># Colorization and ANSI escape sequence codes.</span>
<span class="py">r3bl_tui</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.5.1"</span> <span class="p">}</span>
<span class="py">r3bl_ansi_color</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.6.9"</span> <span class="p">}</span>
</code></pre></div></div>

<h2 id="configure-clap-to-parse-command-line-arguments">Configure clap to parse command line arguments</h2>
<p><a id="markdown-configure-clap-to-parse-command-line-arguments" name="configure-clap-to-parse-command-line-arguments"></a></p>

<p>This Rust app has a single binary, and depending on the command line arguments, it will behave
either as a client or server. We will use the <code class="language-plaintext highlighter-rouge">clap</code> crate to parse the command line arguments.</p>

<p>We will configure <code class="language-plaintext highlighter-rouge">clap</code> so that the following commands will work:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo run server
cargo run client
</code></pre></div></div>

<p>We want to allow the user to specify the following options and chose their own address and
port. If the user does not specify any options, we will use the default values. The
default value for <code class="language-plaintext highlighter-rouge">--address</code> is <code class="language-plaintext highlighter-rouge">127.0.0.1</code>, and the default value for <code class="language-plaintext highlighter-rouge">--port</code> is
<code class="language-plaintext highlighter-rouge">3000</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo run server <span class="nt">--address</span> 127.0.0.1 <span class="nt">--port</span> 8080
cargo run server <span class="nt">--address</span> 127.0.0.1
cargo run server <span class="nt">--port</span> 8080

cargo run client <span class="nt">--address</span> 127.0.0.1 <span class="nt">--port</span> 8080
cargo run client <span class="nt">--address</span> 127.0.0.1
cargo run client <span class="nt">--port</span> 8080
</code></pre></div></div>

<p>Let‚Äôs also add an option that we can use to disable log output to stdout. By default, we
will log to stdout. But if the user specifies the <code class="language-plaintext highlighter-rouge">--log-disable</code> flag, then we disable
all log output.</p>

<p>Here‚Äôs the clap configuration that gives us this behavior.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">clap</span><span class="p">::{</span><span class="n">Parser</span><span class="p">,</span> <span class="n">Subcommand</span><span class="p">};</span>

<span class="k">pub</span> <span class="k">use</span> <span class="nn">defaults</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
<span class="k">mod</span> <span class="n">defaults</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">pub</span> <span class="k">const</span> <span class="n">DEFAULT_PORT</span><span class="p">:</span> <span class="nb">u16</span> <span class="o">=</span> <span class="mi">3000</span><span class="p">;</span>
    <span class="k">pub</span> <span class="k">const</span> <span class="n">DEFAULT_ADDRESS</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">"127.0.0.1"</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">use</span> <span class="nn">clap_config</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
<span class="k">mod</span> <span class="n">clap_config</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="nd">#[derive(Parser,</span> <span class="nd">Debug)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">CLIArg</span> <span class="p">{</span>
        <span class="cd">/// IP Address to connect to or start a server on</span>
        <span class="nd">#[clap(long,</span> <span class="nd">short,</span> <span class="nd">default_value</span> <span class="nd">=</span> <span class="nd">DEFAULT_ADDRESS,</span> <span class="nd">global</span> <span class="nd">=</span> <span class="kc">true</span><span class="nd">)]</span>
        <span class="k">pub</span> <span class="n">address</span><span class="p">:</span> <span class="n">IpAddr</span><span class="p">,</span>

        <span class="cd">/// TCP Port to connect to or start a server on</span>
        <span class="nd">#[clap(long,</span> <span class="nd">short,</span> <span class="nd">default_value_t</span> <span class="nd">=</span> <span class="nd">DEFAULT_PORT,</span> <span class="nd">global</span> <span class="nd">=</span> <span class="kc">true</span><span class="nd">)]</span>
        <span class="k">pub</span> <span class="n">port</span><span class="p">:</span> <span class="nb">u16</span><span class="p">,</span>

        <span class="cd">/// Logs to stdout by default, set this flag to disable it</span>
        <span class="nd">#[clap(long,</span> <span class="nd">short</span> <span class="nd">=</span> <span class="sc">'d'</span><span class="nd">,</span> <span class="nd">global</span> <span class="nd">=</span> <span class="kc">true</span><span class="nd">)]</span>
        <span class="k">pub</span> <span class="n">log_disable</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>

        <span class="cd">/// The subcommand to run</span>
        <span class="nd">#[clap(subcommand)]</span>
        <span class="k">pub</span> <span class="n">subcommand</span><span class="p">:</span> <span class="n">CLISubcommand</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="nd">#[derive(Subcommand,</span> <span class="nd">Debug)]</span>
    <span class="k">pub</span> <span class="k">enum</span> <span class="n">CLISubcommand</span> <span class="p">{</span>
        <span class="cd">/// Start a server on the given address and port</span>
        <span class="n">Server</span><span class="p">,</span>
        <span class="cd">/// Connect to a server running on the given address and port</span>
        <span class="n">Client</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="create-the-client">Create the client</h2>
<p><a id="markdown-create-the-client" name="create-the-client"></a></p>

<p>Let‚Äôs start with the simpler of the two, the client. We will use <code class="language-plaintext highlighter-rouge">std::net::TcpStream</code> to
create a TCP socket client. We will need an IP address and port in order to make a TCP
connection. And to run the client we will need to run the following command:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo run client
</code></pre></div></div>

<p>Here‚Äôs what the main function of our app looks like:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Welcome to rtelnet"</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">cli_arg</span> <span class="o">=</span> <span class="nn">CLIArg</span><span class="p">::</span><span class="nf">parse</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">address</span> <span class="o">=</span> <span class="n">cli_arg</span><span class="py">.address</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">port</span> <span class="o">=</span> <span class="n">cli_arg</span><span class="py">.port</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">socket_address</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{}:{}"</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>

    <span class="k">if</span> <span class="o">!</span><span class="n">cli_arg</span><span class="py">.log_disable</span> <span class="p">{</span>
        <span class="nn">femme</span><span class="p">::</span><span class="nf">start</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">match</span> <span class="k">match</span> <span class="n">cli_arg</span><span class="py">.subcommand</span> <span class="p">{</span>
        <span class="nn">CLISubcommand</span><span class="p">::</span><span class="n">Server</span> <span class="k">=&gt;</span> <span class="nf">start_server</span><span class="p">(</span><span class="n">socket_address</span><span class="p">),</span>
        <span class="nn">CLISubcommand</span><span class="p">::</span><span class="n">Client</span> <span class="k">=&gt;</span> <span class="nf">start_client</span><span class="p">(</span><span class="n">socket_address</span><span class="p">),</span>
    <span class="p">}</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Program exited successfully"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nf">Err</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Program exited with an error: {}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The function that performs the client logic looks like this.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">start_client</span><span class="p">(</span><span class="n">socket_address</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IOResult</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"Start client connection"</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">tcp_stream</span> <span class="o">=</span> <span class="nn">TcpStream</span><span class="p">::</span><span class="nf">connect</span><span class="p">(</span><span class="n">socket_address</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="p">(</span><span class="k">mut</span> <span class="n">reader</span><span class="p">,</span> <span class="k">mut</span> <span class="n">writer</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_stream</span><span class="p">),</span> <span class="nn">BufWriter</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_stream</span><span class="p">));</span>

    <span class="c1">// Client loop.</span>
    <span class="k">loop</span> <span class="p">{</span>
        <span class="c1">// Read user input.</span>
        <span class="k">let</span> <span class="n">outgoing</span> <span class="o">=</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">it</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="nf">stdin</span><span class="p">()</span><span class="nf">.read_line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">it</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="n">it</span><span class="nf">.as_bytes</span><span class="p">()</span><span class="nf">.to_vec</span><span class="p">()</span>
        <span class="p">};</span>

        <span class="c1">// Tx user input to writer.</span>
        <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="n">writer</span><span class="nf">.write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">outgoing</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="n">writer</span><span class="nf">.flush</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

        <span class="c1">// Rx response from reader.</span>
        <span class="k">let</span> <span class="n">incoming</span> <span class="o">=</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">it</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
            <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="n">reader</span><span class="nf">.read_until</span><span class="p">(</span><span class="sc">b'\n'</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">it</span><span class="p">);</span>
            <span class="n">it</span>
        <span class="p">};</span>

        <span class="k">let</span> <span class="n">display_msg</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_lossy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">incoming</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">display_msg</span> <span class="o">=</span> <span class="n">display_msg</span><span class="nf">.trim</span><span class="p">();</span>

        <span class="k">let</span> <span class="n">reset</span> <span class="o">=</span> <span class="nn">SgrCode</span><span class="p">::</span><span class="n">Reset</span><span class="nf">.to_string</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">display_msg</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{}{}"</span><span class="p">,</span> <span class="n">display_msg</span><span class="p">,</span> <span class="n">reset</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">display_msg</span><span class="p">);</span>

        <span class="c1">// Print debug.</span>
        <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span>
            <span class="s">"-&gt; Tx: '{}', size: {} bytes{}"</span><span class="p">,</span>
            <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_lossy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">outgoing</span><span class="p">)</span><span class="nf">.trim</span><span class="p">(),</span>
            <span class="n">outgoing</span><span class="nf">.len</span><span class="p">(),</span>
            <span class="n">reset</span><span class="p">,</span>
        <span class="p">);</span>
        <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span>
            <span class="s">"&lt;- Rx: '{}', size: {} bytes{}"</span><span class="p">,</span>
            <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_lossy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">incoming</span><span class="p">)</span><span class="nf">.trim</span><span class="p">(),</span>
            <span class="n">incoming</span><span class="nf">.len</span><span class="p">(),</span>
            <span class="n">reset</span><span class="p">,</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here are a few things to note about the client code:</p>
<ul>
  <li>We create a <code class="language-plaintext highlighter-rouge">BufReader</code> and <code class="language-plaintext highlighter-rouge">BufWriter</code> for the <code class="language-plaintext highlighter-rouge">TcpStream</code> that we get from
<code class="language-plaintext highlighter-rouge">TcpStream::connect()</code>. This is because we want to read and write data in chunks, and
not one byte at a time, for performance reasons, and to simplify the logic. These two
structs allow us to read and write data very easily in chunks that are delimited by new
lines (<code class="language-plaintext highlighter-rouge">\n</code>).</li>
  <li>There‚Äôs a client loop that runs forever. This is because we want to keep the client
running forever, so that the user can type a message and send it to the server, and
receive a response from the server.</li>
  <li>How do we exit this infinite client loop? Only when the user presses <code class="language-plaintext highlighter-rouge">Ctrl+C</code> will the
client exit. The <a href="https://g.co/bard/share/ac5d3480eb37">default behavior</a> for Rust is to
exit the process when this happens. This drops the TCP connection causing the server to exit as
well.</li>
  <li>When we read data from user input, it too uses a stream, not a <code class="language-plaintext highlighter-rouge">TcpStream</code>, but the
<code class="language-plaintext highlighter-rouge">stdin()</code> stream. This behaves very similarly to the <code class="language-plaintext highlighter-rouge">TcpStream</code> stream. We can read
data from it in chunks delimited by new lines (<code class="language-plaintext highlighter-rouge">\n</code>). Once the user types a message and
presses enter that message, eg: <code class="language-plaintext highlighter-rouge">"hi"</code>, and the new line are stored in the <code class="language-plaintext highlighter-rouge">it</code>
variable, eg: <code class="language-plaintext highlighter-rouge">"hi\n"</code>. We then convert the String into a byte array, eg: <code class="language-plaintext highlighter-rouge">[104, 105,
10]</code>, and then convert it into a <code class="language-plaintext highlighter-rouge">Vec&lt;u8&gt;</code>. We then send it to the server. We must call
<code class="language-plaintext highlighter-rouge">flush()</code> since <code class="language-plaintext highlighter-rouge">BufWriter</code> buffers the data and does not send it to the server until we
call <code class="language-plaintext highlighter-rouge">flush()</code> for IO performance reasons. It queue‚Äôs up the data and sends it in
chunks, instead of sending it one byte at a time.</li>
  <li>Reading there response from the server is similar to reading it from <code class="language-plaintext highlighter-rouge">stdin()</code> as we
have already seen. The main thread blocks until there is some data that can be read from
the server. Or if the TCP connection errors out in any way (timeout or closed by various
means). If there is an error, then this function returns an error, and the main thread
exits. Note that the <code class="language-plaintext highlighter-rouge">start_client()</code> function itself returns an <code class="language-plaintext highlighter-rouge">IOResult</code>, which is
just a type alias for <code class="language-plaintext highlighter-rouge">pub type IOResult&lt;T&gt; = std::io::Result&lt;T&gt;;</code>. The error handling
is quite simple. If there is an error, we print it out and exit the program.</li>
  <li>We read the data from the server into the <code class="language-plaintext highlighter-rouge">incoming</code> variable using
<code class="language-plaintext highlighter-rouge">reader.read_until(b'\n', &amp;mut it);)</code>. This is because we expect the server to send us
data that is terminated by a new line (<code class="language-plaintext highlighter-rouge">\n</code>). So we read the data until we encounter a
new line. This is a blocking call, so the main thread blocks until there is some data
that can be read from the server. Note that the <code class="language-plaintext highlighter-rouge">\n</code> is included in <code class="language-plaintext highlighter-rouge">incoming</code> variable,
much like it is in <code class="language-plaintext highlighter-rouge">stdin()</code>.
    <ul>
      <li>We use this function <code class="language-plaintext highlighter-rouge">String::from_utf8_lossy(&amp;incoming);</code> to convert this <code class="language-plaintext highlighter-rouge">incoming:
Vec&lt;u8&gt;</code> into a <code class="language-plaintext highlighter-rouge">String</code>. We call <code class="language-plaintext highlighter-rouge">.trim()</code> on the String, so that the trailing <code class="language-plaintext highlighter-rouge">\n</code>
is removed.</li>
      <li>Note that <code class="language-plaintext highlighter-rouge">trim()</code> returns a <code class="language-plaintext highlighter-rouge">&amp;str</code>, so if you want to turn it into a String, you have
to run in through this expression <code class="language-plaintext highlighter-rouge">format!("{}",
String::from_utf8_lossy(&amp;incoming).trim())</code> function.</li>
    </ul>
  </li>
  <li>This is a pedagogical example and this algorithm is somewhat contrived to demonstrate
how to send bytes back and forth between client and server and have them interpret the
bytes in a certain way. A more formalized version of this ‚Äúdance‚Äù is called a
‚Äúprotocol‚Äù, eg: HTTP, SMTP, etc.</li>
  <li>In the final step of the <code class="language-plaintext highlighter-rouge">loop</code>, after the incoming data has been read from the server,
we print it out to the terminal. Since the server will send us ANSI escape sequence
codes that colorize the text that we print to the terminal, we want to reset the color
after we print the text, so it does not pollute our <code class="language-plaintext highlighter-rouge">stdout()</code> output stream. We use the
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/ansi_color/src/ansi_escape_codes.rs#L23"><code class="language-plaintext highlighter-rouge">SgrCode::Reset</code> code to reset the
color</a>
of the text that we print to the terminal.</li>
</ul>

<h2 id="create-the-server">Create the server</h2>
<p><a id="markdown-create-the-server" name="create-the-server"></a></p>

<p>Now let‚Äôs create the server. We will use <code class="language-plaintext highlighter-rouge">std::net::TcpListener</code> to create a TCP socket
server. We will need an IP address and port in order to make a TCP connection. To run the
server we will need to run the following command:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo run server
</code></pre></div></div>

<p>The server code is very similar to the client code. We need a server loop that runs
forever, and we need to first read (blocking until there is any data available) and then
write data in chunks delimited by new lines (<code class="language-plaintext highlighter-rouge">\n</code>). When there is no data available to
read <code class="language-plaintext highlighter-rouge">EOF</code> is reached on the reader (aka, input TCP stream) then we break out of this loop
and exit. When data comes in (delimited by <code class="language-plaintext highlighter-rouge">\n</code>) we process it and send a response back to
the client. We process this data by applying a <a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/color_wheel/color_wheel_struct.rs#L457">lolcat
effect</a>
on it, so the client will get a very colorful version of whatever text message that they
sent to the server.</p>

<p>One more thing we will see when implementing the server is having to spawn multiple
threads to handle each incoming client connection. While the client is a single threaded
app, the server is a multi-threaded app. The client is only concerned w/ a single TCP
connection, but the server is concerned with multiple TCP connections, each connection
emanating from a different client process running the <code class="language-plaintext highlighter-rouge">cargo run client</code> and creating a
new OS process. Fortunately Rust is built for fearless concurrency and parallelism from
the ground up.</p>

<p>Here‚Äôs the main function of our server app:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">start_server</span><span class="p">(</span><span class="n">socket_address</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IOResult</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">tcp_listener</span> <span class="o">=</span> <span class="nn">TcpListener</span><span class="p">::</span><span class="nf">bind</span><span class="p">(</span><span class="n">socket_address</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="c1">// Server connection accept loop.</span>
    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"Waiting for a incoming connection..."</span><span class="p">);</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">tcp_stream</span><span class="p">,</span> <span class="o">..</span><span class="p">)</span> <span class="o">=</span> <span class="n">tcp_listener</span><span class="nf">.accept</span><span class="p">()</span><span class="o">?</span><span class="p">;</span> <span class="c1">// This is a blocking call.</span>

        <span class="c1">// Spawn a new thread to handle this connection.</span>
        <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(||</span> <span class="k">match</span> <span class="nf">handle_connection</span><span class="p">(</span><span class="n">tcp_stream</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"Successfully closed connection to client..."</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">log</span><span class="p">::</span><span class="nd">error!</span><span class="p">(</span><span class="s">"Problem with client connection..."</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here are a few things to note about the server code:</p>
<ul>
  <li>We are using <code class="language-plaintext highlighter-rouge">IOResult</code> just like the client code. There are frequent calls to the <code class="language-plaintext highlighter-rouge">?</code>
operator, which is shorthand for matching on the <code class="language-plaintext highlighter-rouge">Result</code> and returning early if there‚Äôs
an error. This is rudimentary error handling, and its good enough for this pedagogical
example. Note that even in this pedagogical example, we don‚Äôt use the <code class="language-plaintext highlighter-rouge">unwrap()</code> method
which will induce a panic if there‚Äôs an error. We always use the <code class="language-plaintext highlighter-rouge">?</code> operator, which
will return early if there‚Äôs an error. It isn‚Äôt a good idea to get into the habit of
using <code class="language-plaintext highlighter-rouge">unwrap()</code> outside of tests. These habits are hard to break once they‚Äôre formed.
You can even add the following
<a href="https://rust-lang.github.io/rust-clippy/master/index.html#/unwrap_used"><code class="language-plaintext highlighter-rouge">#![warn(clippy::unwrap_in_result)]</code></a>
in the top level module of your project to have the compiler warn you if you use
<code class="language-plaintext highlighter-rouge">unwrap()</code> outside of tests. Here‚Äôs an
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/ansi_color/src/lib.rs#L171">example</a>.</li>
  <li>The first thing the server has to do is reserve a port on the given address. This is called
binding, and we do it using <code class="language-plaintext highlighter-rouge">TcpListener::bind(socket_address)?;</code>. This does not start a server
yet. It just reserves a port on the given address, assuming that it is available. If some other
process has already bound to that port, then this will return an error.</li>
  <li>Once we have a <code class="language-plaintext highlighter-rouge">TcpListener</code> instance, we can call <code class="language-plaintext highlighter-rouge">accept()</code> on it to start listening
for incoming connections. This is a blocking call, so the main thread blocks until there
is an incoming connection. Once there is an incoming connection, we get a <code class="language-plaintext highlighter-rouge">TcpStream</code>
instance, which we can use to read and write data to the client. This is a blocking
call. Which means that the main thread won‚Äôt be able to do anything else, like process
other incoming connections, while it is waiting here, for a connection to come in.</li>
  <li>This is why we use <code class="language-plaintext highlighter-rouge">thread::spawn()</code> to create a new thread and have it handle the
incoming connection. We spawn a new thread for each incoming connection. This is <a href="https://g.co/bard/share/74f433bad400">not a
scalable solution</a>, but it is good enough for this
pedagogical example. We will learn about more scalable solutions in a the <a href="/2024/01/13/write-simple-chat-server-in-rust/">Write a
simple TCP chat server in Rust</a> tutorial.</li>
</ul>

<p>Now, let‚Äôs look at the <code class="language-plaintext highlighter-rouge">handle_connection()</code> function that is called by the spawned
thread. This is the function that handles the incoming connection from the client. And it
defines our ‚Äúprotocol‚Äù, along with the client code. We aren‚Äôt using any formalized
protocol like HTTP or SMTP. We are just sending bytes back and forth between the client
and server, and interpreting them in a certain way, which is our informal protocol. This
code is very similar to the client side code, including the <code class="language-plaintext highlighter-rouge">loop</code> and the <code class="language-plaintext highlighter-rouge">BufReader</code> and
<code class="language-plaintext highlighter-rouge">BufWriter</code> structs. And even looking for <code class="language-plaintext highlighter-rouge">EOF</code> to break out of the loop. Except that we
don‚Äôt block on <code class="language-plaintext highlighter-rouge">stdin()</code> for input here.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">handle_connection</span><span class="p">(</span><span class="n">tcp_stream</span><span class="p">:</span> <span class="n">TcpStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IOResult</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"Start handle connection"</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">reader</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_stream</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">write</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">BufWriter</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_stream</span><span class="p">);</span>

    <span class="c1">// Process client connection loop.</span>
    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">incoming</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="c1">// Read from reader.</span>
        <span class="k">let</span> <span class="n">num_bytes_read</span> <span class="o">=</span> <span class="n">reader</span><span class="nf">.read_until</span><span class="p">(</span><span class="sc">b'\n'</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">incoming</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="c1">// Check for EOF. The stream is closed.</span>
        <span class="k">if</span> <span class="n">num_bytes_read</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Process.</span>
        <span class="k">let</span> <span class="n">outgoing</span> <span class="o">=</span> <span class="nf">process</span><span class="p">(</span><span class="o">&amp;</span><span class="n">incoming</span><span class="p">);</span>

        <span class="c1">// Write to writer.</span>
        <span class="n">write</span><span class="nf">.write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">outgoing</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="n">write</span><span class="nf">.flush</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

        <span class="c1">// Print debug.</span>
        <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"-&gt; Rx(bytes) : {:?}"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">incoming</span><span class="p">);</span>
        <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span>
            <span class="s">"-&gt; Rx(string): '{}', size: {} bytes"</span><span class="p">,</span>
            <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_lossy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">incoming</span><span class="p">)</span><span class="nf">.trim</span><span class="p">(),</span>
            <span class="n">incoming</span><span class="nf">.len</span><span class="p">(),</span>
        <span class="p">);</span>
        <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span>
            <span class="s">"&lt;- Tx(string): '{}', size: {} bytes"</span><span class="p">,</span>
            <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_lossy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">outgoing</span><span class="p">)</span><span class="nf">.trim</span><span class="p">(),</span>
            <span class="n">outgoing</span><span class="nf">.len</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"End handle connection - connection closed"</span><span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Finally, let‚Äôs look at the <code class="language-plaintext highlighter-rouge">process()</code> function that takes the incoming bytes to the
outgoing bytes. This is where we add some fun and color and flair to our app. We colorize
the incoming bytes using a lolcat effect and send it back to the client.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">r3bl_tui</span><span class="p">::</span><span class="n">ColorWheel</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">process</span><span class="p">(</span><span class="n">incoming</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Convert incoming to String, and remove any trailing whitespace (includes newline).</span>
    <span class="k">let</span> <span class="n">incoming</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_lossy</span><span class="p">(</span><span class="n">incoming</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">incoming</span> <span class="o">=</span> <span class="n">incoming</span><span class="nf">.trim</span><span class="p">();</span>

    <span class="c1">// Prepare outgoing payload.</span>
    <span class="k">let</span> <span class="n">outgoing</span> <span class="o">=</span> <span class="n">incoming</span><span class="nf">.to_string</span><span class="p">();</span>

    <span class="c1">// Colorize it w/ a gradient.</span>
    <span class="k">let</span> <span class="n">outgoing</span> <span class="o">=</span> <span class="nn">ColorWheel</span><span class="p">::</span><span class="nf">lolcat_into_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">outgoing</span><span class="p">);</span>

    <span class="c1">// Generate outgoing response. Add newline to the end of output (so client can process it).</span>
    <span class="k">let</span> <span class="n">outgoing</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">outgoing</span><span class="p">);</span>

    <span class="c1">// Return outgoing payload.</span>
    <span class="n">outgoing</span><span class="nf">.as_bytes</span><span class="p">()</span><span class="nf">.to_vec</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="next-steps">Next steps</h2>
<p><a id="markdown-next-steps" name="next-steps"></a></p>

<p>Now that you have a handle on the basics of writing a simple netcat client and server, you
can read <a href="/2024/01/13/write-simple-chat-server-in-rust/">this tutorial</a> to learn more about creating a more advanced TCP server that netcat,
telnet, or PuTTY clients can connect to, in order to have multiple client apps chat with
each other.</p>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><summary type="html"><![CDATA[A guide on how to a simple Rust netcat client and server]]></summary></entry><entry><title type="html">How to overcome your fear of git merge conflicts</title><link href="http://developerlife.com/2023/09/22/overcome-your-fear-of-merge-conflicts/" rel="alternate" type="text/html" title="How to overcome your fear of git merge conflicts" /><published>2023-09-22T00:00:00-05:00</published><updated>2023-09-22T00:00:00-05:00</updated><id>http://developerlife.com/2023/09/22/overcome-your-fear-of-merge-conflicts</id><content type="html" xml:base="http://developerlife.com/2023/09/22/overcome-your-fear-of-merge-conflicts/"><![CDATA[<p><img class="post-hero-image" src="/assets/git-merge-conflict-hero.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#setting-the-stage-for-a-merge-conflict">Setting the stage for a merge conflict</a></li>
  <li><a href="#picture-1-how-we-got-here">Picture 1: How we got here</a></li>
  <li><a href="#picture-2-the-conflict-when-develop-is-applied-to-main">Picture 2: The conflict when develop is applied to main</a></li>
  <li><a href="#picture-3-how-to-understand-the-diff">Picture 3: How to understand the diff</a></li>
  <li><a href="#picture-4-how-to-resolve-the-conflict">Picture 4: How to resolve the conflict</a></li>
  <li><a href="#next-steps">Next steps</a></li>
</ul>

<!-- /TOC -->

<h2 id="introduction">Introduction</h2>
<p><a id="markdown-introduction" name="introduction"></a></p>

<p>There are few things that generate as much fear and anxiety in developers as <code class="language-plaintext highlighter-rouge">git</code> merge
conflicts. <code class="language-plaintext highlighter-rouge">git</code> is very popular and very powerful, and it is a low level command line
tool. And it is not very user friendly. It is meant to be orchestrate-able and automated
using scripts and CI/CD tools, and build systems; it is extremely flexible. It is not
meant to be used in an interactive manner w/ a human user at the keyboard.</p>

<p>This just creates an opportunity for others to come along and craft user experiences on
top of <code class="language-plaintext highlighter-rouge">git</code> that are more use case driven. And these UXes can come in the form or GUIs,
TUIs, or even conversational interfaces.</p>

<p>But that‚Äôs not the focus of this article which is all about the CLI experience of inducing
and resolving merge conflicts. So let‚Äôs get started.</p>
<blockquote>

üëÄ Watch Rust ü¶Ä live coding videos on our <a href="https://www.youtube.com/@developerlifecom">YouTube Channel</a>.

<br />
<br />

<!-- video on rust polymorphism (no playlist) -->
<iframe src="https://www.youtube.com/embed/kYTgGtJjSro?si=XmW-_CAvCfB5e269" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<br />
<br />

üì¶ Install our useful Rust command line apps using <code>cargo install r3bl-cmdr</code>
(they are from the <a href="https://github.com/r3bl-org/r3bl-open-core">r3bl-open-core</a>
project):
<ul>
  <li>üê±<code>giti</code>: run interactive git commands with confidence in your terminal</li>
  <li>ü¶ú<code>edi</code>: edit Markdown with style in your terminal</li>
</ul>

<p>
<kbd>giti in action</kbd>
<video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/262f59d1-a95c-4af3-accf-c3d6cac6e586" type="video/mp4" />
</video>
</p>

<p>
<kbd>edi in action</kbd>
<video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/f2c4b07d-b5a2-4f41-af7a-06d1b6660c41" type="video/mp4" />
</video>
</p>

</blockquote>
<h2 id="setting-the-stage-for-a-merge-conflict">Setting the stage for a merge conflict</h2>
<p><a id="markdown-setting-the-stage-for-a-merge-conflict" name="setting-the-stage-for-a-merge-conflict"></a></p>

<p>Let‚Äôs create a local repo from scratch and set things up so that we can predictably
generate a merge conflict. Here‚Äôs what we will do at a high level:</p>
<ol>
  <li>Create a local repo.</li>
  <li>Create a <code class="language-plaintext highlighter-rouge">main</code> branch.</li>
  <li>Create a file in the <code class="language-plaintext highlighter-rouge">main</code> branch and add some content to it.</li>
  <li>Create a <code class="language-plaintext highlighter-rouge">feature</code> branch based on the <code class="language-plaintext highlighter-rouge">main</code> branch.</li>
  <li>Modify the file in the <code class="language-plaintext highlighter-rouge">feature</code> branch.</li>
  <li>Modify the same file in the <code class="language-plaintext highlighter-rouge">main</code> branch with a change that is going to conflict w/ a change in <code class="language-plaintext highlighter-rouge">feature</code> branch.</li>
  <li>Merge the <code class="language-plaintext highlighter-rouge">feature</code> branch into the <code class="language-plaintext highlighter-rouge">main</code> branch.</li>
</ol>

<p>Here‚Äôs a script to get you started:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/usr/bin/env bash</span>

<span class="c"># Create a local repo.</span>
<span class="nb">export </span><span class="nv">TMP_REPO_DIR</span><span class="o">=</span><span class="s2">"~/Downloads/tmp/git-merge-conflict-demo"</span>
<span class="k">if</span> <span class="o">[</span> <span class="nt">-d</span> <span class="nv">$TMP_REPO_DIR</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"Folder exists, recreating </span><span class="nv">$TMP_REPO_DIR</span><span class="s2">"</span>
  <span class="nb">rm</span> <span class="nt">-rf</span> <span class="nv">$TMP_REPO_DIR</span>
  <span class="nb">mkdir</span> <span class="nt">-p</span> <span class="nv">$TMP_REPO_DIR</span>
<span class="k">else
  </span><span class="nb">echo</span> <span class="s2">"Folder does not exist, creating </span><span class="nv">$TMP_REPO_DIR</span><span class="s2">"</span>
  <span class="nb">mkdir</span> <span class="nt">-p</span> <span class="nv">$TMP_REPO_DIR</span>
<span class="k">fi
</span><span class="nb">cd</span> <span class="nv">$TMP_REPO_DIR</span>
git init
git checkout <span class="nt">-b</span> main

<span class="c"># Create a file in the main branch and add some content to it.</span>
<span class="c"># This is the "OG change".</span>
<span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"This is a new feature.</span><span class="se">\n</span><span class="s2">## 3. Example 3"</span> <span class="o">&gt;</span> file.txt
git add file.txt
git commit <span class="nt">-m</span> <span class="s2">"Add myexample3"</span>

<span class="c"># Create a develop branch based on the main branch.</span>
git checkout <span class="nt">-b</span> develop main

<span class="c"># Person A comes along and changes this line w/ a plus in the develop branch.</span>
<span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"This is a new feature.</span><span class="se">\n</span><span class="s2">## 3. Example 3+"</span> <span class="o">&gt;</span> file.txt
git add file.txt
git commit <span class="nt">-m</span> <span class="s2">"Fix typo w/ plus in develop branch"</span>

<span class="c"># Person B comes along and change this line w/ a minus in the main branch.</span>
<span class="c"># This is going to conflict with the change in the develop branch.</span>
git checkout main
<span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"This is a new feature.</span><span class="se">\n</span><span class="s2">## 3. Example 3-"</span> <span class="o">&gt;</span> file.txt
git add file.txt
git commit <span class="nt">-m</span> <span class="s2">"Fix typo w/ minus in main branch"</span>

<span class="c"># Merge (using rebase, so no extra commit) the develop branch into the main branch.</span>
git rebase develop
</code></pre></div></div>

<p>This results in a merge conflict. And when you run <code class="language-plaintext highlighter-rouge">git diff</code> it looks like this:</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh">diff --cc file.txt
index 89da142,ef43c8f..0000000
</span><span class="gd">--- a/file.txt
</span><span class="gi">+++ b/file.txt
</span>@@@ -1,2 -1,2 +1,8 @@@
  This is a new feature.
<span class="gi">++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
</span> +## 3. Example 3+
<span class="gi">++||||||| parent of 7c0f0e4 (Fix typo w/ - in main branch)
++## 3. Example 3
++=======
+ ## 3. Example 3-
++&gt;&gt;&gt;&gt;&gt;&gt;&gt; 7c0f0e4 (Fix typo w/ - in main branch)
</span></code></pre></div></div>

<p>Let‚Äôs use some pictures to understand the story of how we got here. And how to resolve this.</p>

<h2 id="picture-1-how-we-got-here">Picture 1: How we got here</h2>
<p><a id="markdown-picture-1%3A-how-we-got-here" name="picture-1%3A-how-we-got-here"></a></p>

<p><img src="/assets/git-merge-conflicts/act1.svg" alt="" /></p>

<h2 id="picture-2-the-conflict-when-develop-is-applied-to-main">Picture 2: The conflict when develop is applied to main</h2>
<p><a id="markdown-picture-2%3A-the-conflict-when-develop-is-applied-to-main" name="picture-2%3A-the-conflict-when-develop-is-applied-to-main"></a></p>

<p><img src="/assets/git-merge-conflicts/act2.svg" alt="" /></p>

<h2 id="picture-3-how-to-understand-the-diff">Picture 3: How to understand the diff</h2>
<p><a id="markdown-picture-3%3A-how-to-understand-the-diff" name="picture-3%3A-how-to-understand-the-diff"></a></p>

<p><img src="/assets/git-merge-conflicts/act3.svg" alt="" /></p>

<h2 id="picture-4-how-to-resolve-the-conflict">Picture 4: How to resolve the conflict</h2>
<p><a id="markdown-picture-4%3A-how-to-resolve-the-conflict" name="picture-4%3A-how-to-resolve-the-conflict"></a></p>

<p><img src="/assets/git-merge-conflicts/act4.svg" alt="" /></p>

<h2 id="next-steps">Next steps</h2>
<p><a id="markdown-next-steps" name="next-steps"></a></p>]]></content><author><name>Nazmul Idris</name></author><category term="CLI" /><summary type="html"><![CDATA[A visual guide on how to understand git merge conflict messages and resolve them with confidence.]]></summary></entry><entry><title type="html">tuify your clap CLI apps and make them more interactive</title><link href="http://developerlife.com/2023/09/17/tuify-clap/" rel="alternate" type="text/html" title="tuify your clap CLI apps and make them more interactive" /><published>2023-09-17T10:00:00-05:00</published><updated>2023-09-17T10:00:00-05:00</updated><id>http://developerlife.com/2023/09/17/tuify-clap</id><content type="html" xml:base="http://developerlife.com/2023/09/17/tuify-clap/"><![CDATA[<p><img class="post-hero-image" src="/assets/tuify-clap-hero.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#cli-design-concepts">CLI design concepts</a></li>
  <li><a href="#show-me">Show me</a></li>
  <li><a href="#the-r3bl_tuify-crate-and-clap">The r3bl_tuify crate and clap</a>
    <ul>
      <li><a href="#example-1-add-interactivity-using-a-list-selection-component">Example 1: Add interactivity using a list selection component</a></li>
      <li><a href="#example-2-adding-interactivity-using-a-text-input-field">Example 2: Adding interactivity using a text input field</a></li>
    </ul>
  </li>
  <li><a href="#next-steps">Next steps</a></li>
</ul>

<!-- /TOC -->

<h2 id="introduction">Introduction</h2>
<p><a id="markdown-introduction" name="introduction"></a></p>

<p>As developers we tend to spend a lot of time in the terminal. It is a great place to exercise
precise control over our computers. And it is a great place to automate tasks. However, there are
some rough edges to this experience. For example, even though the interaction metaphor w/ CLI apps
is a conversation, we have to be very precise in the language we use in this conversation. Lots of
trial and error, patience and resilience are required to make it work. And it does not have to be
this way.</p>

<p>To use a racing analogy, terminals are like race cars. They are fast and powerful, and you can
exercise direct and precise control over them. But if you get things wrong, there can be
consequences. Porsche is a car company that
<a href="https://en.wikipedia.org/wiki/List_of_24_Hours_of_Le_Mans_winners#By_manufacturer">wins endurance races</a>,
and a very long time ago, they decided to make a race car that was friendly to the ergonomics of
their drivers.</p>

<p>The thinking was that if the driver is comfortable, they will perform better, and the 24 hour race
wins will be just a little bit closer within reach. Similarly, we can add some interactivity to our
CLI apps to make them more ergonomic to use. And we can do this without going full TUI. We can do
this in a way that is additive to the existing CLI experience. We can ‚Äútuify‚Äù our CLI apps that are
built using <code class="language-plaintext highlighter-rouge">clap</code>.</p>
<blockquote>

üëÄ Watch Rust ü¶Ä live coding videos on our <a href="https://www.youtube.com/@developerlifecom">YouTube Channel</a>.

<br />
<br />

<!-- video on rust polymorphism (no playlist) -->
<iframe src="https://www.youtube.com/embed/kYTgGtJjSro?si=XmW-_CAvCfB5e269" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<br />
<br />

üì¶ Install our useful Rust command line apps using <code>cargo install r3bl-cmdr</code>
(they are from the <a href="https://github.com/r3bl-org/r3bl-open-core">r3bl-open-core</a>
project):
<ul>
  <li>üê±<code>giti</code>: run interactive git commands with confidence in your terminal</li>
  <li>ü¶ú<code>edi</code>: edit Markdown with style in your terminal</li>
</ul>

<p>
<kbd>giti in action</kbd>
<video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/262f59d1-a95c-4af3-accf-c3d6cac6e586" type="video/mp4" />
</video>
</p>

<p>
<kbd>edi in action</kbd>
<video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/f2c4b07d-b5a2-4f41-af7a-06d1b6660c41" type="video/mp4" />
</video>
</p>

</blockquote>
<blockquote>
  <p>For more information on general Rust type system design (functional approach rather than
object oriented), please take a look at this <a href="https://arxiv.org/pdf/2307.07069.pdf">paper</a>
by Will Crichton demonstrating Typed Design Patterns with Rust.</p>
</blockquote>

<h2 id="cli-design-concepts">CLI design concepts</h2>
<p><a id="markdown-cli-design-concepts" name="cli-design-concepts"></a></p>

<p>Here are some great resources to learn more about good CLI design concepts. The Rust crate <code class="language-plaintext highlighter-rouge">clap</code> is
used by a lot of Rust apps to implement this CLI. And in this tutorial we will take a look at how to
add some interactivity to these <code class="language-plaintext highlighter-rouge">clap</code> CLI apps using the <code class="language-plaintext highlighter-rouge">r3bl_tuify</code> crate.</p>

<blockquote>
  <p>Note that these resources are all about CLI and not TUI. There isn‚Äôt very much information out
there about TUIs. It is a new and evolving space.</p>
</blockquote>

<ol>
  <li><a href="https://clig.dev/#foreword">Command Line Interface Guidelines</a></li>
  <li><a href="https://docs.rs/clap/latest/clap/_derive/#overview"><code class="language-plaintext highlighter-rouge">clap</code> docs</a></li>
  <li><a href="https://rust-cli-recommendations.sunshowers.io/handling-arguments.html"><code class="language-plaintext highlighter-rouge">clap</code> command and subcommand structure guidelines</a></li>
  <li><a href="https://rust-cli-recommendations.sunshowers.io/hierarchical-config.html">Hierarchy of configuration</a></li>
</ol>

<p>The CLI guidelines above do a great job of explaining how to create a good CLI experience. However
they do not cover how to add interactivity to your CLI apps. Why would we want to do this? Let‚Äôs
take a real example to illustrate the benefits of this next.</p>

<h2 id="show-me">Show me</h2>
<p><a id="markdown-show-me" name="show-me"></a></p>

<p>This example is a little ‚Äúmeta‚Äù. The <code class="language-plaintext highlighter-rouge">r3bl_tuify</code> crate, that allows interactivity to be added to
<code class="language-plaintext highlighter-rouge">clap</code> CLI apps, is available as a binary and library. The binary which can be used from the command
line (and uses <code class="language-plaintext highlighter-rouge">clap</code>) uses the library to provide an interactive experience when certain arguments
aren‚Äôt provided on the command line.</p>

<p>The idea with the binary target is that you might want to quickly incorporate some interactivity
into your shell scripts without getting into the Rust library. In this case, you can use the <code class="language-plaintext highlighter-rouge">rt</code>
binary target to do that. This binary takes quite a few arguments as you might imagine. However, you
don‚Äôt have to supply all of them at the start.</p>

<p>So instead of typing this massive command at the start (where <code class="language-plaintext highlighter-rouge">cargo run --</code> simply runs the binary
called <code class="language-plaintext highlighter-rouge">rt</code>):</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>TODO.todo | cargo run <span class="nt">--</span> <span class="k">select</span><span class="nt">-from-list</span> <span class="se">\</span>
    <span class="nt">--selection-mode</span> single <span class="se">\</span>
    <span class="nt">--command-to-run-with-each-selection</span> <span class="s2">"echo %"</span>
</code></pre></div></div>

<p>You can simply type the following shorter command and have the app prompt you for the rest of the
information that it needs:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>TODO.todo | cargo run <span class="nt">--</span> <span class="k">select</span><span class="nt">-from-list</span>
</code></pre></div></div>

<p>Here‚Äôs a video of this in action, where the app is prompting the user for two items:</p>

<ol>
  <li>the <code class="language-plaintext highlighter-rouge">selection-mode</code> and</li>
  <li><code class="language-plaintext highlighter-rouge">command-to-run-with-each-selection</code> interactively üéâ:</li>
</ol>

<!-- tuify-interactive-happy-path -->
<video width="100%" controls="">
  <source src="https://github.com/r3bl-org/r3bl-open-core/assets/2966499/51de8867-513b-429f-aff2-63dd25d71c82" type="video/mp4" />
</video>

<h2 id="the-r3bl_tuify-crate-and-clap">The r3bl_tuify crate and clap</h2>
<p><a id="markdown-the-r3bl_tuify-crate-and-clap" name="the-r3bl_tuify-crate-and-clap"></a></p>

<p>The <code class="language-plaintext highlighter-rouge">r3bl_tuify</code> app itself uses <code class="language-plaintext highlighter-rouge">clap</code> to parse the command line arguments. Here‚Äôs an overview of
what that looks like (all of it using the <code class="language-plaintext highlighter-rouge">derive</code> macro approach). Here‚Äôs a link to the
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tuify/src/main.rs#L30"><code class="language-plaintext highlighter-rouge">main.rs::AppArgs</code></a>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Debug,</span> <span class="nd">Parser)]</span>
<span class="nd">#[command(bin_name</span> <span class="nd">=</span> <span class="s">"rt"</span><span class="nd">)]</span>
<span class="nd">#[command(about</span> <span class="nd">=</span> <span class="s">"Easily add lightweight TUI capabilities to any CLI apps using pipes"</span><span class="nd">,</span> <span class="nd">long_about</span> <span class="nd">=</span> <span class="nd">None)]</span>
<span class="nd">#[command(version)]</span>
<span class="nd">#[command(next_line_help</span> <span class="nd">=</span> <span class="kc">true</span><span class="nd">)]</span>
<span class="nd">#[command(arg_required_else_help(</span><span class="kc">true</span><span class="nd">))]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">AppArgs</span> <span class="p">{</span>
    <span class="nd">#[clap(subcommand)]</span>
    <span class="n">command</span><span class="p">:</span> <span class="n">CLICommand</span><span class="p">,</span>

    <span class="nd">#[clap(flatten)]</span>
    <span class="n">global_opts</span><span class="p">:</span> <span class="n">GlobalOpts</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Args)]</span>
<span class="k">struct</span> <span class="n">GlobalOpts</span> <span class="p">{</span>
    <span class="cd">/// Print debug output to log file (log.txt)</span>
    <span class="nd">#[arg(long,</span> <span class="nd">short</span> <span class="nd">=</span> <span class="sc">'l'</span><span class="nd">)]</span>
    <span class="n">enable_logging</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>

    <span class="cd">/// Optional maximum height of the TUI (rows)</span>
    <span class="nd">#[arg(value_name</span> <span class="nd">=</span> <span class="s">"height"</span><span class="nd">,</span> <span class="nd">long,</span> <span class="nd">short</span> <span class="nd">=</span> <span class="sc">'r'</span><span class="nd">)]</span>
    <span class="n">tui_height</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>

    <span class="cd">/// Optional maximum width of the TUI (columns)</span>
    <span class="nd">#[arg(value_name</span> <span class="nd">=</span> <span class="s">"width"</span><span class="nd">,</span> <span class="nd">long,</span> <span class="nd">short</span> <span class="nd">=</span> <span class="sc">'c'</span><span class="nd">)]</span>
    <span class="n">tui_width</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Subcommand)]</span>
<span class="k">enum</span> <span class="n">CLICommand</span> <span class="p">{</span>
    <span class="cd">/// Show TUI to allow you to select one or more options from a list, piped in via stdin üëâ</span>
    <span class="n">SelectFromList</span> <span class="p">{</span>
        <span class="cd">/// Would you like to select one or more items?</span>
        <span class="nd">#[arg(value_name</span> <span class="nd">=</span> <span class="s">"mode"</span><span class="nd">,</span> <span class="nd">long,</span> <span class="nd">short</span> <span class="nd">=</span> <span class="sc">'s'</span><span class="nd">)]</span>
        <span class="n">selection_mode</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">SelectionMode</span><span class="o">&gt;</span><span class="p">,</span>

        <span class="cd">/// Each selected item is passed to this command as `%` and executed in your shell.</span>
        <span class="cd">/// For eg: "echo %". Please wrap the command in quotes üí°</span>
        <span class="nd">#[arg(value_name</span> <span class="nd">=</span> <span class="s">"command"</span><span class="nd">,</span> <span class="nd">long,</span> <span class="nd">short</span> <span class="nd">=</span> <span class="sc">'c'</span><span class="nd">)]</span>
        <span class="n">command_to_run_with_each_selection</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The things to note are that the <code class="language-plaintext highlighter-rouge">selection_mode</code> and <code class="language-plaintext highlighter-rouge">command_to_run_with_each_selection</code> fields of
the <code class="language-plaintext highlighter-rouge">CliCommand::SelectFromList</code> enum are optional. This is where the <code class="language-plaintext highlighter-rouge">r3bl_tuify</code> crate comes in.
It will prompt the user for these two fields if they are not supplied on the command line.</p>

<p>You can add this programmatically using the library to your existing CLI apps.</p>

<blockquote>
  <p>The piping option using the binary is severely limited, so the library option is strongly
recommended. The binary is more of a convenience for shell scripts only on Linux.</p>
</blockquote>

<p>You can see how to use the library to perform this interactivity in
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tuify/src/main.rs#L179"><code class="language-plaintext highlighter-rouge">main.rs::show_tui()</code></a>.</p>

<p>Here are two examples of adding interactivity.</p>

<h3 id="example-1-add-interactivity-using-a-list-selection-component">Example 1: Add interactivity using a list selection component</h3>
<p><a id="markdown-example-1%3A-add-interactivity-using-a-list-selection-component" name="example-1%3A-add-interactivity-using-a-list-selection-component"></a></p>

<p>Here‚Äôs an example of adding interactivity using a list selection component. This is useful
when the values that a field can take are known in advance. In this example, they are
since <code class="language-plaintext highlighter-rouge">selection-mode</code> is a <code class="language-plaintext highlighter-rouge">clap</code> <code class="language-plaintext highlighter-rouge">EnumValue</code> that can only take one of the following
values: <code class="language-plaintext highlighter-rouge">single</code>, or <code class="language-plaintext highlighter-rouge">multiple</code>.</p>

<p>In this scenario, <code class="language-plaintext highlighter-rouge">--selection-mode</code> is <em>not</em> passed in the command line. So it only
interactively prompts the user for this piece of information. Similarly, if the user does
not provide this information, the app exits and provides a help message.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>TODO.todo | cargo run <span class="nt">--</span> <span class="k">select</span><span class="nt">-from-list</span> <span class="nt">--command-to-run-with-each-selection</span> <span class="s2">"echo %"</span>
</code></pre></div></div>

<!-- tuify-interactive-selection-mode-not-provided -->
<video width="100%" controls="">
  <source src="https://github.com/r3bl-org/r3bl-open-core/assets/2966499/be65d9b2-575b-47c0-8291-110340bd2fe7" type="video/mp4" />
</video>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Handle `selection-mode` is not passed in.</span>
<span class="k">let</span> <span class="n">selection_mode</span> <span class="o">=</span> <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">selection_mode</span><span class="p">)</span> <span class="o">=</span> <span class="n">maybe_selection_mode</span> <span class="p">{</span>
    <span class="n">selection_mode</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">possible_values_for_selection_mode</span> <span class="o">=</span>
        <span class="nf">get_possible_values_for_subcommand_and_option</span><span class="p">(</span>
            <span class="s">"select-from-list"</span><span class="p">,</span>
            <span class="s">"selection-mode"</span><span class="p">,</span>
        <span class="p">);</span>
    <span class="nf">print_help_for_subcommand_and_option</span><span class="p">(</span><span class="s">"select-from-list"</span><span class="p">,</span> <span class="s">"selection-mode"</span><span class="p">)</span><span class="nf">.ok</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">user_selection</span> <span class="o">=</span> <span class="nf">select_from_list</span><span class="p">(</span>
        <span class="s">"Choose selection-mode"</span><span class="nf">.to_string</span><span class="p">(),</span>
        <span class="n">possible_values_for_selection_mode</span><span class="p">,</span>
        <span class="n">max_height_row_count</span><span class="p">,</span>
        <span class="n">max_width_col_count</span><span class="p">,</span>
        <span class="nn">SelectionMode</span><span class="p">::</span><span class="n">Single</span><span class="p">,</span>
    <span class="p">);</span>

    <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">user_selection</span><span class="p">)</span> <span class="o">=</span> <span class="n">user_selection</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="o">=</span> <span class="n">user_selection</span><span class="nf">.first</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"selection-mode: {}"</span><span class="p">,</span> <span class="n">it</span><span class="p">);</span>
            <span class="nn">SelectionMode</span><span class="p">::</span><span class="nf">from_str</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span><span class="nf">.unwrap_or</span><span class="p">(</span><span class="nn">SelectionMode</span><span class="p">::</span><span class="n">Single</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">print_help_for</span><span class="p">(</span><span class="s">"select-from-list"</span><span class="p">)</span><span class="nf">.ok</span><span class="p">();</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nf">print_help_for</span><span class="p">(</span><span class="s">"select-from-list"</span><span class="p">)</span><span class="nf">.ok</span><span class="p">();</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">it</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="example-2-adding-interactivity-using-a-text-input-field">Example 2: Adding interactivity using a text input field</h3>
<p><a id="markdown-example-2%3A-adding-interactivity-using-a-text-input-field" name="example-2%3A-adding-interactivity-using-a-text-input-field"></a></p>

<p>Here‚Äôs an example of adding interactivity using a text input field. This is useful when the values
that a field can take are not known in advance. The <code class="language-plaintext highlighter-rouge">r3bl_tuify</code> crate uses the <code class="language-plaintext highlighter-rouge">reedline</code> crate to
do this.</p>

<blockquote>
  <p>Fun fact: <a href="https://docs.rs/reedline/"><code class="language-plaintext highlighter-rouge">reedline</code></a> is the text input field (line editor)
that is used in <a href="https://github.com/nushell/nushell"><code class="language-plaintext highlighter-rouge">nushell</code></a>.</p>
</blockquote>

<p>In this scenario, <code class="language-plaintext highlighter-rouge">--command-to-run-with-each-selection</code> is <em>not</em> passed in the command
line. So it only interactively prompts the user for this piece of information. Similarly,
if the user does not provide this information, the app exits and provides a help message.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>TODO.todo | cargo run <span class="nt">--</span> <span class="k">select</span><span class="nt">-from-list</span> <span class="nt">--selection-mode</span> single
</code></pre></div></div>

<!-- tuify-interactive-command-to-run-with-selection-not-provided -->
<video width="100%" controls="">
  <source src="https://github.com/r3bl-org/r3bl-open-core/assets/2966499/d8d7d419-c85e-4c10-bea5-345aa31a92a3" type="video/mp4" />
</video>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Handle `command-to-run-with-each-selection` is not passed in.</span>
<span class="k">let</span> <span class="n">command_to_run_with_each_selection</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">maybe_command_to_run_with_each_selection</span> <span class="p">{</span>
        <span class="nf">Some</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">it</span><span class="p">,</span>
        <span class="nb">None</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nf">print_help_for_subcommand_and_option</span><span class="p">(</span>
                <span class="s">"select-from-list"</span><span class="p">,</span>
                <span class="s">"command-to-run-with-each-selection"</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="nf">.ok</span><span class="p">();</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">line_editor</span> <span class="o">=</span> <span class="nn">Reedline</span><span class="p">::</span><span class="nf">create</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">prompt</span> <span class="o">=</span> <span class="n">DefaultPrompt</span> <span class="p">{</span>
                <span class="n">left_prompt</span><span class="p">:</span> <span class="nn">DefaultPromptSegment</span><span class="p">::</span><span class="nf">Basic</span><span class="p">(</span>
                    <span class="s">"Enter command to run w/ each selection `%`: "</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="p">),</span>
                <span class="n">right_prompt</span><span class="p">:</span> <span class="nn">DefaultPromptSegment</span><span class="p">::</span><span class="n">Empty</span><span class="p">,</span>
            <span class="p">};</span>

            <span class="k">let</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">line_editor</span><span class="nf">.read_line</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prompt</span><span class="p">);</span>
            <span class="k">match</span> <span class="n">sig</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="nn">Signal</span><span class="p">::</span><span class="nf">Success</span><span class="p">(</span><span class="n">buffer</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="n">buffer</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
                        <span class="nf">print_help_for</span><span class="p">(</span><span class="s">"select-from-list"</span><span class="p">)</span><span class="nf">.ok</span><span class="p">();</span>
                        <span class="k">return</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="nd">println!</span><span class="p">(</span><span class="s">"Command to run w/ each selection: {}"</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
                    <span class="n">buffer</span>
                <span class="p">}</span>
                <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nf">print_help_for</span><span class="p">(</span><span class="s">"select-from-list"</span><span class="p">)</span><span class="nf">.ok</span><span class="p">();</span>
                    <span class="k">return</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">};</span>

<span class="c1">// Actually get input from the user.</span>
<span class="k">let</span> <span class="n">selected_items</span> <span class="o">=</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="nf">select_from_list</span><span class="p">(</span>
        <span class="s">"Select one line"</span><span class="nf">.to_string</span><span class="p">(),</span>
        <span class="n">lines</span><span class="p">,</span>
        <span class="n">max_height_row_count</span><span class="p">,</span>
        <span class="n">max_width_col_count</span><span class="p">,</span>
        <span class="n">selection_mode</span><span class="p">,</span>
    <span class="p">);</span>
    <span class="nf">convert_user_input_into_vec_of_strings</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="next-steps">Next steps</h2>
<p><a id="markdown-next-steps" name="next-steps"></a></p>

<p>There are many more components that need to be added to make it easier to ‚Äútuify‚Äù lots of
existing CLI experiences. Things like multi line editor component w/ syntax highlighting,
scroll view, form input fields, and more. If you would like to contribute to this effort,
it would be great to have your help.</p>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><summary type="html"><![CDATA[A guide on how to add minimal interactivity to your clap CLI apps using tuify. It doesn't have to be an all or nothing approach w/ going full TUI or CLI.]]></summary></entry><entry><title type="html">Use just to manage project specific commands</title><link href="http://developerlife.com/2023/08/28/justfile/" rel="alternate" type="text/html" title="Use just to manage project specific commands" /><published>2023-08-28T10:00:00-05:00</published><updated>2023-08-28T10:00:00-05:00</updated><id>http://developerlife.com/2023/08/28/justfile</id><content type="html" xml:base="http://developerlife.com/2023/08/28/justfile/"><![CDATA[<p><img class="post-hero-image" src="/assets/justfile.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#prerequisites">Prerequisites</a></li>
  <li><a href="#basic-usage">Basic usage</a></li>
  <li><a href="#advanced-usage">Advanced usage</a>
    <ul>
      <li><a href="#running-many-different-commands">Running many different commands</a></li>
      <li><a href="#run-on-windows">Run on Windows</a></li>
      <li><a href="#run-in-ci--cd-environments-github-actions">Run in CI / CD environments Github Actions</a></li>
      <li><a href="#pass-arguments-into-commands">Pass arguments into commands</a></li>
    </ul>
  </li>
  <li><a href="#next-steps">Next steps</a></li>
</ul>

<!-- /TOC -->

<h2 id="introduction">Introduction</h2>
<p><a id="markdown-introduction" name="introduction"></a></p>

<p>In this tutorial we will learn how to use <a href="https://github.com/casey/just"><code class="language-plaintext highlighter-rouge">just</code></a> by example to
manage project specific commands. <code class="language-plaintext highlighter-rouge">just</code> is like <code class="language-plaintext highlighter-rouge">make</code>, but it is written in Rust, and it works
with <code class="language-plaintext highlighter-rouge">cargo</code>.</p>

<p>Before we get started, please take a look at the
<a href="https://github.com/casey/just"><code class="language-plaintext highlighter-rouge">just</code> project README</a>.</p>
<blockquote>

üëÄ Watch Rust ü¶Ä live coding videos on our <a href="https://www.youtube.com/@developerlifecom">YouTube Channel</a>.

<br />
<br />

<!-- video on rust polymorphism (no playlist) -->
<iframe src="https://www.youtube.com/embed/kYTgGtJjSro?si=XmW-_CAvCfB5e269" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<br />
<br />

üì¶ Install our useful Rust command line apps using <code>cargo install r3bl-cmdr</code>
(they are from the <a href="https://github.com/r3bl-org/r3bl-open-core">r3bl-open-core</a>
project):
<ul>
  <li>üê±<code>giti</code>: run interactive git commands with confidence in your terminal</li>
  <li>ü¶ú<code>edi</code>: edit Markdown with style in your terminal</li>
</ul>

<p>
<kbd>giti in action</kbd>
<video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/262f59d1-a95c-4af3-accf-c3d6cac6e586" type="video/mp4" />
</video>
</p>

<p>
<kbd>edi in action</kbd>
<video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/f2c4b07d-b5a2-4f41-af7a-06d1b6660c41" type="video/mp4" />
</video>
</p>

</blockquote>
<p>Let‚Äôs say you have a <code class="language-plaintext highlighter-rouge">justfile</code> that looks like this, and it has a single recipe called
<code class="language-plaintext highlighter-rouge">list</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>list:
  ls -l
</code></pre></div></div>

<p>And you run it by typing <code class="language-plaintext highlighter-rouge">just list</code>. It just turns around and runs this <code class="language-plaintext highlighter-rouge">sh -c "ls -l"</code>.
That‚Äôs it. So on Windows, this doesn‚Äôt work, because <code class="language-plaintext highlighter-rouge">sh</code> isn‚Äôt installed by default. So
you have to install cygwin. And then you have to install <code class="language-plaintext highlighter-rouge">just</code> and then you have to
install <code class="language-plaintext highlighter-rouge">sh</code>.</p>

<p>Alternatively, you can specify that you want to use <code class="language-plaintext highlighter-rouge">powershell</code> instead by
adding this to the top of the <code class="language-plaintext highlighter-rouge">justfile</code>: <code class="language-plaintext highlighter-rouge">set shell := ["powershell.exe", "-c"]</code>. Or you
can just run this <code class="language-plaintext highlighter-rouge">just --shell powershell.exe --shell-arg -c list</code> to run <code class="language-plaintext highlighter-rouge">just</code> itself
at the command prompt.</p>

<p>You can also supply different shell interpreters like <code class="language-plaintext highlighter-rouge">python</code> or <code class="language-plaintext highlighter-rouge">node</code>. And you can even
provide <code class="language-plaintext highlighter-rouge">shebang</code> lines like <code class="language-plaintext highlighter-rouge">#!/usr/bin/env python</code> or <code class="language-plaintext highlighter-rouge">#!/usr/bin/env node</code> at the top
of each recipe.</p>

<h2 id="prerequisites">Prerequisites</h2>
<p><a id="markdown-prerequisites" name="prerequisites"></a></p>

<p>üå† In order for our <code class="language-plaintext highlighter-rouge">just</code> file to work, we must first install the Rust toolchain and <code class="language-plaintext highlighter-rouge">just</code> and
<code class="language-plaintext highlighter-rouge">cargo-watch</code>:</p>

<ol>
  <li>Install the Rust toolchain using <code class="language-plaintext highlighter-rouge">rustup</code> by following the instructions
<a href="https://rustup.rs/">here</a>.</li>
  <li>Install <code class="language-plaintext highlighter-rouge">cargo-watch</code> using <code class="language-plaintext highlighter-rouge">cargo install cargo-watch</code>.</li>
  <li><a href="https://just.systems/man/en/chapter_4.html">Install</a> <code class="language-plaintext highlighter-rouge">just</code> on your system using
<code class="language-plaintext highlighter-rouge">cargo install just</code>. It is available for Linux, macOS, and Windows.
    <ul>
      <li>If you want shell completions for <code class="language-plaintext highlighter-rouge">just</code> you can follow
<a href="https://github.com/casey/just#shell-completion-scripts">these instructions</a>.</li>
      <li>If you install <code class="language-plaintext highlighter-rouge">just</code> using <code class="language-plaintext highlighter-rouge">cargo install just</code> or <code class="language-plaintext highlighter-rouge">brew install just</code> you will not get shell
completions without doing one extra configuration step. So on Linux it is best to use
<code class="language-plaintext highlighter-rouge">sudo apt install -y just</code> if you want them.</li>
    </ul>
  </li>
</ol>

<h2 id="basic-usage">Basic usage</h2>
<p><a id="markdown-basic-usage" name="basic-usage"></a></p>

<p>For Rust projects, typically we will have a build, run, test project specific commands. Let‚Äôs start
with these simple ones first. The benefit of <code class="language-plaintext highlighter-rouge">just</code> is that we can use it to run these commands on
any platform (Linux, Mac, Windows). And we don‚Äôt need to create OS or shell specific scripts to do
this üéâ.</p>

<p>Let‚Äôs start by creating a <code class="language-plaintext highlighter-rouge">justfile</code> in the root of our project. The <code class="language-plaintext highlighter-rouge">justfile</code> is where we will
define our project specific commands. Here is what it looks like for the
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/ansi_color/justfile"><code class="language-plaintext highlighter-rouge">r3bl_ansi_color</code> repo</a>:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>build:
  cargo build

clean:
  cargo clean

run:
  cargo run --example main
</code></pre></div></div>

<p>These are pretty simple commands. The syntax is pretty simple. The first line is the command name.
And the second line is the command to run. The command can be a single command or a series of
commands.</p>

<p>Now in order to run this, we can just run <code class="language-plaintext highlighter-rouge">just --list</code> in the root of our project. And it will show
us the list of commands that we can run.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>just <span class="nt">--list</span>
Available recipes:
    build
    clean
    run
</code></pre></div></div>

<p>Then to run a command, we can just run <code class="language-plaintext highlighter-rouge">just &lt;command_name&gt;</code>. For example, to run the <code class="language-plaintext highlighter-rouge">build</code>
command, we can run <code class="language-plaintext highlighter-rouge">just build</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>just build
</code></pre></div></div>

<h2 id="advanced-usage">Advanced usage</h2>
<p><a id="markdown-advanced-usage" name="advanced-usage"></a></p>

<h3 id="running-many-different-commands">Running many different commands</h3>
<p><a id="markdown-running-many-different-commands" name="running-many-different-commands"></a></p>

<p>This is pretty straightforward. You can just list all other other just commands inline.
Here‚Äôs an example.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>all: clean build test clippy docs rustfmt
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">all</code> command will run the other commands in the order they‚Äôre written.</p>

<h3 id="run-on-windows">Run on Windows</h3>
<p><a id="markdown-run-on-windows" name="run-on-windows"></a></p>

<p>Currently our <code class="language-plaintext highlighter-rouge">justfile</code> will run on Linux and macOS. To make it run on Windows, we can
run <code class="language-plaintext highlighter-rouge">just</code> itself using <code class="language-plaintext highlighter-rouge">powershell.exe</code>. Here is what it looks like:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>just <span class="nt">--shell</span> powershell.exe <span class="nt">--shell-arg</span> <span class="nt">-c</span> build
</code></pre></div></div>

<p>Or we can add the line <code class="language-plaintext highlighter-rouge">set shell := ["powershell.exe", "-c"]</code> to the top of the
<code class="language-plaintext highlighter-rouge">justfile</code>.</p>

<p>Alternatively, we can use <code class="language-plaintext highlighter-rouge">nu</code> shell instead of <code class="language-plaintext highlighter-rouge">powershell.exe</code> since it is written in
Rust and available via <code class="language-plaintext highlighter-rouge">cargo install nu</code>.</p>

<h3 id="run-in-ci--cd-environments-github-actions">Run in CI / CD environments (Github Actions)</h3>
<p><a id="markdown-run-in-ci-%2F-cd-environments-github-actions" name="run-in-ci-%2F-cd-environments-github-actions"></a></p>

<p>Let‚Äôs add a new command called <code class="language-plaintext highlighter-rouge">all</code> to our <code class="language-plaintext highlighter-rouge">justfile</code>. This will just turn around and run the
<code class="language-plaintext highlighter-rouge">build</code> and <code class="language-plaintext highlighter-rouge">clean</code> commands. Here is what it looks like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>all: build clean
</code></pre></div></div>

<p>Now, we can also use <code class="language-plaintext highlighter-rouge">just</code> in CI / CD environments. For example, here is the <a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/ansi_color/.github/workflows/rust.yml"><code class="language-plaintext highlighter-rouge">rust.yml</code>
file</a>
for this repo‚Äôs Github Actions. It runs <code class="language-plaintext highlighter-rouge">just all</code> in the <code class="language-plaintext highlighter-rouge">build</code> step.</p>

<p>The one thing to note is that we are installing <code class="language-plaintext highlighter-rouge">just</code> in the docker container before we
run the <code class="language-plaintext highlighter-rouge">just</code> command. We do this by pulling in the prebuilt binary for Ubuntu as shown
<a href="https://github.com/casey/just#pre-built-binaries">here</a>: <code class="language-plaintext highlighter-rouge">curl --proto '=https' --tlsv1.2
-sSf https://just.systems/install.sh | bash -s -- --to DEST</code></p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">jobs</span><span class="pi">:</span>
  <span class="na">build</span><span class="pi">:</span>

    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>

    <span class="na">steps</span><span class="pi">:</span>

    <span class="pi">-</span> <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v3</span>

    <span class="c1"># Install just before running it below.</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Install just</span>
      <span class="na">run</span><span class="pi">:</span> <span class="s">curl --proto '=https' --tlsv1.2 -sSf https://just.systems/install.sh | bash -s -- --to /usr/local/bin</span>

    <span class="c1"># Simply run the `just all` command.</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">all</span>
      <span class="na">run</span><span class="pi">:</span> <span class="s">just all</span>
</code></pre></div></div>

<p>Using <code class="language-plaintext highlighter-rouge">just all</code> is relatively straightforward way to run all our build steps (that would
run in a CI / CD environment) on our local computer w/out installing docker. While
ensuring that these same steps are carried out in the CI / CD environment.</p>

<h3 id="pass-arguments-into-commands">Pass arguments into commands</h3>
<p><a id="markdown-pass-arguments-into-commands" name="pass-arguments-into-commands"></a></p>

<p>We can also pass arguments into our commands. Let‚Äôs say that we have a command that we can use to
run a single test. We can pass the name of the test into the command. Here is what it looks like:</p>

<!--
  More info on escaping `` in markdown:
  - https://stackoverflow.com/questions/24102498/escaping-double-curly-braces-inside-a-markdown-code-block-in-jekyll
  - https://jekyllrb.com/docs/liquid/tags/
 -->

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>watch-one-test test_name:
  <span class="c"># More info on cargo test: https://doc.rust-lang.org/cargo/commands/cargo-test.html</span>
  <span class="c"># More info on cargo watch: https://github.com/watchexec/cargo-watch</span>
  cargo watch <span class="nt">-x</span> check <span class="nt">-x</span> <span class="s1">'test -- --test-threads=1 --nocapture {{test_name}}'</span> <span class="nt">-c</span> <span class="nt">-q</span>
</code></pre></div></div>

<p>There are a few things to note here:</p>

<ol>
  <li>The syntax to name the command is still the same as before.</li>
  <li>However, we have added another string after the command name, which is the argument name
<code class="language-plaintext highlighter-rouge">test_name</code>. If an argument is not passed in then <code class="language-plaintext highlighter-rouge">just</code> will display an error and print a
message stating that an argument is required.</li>
  <li>This argument is used just like a variable would in a <code class="language-plaintext highlighter-rouge">justfile</code>. The `` enclose a
variable name.</li>
</ol>

<p>Now we can run this command by passing in the name of the test that we want to run. For example, if
we want to run the <code class="language-plaintext highlighter-rouge">test_ansi_color</code> test, we can run <code class="language-plaintext highlighter-rouge">just watch-one-test test_ansi_color</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>just watch-one-test bold
</code></pre></div></div>

<p>Here‚Äôs an example of a <code class="language-plaintext highlighter-rouge">justfile</code> that has a lot more commands for you to look at:
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/ansi_color/justfile">r3bl_ansi_color justfile</a>.</p>

<h2 id="next-steps">Next steps</h2>
<p><a id="markdown-next-steps" name="next-steps"></a></p>

<p>The <code class="language-plaintext highlighter-rouge">just</code> project <a href="https://github.com/casey/just">README</a> has lots of information on how to use
<code class="language-plaintext highlighter-rouge">just</code>. It is best to have a specific thing you are looking for before you visit this page. Here are
some interesting links inside the README:</p>

<ol>
  <li><a href="https://github.com/casey/just#recipe-parameters">Command line arguments</a>.</li>
  <li><a href="https://github.com/casey/just#dotenv-integration">Support for .env files</a>.</li>
  <li><a href="https://github.com/casey/just#conditional-expressions">Conditional expressions</a>.</li>
  <li><a href="https://github.com/casey/just#setting-variables-from-the-command-line">Setting variables</a>.</li>
</ol>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><summary type="html"><![CDATA[A guide on how to create just files (which are like make files) to manage project specific commands. In a cross platform way.]]></summary></entry><entry><title type="html">Build a Chrome Extension using Manifest V3</title><link href="http://developerlife.com/2023/08/11/chrome-extension-shortlink/" rel="alternate" type="text/html" title="Build a Chrome Extension using Manifest V3" /><published>2023-08-11T10:00:00-05:00</published><updated>2023-08-11T10:00:00-05:00</updated><id>http://developerlife.com/2023/08/11/chrome-extension-shortlink</id><content type="html" xml:base="http://developerlife.com/2023/08/11/chrome-extension-shortlink/"><![CDATA[<p><img class="post-hero-image" src="/assets/chrome-extension.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#step-1-create-a-new-chrome-extension">Step 1: Create a new Chrome Extension</a></li>
  <li><a href="#step-2-build-and-load-the-chrome-extension">Step 2: Build and load the Chrome Extension</a></li>
  <li><a href="#step-3-add-functionality">Step 3: Add functionality</a></li>
  <li><a href="#step-4-publish-it">Step 4: Publish it</a></li>
  <li><a href="#next-steps-contribute-to-the-shortlink-project">Next steps: Contribute to the Shortlink project</a></li>
</ul>

<!-- /TOC -->

<h2 id="introduction">Introduction</h2>
<p><a id="markdown-introduction" name="introduction"></a></p>

<p>In this tutorial we will create a new Chrome Extension using Manifest V3 that allows us to create
our own names for a URL or a set of URLs. This is useful when you have a set of URLs that you want
to open at once, or you want to create a name for a URL that is hard to remember. Or if you just
don‚Äôt want to use bookmarks. We will also save these shortlinks to the Chrome Sync key-value pair
store. This extension will also allow the user to type commands when it is activated (in its popped
up state). And we will use Typescript and React to build it.</p>

<p>Before we get started, here are some good references to take a look at:</p>

<ol>
  <li><a href="https://developer.chrome.com/docs/extensions/mv3/intro/">Official Chrome docs on writing an extension</a></li>
  <li><a href="https://github.com/r3bl-org/chrome-extension-typescript-react-template">Template to build a Chrome extension without having to configure Typescript and React</a></li>
</ol>

<blockquote>
  <p>üöÄ Please star and fork / clone the <a href="https://github.com/r3bl-org/shortlink">Shortlink repo</a> üåü
Install the
<a href="https://chrome.google.com/webstore/detail/r3bl-shortlink/ffhfkgcfbjoadmhdmdcmigopbfkddial?hl=en-US&amp;gl=US">Chrome Extension</a>
üõ†Ô∏è</p>
</blockquote>
<blockquote>

üëÄ Watch Rust ü¶Ä live coding videos on our <a href="https://www.youtube.com/@developerlifecom">YouTube Channel</a>.

<br />
<br />

<!-- video on rust polymorphism (no playlist) -->
<iframe src="https://www.youtube.com/embed/kYTgGtJjSro?si=XmW-_CAvCfB5e269" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<br />
<br />

üì¶ Install our useful Rust command line apps using <code>cargo install r3bl-cmdr</code>
(they are from the <a href="https://github.com/r3bl-org/r3bl-open-core">r3bl-open-core</a>
project):
<ul>
  <li>üê±<code>giti</code>: run interactive git commands with confidence in your terminal</li>
  <li>ü¶ú<code>edi</code>: edit Markdown with style in your terminal</li>
</ul>

<p>
<kbd>giti in action</kbd>
<video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/262f59d1-a95c-4af3-accf-c3d6cac6e586" type="video/mp4" />
</video>
</p>

<p>
<kbd>edi in action</kbd>
<video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/f2c4b07d-b5a2-4f41-af7a-06d1b6660c41" type="video/mp4" />
</video>
</p>

</blockquote>
<h2 id="step-1-create-a-new-chrome-extension">Step 1: Create a new Chrome Extension</h2>
<p><a id="markdown-step-1%3A-create-a-new-chrome-extension" name="step-1%3A-create-a-new-chrome-extension"></a></p>

<p>The first thing to is to create a new repo on GitHub using this
<a href="https://github.com/r3bl-org/chrome-extension-typescript-react-template">template repo</a>.</p>

<p>You can do this in two ways.</p>

<ol>
  <li>Using github.com and a web browser. Here are the
<a href="https://docs.github.com/en/repositories/creating-and-managing-repositories/creating-a-repository-from-a-template">instructions</a>
on how to do this.</li>
  <li>Using the GitHub CLI. You must have the <a href="https://cli.github.com/">GitHub CLI</a> installed and be
logged in to github.com (using <code class="language-plaintext highlighter-rouge">gh auth login</code>).
    <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># More info: https://cli.github.com/manual/gh_repo_create</span>
gh repo create shortlink <span class="nt">--public</span> <span class="nt">--template</span> r3bl-org/chrome-extension-typescript-react-template
<span class="c"># More info: https://cli.github.com/manual/gh_repo_clone</span>
gh repo clone shortlink
</code></pre></div>    </div>
  </li>
</ol>

<h2 id="step-2-build-and-load-the-chrome-extension">Step 2: Build and load the Chrome Extension</h2>
<p><a id="markdown-step-2%3A-build-and-load-the-chrome-extension" name="step-2%3A-build-and-load-the-chrome-extension"></a></p>

<p>At this point we have a <code class="language-plaintext highlighter-rouge">shortlink</code> git repo on our local machine that is setup to build a Chrome
Extension. You can run the following command to build it.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm <span class="nb">install
</span>npm run build
</code></pre></div></div>

<p>This will generate a <code class="language-plaintext highlighter-rouge">dist/</code> directory that contains the Chrome Extension. You can load this into
Chrome by:</p>

<ol>
  <li>Type <code class="language-plaintext highlighter-rouge">chrome:extensions</code> in the URL bar.</li>
  <li>Turn on ‚ÄúDeveloper Mode‚Äù.</li>
  <li>Then click on ‚ÄúLoad unpacked‚Äù and select the <code class="language-plaintext highlighter-rouge">dist/</code> directory. Your extension will be loaded
into Chrome.</li>
</ol>

<h2 id="step-3-add-functionality">Step 3: Add functionality</h2>
<p><a id="markdown-step-3%3A-add-functionality" name="step-3%3A-add-functionality"></a></p>

<p>In our extension we will ask for the minimum of
<a href="https://developer.chrome.com/docs/extensions/reference/permissions/">permissions</a> from the user.
This ensures that our extension doesn‚Äôt have access to anything more than it needs. All of this is
specified in the <code class="language-plaintext highlighter-rouge">public/manifest.json</code> file. Here‚Äôs an example of what this file might look like
when we are done building our extension.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"manifest_version"</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w">
  </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"R3BL Shortlink"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Make go links"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"version"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2.0"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"icons"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"16"</span><span class="p">:</span><span class="w"> </span><span class="s2">"icon16.png"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"32"</span><span class="p">:</span><span class="w"> </span><span class="s2">"icon32.png"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"48"</span><span class="p">:</span><span class="w"> </span><span class="s2">"icon48.png"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"128"</span><span class="p">:</span><span class="w"> </span><span class="s2">"icon128.png"</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"action"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"default_title"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Click to make go link for URL"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"default_popup"</span><span class="p">:</span><span class="w"> </span><span class="s2">"popup.html"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"default_icon"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"16"</span><span class="p">:</span><span class="w"> </span><span class="s2">"icon16.png"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"32"</span><span class="p">:</span><span class="w"> </span><span class="s2">"icon32.png"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"48"</span><span class="p">:</span><span class="w"> </span><span class="s2">"icon48.png"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"128"</span><span class="p">:</span><span class="w"> </span><span class="s2">"icon128.png"</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"omnibox"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"keyword"</span><span class="p">:</span><span class="w"> </span><span class="s2">"go"</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"background"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"service_worker"</span><span class="p">:</span><span class="w"> </span><span class="s2">"js/background.js"</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"commands"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"_execute_action"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"suggested_key"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"default"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Alt+L"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"mac"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Alt+L"</span><span class="w">
      </span><span class="p">},</span><span class="w">
      </span><span class="nl">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Make a go link for URL in address bar"</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"permissions"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"activeTab"</span><span class="p">,</span><span class="w"> </span><span class="s2">"tabs"</span><span class="p">,</span><span class="w"> </span><span class="s2">"storage"</span><span class="p">,</span><span class="w"> </span><span class="s2">"clipboardWrite"</span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Now that we have our permissions sorted, we can start by adding functionality to the extension. When
we activate the extension by clicking its icon in the Chrome toolbar or by pressing the shortcut
<kbd>Alt+l</kbd> the <code class="language-plaintext highlighter-rouge">popup.tsx</code> file will be run which itself is loaded by <code class="language-plaintext highlighter-rouge">popup.html</code>.</p>

<blockquote>
  <p>You can learn more about activating the extension and the popup in the
<a href="https://developer.chrome.com/docs/extensions/reference/browserAction/#popups"><code class="language-plaintext highlighter-rouge">chrome.browserAction</code> docs</a>.</p>
</blockquote>

<p>This <code class="language-plaintext highlighter-rouge">popup.tsx</code> file will be the entry point for our extension. It is the main function in a node
program or the <code class="language-plaintext highlighter-rouge">App</code> top level component in a React app. It sets up the UI and handles the user
input events (key presses).</p>

<blockquote>
  <p>This is what the UI looks like on Linux on my machine:
<img src="/assets/shortlink-image.png" alt="Shortlink Screenshot" /></p>
</blockquote>

<p>This is what the file looks like in the real Shortcut extension:
<a href="https://github.com/r3bl-org/shortlink-react-webpack/blob/main/src/popup.tsx"><code class="language-plaintext highlighter-rouge">popup.tsx</code></a>. If you
go through this code, these are some of the things you will notice:</p>

<ol>
  <li>The <code class="language-plaintext highlighter-rouge">main()</code> function just sets up the main React component <code class="language-plaintext highlighter-rouge">Popup</code> and mounts it to the DOM
(<code class="language-plaintext highlighter-rouge">div</code> with id <code class="language-plaintext highlighter-rouge">root</code>).</li>
  <li>There are some <code class="language-plaintext highlighter-rouge">useEffect()</code> hooks which ensures that when <code class="language-plaintext highlighter-rouge">chrome.storage</code> changes, the global
state is updated and the component is re-rendered. Learn more about <code class="language-plaintext highlighter-rouge">chrome.storage</code> in the API
reference <a href="https://developer.chrome.com/docs/extensions/reference/storage/">here</a>. Another hook
is responsible for painting the badge on the extension icon in the toolbar (when the
<code class="language-plaintext highlighter-rouge">Shortlink[]</code> in the state changes).</li>
  <li>The <code class="language-plaintext highlighter-rouge">Popup</code> function component returns some JSX that is used to render the global state, which
are two things: <code class="language-plaintext highlighter-rouge">Shortlink[]</code> and <code class="language-plaintext highlighter-rouge">string</code>. The <code class="language-plaintext highlighter-rouge">Shortlink[]</code> is used to render the list of
shortcuts and the <code class="language-plaintext highlighter-rouge">string</code> is used to render the input field.</li>
  <li>The <code class="language-plaintext highlighter-rouge">handleOnChange()</code> and <code class="language-plaintext highlighter-rouge">handleEnterKey()</code> function is where the user input that is typed is
interpreted into a command and then executed.</li>
</ol>

<p>There are some other files of note. Please take a look at their linked source code.</p>

<ol>
  <li><a href="https://github.com/r3bl-org/shortlink-react-webpack/blob/main/src/command.ts"><code class="language-plaintext highlighter-rouge">command.ts</code></a>: The
main logic for parsing a <code class="language-plaintext highlighter-rouge">string</code> into a command is handled by this file. The
<code class="language-plaintext highlighter-rouge">parseUserInputTextIntoCommand()</code> function does all the work of converting a given <code class="language-plaintext highlighter-rouge">string</code> into
a <code class="language-plaintext highlighter-rouge">Command</code>, and has a very Rust ‚Äúvibe‚Äù. Please check out how this works. It makes it very easy
to add or change commands in the future.</li>
  <li><a href="https://github.com/r3bl-org/shortlink-react-webpack/blob/main/src/storage.ts"><code class="language-plaintext highlighter-rouge">storage.ts</code></a>:
This is where all the functions to manipulate the storage that syncs w/ Chrome accounts is
located. Functions that handle shortlinks to be deleted, or added, or updated can all be found
here. The Chrome storage API is async which is why the code in this file is written in the way
that it is.</li>
  <li><a href="https://github.com/r3bl-org/shortlink-react-webpack/blob/main/src/omnibox.ts"><code class="language-plaintext highlighter-rouge">omnibox.ts</code></a>:
This file works w/ <code class="language-plaintext highlighter-rouge">background.ts</code> to handle the omnibox functionality. The omnibox is the
<a href="https://developer.chrome.com/docs/extensions/reference/omnibox/">address bar</a> in Chrome. When
the user types <code class="language-plaintext highlighter-rouge">go</code> and then a space, the omnibox will be activated and the user can type in a
shortcut. When the user presses <kbd>Enter</kbd>, the <code class="language-plaintext highlighter-rouge">background.ts</code> file will be run and the
shortcut will be expanded to the full URL.</li>
</ol>

<h2 id="step-4-publish-it">Step 4: Publish it</h2>
<p><a id="markdown-step-4%3A-publish-it" name="step-4%3A-publish-it"></a></p>

<p>Please read this <a href="https://developer.chrome.com/docs/webstore/publish/">guide</a> on how to publish the
extension. You will have to get a developer account, and then upload the extension binaries. There‚Äôs
a <code class="language-plaintext highlighter-rouge">make-distro-zip.sh</code> script provided in this repo that will create a zip file that you can upload
to the Chrome Web Store.</p>

<p>As part of publishing a version you have to provide justification for why
you are requesting the permissions that you are. The fewer the permissions that you use, the better
for the end user, and also for the review process to take less time.</p>

<h2 id="next-steps-contribute-to-the-shortlink-project">Next steps: Contribute to the Shortlink project</h2>
<p><a id="markdown-next-steps%3A-contribute-to-the-shortlink-project" name="next-steps%3A-contribute-to-the-shortlink-project"></a></p>

<blockquote>
  <p>üöÄ Please star and fork / clone the <a href="https://github.com/r3bl-org/shortlink">Shortlink repo</a> üåü
Install the
<a href="https://chrome.google.com/webstore/detail/r3bl-shortlink/ffhfkgcfbjoadmhdmdcmigopbfkddial?hl=en-US&amp;gl=US">Chrome Extension</a>
üõ†Ô∏è</p>
</blockquote>

<p>If you would like to get involved in an open source project and like Chrome extensions, please feel
free to contribute to the <a href="https://github.com/r3bl-org/shortlink/issues">Shortlink repo</a>. There are
a lot of small features that need to be added. And they can be a nice stepping stone into the world
of open source contribution üéâ.</p>]]></content><author><name>Nazmul Idris</name></author><category term="TS" /><category term="Web" /><category term="React" /><summary type="html"><![CDATA[A guide on how to build a Chrome Extension using Manifest V3 that replaces the use of bookmarks (in a way) allowing you to create your own names for a URL or a set of URLs.]]></summary></entry><entry><title type="html">Guide to parsing with nom</title><link href="http://developerlife.com/2023/02/20/guide-to-nom-parsing/" rel="alternate" type="text/html" title="Guide to parsing with nom" /><published>2023-02-20T09:00:00-06:00</published><updated>2023-02-20T09:00:00-06:00</updated><id>http://developerlife.com/2023/02/20/guide-to-nom-parsing</id><content type="html" xml:base="http://developerlife.com/2023/02/20/guide-to-nom-parsing/"><![CDATA[<p><img class="post-hero-image" src="/assets/nom-parser.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#documentation">Documentation</a></li>
  <li><a href="#getting-to-know-nom-using-a-simple-example">Getting to know nom using a simple example</a>
    <ul>
      <li><a href="#parsing-hex-color-codes">Parsing hex color codes</a></li>
      <li><a href="#what-does-this-code-do-how-does-it-work">What does this code do, how does it work?</a></li>
      <li><a href="#generalized-workflow">Generalized workflow</a></li>
    </ul>
  </li>
  <li><a href="#build-a-markdown-parser">Build a Markdown parser</a></li>
</ul>

<!-- /TOC -->

<h2 id="introduction">Introduction</h2>
<p><a id="markdown-introduction" name="introduction"></a></p>

<p>This tutorial is a guide to parsing with nom. It covers the basics of parsing and how to use nom to
parse a string into a data structure. We will cover a variety of different examples ranging from
parsing simple CSS like syntax to a full blown Markdown parser.</p>

<p>This tutorial has 2 examples in it:</p>

<ol>
  <li><a href="#getting-to-know-nom-using-a-simple-example">CSS style syntax</a></li>
  <li><a href="#build-a-markdown-parser">Markdown parser</a></li>
</ol>
<blockquote>

üëÄ Watch Rust ü¶Ä live coding videos on our <a href="https://www.youtube.com/@developerlifecom">YouTube Channel</a>.

<br />
<br />

<!-- video on rust polymorphism (no playlist) -->
<iframe src="https://www.youtube.com/embed/kYTgGtJjSro?si=XmW-_CAvCfB5e269" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<br />
<br />

üì¶ Install our useful Rust command line apps using <code>cargo install r3bl-cmdr</code>
(they are from the <a href="https://github.com/r3bl-org/r3bl-open-core">r3bl-open-core</a>
project):
<ul>
  <li>üê±<code>giti</code>: run interactive git commands with confidence in your terminal</li>
  <li>ü¶ú<code>edi</code>: edit Markdown with style in your terminal</li>
</ul>

<p>
<kbd>giti in action</kbd>
<video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/262f59d1-a95c-4af3-accf-c3d6cac6e586" type="video/mp4" />
</video>
</p>

<p>
<kbd>edi in action</kbd>
<video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/f2c4b07d-b5a2-4f41-af7a-06d1b6660c41" type="video/mp4" />
</video>
</p>

</blockquote>
<blockquote>
  <p>For more information on general Rust type system design (functional approach rather than
object oriented), please take a look at this <a href="https://arxiv.org/pdf/2307.07069.pdf">paper</a>
by Will Crichton demonstrating Typed Design Patterns with Rust.</p>
</blockquote>

<h2 id="documentation">Documentation</h2>
<p><a id="markdown-documentation" name="documentation"></a></p>

<p>nom is a huge topic. This tutorial takes a hands on approach to learning nom. However, the resources
listed below are very useful for learning nom. Think of them as a reference guide and deep dive into
how the nom library works.</p>

<ul>
  <li>Useful:
    <ul>
      <li>Source code examples (fantastic way to learn nom):
        <ul>
          <li><a href="https://github.com/dimfeld/export-logseq-notes/tree/master/src">export-logseq-notes repo</a></li>
        </ul>
      </li>
      <li>Videos:
        <ul>
          <li><a href="https://youtu.be/EXEMm5173SM">Intro from the author 7yrs old</a></li>
          <li>Nom 7 deep dive videos:
            <ul>
              <li><a href="https://youtu.be/Igajh2Vliog">Parsing name, age, and preference from natural language input</a></li>
              <li><a href="https://youtu.be/Xm4jrjohDN8">Parsing number ranges</a></li>
              <li><a href="https://youtu.be/6b2ymQWldoE">Parsing lines of text</a></li>
            </ul>
          </li>
          <li>Nom 6 videos (deep dive into how nom combinators themselves are constructed):
            <ul>
              <li><a href="https://youtu.be/zHF6j1LvngA">Deep dive, Part 1</a></li>
              <li><a href="https://youtu.be/9GLFJcSO08Y">Deep dive, Part 2</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Tutorials:
        <ul>
          <li><a href="https://codeandbitters.com/lets-build-a-parser/">Build a JSON parser using nom7</a></li>
          <li><a href="https://github.com/benkay86/nom-tutorial">Excellent beginner to advanced</a></li>
          <li><a href="https://github.com/rust-bakery/nom/blob/main/doc/making_a_new_parser_from_scratch.md">Write a parser from scratch</a></li>
        </ul>
      </li>
      <li>Reference docs:
        <ul>
          <li><a href="https://tfpk.github.io/nominomicon/introduction.html">nominomicon</a></li>
          <li><a href="https://github.com/rust-bakery/nom/blob/main/doc/choosing_a_combinator.md">What combinator or parser to use?</a></li>
          <li><a href="https://docs.rs/nom/7.1.3/nom/">docs.rs</a></li>
          <li><a href="https://github.com/rust-bakery/nom/blob/main/doc/upgrading_to_nom_5.md">Upgrading to nom 5.0</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Less useful:
    <ul>
      <li><a href="https://github.com/rust-bakery/nom">README</a></li>
      <li><a href="https://crates.io/crates/nom">nom crate</a></li>
    </ul>
  </li>
</ul>

<h2 id="getting-to-know-nom-using-a-simple-example">Getting to know nom using a simple example</h2>
<p><a id="markdown-getting-to-know-nom-using-a-simple-example" name="getting-to-know-nom-using-a-simple-example"></a></p>

<p><a href="https://crates.io/crates/nom">nom</a> is a parser combinator library for Rust. You can write small
functions that parse a specific part of your input, and then combine them to build a parser that
parses the whole input. nom is very efficient and fast, it does not allocate memory when parsing if
it doesn‚Äôt have to, and it makes it very easy for you to do the same. nom uses streaming mode or
complete mode, and in this tutorial &amp; code examples provided we will be using complete mode.</p>

<p>Roughly the way it works is that you tell nom how to parse a bunch of bytes in a way that matches
some pattern that is valid for your data. It will try to parse as much as it can from the input, and
the rest of the input will be returned to you.</p>

<p>You express the pattern that you‚Äôre looking for by combining parsers. nom has a whole bunch of these
that come out of the box. And a huge part of learning nom is figuring out what these built in
parsers are and how to combine them to build a parser that does what you want.</p>

<p>Errors are a key part of it being able to apply a variety of different parsers to the same input. If
a parser fails, nom will return an error, and the rest of the input will be returned to you. This
allows you to combine parsers in a way that you can try to parse a bunch of different things, and if
one of them fails, you can try the next one. This is very useful when you are trying to parse a
bunch of different things, and you don‚Äôt know which one you are going to get.</p>

<h3 id="parsing-hex-color-codes">Parsing hex color codes</h3>
<p><a id="markdown-parsing-hex-color-codes" name="parsing-hex-color-codes"></a></p>

<p>Let‚Äôs dive into nom using a simple example of parsing
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color">hex color codes</a>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">//! This module contains a parser that parses a hex color string into a [Color] struct.</span>
<span class="cd">//! The hex color string can be in the following format `#RRGGBB`.</span>
<span class="cd">//! For example, `#FF0000` is red.</span>

<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">num</span><span class="p">::</span><span class="n">ParseIntError</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">nom</span><span class="p">::{</span><span class="nn">bytes</span><span class="p">::</span><span class="nn">complete</span><span class="p">::</span><span class="o">*</span><span class="p">,</span> <span class="nn">combinator</span><span class="p">::</span><span class="o">*</span><span class="p">,</span> <span class="nn">error</span><span class="p">::</span><span class="o">*</span><span class="p">,</span> <span class="nn">sequence</span><span class="p">::</span><span class="o">*</span><span class="p">,</span> <span class="n">IResult</span><span class="p">,</span> <span class="n">Parser</span><span class="p">};</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Color</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">red</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">green</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">blue</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Color</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">red</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">green</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">blue</span><span class="p">:</span> <span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cd">/// Helper functions to match and parse hex digits. These are not [Parser]</span>
<span class="cd">/// implementations.</span>
<span class="k">mod</span> <span class="n">helper_fns</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="cd">/// This function is used by [map_res] and it returns a [Result], not [IResult].</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">parse_str_to_hex_num</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="nn">std</span><span class="p">::</span><span class="nn">num</span><span class="p">::</span><span class="n">ParseIntError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nn">u8</span><span class="p">::</span><span class="nf">from_str_radix</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="cd">/// This function is used by [take_while_m_n] and as long as it returns `true`</span>
    <span class="cd">/// items will be taken from the input.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">match_is_hex_digit</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="nb">char</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="n">c</span><span class="nf">.is_ascii_hexdigit</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">parse_hex_seg</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IResult</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="nb">u8</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">map_res</span><span class="p">(</span>
            <span class="nf">take_while_m_n</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">match_is_hex_digit</span><span class="p">),</span>
            <span class="n">parse_str_to_hex_num</span><span class="p">,</span>
        <span class="p">)(</span><span class="n">input</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cd">/// These are [Parser] implementations that are used by [hex_color_no_alpha].</span>
<span class="k">mod</span> <span class="n">intermediate_parsers</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="cd">/// Call this to return function that implements the [Parser] trait.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">gen_hex_seg_parser_fn</span><span class="o">&lt;</span><span class="nv">'input</span><span class="p">,</span> <span class="n">E</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="n">Parser</span><span class="o">&lt;&amp;</span><span class="nv">'input</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">E</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">E</span><span class="p">:</span> <span class="n">FromExternalError</span><span class="o">&lt;&amp;</span><span class="nv">'input</span> <span class="nb">str</span><span class="p">,</span> <span class="n">ParseIntError</span><span class="o">&gt;</span> <span class="o">+</span> <span class="n">ParseError</span><span class="o">&lt;&amp;</span><span class="nv">'input</span> <span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nf">map_res</span><span class="p">(</span>
            <span class="nf">take_while_m_n</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nn">helper_fns</span><span class="p">::</span><span class="n">match_is_hex_digit</span><span class="p">),</span>
            <span class="nn">helper_fns</span><span class="p">::</span><span class="n">parse_str_to_hex_num</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cd">/// This is the "main" function that is called by the tests.</span>
<span class="k">fn</span> <span class="nf">hex_color_no_alpha</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IResult</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">Color</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// This tuple contains 3 ways to do the same thing.</span>
    <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="p">(</span>
        <span class="nn">helper_fns</span><span class="p">::</span><span class="n">parse_hex_seg</span><span class="p">,</span>
        <span class="nn">intermediate_parsers</span><span class="p">::</span><span class="nf">gen_hex_seg_parser_fn</span><span class="p">(),</span>
        <span class="nf">map_res</span><span class="p">(</span>
            <span class="nf">take_while_m_n</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nn">helper_fns</span><span class="p">::</span><span class="n">match_is_hex_digit</span><span class="p">),</span>
            <span class="nn">helper_fns</span><span class="p">::</span><span class="n">parse_str_to_hex_num</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">);</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="nf">tag</span><span class="p">(</span><span class="s">"#"</span><span class="p">)(</span><span class="n">input</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="p">(</span><span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span><span class="p">))</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">(</span><span class="n">it</span><span class="p">)(</span><span class="n">input</span><span class="p">)</span><span class="o">?</span><span class="p">;</span> <span class="c1">// same as `it.parse(input)?`</span>
    <span class="nf">Ok</span><span class="p">((</span><span class="n">input</span><span class="p">,</span> <span class="n">Color</span> <span class="p">{</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="p">}))</span>
<span class="p">}</span>

<span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">parse_valid_color</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">input</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="n">input</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"#2F14DF"</span><span class="p">);</span>
        <span class="n">input</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'üîÖ'</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nd">dbg!</span><span class="p">(</span><span class="nf">hex_color_no_alpha</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input</span><span class="p">));</span>

        <span class="k">let</span> <span class="nf">Ok</span><span class="p">((</span><span class="n">remainder</span><span class="p">,</span> <span class="n">color</span><span class="p">))</span> <span class="o">=</span> <span class="n">result</span> <span class="k">else</span> <span class="p">{</span> <span class="nd">panic!</span><span class="p">();</span> <span class="p">};</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">remainder</span><span class="p">,</span> <span class="s">"üîÖ"</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="nn">Color</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">47</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">223</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">parse_invalid_color</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nd">dbg!</span><span class="p">(</span><span class="nf">hex_color_no_alpha</span><span class="p">(</span><span class="s">"üîÖ#2F14DF"</span><span class="p">));</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">result</span><span class="nf">.is_err</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="what-does-this-code-do-how-does-it-work">What does this code do, how does it work?</h3>
<p><a id="markdown-what-does-this-code-do%2C-how-does-it-work%3F" name="what-does-this-code-do%2C-how-does-it-work%3F"></a></p>

<p>Please note that:</p>

<ul>
  <li>This string can be parsed: <code class="language-plaintext highlighter-rouge">#2F14DFüîÖ</code>.</li>
  <li>However, this string can‚Äôt <code class="language-plaintext highlighter-rouge">üîÖ#2F14DF</code>.</li>
</ul>

<p>So what is going on in the source code above?</p>

<ol>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">intermediate_parsers::hex_color_no_alpha()</code> function is the main function that orchestrates
all the other functions to parse an <code class="language-plaintext highlighter-rouge">input: &amp;str</code> and turn it into a <code class="language-plaintext highlighter-rouge">(&amp;str, Color)</code>.</p>

    <ul>
      <li>The <code class="language-plaintext highlighter-rouge">tag</code> combinator function is used to match the <code class="language-plaintext highlighter-rouge">#</code> character. This means that if the input
doesn‚Äôt start with <code class="language-plaintext highlighter-rouge">#</code>, the parser will fail (which is why <code class="language-plaintext highlighter-rouge">üîÖ#2F14DF</code> fails). It returns the
remaining input after <code class="language-plaintext highlighter-rouge">#</code>. And the output is <code class="language-plaintext highlighter-rouge">#</code> which we throw away.</li>
      <li>A <code class="language-plaintext highlighter-rouge">tuple</code> is created that takes 3 parsers, which all do the same exact thing, but are written
in 3 different ways just to demonstrate how these can be written.
        <ol>
          <li>The <code class="language-plaintext highlighter-rouge">helper_fns::parse_hex_seg()</code> function is added to a tuple.</li>
          <li>The higher order function <code class="language-plaintext highlighter-rouge">intermediate_parsers::gen_hex_seg_parser_fn()</code> is added to the
tuple.</li>
          <li>Finally, the <code class="language-plaintext highlighter-rouge">map_res</code> combinator is directly added to the tuple.</li>
        </ol>
      </li>
      <li>An extension function on this tuple called <code class="language-plaintext highlighter-rouge">parse()</code> is called w/ the <code class="language-plaintext highlighter-rouge">input</code> (thus far). This
is used to parse the input hex number.
        <ul>
          <li>It returns the remaining input after the hex number which is why <code class="language-plaintext highlighter-rouge">#2F14DFüîÖ</code> returns <code class="language-plaintext highlighter-rouge">üîÖ</code> as
the first item in the tuple.</li>
          <li>The second item in the tuple is the parsed color string turned into a <code class="language-plaintext highlighter-rouge">Color</code> struct.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Let‚Äôs look at the <code class="language-plaintext highlighter-rouge">helper_fns::parse_hex_seg</code> (the other 2 ways shown above do the same exact
thing). The signature of this function tells nom that you can call the function w/ <code class="language-plaintext highlighter-rouge">input</code>
argument and it will return <code class="language-plaintext highlighter-rouge">IResult&lt;Input, Output, Error&gt;</code>. This signature is the pattern that
we will end up using to figure out how to chain combinators together. Here‚Äôs how the <code class="language-plaintext highlighter-rouge">map_res</code>
combinator is used by <code class="language-plaintext highlighter-rouge">parse_hex_seg()</code> to actually do the parsing:</p>

    <ol>
      <li><code class="language-plaintext highlighter-rouge">take_while_m_n</code>: This combinator takes a range of characters (<code class="language-plaintext highlighter-rouge">2, 2</code>) and applies the
function <code class="language-plaintext highlighter-rouge">match_is_hex_digit</code> to determine whether the <code class="language-plaintext highlighter-rouge">char</code> is a hex digit (using
<code class="language-plaintext highlighter-rouge">is_ascii_hexdigit()</code> on the <code class="language-plaintext highlighter-rouge">char</code>). This is used to match a valid hex digit. It returns a
<code class="language-plaintext highlighter-rouge">&amp;str</code> slice of the matched characters. Which is then passed to the next combinator.</li>
      <li><code class="language-plaintext highlighter-rouge">parse_str_to_hex_num</code>: This parser is used on the string slice returned from above. It simply
takes string slice and turns it into a <code class="language-plaintext highlighter-rouge">Result&lt;u8&gt;, std::num::ParseIntError&gt;</code>. The error is
important, since if the string slice is not a valid hex digit, then we want to return this
error.</li>
    </ol>
  </li>
  <li>
    <p>The key concept in nom is the <code class="language-plaintext highlighter-rouge">Parser</code> trait which is implemented for any <code class="language-plaintext highlighter-rouge">FnMut</code> that accepts an
input and returns an <code class="language-plaintext highlighter-rouge">IResult&lt;Input, Output, Error&gt;</code>.</p>
    <ul>
      <li>If you write a simple function w/ the signature
<code class="language-plaintext highlighter-rouge">fn(input: Input) -&gt; IResult&lt;Input, Output, Error&gt;</code> then you are good to go! You just need to
call <code class="language-plaintext highlighter-rouge">parse()</code> on the <code class="language-plaintext highlighter-rouge">Input</code> type and this will kick off the parsing.</li>
      <li>Alternatively, you can just call the nom <code class="language-plaintext highlighter-rouge">tuple</code> function directly via
<code class="language-plaintext highlighter-rouge">nom::sequence::tuple(...)(input)?</code>. Or you can just call the <code class="language-plaintext highlighter-rouge">parse()</code> method on the tuple
since this is an extension function on tuples provided by nom.</li>
      <li><code class="language-plaintext highlighter-rouge">IResult</code> is a very important type alias. It encapsulates 3 key types that are related to
parsing:
        <ol>
          <li>The <code class="language-plaintext highlighter-rouge">Input</code> type is the type of the input that is being parsed. For example, if you are
parsing a string, then the <code class="language-plaintext highlighter-rouge">Input</code> type is <code class="language-plaintext highlighter-rouge">&amp;str</code>.</li>
          <li>The <code class="language-plaintext highlighter-rouge">Output</code> type is the type of the output that is returned by the parser. For example, if
you are parsing a string and you want to return a <code class="language-plaintext highlighter-rouge">Color</code> struct, then the <code class="language-plaintext highlighter-rouge">Output</code> type is
<code class="language-plaintext highlighter-rouge">Color</code>.</li>
          <li>The <code class="language-plaintext highlighter-rouge">Error</code> type is the type of the error that is returned by the parser. For example, if
you are parsing a string and you want to return a <code class="language-plaintext highlighter-rouge">nom::Err::Error</code> error, then the <code class="language-plaintext highlighter-rouge">Error</code>
type is <code class="language-plaintext highlighter-rouge">nom::Err::Error</code>. This is very useful when you are developing your parser
combinators and you run into errors and have to debug them.</li>
        </ol>
      </li>
    </ul>
  </li>
</ol>

<h3 id="generalized-workflow">Generalized workflow</h3>
<p><a id="markdown-generalized-workflow" name="generalized-workflow"></a></p>

<p>After the really complicated walk through above, we could have just written the entire thing
concisely like so:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">parse_hex_seg</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IResult</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="nb">u8</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nf">map_res</span><span class="p">(</span>
    <span class="nf">take_while_m_n</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">|</span><span class="n">it</span><span class="p">:</span> <span class="nb">char</span><span class="p">|</span> <span class="n">it</span><span class="nf">.is_ascii_hexdigit</span><span class="p">()),</span>
    <span class="p">|</span><span class="n">it</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">|</span> <span class="nn">u8</span><span class="p">::</span><span class="nf">from_str_radix</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span>
  <span class="p">)(</span><span class="n">input</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">hex_color_no_alpha</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IResult</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">Color</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">let</span> <span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="nf">tag</span><span class="p">(</span><span class="s">"#"</span><span class="p">)(</span><span class="n">input</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
  <span class="k">let</span> <span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="p">(</span><span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span><span class="p">))</span> <span class="o">=</span> <span class="nf">tuple</span><span class="p">((</span>
    <span class="nn">helper_fns</span><span class="p">::</span><span class="n">parse_hex_seg</span><span class="p">,</span>
    <span class="nn">helper_fns</span><span class="p">::</span><span class="n">parse_hex_seg</span><span class="p">,</span>
    <span class="nn">helper_fns</span><span class="p">::</span><span class="n">parse_hex_seg</span><span class="p">,</span>
  <span class="p">))(</span><span class="n">input</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
  <span class="nf">Ok</span><span class="p">((</span><span class="n">input</span><span class="p">,</span> <span class="n">Color</span> <span class="p">{</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="p">}))</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This is a very simple example, but it shows how you can combine parsers together to create more
complex parsers. You start w/ the simplest one first, and then build up from there.</p>

<ul>
  <li>In this case the simplest one is <code class="language-plaintext highlighter-rouge">parse_hex_seg()</code> which is used to parse a single hex segment.
Inside this function we call <code class="language-plaintext highlighter-rouge">map_res()</code> w/ the supplied <code class="language-plaintext highlighter-rouge">input</code> and simply return the result.
This is also a very common thing to do, is to wrap calls to other parsers in functions and then
re-use them in other parsers.</li>
  <li>Finally, the <code class="language-plaintext highlighter-rouge">hex_color_no_alpha()</code> function is used to parse a hex color w/o an alpha channel.
    <ul>
      <li>The <code class="language-plaintext highlighter-rouge">tag()</code> combinator is used to match the <code class="language-plaintext highlighter-rouge">#</code> character.</li>
      <li>The <code class="language-plaintext highlighter-rouge">tuple()</code> combinator is used to match the 3 hex segments.</li>
      <li>The <code class="language-plaintext highlighter-rouge">?</code> operator is used to return the error if there is one.</li>
      <li>The <code class="language-plaintext highlighter-rouge">Ok()</code> is used to return the parsed <code class="language-plaintext highlighter-rouge">Color</code> struct and the remaining input.</li>
    </ul>
  </li>
</ul>

<h2 id="build-a-markdown-parser">Build a Markdown parser</h2>
<p><a id="markdown-build-a-markdown-parser" name="build-a-markdown-parser"></a></p>

<blockquote>
  <p>üí° You can get the source code for the Markdown parser shown in this article from the
<a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/tui/src/tui/md_parser"><code class="language-plaintext highlighter-rouge">r3bl-open-core</code></a>
repo.</p>

  <p>üåü Please star this repo on github if you like it üôè.</p>
</blockquote>

<p>The <a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/tui/src/tui/md_parser"><code class="language-plaintext highlighter-rouge">md_parser</code></a> module
in the <code class="language-plaintext highlighter-rouge">r3bl-open-core</code> repo contains a fully functional Markdown parser (and isn‚Äôt written as a test
but a real module that you can use in your projects that need a Markdown parser). This parser
supports standard Markdown syntax as well as some extensions that are added to make it work w/ R3BL
products. It makes a great starting point to study how a relatively complex parser is written. There
are lots of tests that you can follow along to understand what the code is doing.</p>

<p>Here are some entry points into the codebase.</p>

<ol>
  <li>
    <p>The main function
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/parser.rs"><code class="language-plaintext highlighter-rouge">parse_markdown()</code></a>
that does the parsing of a string slice into a
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/types.rs"><code class="language-plaintext highlighter-rouge">Document</code></a>.
The tests are provided alongside the code itself. And you can follow along to see how other
smaller parsers are used to build up this big one that parses the whole of the Markdown document.</p>

    <ol>
      <li>All the parsers related to parsing metadata specific for R3BL applications which are not
standard Markdown can be found in
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/parser_impl_metadata.rs"><code class="language-plaintext highlighter-rouge">parser_impl_metadata</code></a>.</li>
      <li>All the parsers that are related to parsing the main ‚Äúblocks‚Äù of Markdown, such as order
lists, unordered lists, code blocks, text blocks, heading blocks, can be found
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/parser_impl_block.rs"><code class="language-plaintext highlighter-rouge">parser_impl_block</code></a></li>
      <li>All the parsers that are related to parsing a single line of Markdown text, such as links,
bold, italic, etc. can be found
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/parser_impl_element.rs"><code class="language-plaintext highlighter-rouge">parser_impl_element</code></a></li>
    </ol>
  </li>
  <li>
    <p>The <a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/types.rs">types</a>
that are used to represent the Markdown document model
(<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/types.rs"><code class="language-plaintext highlighter-rouge">Document</code></a>)
and all the other intermediate types (<code class="language-plaintext highlighter-rouge">Fragment</code>, <code class="language-plaintext highlighter-rouge">Block</code>, etc) &amp; enums required for parsing.</p>
  </li>
</ol>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><summary type="html"><![CDATA[This tutorial is a guide to parsing with nom. It covers the basics of parsing and how to use nom to parse a string into a data structure. We will cover a variety of different examples ranging from parsing simple CSS like syntax to a full blown Markdown parser.]]></summary></entry></feed>