<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://developerlife.com/feed.xml" rel="self" type="application/atom+xml" /><link href="http://developerlife.com/" rel="alternate" type="text/html" /><updated>2025-05-20T12:17:51-05:00</updated><id>http://developerlife.com/feed.xml</id><title type="html">developerlife.com</title><subtitle>Rust, TUI, Android, Web, Desktop, Cloud technologies, and UX engineering and design tutorials.</subtitle><author><name>Nazmul Idris</name></author><entry><title type="html">Build with Naz : Rust, Memory performance &amp;amp; latency - locality, access, allocate, cache lines</title><link href="http://developerlife.com/2025/05/19/rust-mem-latency/" rel="alternate" type="text/html" title="Build with Naz : Rust, Memory performance &amp;amp; latency - locality, access, allocate, cache lines" /><published>2025-05-19T00:00:00-05:00</published><updated>2025-05-19T00:00:00-05:00</updated><id>http://developerlife.com/2025/05/19/rust-mem-latency</id><content type="html" xml:base="http://developerlife.com/2025/05/19/rust-mem-latency/"><![CDATA[<p><img class="post-hero-image" src="/assets/rust-mem-latency-perf.png" /></p>

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

<ul>
  <li><a href="#rest-in-peace-moores-law">Rest In Peace, Moore’s Law</a></li>
  <li><a href="#memory-latency-and-cache-lines">Memory latency and cache lines</a>
    <ul>
      <li><a href="#order-of-magnitude-latency-differences">Order of magnitude latency differences</a></li>
      <li><a href="#cache-line">Cache line</a></li>
    </ul>
  </li>
  <li><a href="#stack-vs-heap">Stack vs heap</a>
    <ul>
      <li><a href="#stack-memory">Stack memory</a></li>
      <li><a href="#heap-memory">Heap memory</a></li>
      <li><a href="#why-stack-access-is-often-faster">Why stack access is often faster</a></li>
      <li><a href="#practical-implications-in-rust-and-linux">Practical implications in Rust and Linux</a></li>
      <li><a href="#stack-size-in-ubuntu-2504">Stack size in Ubuntu 25.04</a></li>
      <li><a href="#allocation-and-drop">Allocation and drop</a></li>
      <li><a href="#heap-memory-example-string-and-string-slice">Heap memory example, String and string slice</a></li>
    </ul>
  </li>
  <li><a href="#memory-alignment">Memory alignment</a></li>
  <li><a href="#global-allocators">Global allocators</a></li>
  <li><a href="#using-arrays-for-stack-or-heap-allocation">Using arrays for stack or heap allocation</a></li>
  <li><a href="#using-smallvec-and-smallstr-crates">Using smallvec and smallstr crates</a>
    <ul>
      <li><a href="#smallvec">smallvec</a></li>
      <li><a href="#smallstr">smallstr</a></li>
    </ul>
  </li>
  <li><a href="#other-code-examples">Other code examples</a></li>
  <li><a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</a></li>
</ul>

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

<h2 id="rest-in-peace-moores-law">Rest In Peace, Moore’s Law</h2>

<p>Moore’s Law, the observation that the number of transistors on a chip doubles roughly
every two years, has slowed significantly in recent years. While there’s no official end
date, the it effectively ended around 2015–2020. Modern process nodes (e.g., 7nm, 5nm,
3nm) are much harder and more expensive to shrink further, and improvements now take
longer than two years.</p>

<p>Implications:</p>

<ul>
  <li>This means CPU bound code that runs slowly will run slowly on future CPUs.</li>
  <li>The traditional approach of Big-O analysis and algorithmic improvements is not accurate,
since it only accounts for “op-count” and totally ignores the cost of memory access.</li>
  <li>Modern CPUs have many cores, but each core isn’t getting any faster. So using
parallelism is another way to get more performance.</li>
</ul>

<p>In this article, we will explore many of these topics in Rust, with examples written for
didactic exposition.</p>

<p>Here are some great resources to understand the implication of the end of Moore’s Law on
software performance.</p>

<ul>
  <li><a href="https://youtu.be/m7PVZixO35c">New CPUs don’t speed up old code</a></li>
  <li><a href="https://youtu.be/WwkuAqObplU">Data oriented design (YouTube)</a>
    <ul>
      <li>“Flat” data structures are better for memory locality.</li>
      <li>Pointer jumps are expensive and can slow down access (e.g., a Unicode string that
doesn’t own its data and fetches from another slice is slower due to poor locality).</li>
    </ul>
  </li>
  <li><a href="https://youtu.be/Dhn-JgZaBWo">Memory Latency vs CPU operation (YouTube)</a></li>
  <li><a href="https://youtu.be/pJ-FRRB5E84&amp;t=1831">Memory Allocation Tips (YouTube)</a>
    <ul>
      <li>For <code class="language-plaintext highlighter-rouge">Vec</code> and <code class="language-plaintext highlighter-rouge">String</code>, use <code class="language-plaintext highlighter-rouge">.with_capacity()</code> to pre-allocate memory and reduce
reallocations.</li>
      <li>Consider using these crates for performance improvements:
        <ul>
          <li><a href="https://docs.rs/smallvec/latest/smallvec/struct.SmallVec.html"><code class="language-plaintext highlighter-rouge">smallvec</code></a> (part of
Servo): Store small numbers of elements on the stack.</li>
          <li><a href="https://docs.rs/smallstr/0.3.0/smallstr/"><code class="language-plaintext highlighter-rouge">smallstr</code></a> (based on smallvec): Store
small strings on the stack.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="memory-latency-and-cache-lines">Memory latency and cache lines</h2>

<p>The CPU’s cache hierarchy (L1, L2, and often L3) acts as a crucial intermediary, bridging
the massive performance gap between the incredibly fast CPU registers and the much slower
main memory and storage. Cache lines are the fundamental building blocks that enable this
efficient data movement and significantly impact overall system performance.</p>

<h3 id="order-of-magnitude-latency-differences">Order of magnitude latency differences</h3>

<p>The relative latencies look something like this (very approximate) for a machine with
Intel 14th Gen, DDR5-5200, PCIe 4 SSD:</p>

<table>
  <thead>
    <tr>
      <th>Memory Type</th>
      <th>Relative Latency (vs. Register)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Register</td>
      <td>1x</td>
    </tr>
    <tr>
      <td>L1 Cache</td>
      <td>10x - 50x</td>
    </tr>
    <tr>
      <td>L2 Cache</td>
      <td>50x - 200x</td>
    </tr>
    <tr>
      <td>RAM</td>
      <td>500x - 1000x</td>
    </tr>
    <tr>
      <td>GPU HBM/GDDR6</td>
      <td>1,000x - 2,000x</td>
    </tr>
    <tr>
      <td>SSD</td>
      <td>10,000x - 100,000x</td>
    </tr>
    <tr>
      <td>Local Network (LAN)</td>
      <td>100,000x - 1,000,000x</td>
    </tr>
    <tr>
      <td>Internet (Same Region)</td>
      <td>1,000,000x - 10,000,000x</td>
    </tr>
    <tr>
      <td>Internet (Cross-Continental)</td>
      <td>10,000,000x - 100,000,000x</td>
    </tr>
  </tbody>
</table>

<p><img src="/assets/memory_latency.svg" alt="Memory Latency" /></p>

<p>It’s important to understand that these are <em>relative</em> order-of-magnitude estimates and
can vary based on specific workloads, system configurations, and the exact characteristics
of the components. However, they provide a good sense of the performance hierarchy:</p>

<ol>
  <li>
    <p><strong>Fetching Data from a Register:</strong> This is the fastest operation, happening within the
CPU core itself.</p>

    <ul>
      <li><strong>Latency:</strong> Sub-nanosecond (on the order of picoseconds). Let’s consider this as
<strong>~1 unit of time</strong>.</li>
    </ul>
  </li>
  <li>
    <p><strong>Fetching Data from L1 Cache:</strong> The L1 cache is the smallest and closest cache to the
CPU cores.</p>

    <ul>
      <li><strong>Latency:</strong> Around 1-5 nanoseconds. This is still incredibly fast, but noticeably
slower than register access.</li>
      <li><strong>Relative Order of Magnitude:</strong> <strong>~10x - 50x</strong> slower than register access.</li>
    </ul>
  </li>
  <li>
    <p><strong>Fetching Data from L2 Cache:</strong> The L2 cache is larger and slightly further away than
L1.</p>

    <ul>
      <li><strong>Latency:</strong> Around 5-20 nanoseconds.</li>
      <li><strong>Relative Order of Magnitude:</strong> <strong>~50x - 200x</strong> slower than register access.</li>
    </ul>
  </li>
  <li>
    <p><strong>Fetching Data from Main Memory (DDR5-5200):</strong> Accessing RAM is significantly slower
than cache access. DDR5-5200 specifies the data transfer rate, but the actual latency
to fetch data involves factors like CAS latency and command cycles.</p>

    <ul>
      <li><strong>Latency:</strong> Around 50-100 nanoseconds (or even higher depending on the specific
timings and system load).</li>
      <li><strong>Relative Order of Magnitude:</strong> <strong>~500x - 1000x</strong> slower than register access.</li>
    </ul>
  </li>
  <li>
    <p><strong>Fetching Data from SSD (PCIe 4):</strong> Accessing an SSD is orders of magnitude slower
than RAM, although much faster than traditional hard drives. PCIe 4 offers high
bandwidth, but the latency for a random access is still considerable in CPU time
scales.</p>
    <ul>
      <li><strong>Latency:</strong> Tens to hundreds of <em>microseconds</em> (thousands to hundreds of thousands
of nanoseconds). Let’s say around 10-100 microseconds for a typical random read.</li>
      <li><strong>Relative Order of Magnitude:</strong> <strong>~10,000x - 100,000x</strong> slower than register
access.</li>
    </ul>
  </li>
</ol>

<blockquote>
  <table>
    <thead>
      <tr>
        <th>Unit Name</th>
        <th>Symbol</th>
        <th>Value in Seconds</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>second</td>
        <td>s</td>
        <td>1</td>
      </tr>
      <tr>
        <td>millisecond</td>
        <td>ms</td>
        <td>1/1,000 = 10⁻³ s</td>
      </tr>
      <tr>
        <td>microsecond</td>
        <td>μs</td>
        <td>1/1,000,000 = 10⁻⁶ s</td>
      </tr>
      <tr>
        <td>nanosecond</td>
        <td>ns</td>
        <td>1/1,000,000,000 = 10⁻⁹ s</td>
      </tr>
      <tr>
        <td>picosecond</td>
        <td>ps</td>
        <td>1/1,000,000,000,000 = 10⁻¹² s</td>
      </tr>
      <tr>
        <td>femtosecond</td>
        <td>fs</td>
        <td>1/1,000,000,000,000,000 = 10⁻¹⁵ s</td>
      </tr>
    </tbody>
  </table>
</blockquote>

<h3 id="cache-line">Cache line</h3>

<p>A <strong>cache line</strong> is the fundamental unit of data transfer between the CPU’s cache
hierarchy and the main memory. On the 14th gen Intel CPUs it is 64 bytes, its primary
function is to enhance performance by fetching and storing data in larger blocks, thereby
reducing the frequency of slower main memory accesses. It is 128 bytes or twice as large
on an Apple M4 chip.</p>

<p>All CPU accesses to RAM are done in cache line units, even if the CPU only needs a single
byte or word (e.g., <code class="language-plaintext highlighter-rouge">usize</code>, or 64 bits / 8 bytes on 14th gen Intel CPU). The cache line
is the fundamental unit of data transfer between RAM and the CPU cache.</p>

<p><strong>How it works:</strong> When the CPU needs to read data, it first checks its caches (L1, L2,
L3):</p>

<ul>
  <li>If the data is not present (<strong>cache miss</strong>), the CPU fetches the data from RAM.</li>
  <li>However, it does not fetch just the specific byte or word requested—it fetches an entire
<strong>cache line</strong> (e.g., 64 bytes on Intel CPUs).</li>
  <li>This cache line is then stored in the cache, and the requested data is delivered to the
CPU. Similarly, when data is written, the corresponding cache line is updated and
eventually written back to main memory.</li>
</ul>

<p><strong>Impact on Memory Latency:</strong> Cache lines significantly influence memory latency:</p>

<ul>
  <li><strong>Spatial Locality:</strong> By fetching a block of contiguous data, cache lines exploit the
tendency of programs to access nearby memory locations, minimizing subsequent memory
accesses.</li>
  <li><strong>Cache Miss Penalty:</strong> While a cache miss incurs a substantial latency penalty to fetch
the entire line, this is often offset by the fact that a larger chunk of potentially
needed data is brought into the cache at once.</li>
  <li><strong>Bandwidth Utilization:</strong> Transferring data in larger cache line units optimizes the
use of the available memory bandwidth compared to numerous small transfers.</li>
</ul>

<p><strong>Example Benefit:</strong> Accessing elements of an array sequentially demonstrates the
advantage. With a 64-byte cache line and 4-byte integers, fetching one integer brings 15
neighboring integers into the cache, likely satisfying future access requests without
needing to go back to main memory.</p>

<p>More information on cache placement policies:</p>

<ul>
  <li><a href="https://en.wikipedia.org/wiki/Cache_placement_policies#Example_3">Wikipedia: CPU Cache placement policies</a></li>
</ul>

<h2 id="stack-vs-heap">Stack vs heap</h2>

<p>Both stack and heap are in main memory (RAM). Their differences are logical rather than
physical.</p>

<h3 id="stack-memory">Stack memory</h3>

<ul>
  <li><strong>Cache friendliness</strong>: Stack memory tends to be more cache-friendly.
    <ul>
      <li>Access patterns are predictable and localized.</li>
      <li>Recent stack frames likely remain in CPU cache.</li>
    </ul>
  </li>
  <li><strong>Locality</strong>: Excellent spatial and temporal locality.
    <ul>
      <li>Data accessed together is stored together.</li>
      <li>Recently accessed data is likely to be accessed again soon.</li>
    </ul>
  </li>
  <li><strong>Allocation cost</strong>: Essentially free (just incrementing/decrementing a stack pointer).</li>
</ul>

<h3 id="heap-memory">Heap memory</h3>

<ul>
  <li><strong>Cache behavior</strong>: Often less cache-friendly.
    <ul>
      <li>Allocations can be scattered throughout memory.</li>
      <li>More likely to cause cache misses.</li>
    </ul>
  </li>
  <li><strong>Locality</strong>: Usually poorer spatial locality.
    <ul>
      <li>Related objects may be far apart in memory.</li>
      <li>More random access patterns.</li>
    </ul>
  </li>
  <li><strong>Allocation cost</strong>: Relatively expensive.
    <ul>
      <li>Requires searching for free blocks.</li>
      <li>May involve complex bookkeeping.</li>
    </ul>
  </li>
</ul>

<h3 id="why-stack-access-is-often-faster">Why stack access is often faster</h3>

<ol>
  <li><strong>Predictable access pattern</strong>: The CPU can prefetch stack data more effectively.</li>
  <li><strong>Cache utilization</strong>: Better use of cache lines due to contiguous memory access.</li>
  <li><strong>Allocation overhead</strong>: No complex memory management routines.</li>
</ol>

<h3 id="practical-implications-in-rust-and-linux">Practical implications in Rust and Linux</h3>

<ul>
  <li>Small, fixed-size values benefit from stack allocation.</li>
  <li>Larger or dynamically-sized values must use heap allocation.</li>
  <li>Cache line considerations might apply more predictably to stack memory.</li>
</ul>

<p>Stack size is important when considering memory access patterns. Stack memory benefits
from:</p>

<ul>
  <li>Better cache locality (growing/shrinking in a linear fashion)</li>
  <li>More predictable access patterns</li>
  <li>Automatic management (no allocation overhead)</li>
</ul>

<p>The fixed size nature of stacks is why recursion can cause stack overflow errors, while
heap allocations (which have their own performance trade-offs) can grow dynamically until
system memory is exhausted.</p>

<p>This is why data-oriented design principles often recommend organizing data for better
cache utilization, regardless of whether it’s on stack or heap.</p>

<h3 id="stack-size-in-ubuntu-2504">Stack size in Ubuntu 25.04</h3>

<p>In Ubuntu 25.04 with the latest Linux kernel, the default stack size for:</p>

<ul>
  <li><strong>User threads</strong>: 8 MB (8,388,608 bytes)</li>
  <li><strong>Kernel threads</strong>: ~16 KB (kernel space stack)</li>
</ul>

<p>This is configurable through several mechanisms:</p>

<ol>
  <li>Check current stack size in a terminal with:</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c"># Displays the current stack size limit in KB.</span>
  <span class="nb">ulimit</span> <span class="nt">-s</span>
</code></pre></div></div>

<ol>
  <li>Modify stack size temporarily:</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c"># Set stack size to 8192 KB.</span>
  <span class="nb">ulimit</span> <span class="nt">-s</span> 8192
</code></pre></div></div>

<ol>
  <li>For permanent changes, edit <code class="language-plaintext highlighter-rouge">/etc/security/limits.conf</code>:</li>
</ol>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c"># &lt;domain&gt; &lt;type&gt; &lt;item&gt; &lt;value&gt;
</span>  <span class="c"># - domain: * means all users.
</span>  <span class="c"># - type: soft and hard are the limit types.
</span>  <span class="c"># - item: stack is the resource.
</span>  <span class="c"># - value: The value is in kilobytes (KB).
</span>  * <span class="n">soft</span> <span class="n">stack</span> <span class="m">8192</span>
  * <span class="n">hard</span> <span class="n">stack</span> <span class="m">16384</span>
</code></pre></div></div>

<h3 id="allocation-and-drop">Allocation and drop</h3>

<p>The cost of dropping (deallocating) memory on the heap using Rust’s default allocator
(<code class="language-plaintext highlighter-rouge">std::alloc::System</code>, which typically wraps the underlying OS <code class="language-plaintext highlighter-rouge">malloc</code> / <code class="language-plaintext highlighter-rouge">free</code> provided
by <code class="language-plaintext highlighter-rouge">glibc</code> GNU C Library) is generally much lower than the cost of allocating it, but it
is not free. Here’s an example of the costs involved in allocating and dropping 500KB of
memory on the heap and stack:</p>

<table>
  <thead>
    <tr>
      <th>Operation</th>
      <th>Stack (500 KB)</th>
      <th>Heap (500 KB)</th>
      <th>Relative Difference</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Allocation</td>
      <td>~10–100 ns</td>
      <td>~1–10 μs</td>
      <td>10x–100x slower</td>
    </tr>
    <tr>
      <td>Deallocation</td>
      <td>~10–100 ns</td>
      <td>~1–10 μs</td>
      <td>10x–100x slower</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>Note: 1μs (micro second) = 1,000ns (nano second)</p>
</blockquote>

<p><strong>Heap:</strong></p>

<ul>
  <li><strong>Allocating</strong>: Can be expensive, especially for large or many small allocations, due to
searching for free blocks, updating allocator metadata, and possible fragmentation.</li>
  <li><strong>Dropping/Deallocating</strong>: Usually faster, as it typically just marks the memory as free
and updates allocator metadata. However, the actual cost depends on the allocator’s
implementation and fragmentation state.</li>
</ul>

<p><strong>Stack:</strong></p>

<ul>
  <li><strong>Allocating</strong>: Very cheap (just moves the stack pointer). However, note that filling it
with valid data can be expensive if the data is large.</li>
  <li><strong>Dropping/Deallocating</strong>: Also very cheap (just moves the stack pointer back).</li>
</ul>

<h3 id="heap-memory-example-string-and-string-slice">Heap memory example, String and string slice</h3>

<p>Let’s get started with memory layout in Rust using the <code class="language-plaintext highlighter-rouge">String</code> and <code class="language-plaintext highlighter-rouge">&amp;str</code> types. <code class="language-plaintext highlighter-rouge">String</code>
is a heap-allocated, growable string type, while <code class="language-plaintext highlighter-rouge">&amp;str</code> is a string slice that is a view
into owned data somewhere else (like a <code class="language-plaintext highlighter-rouge">String</code>).</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">&amp;str</code> is is comprised of a pointer to the data and a length.</li>
  <li><code class="language-plaintext highlighter-rouge">String</code> is a struct that contains a pointer to the data, a length, and a capacity. And
is a <code class="language-plaintext highlighter-rouge">Vec&lt;u8&gt;</code> under the hood. A <code class="language-plaintext highlighter-rouge">Vec</code> itself is comprised of a pointer to the data, a
length, and a capacity.</li>
</ul>

<p>First add the following dependencies to your project:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo add r3bl_tui
</code></pre></div></div>

<p>Then you can run the following code:</p>

<div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">string_and_vec_tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">r3bl_tui</span><span class="p">::{</span><span class="n">fg_light_yellow_green</span><span class="p">,</span> <span class="n">fg_lizard_green</span><span class="p">};</span>

    <span class="nd">#[serial_test::serial]</span>
    <span class="nd">#[test]</span>
    <span class="cd">/// Demonstrates the memory layout of String, which contains [ptr, len, capacity].</span>
    <span class="k">fn</span> <span class="nf">mem_layout_string</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">fg_lizard_green</span><span class="p">(</span>
            <span class="s">"</span><span class="se">\n</span><span class="s">=== String Memory Layout Example ==="</span>
        <span class="p">)</span><span class="nf">.println</span><span class="p">();</span>

        <span class="c1">// Create a String.</span>
        <span class="c1">// ASCII values for digits:</span>
        <span class="c1">// '0': 48 (0x30), '1': 49 (0x31), '2': 50 (0x32),</span>
        <span class="c1">// '3': 51 (0x33), '4': 52 (0x34), '6': 54 (0x36),</span>
        <span class="c1">// '7': 55 (0x37), '8': 56 (0x38), '9': 57 (0x39)</span>
        <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"0123456789"</span><span class="p">);</span>

        <span class="c1">// We can get these values safely.</span>
        <span class="nf">fg_light_yellow_green</span><span class="p">(</span>
            <span class="s">"</span><span class="se">\n</span><span class="s">Safely accessing String metadata:"</span>
        <span class="p">)</span><span class="nf">.println</span><span class="p">();</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"  ptr: {:p}"</span><span class="p">,</span> <span class="n">s</span><span class="nf">.as_ptr</span><span class="p">());</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"  len: {}"</span><span class="p">,</span> <span class="n">s</span><span class="nf">.len</span><span class="p">());</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"  cap: {}"</span><span class="p">,</span> <span class="n">s</span><span class="nf">.capacity</span><span class="p">());</span>

        <span class="c1">// Unsafely transmute String to Vec of bytes.</span>
        <span class="c1">// This will show the Vec representation which</span>
        <span class="c1">// includes the UTF-8 bytes (identical to ASCII</span>
        <span class="c1">// values for these digits).</span>
        <span class="nf">fg_light_yellow_green</span><span class="p">(</span>
            <span class="s">"</span><span class="se">\n</span><span class="s">Unsafely accessing String as Vec&lt;u8&gt; (hex dump):"</span>
        <span class="p">)</span><span class="nf">.println</span><span class="p">();</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{:x?}"</span><span class="p">,</span> <span class="k">unsafe</span> <span class="p">{</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nn">transmute</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="p">});</span>

        <span class="c1">// Note that transmuting a String to the following</span>
        <span class="c1">// does not work:</span>
        <span class="c1">//</span>
        <span class="c1">// let (ptr, len, cap): (*mut usize, usize, usize) =</span>
        <span class="c1">//   unsafe { std::mem::transmute(s) };</span>
        <span class="c1">//</span>
        <span class="c1">// Both of the following are invalid:</span>
        <span class="c1">// - `(*const u8, usize, usize)`</span>
        <span class="c1">// - `(*mut u8, usize, usize)`</span>
        <span class="p">{</span>
            <span class="nf">fg_light_yellow_green</span><span class="p">(</span>
                <span class="s">"</span><span class="se">\n</span><span class="s">Accessing String with into_raw_parts():"</span>
            <span class="p">)</span><span class="nf">.println</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"0123456789"</span><span class="p">);</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">cap</span><span class="p">)</span> <span class="o">=</span> <span class="n">s</span><span class="nf">.into_raw_parts</span><span class="p">();</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"  ptr: {:p}"</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"  len: {}"</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"  cap: {}"</span><span class="p">,</span> <span class="n">cap</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">#[serial_test::serial]</span>
    <span class="nd">#[test]</span>
    <span class="cd">/// Demonstrates the memory layout of &amp;str, which</span>
    <span class="cd">/// contains [ptr, len].</span>
    <span class="k">fn</span> <span class="nf">mem_layout_str_slice</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">fg_lizard_green</span><span class="p">(</span>
            <span class="s">"</span><span class="se">\n</span><span class="s">=== &amp;str Memory Layout Example 1 ==="</span>
        <span class="p">)</span><span class="nf">.println</span><span class="p">();</span>

        <span class="c1">// Create a string slice</span>
        <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"Hello, world!"</span><span class="p">;</span>

        <span class="c1">// &amp;str is represented as [ptr, len].</span>
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="c1">// Transmute &amp;str to raw parts.</span>
            <span class="k">let</span> <span class="n">raw_parts</span><span class="p">:</span> <span class="p">(</span><span class="o">*</span><span class="k">const</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">transmute</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

            <span class="nf">fg_light_yellow_green</span><span class="p">(</span>
                <span class="s">"</span><span class="se">\n</span><span class="s">&amp;str memory layout:"</span>
            <span class="p">)</span><span class="nf">.println</span><span class="p">();</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"  ptr: {:p}"</span><span class="p">,</span> <span class="n">raw_parts</span><span class="na">.0</span><span class="p">);</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"  len: {}"</span><span class="p">,</span> <span class="n">raw_parts</span><span class="na">.1</span><span class="p">);</span>

            <span class="c1">// We can also get these values safely</span>
            <span class="nf">fg_light_yellow_green</span><span class="p">(</span>
                <span class="s">"</span><span class="se">\n</span><span class="s">Safely accessing &amp;str metadata:"</span>
            <span class="p">)</span><span class="nf">.println</span><span class="p">();</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"  ptr: {:p}"</span><span class="p">,</span> <span class="n">s</span><span class="nf">.as_ptr</span><span class="p">());</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"  len: {}"</span><span class="p">,</span> <span class="n">s</span><span class="nf">.len</span><span class="p">());</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">#[serial_test::serial]</span>
    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">mem_layout_str_slice_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">fg_lizard_green</span><span class="p">(</span>
            <span class="s">"</span><span class="se">\n</span><span class="s">=== &amp;str Memory Layout Example 2 ==="</span>
        <span class="p">)</span><span class="nf">.println</span><span class="p">();</span>

        <span class="c1">// Demonstrate that &amp;str is just a view into some data.</span>
        <span class="k">let</span> <span class="n">owned</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Hello, world!"</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">slice</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">owned</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">5</span><span class="p">];</span> <span class="c1">// "Hello".</span>

        <span class="c1">// Safe approach to get the pointer and length for slice.</span>
        <span class="k">let</span> <span class="n">slice_ptr</span> <span class="o">=</span> <span class="n">slice</span><span class="nf">.as_ptr</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">slice_len</span> <span class="o">=</span> <span class="n">slice</span><span class="nf">.len</span><span class="p">();</span>

        <span class="c1">// Safe approach to get the pointer and length for owned.</span>
        <span class="k">let</span> <span class="n">owned_ptr</span> <span class="o">=</span> <span class="n">owned</span><span class="nf">.as_ptr</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">owned_len</span> <span class="o">=</span> <span class="n">owned</span><span class="nf">.len</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">owned_capacity</span> <span class="o">=</span> <span class="n">owned</span><span class="nf">.capacity</span><span class="p">();</span>

        <span class="nf">fg_light_yellow_green</span><span class="p">(</span>
            <span class="s">"</span><span class="se">\n</span><span class="s">Comparing owned String and &amp;str slice (safely):"</span>
        <span class="p">)</span><span class="nf">.println</span><span class="p">();</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"  String ptr: {:p}"</span><span class="p">,</span> <span class="n">owned_ptr</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"  &amp;str ptr:   {:p}"</span><span class="p">,</span> <span class="n">slice_ptr</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span>
            <span class="s">"  String points to same memory as slice: {}"</span><span class="p">,</span>
            <span class="n">slice_ptr</span> <span class="o">==</span> <span class="n">owned_ptr</span>
        <span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"  String len: {}, slice len: {}"</span><span class="p">,</span>
            <span class="n">owned_len</span><span class="p">,</span> <span class="n">slice_len</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"  String cap: {}"</span><span class="p">,</span> <span class="n">owned_capacity</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="memory-alignment">Memory alignment</h2>

<p>Memory alignment refers to arranging data in memory at addresses that are multiples of the
data type’s alignment requirement.</p>

<p>The alignment of a value specifies what addresses are valid to store the value at.</p>

<p>A value of alignment n must only be stored at an address that is a multiple of <code class="language-plaintext highlighter-rouge">n</code>. For
example, a value with an alignment of <code class="language-plaintext highlighter-rouge">2</code> must be stored at an even address, while a value
with an alignment of <code class="language-plaintext highlighter-rouge">1</code> can be stored at any address.</p>

<ul>
  <li>Alignment is measured in bytes, and must be at least <code class="language-plaintext highlighter-rouge">1</code>, and always a power of <code class="language-plaintext highlighter-rouge">2</code>.</li>
  <li>The alignment of a value can be checked with the
<a href="https://doc.rust-lang.org/core/mem/fn.align_of_val.html"><code class="language-plaintext highlighter-rouge">align_of_val</code></a> function.</li>
</ul>

<p>Rust’s type system and compiler automatically handle memory alignment for safety and
performance, but understanding alignment is important when working with FFI, low-level
code, or optimizing data structures.</p>

<p>On a 14th gen Intel CPU (which is a 64-bit x86_64 architecture), the default alignment for
primitive types in Rust is:</p>

<ul>
  <li>8 bytes for types whose size is 8 bytes (e.g., <code class="language-plaintext highlighter-rouge">u64</code>, <code class="language-plaintext highlighter-rouge">f64</code>, <code class="language-plaintext highlighter-rouge">usize</code>, pointers)</li>
  <li>4 bytes for types whose size is 4 bytes (e.g., <code class="language-plaintext highlighter-rouge">u32</code>, <code class="language-plaintext highlighter-rouge">i32</code>, <code class="language-plaintext highlighter-rouge">f32</code>)</li>
  <li>2 bytes for types whose size is 2 bytes (e.g., <code class="language-plaintext highlighter-rouge">u16</code>, <code class="language-plaintext highlighter-rouge">i16</code>)</li>
  <li>1 byte for types whose size is 1 byte (e.g., <code class="language-plaintext highlighter-rouge">u8</code>, <code class="language-plaintext highlighter-rouge">i8</code>)</li>
  <li>The alignment of a type is usually equal to its size, but only up to the CPU’s word size
(which is 8 bytes on 64-bit Intel CPUs). So, the maximum default alignment for most
types is 8 bytes. Custom types (structs, arrays) may have larger alignment if specified
with <code class="language-plaintext highlighter-rouge">repr(align(N))</code>.</li>
</ul>

<p>Let’s play with the following example to understand how how alignment can affect the
layout of a struct in memory.</p>

<p>First add the following dependencies to your project:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo add r3bl_tui
</code></pre></div></div>

<p>Then you can run the following code to see the alignment in Rust:</p>

<div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::{</span><span class="n">size_of</span><span class="p">,</span> <span class="n">align_of</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">r3bl_tui</span><span class="p">::{</span><span class="n">fg_light_yellow_green</span><span class="p">,</span> <span class="n">fg_lizard_green</span><span class="p">};</span>
<span class="k">struct</span> <span class="n">Demo</span> <span class="p">{</span>
    <span class="n">a</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>  <span class="c1">// 1 byte, alignment 1</span>
    <span class="n">b</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="c1">// 4 bytes, alignment 4</span>
    <span class="n">c</span><span class="p">:</span> <span class="nb">u16</span><span class="p">,</span> <span class="c1">// 2 bytes, alignment 2</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">size</span> <span class="o">=</span> <span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Demo</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">align</span> <span class="o">=</span> <span class="nn">align_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Demo</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">align</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

    <span class="nf">fg_lizard_green</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Size of Demo: {size}"</span><span class="p">))</span><span class="nf">.println</span><span class="p">();</span>
    <span class="nf">fg_light_yellow_green</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"Alignment of Demo: {align}"</span><span class="p">))</span><span class="nf">.println</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here’s what this would like if we used C alignment rules instead of Rust:</p>

<div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::{</span><span class="n">size_of</span><span class="p">,</span> <span class="n">align_of</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">r3bl_tui</span><span class="p">::{</span><span class="n">fg_light_yellow_green</span><span class="p">,</span> <span class="n">fg_lizard_green</span><span class="p">};</span>
<span class="nd">#[repr(C)]</span>
<span class="k">struct</span> <span class="n">Demo</span> <span class="p">{</span>
    <span class="n">a</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>  <span class="c1">// 1 byte, alignment 1</span>
    <span class="n">b</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="c1">// 4 bytes, alignment 4</span>
    <span class="n">c</span><span class="p">:</span> <span class="nb">u16</span><span class="p">,</span> <span class="c1">// 2 bytes, alignment 2</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">size</span> <span class="o">=</span> <span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Demo</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">align</span> <span class="o">=</span> <span class="nn">align_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Demo</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">align</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

    <span class="nf">fg_lizard_green</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Size of Demo: {size}"</span><span class="p">))</span><span class="nf">.println</span><span class="p">();</span>
    <span class="nf">fg_light_yellow_green</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"Alignment of Demo: {align}"</span><span class="p">))</span><span class="nf">.println</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The default alignment of 4 bytes for many types (like <code class="language-plaintext highlighter-rouge">u32</code> or <code class="language-plaintext highlighter-rouge">i32</code>) is based on their
size and the requirements of most modern CPUs, especially 32-bit architectures. The
alignment ensures that memory accesses are efficient and compatible with the CPU’s
expectations.</p>

<ul>
  <li>On a 32-bit CPU, the natural word size is 4 bytes, so types like <code class="language-plaintext highlighter-rouge">u32</code> and pointers are
aligned to 4 bytes.</li>
  <li>On a 64-bit CPU, the natural word size is 8 bytes, so types like <code class="language-plaintext highlighter-rouge">u64</code> and pointers are
aligned to 8 bytes. However, smaller types (<code class="language-plaintext highlighter-rouge">u32</code>, <code class="language-plaintext highlighter-rouge">i32</code>, etc.) still have 4-byte
alignment, unless you use a type that requires more.</li>
</ul>

<p>Next, let’s work with an example that shows the alignment of different types.</p>

<p>First add the following dependencies to your project:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo add r3bl_tui
</code></pre></div></div>

<p>Then you can run the following code:</p>

<div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::{</span><span class="n">size_of</span><span class="p">,</span> <span class="n">align_of</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">r3bl_tui</span><span class="p">::{</span><span class="n">fg_light_yellow_green</span><span class="p">,</span> <span class="n">fg_lizard_green</span><span class="p">};</span>

<span class="k">fn</span> <span class="n">pretty_print</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">type_name</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">any</span><span class="p">::</span><span class="nn">type_name</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">size</span> <span class="o">=</span> <span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">align</span> <span class="o">=</span> <span class="nn">align_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="nf">fg_lizard_green</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">{type_name}"</span><span class="p">))</span><span class="nf">.println</span><span class="p">();</span>
    <span class="nf">fg_light_yellow_green</span><span class="p">(</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"  size = {size}</span><span class="se">\n</span><span class="s">  alignment = {align}"</span><span class="p">)</span>
    <span class="p">)</span><span class="nf">.println</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nn">pretty_print</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="nn">pretty_print</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u16</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="nn">pretty_print</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="nn">pretty_print</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="nn">pretty_print</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="nn">pretty_print</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">f64</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Resources:</p>

<ul>
  <li><a href="https://doc.rust-lang.org/reference/type-layout.html">Rust Reference: Type Layout</a></li>
  <li><a href="https://users.rust-lang.org/t/type-alignment-understanding-memory-layout/126503/56">Forum discussion</a></li>
</ul>

<h2 id="global-allocators">Global allocators</h2>

<p><code class="language-plaintext highlighter-rouge">jemalloc</code> is a replacement for the default global allocator. It’s optimized for
multi-threaded use cases where lots of small objects are created and destroyed. The
default allocator is the system allocator that’s optimized for single threaded use cases.</p>

<ul>
  <li><a href="https://www.svix.com/blog/heap-fragmentation-in-rust-applications/">https://www.svix.com/blog/heap-fragmentation-in-rust-applications/</a></li>
  <li><a href="https://news.ycombinator.com/item?id=35473271">https://news.ycombinator.com/item?id=35473271</a></li>
  <li><a href="https://crates.io/crates/jemallocator">https://crates.io/crates/jemallocator</a></li>
  <li><a href="https://engineering.fb.com/2011/01/03/core-infra/scalable-memory-allocation-using-jemalloc/">https://engineering.fb.com/2011/01/03/core-infra/scalable-memory-allocation-using-jemalloc/</a></li>
</ul>

<p>Here’s an example of how to use <code class="language-plaintext highlighter-rouge">jemalloc</code> as the global allocator in a Rust project.</p>

<p>First add the following dependencies to your project:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo add tikv-jemallocator r3bl_tui
</code></pre></div></div>

<p>Then you can use it in your code:</p>

<div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">r3bl_tui</span><span class="p">::</span><span class="n">set_jemalloc_in_main</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">set_jemalloc_in_main!</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"jemalloc allocator is set."</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="using-arrays-for-stack-or-heap-allocation">Using arrays for stack or heap allocation</h2>

<p>A ring buffer is a data structure that uses a fixed-size array to store elements in a
circular manner. It is often used in scenarios where a fixed-size buffer is needed, such
as in embedded systems or real-time applications. The ring buffer can be implemented using
either stack or heap allocation, depending on the requirements of the application.</p>

<p>Regardless of allocating this on the stack or the heap, we are working with a fixed-size
array, which can’t be resized. So instead of using a <code class="language-plaintext highlighter-rouge">Vec</code>, we can use a fixed-size array.</p>

<p>Here are some tips on how to work with these types of data structures in Rust:</p>

<ol>
  <li>Here’s the pattern we can use for declaring how the data will be stored in the ring
buffer struct: <code class="language-plaintext highlighter-rouge">internal_storage: [Option&lt;T&gt;; N]</code>. The type is <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code> because any
slot in the ring buffer can be empty or contain a value.</li>
  <li>In order to construct this struct, we can use the pattern
<code class="language-plaintext highlighter-rouge">internal_storage: [(); N].map(|_| None)</code>, which works for any <code class="language-plaintext highlighter-rouge">T</code>. Since
<code class="language-plaintext highlighter-rouge">internal_storage: [None; N]</code> does not work unless you are willing to constrain
<code class="language-plaintext highlighter-rouge">T: Copy</code> which can be limiting.</li>
  <li>The struct will have to use this generic header:
<code class="language-plaintext highlighter-rouge">pub struct RingBuffer&lt;T, const N: usize&gt;</code>. This allows us to create a ring buffer of
any type <code class="language-plaintext highlighter-rouge">T</code> with a fixed size <code class="language-plaintext highlighter-rouge">N</code>.</li>
  <li>The impl block of this struct will have to use the same generic header:
<code class="language-plaintext highlighter-rouge">impl&lt;T, const N: usize&gt; RingBuffer&lt;T, N&gt;</code>. This allows us to implement methods for the
ring buffer that can work with any type <code class="language-plaintext highlighter-rouge">T</code> and any size <code class="language-plaintext highlighter-rouge">N</code>.</li>
</ol>

<div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">//! - Show stack alloc ring buffer using array allocated on stack.</span>
<span class="cd">//! - And pre-allocate using the pattern `internal_storage: [Option&lt;T&gt;; N]`.</span>
<span class="cd">//! - Show this constructor magic: `internal_storage: [(); N].map(|_| None)`.</span>
<span class="cd">//! - Show this generic header: `pub struct RingBuffer&lt;T, const N: usize&gt;`.</span>
<span class="cd">//! - Show the impl block with the same generic header: `impl&lt;T, const N: usize&gt;`.</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">RingBuffer</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">internal_storage</span><span class="p">:</span> <span class="p">[</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span> <span class="n">N</span><span class="p">],</span>
    <span class="n">head</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">tail</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">count</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">RingBuffer</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="n">RingBuffer</span> <span class="p">{</span>
            <span class="n">internal_storage</span><span class="p">:</span> <span class="p">[();</span> <span class="n">N</span><span class="p">]</span><span class="nf">.map</span><span class="p">(|</span><span class="n">_</span><span class="p">|</span> <span class="nb">None</span><span class="p">),</span>
            <span class="n">head</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">tail</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">count</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.count</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">cap</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="n">N</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.count</span> <span class="o">==</span> <span class="n">N</span> <span class="p">{</span>
            <span class="c1">// Buffer is full, overwrite the oldest item.</span>
            <span class="k">self</span><span class="py">.tail</span> <span class="o">=</span> <span class="p">(</span><span class="k">self</span><span class="py">.tail</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">self</span><span class="py">.internal_storage</span><span class="p">[</span><span class="k">self</span><span class="py">.head</span><span class="p">]</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
        <span class="k">self</span><span class="py">.head</span> <span class="o">=</span> <span class="p">(</span><span class="k">self</span><span class="py">.head</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">remove</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">None</span><span class="p">;</span> <span class="c1">// Buffer is empty.</span>
        <span class="p">}</span>
        <span class="k">let</span> <span class="n">item</span> <span class="o">=</span> <span class="k">self</span><span class="py">.internal_storage</span><span class="p">[</span><span class="k">self</span><span class="py">.tail</span><span class="p">]</span><span class="nf">.take</span><span class="p">();</span>
        <span class="k">self</span><span class="py">.tail</span> <span class="o">=</span> <span class="p">(</span><span class="k">self</span><span class="py">.tail</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span><span class="p">;</span>
        <span class="k">self</span><span class="py">.count</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">item</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">ring_buffer_inline_tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_queue_api</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">rb</span> <span class="o">=</span> <span class="nn">RingBuffer</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="c1">// Partially fill the ring buffer.</span>
        <span class="p">{</span>
            <span class="n">rb</span><span class="nf">.add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
            <span class="n">rb</span><span class="nf">.add</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
            <span class="n">rb</span><span class="nf">.add</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">rb</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">3</span><span class="p">);</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">rb</span><span class="nf">.cap</span><span class="p">(),</span> <span class="mi">4</span><span class="p">);</span>

            <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="n">rb</span><span class="nf">.remove</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">rb</span><span class="nf">.remove</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="n">rb</span><span class="nf">.remove</span><span class="p">();</span>

            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="c1">// Fill the ring buffer to capacity.</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">4</span> <span class="p">{</span>
                <span class="n">rb</span><span class="nf">.add</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">rb</span><span class="nf">.remove</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">rb</span><span class="nf">.remove</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">rb</span><span class="nf">.remove</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">rb</span><span class="nf">.remove</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">rb</span><span class="nf">.remove</span><span class="p">(),</span> <span class="nb">None</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Overfill the ring buffer.</span>
        <span class="p">{</span>
            <span class="n">rb</span><span class="nf">.add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
            <span class="n">rb</span><span class="nf">.add</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
            <span class="n">rb</span><span class="nf">.add</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
            <span class="n">rb</span><span class="nf">.add</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
            <span class="n">rb</span><span class="nf">.add</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">rb</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">4</span><span class="p">);</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">rb</span><span class="nf">.cap</span><span class="p">(),</span> <span class="mi">4</span><span class="p">);</span>

            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">rb</span><span class="nf">.remove</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">rb</span><span class="nf">.remove</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">rb</span><span class="nf">.remove</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">rb</span><span class="nf">.remove</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">rb</span><span class="nf">.remove</span><span class="p">(),</span> <span class="nb">None</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="using-smallvec-and-smallstr-crates">Using smallvec and smallstr crates</h2>

<h3 id="smallvec">smallvec</h3>

<p><code class="language-plaintext highlighter-rouge">smallvec</code> is a crate that is part of the Servo project (which is now in the Linux
Foundation) that provides a vector type that can store a small number of elements on the
stack. If the capacity of the vector exceeds the stack size, it will automatically
allocate on the heap. You can check this using the <code class="language-plaintext highlighter-rouge">spilled()</code> method.</p>

<p>This is useful if you want to allocate a small number of <code class="language-plaintext highlighter-rouge">Sized</code> items on the stack.
However, if you have a large number of items, then <code class="language-plaintext highlighter-rouge">Vec</code> is a better choice. Also the size
of the stack is typically limited to 8MB on most systems, so be careful when using
<code class="language-plaintext highlighter-rouge">smallvec</code> with large types or lots of items of a type, to avoid stack overflow.</p>

<p>The <code class="language-plaintext highlighter-rouge">r3bl_tui</code> crate provides a <code class="language-plaintext highlighter-rouge">InlineVec</code> type that is a wrapper around
<code class="language-plaintext highlighter-rouge">smallvec::SmallVec</code> and a <code class="language-plaintext highlighter-rouge">inline_vec!</code> macro that can be used to create an <code class="language-plaintext highlighter-rouge">InlineVec</code>
with items that are provided inline to the macro.</p>

<p>To run the example below, first add the following dependencies to your project:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo add smallvec r3bl_tui
</code></pre></div></div>

<p>Then you can run the following code:</p>

<div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">//! This module demonstrates the use of `smallvec` crate. And easier to</span>
<span class="cd">//! use version: `InlineVec`.</span>
<span class="cd">//!</span>
<span class="cd">//! - Show how to use smallvec -&gt; InlineVec</span>
<span class="cd">//! - Show how to use smallstr -&gt; InlineString</span>
<span class="cd">//! - Use the join_ macros from r3bl_tui</span>

<span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">inline_vec_ex_tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">r3bl_tui</span><span class="p">::{</span><span class="nb">Index</span><span class="p">,</span> <span class="n">InlineVec</span><span class="p">,</span> <span class="n">Length</span><span class="p">,</span> <span class="n">fg_lizard_green</span><span class="p">,</span> <span class="n">inline_vec</span><span class="p">,</span> <span class="n">len</span><span class="p">};</span>

    <span class="nd">#[serial_test::serial]</span>
    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">test_new_inline_vec</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Using with default capacity. Use `[]` accessor.</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">inline_vec</span> <span class="o">=</span> <span class="nn">InlineVec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">length</span><span class="p">:</span> <span class="n">Length</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// 5</span>
            <span class="k">let</span> <span class="n">max_index</span><span class="p">:</span> <span class="nb">Index</span> <span class="o">=</span> <span class="n">length</span><span class="nf">.convert_to_index</span><span class="p">();</span> <span class="c1">// 4</span>
            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..=</span><span class="n">max_index</span><span class="nf">.as_usize</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">inline_vec</span><span class="nf">.push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// 0, 1, 2, 3, 4</span>
            <span class="p">}</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="p">[</span><span class="nn">Index</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="nf">.as_usize</span><span class="p">()],</span> <span class="mi">0</span><span class="p">);</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="p">[</span><span class="n">max_index</span><span class="nf">.as_usize</span><span class="p">()],</span> <span class="mi">4</span><span class="p">);</span>
            <span class="c1">// assert_eq!(inline_vec[max_index.as_usize() + 1], 0); // OOB error!</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.get</span><span class="p">(</span><span class="n">max_index</span><span class="nf">.as_usize</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">None</span><span class="p">);</span>
            <span class="nf">fg_lizard_green</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"InlineVec: {:?}"</span><span class="p">,</span> <span class="n">inline_vec</span><span class="p">))</span><span class="nf">.println</span><span class="p">();</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.capacity</span><span class="p">(),</span> <span class="mi">8</span><span class="p">);</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">5</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Using with macro. Use `get()` accessor.</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">length</span><span class="p">:</span> <span class="n">Length</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// 5</span>
            <span class="k">let</span> <span class="n">max_index</span><span class="p">:</span> <span class="nb">Index</span> <span class="o">=</span> <span class="n">length</span><span class="nf">.convert_to_index</span><span class="p">();</span> <span class="c1">// 4</span>
            <span class="k">let</span> <span class="n">inline_vec</span> <span class="o">=</span> <span class="nd">inline_vec!</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.get</span><span class="p">(</span><span class="nn">Index</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="nf">.as_usize</span><span class="p">()),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">0</span><span class="p">));</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.get</span><span class="p">(</span><span class="n">max_index</span><span class="nf">.as_usize</span><span class="p">()),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">4</span><span class="p">));</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.get</span><span class="p">(</span><span class="n">max_index</span><span class="nf">.as_usize</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">None</span><span class="p">);</span>
            <span class="nf">fg_lizard_green</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"InlineVec: {:?}"</span><span class="p">,</span> <span class="n">inline_vec</span><span class="p">))</span><span class="nf">.println</span><span class="p">();</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.capacity</span><span class="p">(),</span> <span class="mi">8</span><span class="p">);</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">5</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Using with capacity (even though it is pre-allocated). Use `get()` accessor.</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">inline_vec</span> <span class="o">=</span> <span class="nn">InlineVec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">length</span><span class="p">:</span> <span class="n">Length</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// 5</span>
            <span class="k">let</span> <span class="n">max_index</span><span class="p">:</span> <span class="nb">Index</span> <span class="o">=</span> <span class="n">length</span><span class="nf">.convert_to_index</span><span class="p">();</span> <span class="c1">// 4</span>
            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..=</span><span class="n">max_index</span><span class="nf">.as_usize</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">inline_vec</span><span class="nf">.push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// 0, 1, 2, 3, 4</span>
            <span class="p">}</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.get</span><span class="p">(</span><span class="nn">Index</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="nf">.as_usize</span><span class="p">()),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">0</span><span class="p">));</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.get</span><span class="p">(</span><span class="n">max_index</span><span class="nf">.as_usize</span><span class="p">()),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">4</span><span class="p">));</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.get</span><span class="p">(</span><span class="n">max_index</span><span class="nf">.as_usize</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">None</span><span class="p">);</span>
            <span class="nf">fg_lizard_green</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"InlineVec: {:?}"</span><span class="p">,</span> <span class="n">inline_vec</span><span class="p">))</span><span class="nf">.println</span><span class="p">();</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.capacity</span><span class="p">(),</span> <span class="mi">8</span><span class="p">);</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">5</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">#[serial_test::serial]</span>
    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">test_mut_inline_vec</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">inline_vec</span> <span class="o">=</span> <span class="nn">InlineVec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="k">let</span> <span class="n">length</span><span class="p">:</span> <span class="n">Length</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// 5</span>
        <span class="k">let</span> <span class="n">max_index</span><span class="p">:</span> <span class="nb">Index</span> <span class="o">=</span> <span class="n">length</span><span class="nf">.convert_to_index</span><span class="p">();</span> <span class="c1">// 4</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..=</span><span class="n">max_index</span><span class="nf">.as_usize</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">inline_vec</span><span class="nf">.push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// 0, 1, 2, 3, 4</span>
        <span class="p">}</span>

        <span class="n">inline_vec</span><span class="p">[</span><span class="n">max_index</span><span class="nf">.as_usize</span><span class="p">()]</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="p">[</span><span class="n">max_index</span><span class="nf">.as_usize</span><span class="p">()],</span> <span class="mi">100</span><span class="p">);</span>

        <span class="nf">fg_lizard_green</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"InlineVec: {:?}"</span><span class="p">,</span> <span class="n">inline_vec</span><span class="p">))</span><span class="nf">.println</span><span class="p">();</span>

        <span class="c1">// Remove the first element, and shift the rest.</span>
        <span class="n">inline_vec</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">4</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.capacity</span><span class="p">(),</span> <span class="mi">8</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">100</span><span class="p">);</span>
        <span class="nf">fg_lizard_green</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"InlineVec: {:?}"</span><span class="p">,</span> <span class="n">inline_vec</span><span class="p">))</span><span class="nf">.println</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="nd">#[serial_test::serial]</span>
    <span class="nd">#[test]</span>
    <span class="nd">#[should_panic]</span>
    <span class="k">fn</span> <span class="nf">test_inline_vec_oob</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">inline_vec</span> <span class="o">=</span> <span class="nn">InlineVec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.capacity</span><span class="p">(),</span> <span class="mi">8</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">length</span><span class="p">:</span> <span class="n">Length</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// 5</span>
        <span class="k">let</span> <span class="n">max_index</span><span class="p">:</span> <span class="nb">Index</span> <span class="o">=</span> <span class="n">length</span><span class="nf">.convert_to_index</span><span class="p">();</span> <span class="c1">// 4</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..=</span><span class="n">max_index</span><span class="nf">.as_usize</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">inline_vec</span><span class="nf">.push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// 0, 1, 2, 3, 4</span>
        <span class="p">}</span>

        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.capacity</span><span class="p">(),</span> <span class="mi">8</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">5</span><span class="p">);</span>

        <span class="c1">// This should panic because we are trying to access an index that is out of</span>
        <span class="c1">// bounds.</span>
        <span class="n">inline_vec</span><span class="p">[</span><span class="n">max_index</span><span class="nf">.as_usize</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">smallvec_ex_tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">smallvec</span><span class="p">::{</span><span class="n">SmallVec</span><span class="p">,</span> <span class="n">smallvec</span><span class="p">};</span>

    <span class="c1">// Type alias to reduce typing.</span>
    <span class="k">type</span> <span class="n">MySmallVec</span> <span class="o">=</span> <span class="n">SmallVec</span><span class="o">&lt;</span><span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">4</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="nd">#[serial_test::serial]</span>
    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">test_new_smallvec</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// With new.</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">acc</span> <span class="o">=</span> <span class="nn">MySmallVec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..=</span><span class="mi">2</span> <span class="p">{</span>
                <span class="n">acc</span><span class="nf">.push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// 0, 1, 2</span>
            <span class="p">}</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">3</span><span class="p">);</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="nf">.capacity</span><span class="p">(),</span> <span class="mi">4</span><span class="p">);</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="nf">.get</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">0</span><span class="p">));</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="nf">.get</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">));</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="nf">.get</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">2</span><span class="p">));</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="nf">.get</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="nb">None</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// With macro.</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">acc</span><span class="p">:</span> <span class="n">MySmallVec</span> <span class="o">=</span> <span class="nd">smallvec!</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">3</span><span class="p">);</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="nf">.capacity</span><span class="p">(),</span> <span class="mi">4</span><span class="p">);</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">#[serial_test::serial]</span>
    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">test_mut_smallvec</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">acc</span> <span class="o">=</span> <span class="nn">MySmallVec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..=</span><span class="mi">2</span> <span class="p">{</span>
            <span class="n">acc</span><span class="nf">.push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// 0, 1, 2</span>
        <span class="p">}</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">3</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="nf">.capacity</span><span class="p">(),</span> <span class="mi">4</span><span class="p">);</span>

        <span class="n">acc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">100</span><span class="p">);</span>

        <span class="c1">// Remove the first element, and shift the rest.</span>
        <span class="n">acc</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">2</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="nf">.capacity</span><span class="p">(),</span> <span class="mi">4</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">100</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="smallstr">smallstr</h3>

<p>The <code class="language-plaintext highlighter-rouge">smallstr</code> crate is similar to <code class="language-plaintext highlighter-rouge">smallvec</code>, and it is build on top of <code class="language-plaintext highlighter-rouge">smallvec</code>. It
provides a string type that can store a small number of characters on the stack. If the
capacity of the string exceeds the stack size, it will automatically allocate on the heap.
This is useful for storing small strings on the stack, but if you have a large string,
then <code class="language-plaintext highlighter-rouge">String</code> is a better choice.</p>

<p>The <code class="language-plaintext highlighter-rouge">r3bl_tui</code> crate provides a <code class="language-plaintext highlighter-rouge">InlineString</code> type that is a wrapper around
<code class="language-plaintext highlighter-rouge">smallstr::SmallStr</code> and a <code class="language-plaintext highlighter-rouge">inline_string!</code> macro that can be used to create an
<code class="language-plaintext highlighter-rouge">InlineString</code> with items that are provided inline to the macro (use it like you would
<code class="language-plaintext highlighter-rouge">println!</code> since it uses <code class="language-plaintext highlighter-rouge">FmtArgs</code> under the hood).</p>

<p>To run the example below, first add the following dependencies to your project:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo add smallstr r3bl_tui
</code></pre></div></div>

<p>Then you can run the following code:</p>

<div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">//! This module demonstrates the use of `smallstr` crate. And easier to</span>
<span class="cd">//! use version of them: `InlineString`.</span>
<span class="cd">//!</span>
<span class="cd">//! Show how to use smallstr -&gt; InlineString</span>

<span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">inline_string_ex_tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">r3bl_tui</span><span class="p">::{</span><span class="n">InlineString</span><span class="p">,</span> <span class="n">fg_lizard_green</span><span class="p">,</span> <span class="n">fg_soft_pink</span><span class="p">,</span> <span class="n">inline_string</span><span class="p">};</span>
    <span class="k">use</span> <span class="nn">smallstr</span><span class="p">::</span><span class="n">SmallString</span><span class="p">;</span>

    <span class="nd">#[serial_test::serial]</span>
    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">test_new_inline_string</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Constructor.</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">acc</span> <span class="o">=</span> <span class="nn">InlineString</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Write</span> <span class="k">as</span> <span class="n">_</span><span class="p">;</span>
            <span class="n">_</span> <span class="o">=</span> <span class="nd">write!</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="s">"Hello, world!"</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="s">"Hello, world!"</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Macro.</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">acc</span> <span class="o">=</span> <span class="nd">inline_string!</span><span class="p">(</span><span class="s">"Hello,"</span><span class="p">);</span>
            <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Write</span> <span class="k">as</span> <span class="n">_</span><span class="p">;</span>
            <span class="n">_</span> <span class="o">=</span> <span class="nd">write!</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="s">" world!"</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="s">"Hello, world!"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cd">/// Demonstrates the use of `inline_string!` macro to create an</span>
    <span class="cd">/// `InlineString` and then format it using the `Display` trait.</span>
    <span class="cd">/// Without allocating a new [String] (on the heap).</span>
    <span class="nd">#[serial_test::serial]</span>
    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">test_new_inline_string_display_impl</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">DemoStruct</span> <span class="p">{</span>
            <span class="n">id</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
            <span class="n">name</span><span class="p">:</span> <span class="n">InlineString</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">impl</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span> <span class="k">for</span> <span class="n">DemoStruct</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
                <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"id: {}, name: {}"</span><span class="p">,</span> <span class="k">self</span><span class="py">.id</span><span class="p">,</span> <span class="k">self</span><span class="py">.name</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">demo</span> <span class="o">=</span> <span class="n">DemoStruct</span> <span class="p">{</span>
            <span class="n">id</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">name</span><span class="p">:</span> <span class="nd">inline_string!</span><span class="p">(</span><span class="s">"Hello, world!"</span><span class="p">),</span>
        <span class="p">};</span>
        <span class="k">let</span> <span class="n">to_inline_string</span> <span class="o">=</span> <span class="nd">inline_string!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">demo</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">to_inline_string</span><span class="p">,</span> <span class="s">"id: 1, name: Hello, world!"</span><span class="p">);</span>
        <span class="nf">fg_lizard_green</span><span class="p">(</span><span class="n">to_inline_string</span><span class="p">)</span><span class="nf">.println</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="nd">#[serial_test::serial]</span>
    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">test_new_smallstr</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">acc</span><span class="p">:</span> <span class="n">SmallString</span><span class="o">&lt;</span><span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">8</span><span class="p">]</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">SmallString</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="nf">.capacity</span><span class="p">(),</span> <span class="mi">8</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
        <span class="nf">fg_lizard_green</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"is spilled: {}"</span><span class="p">,</span> <span class="n">acc</span><span class="nf">.spilled</span><span class="p">()))</span><span class="nf">.println</span><span class="p">();</span>

        <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Write</span> <span class="k">as</span> <span class="n">_</span><span class="p">;</span>
        <span class="n">_</span> <span class="o">=</span> <span class="nd">write!</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="s">"Hello, world!"</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="s">"Hello, world!"</span><span class="p">);</span>

        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">13</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="nf">.spilled</span><span class="p">(),</span> <span class="kc">true</span><span class="p">);</span>
        <span class="nf">fg_soft_pink</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"is spilled: {}"</span><span class="p">,</span> <span class="n">acc</span><span class="nf">.spilled</span><span class="p">()))</span><span class="nf">.println</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="other-code-examples">Other code examples</h2>

<ol>
  <li><a href="https://github.com/r3bl-org/r3bl-open-core/blob/0479c4deb620c1e75f7d053627566e332996ee8b/core/src/common/ring_buffer.rs#L28">Fixed size buffer, array, ring buffer, one time alloc, no delete penalty</a></li>
  <li><a href="https://github.com/r3bl-org/r3bl-open-core/blob/0479c4deb620c1e75f7d053627566e332996ee8b/core/src/common/telemetry.rs#L414">Telemetry generate report to stack allocated fixed size buffer, re-use this, instead of heap alloc string</a></li>
  <li><a href="https://github.com/r3bl-org/r3bl-open-core/blob/0479c4deb620c1e75f7d053627566e332996ee8b/tui/examples/demo/ex_app_no_layout/app_main.rs#L74">smallvec usage to store data for ‘static, instead of vec! or &amp;[], supports mut, on stack, “spills” into heap if gets too big</a></li>
  <li><a href="https://github.com/r3bl-org/r3bl-open-core/blob/0479c4deb620c1e75f7d053627566e332996ee8b/tui/src/tui/editor/editor_buffer/editor_buffer_struct.rs#L199">smallvec used with unicodestring in editor buffer</a></li>
  <li><a href="https://github.com/r3bl-org/r3bl-open-core/blob/0479c4deb620c1e75f7d053627566e332996ee8b/tui/src/tui/md_parser/block/parse_block_smart_list.rs#L720">smallvec in nom parser</a></li>
  <li><a href="https://github.com/r3bl-org/r3bl-open-core/blob/0479c4deb620c1e75f7d053627566e332996ee8b/tui/src/tui/syntax_highlighting/md_parser_syn_hi/md_parser_syn_hi_impl.rs#L641">smallvec in scratch or intermediate data structures</a></li>
  <li><a href="https://github.com/r3bl-org/r3bl-open-core/blob/0479c4deb620c1e75f7d053627566e332996ee8b/tui/src/tui/terminal_lib_backends/offscreen_buffer.rs#L165">smallvec and smallstr used in offscreen buffer to prevent heap alloc for small &amp; frequent operations, and alloc internal buffers on stack, not heap</a></li>
  <li><a href="https://github.com/r3bl-org/r3bl-open-core/blob/0479c4deb620c1e75f7d053627566e332996ee8b/tui/src/tui/terminal_lib_backends/render_op.rs#L243">smallvec and smallstr used for fast Debug impl w/ formatter</a></li>
</ol>

<h2 id="build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</h2>

<p>You can watch Rust live coding videos with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a></li>
  <li>Playlists
    <ul>
      <li><a href="https://www.youtube.com/watch?v=bolScvh4x7I&amp;list=PLofhE49PEwmw3MKOU1Kn3xbP4FRQR4Mb3">Build with Naz, Linux TTY, process, signals, commands in async Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmza94sS7UmJnN9gSCHTVTfz">Build with Naz, fundamental effective Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmwO69E7eiQ-ewnMME8ydgQ5">Build with Naz, effective async Rust and tokio</a></li>
      <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CS" /><category term="Server" /><summary type="html"><![CDATA[Moore’s Law, the observation that the number of transistors on a chip doubles roughly every 2 years, ended around 2015–2020. This means CPU bound code that runs slowly will run slowly on future CPUs. The traditional approach of Big-O analysis and algorithmic improvements is no longer accurate, since it only accounts for "op-count" and ignores the cost of memory access. Modern CPUs have many cores, but each core isn't getting any faster. So using parallelism is another way to get more performance. Let's explore memory performance and latency in Rust.]]></summary></entry><entry><title type="html">Build with Naz : Diesel ORM, SQLite, and Rust</title><link href="http://developerlife.com/2024/11/28/rust-sqlite-diesel/" rel="alternate" type="text/html" title="Build with Naz : Diesel ORM, SQLite, and Rust" /><published>2024-11-28T00:00:00-06:00</published><updated>2024-11-28T00:00:00-06:00</updated><id>http://developerlife.com/2024/11/28/rust-sqlite-diesel</id><content type="html" xml:base="http://developerlife.com/2024/11/28/rust-sqlite-diesel/"><![CDATA[<p><img class="post-hero-image" src="/assets/rust-sqlite-diesel.png" /></p>

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#rusqlite-and-sqlite-example">rusqlite and SQLite example</a></li>
  <li><a href="#diesel-and-sqlite-example">diesel and SQLite example</a>
    <ul>
      <li><a href="#why-diesel-and-not-sqlx">Why Diesel and not SQLx?</a></li>
      <li><a href="#youtube-videos-for-this-article">YouTube videos for this article</a></li>
      <li><a href="#1-add-the-cargo-dependencies">1. Add the Cargo dependencies</a></li>
      <li><a href="#2-add-linux-packages-sqlite-dev-and-diesel-cli">2. Add Linux packages (sqlite-dev) and Diesel CLI</a></li>
      <li><a href="#3-use-the-diesel-cli-to-create-database-file-and-migrations">3. Use the Diesel CLI to create database file and migrations</a></li>
      <li><a href="#4-write-sql-migrations-then-run-them-to-create-tables-and-generate-schemars">4. Write SQL migrations, then run them to create tables and generate schema.rs</a>
        <ul>
          <li><a href="#41-what-is-the-difference-between-redo-and-run">4.1 What is the difference between redo and run?</a></li>
          <li><a href="#42-location-of-the-generated-schemars-file">4.2. Location of the generated schema.rs file</a></li>
          <li><a href="#43-for-the-current-migration-change-the-upsql-file-and-run-it-again">4.3. For the current migration, change the up.sql file and run it again</a></li>
        </ul>
      </li>
      <li><a href="#5-use-the-script-luke">5. Use the script, Luke</a>
        <ul>
          <li><a href="#51-instead-of-raw-sql-write-rust-for-migrations">5.1. Instead of raw SQL, write Rust for migrations</a></li>
          <li><a href="#52-include-migrations-in-the-final-binary">5.2. Include migrations in the final binary</a></li>
        </ul>
      </li>
      <li><a href="#6-add-a-new-migration-that-changes-existing-tables-by-adding-a-new-column-and-preserve-data">6. Add a new migration that changes existing tables by adding a new column and preserve data</a></li>
      <li><a href="#7-diesel-and-rust">7. Diesel and Rust</a>
        <ul>
          <li><a href="#create-a-connection">Create a connection</a></li>
          <li><a href="#crud-operations">CRUD operations</a></li>
          <li><a href="#timestamps">Timestamps</a></li>
          <li><a href="#automatically-run-migrations">Automatically run migrations</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#vscode-and-sqlite-extension">VSCode and SQLite extension</a></li>
  <li><a href="#history">History</a></li>
  <li><a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</a></li>
</ul>

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

<h2 id="introduction">Introduction</h2>

<p>This crate is an exploration of SQL in Rust. All the examples use SQLite as the database.
However, the driver / ORM used is different in each example.</p>

<ol>
  <li><a href="#rusqlite-and-sqlite-example"><code class="language-plaintext highlighter-rouge">rusqlite</code> and SQLite example</a></li>
  <li><a href="#diesel-and-sqlite-example"><code class="language-plaintext highlighter-rouge">diesel</code> and SQLite example</a></li>
</ol>

<blockquote>
  <p>The code in the video and this tutorial are all in <a href="https://github.com/nazmulidris/rust-scratch/tree/main/sql">this GitHub
repo</a>.</p>
</blockquote>

<h2 id="rusqlite-and-sqlite-example">rusqlite and SQLite example</h2>

<p>The <code class="language-plaintext highlighter-rouge">rusqlite</code> library is a low-level SQLite driver for Rust.</p>

<ul>
  <li>It is a thin wrapper around the SQLite C API.</li>
  <li>And it bundles the SQLite C library, so there is no need to install <code class="language-plaintext highlighter-rouge">sqlite3</code> on the
system.</li>
</ul>

<p>The primary use case that this example addresses is storing an application’s settings that
are a mix of binary and JSON formatted text data. Using the filesystem naively where we
have a separate file for each, can cause problems in scenarios where multiple processes of
this binary run concurrently. Instead we will use a SQLite database to store this data.</p>

<p>This example works with 2 tables:</p>

<ol>
  <li>One contains JSON Text formatted data, and the</li>
  <li>The other contains binary data that’s read for a file.</li>
</ol>

<p>This is meant to demonstrate how to work with JSON encoded data and binary data in SQLite
using Rust. The example
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/sql/src/bin/rusqlite_ex.rs">here</a>
does the following:</p>

<ul>
  <li>This will create a <code class="language-plaintext highlighter-rouge">rusqlite.db</code> file in the current directory.</li>
  <li>It will use the <code class="language-plaintext highlighter-rouge">rusqlite</code> Rust crate to interact with it to perform some simple CRUD
operations on the database.</li>
  <li>The code is very simple, there is no ORM, or SQL syntax checking, or migrations. The SQL
is just written as Rust strings.</li>
  <li>There are 2 tables, one containing JSON text data, and the other containing binary data.</li>
</ul>

<p>To run this example, use:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo run <span class="nt">--bin</span> rusqlite
</code></pre></div></div>

<h2 id="diesel-and-sqlite-example">diesel and SQLite example</h2>

<p>The <code class="language-plaintext highlighter-rouge">diesel</code> library is a high-level ORM for Rust.</p>

<blockquote>
  <p>The main instructions are from the
<a href="https://diesel.rs/guides/getting-started.html"><code class="language-plaintext highlighter-rouge">diesel</code> official getting started guide</a>
for use with SQLite.</p>
</blockquote>

<p>In this example we will work with Rust, Diesel, and SQLite to setup databases, using
migrations, and do CRUD operations in Rust code. Here are the details:</p>

<ol>
  <li>We will create a migration to setup the database.</li>
  <li>Then create the models.</li>
  <li>And write some code to do CRUD operations in Rust.</li>
  <li>Then we will add another migration to alter the database, then migrate any existing
data, and then update the models to reflect the changes.</li>
  <li>Finally, we will automate these migrations so that they don’t have to be run manually.
And they will be done in your binary target when it starts.</li>
</ol>

<p>The example
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/sql/src/bin/diesel_sqlite_ex.rs">here</a>
does the following:</p>

<ul>
  <li>This will create a <code class="language-plaintext highlighter-rouge">diesel.db</code> file in the current directory. It runs migrations as well
programmatically when the binary runs, at the very start.</li>
  <li>It will use the <code class="language-plaintext highlighter-rouge">diesel</code> Rust crate (and ORM) to interact with it to perform some simple
CRUD operations on the database.</li>
  <li>There are 2 tables, one containing JSON text data, and the other containing binary data.</li>
</ul>

<p>To run this example, use:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo run <span class="nt">--bin</span> diesel
</code></pre></div></div>

<h3 id="why-diesel-and-not-sqlx">Why Diesel and not SQLx?</h3>

<p><a href="https://users.rust-lang.org/t/which-one-to-use-postgres-vs-sqlx/63680/6">Here</a> are some
reasons to use Diesel over SQLx.</p>

<h3 id="youtube-videos-for-this-article">YouTube videos for this article</h3>
<p><a id="markdown-youtube-videos-for-this-article" name="youtube-videos-for-this-article"></a></p>

<p>If you like to learn via video, please watch the companion video on the <a href="https://www.youtube.com/@developerlifecom">developerlife.com
YouTube channel</a>. You can follow along with the video,
this article, and code in the <a href="https://github.com/nazmulidris/rust-scratch/tree/main/sql">repo</a>.</p>

<!-- rust diesel sqlite -->
<iframe src="https://www.youtube.com/embed/d9x_5X9R5LI?si=DiNiF8GVG3aoNdig" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<blockquote>
  <p>The code in the video and this tutorial are all in <a href="https://github.com/nazmulidris/rust-scratch/tree/main/sql">this GitHub
repo</a>.</p>
</blockquote>

<h3 id="1-add-the-cargo-dependencies">1. Add the Cargo dependencies</h3>

<p>Here are the commands to add the required dependencies in <code class="language-plaintext highlighter-rouge">Cargo.toml</code>:</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="py">diesel</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"2.2.0"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"sqlite"</span><span class="p">,</span> <span class="s">"returning_clauses_for_sqlite_3_35"</span><span class="p">]</span> <span class="p">}</span>
<span class="py">dotenvy</span> <span class="p">=</span> <span class="s">"0.15"</span>
</code></pre></div></div>

<h3 id="2-add-linux-packages-sqlite-dev-and-diesel-cli">2. Add Linux packages (sqlite-dev) and Diesel CLI</h3>

<blockquote>
  <p>All the steps between 2 and 5 can be automated by running the <code class="language-plaintext highlighter-rouge">diesel_setup.sh</code> script.</p>
</blockquote>

<p>Here are the commands to setup the Diesel CLI for SQLite for Linux:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>libsqlite3-dev
cargo <span class="nb">install </span>diesel_cli <span class="nt">--no-default-features</span> <span class="nt">--features</span> sqlite
</code></pre></div></div>

<h3 id="3-use-the-diesel-cli-to-create-database-file-and-migrations">3. Use the Diesel CLI to create database file and migrations</h3>

<p>There are a few ways to run <code class="language-plaintext highlighter-rouge">diesel setup</code>. The <code class="language-plaintext highlighter-rouge">path/to/your/database.db</code> is the value
for <code class="language-plaintext highlighter-rouge">DATABASE_URL</code>.</p>

<ol>
  <li>
    <p>Use the <code class="language-plaintext highlighter-rouge">.env</code> file to store the <code class="language-plaintext highlighter-rouge">DATABASE_URL</code> environment variable. Run
<code class="language-plaintext highlighter-rouge">echo DATABASE_URL=diesel.db &gt; .env</code>. Then you can run <code class="language-plaintext highlighter-rouge">diesel setup</code>.</p>
  </li>
  <li>
    <p>If you don’t want to set this environment variable, you can just pass it inline to the
shell <code class="language-plaintext highlighter-rouge">DATABASE_URL=diesel.db diesel setup</code>.</p>
  </li>
  <li>
    <p>You can use the <code class="language-plaintext highlighter-rouge">--database-url</code> flag to specify the path to the database directly. For
example: <code class="language-plaintext highlighter-rouge">diesel --database-url=diesel.db setup</code>.</p>
  </li>
</ol>

<p>We are going to use the 3rd option. Here are the commands to setup the database file.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>diesel <span class="nt">--database-url</span><span class="o">=</span>diesel.db setup
</code></pre></div></div>

<p>This command actually creates the database file. The <code class="language-plaintext highlighter-rouge">diesel.db</code> file is created in the
current directory. If the migrations are already present (as can be gleaned from the
<code class="language-plaintext highlighter-rouge">diesel.toml</code> file), then the <code class="language-plaintext highlighter-rouge">schema.rs</code> file is generated and the <code class="language-plaintext highlighter-rouge">diesel.db</code> file is
generated.</p>

<h3 id="4-write-sql-migrations-then-run-them-to-create-tables-and-generate-schemars">4. Write SQL migrations, then run them to create tables and generate schema.rs</h3>

<p>Now that the database file is created, we have to define our migration, that will actually
run some SQL that we provide and generate the <code class="language-plaintext highlighter-rouge">schema.rs</code> file. This process can also
happen in reverse, where we can write the <code class="language-plaintext highlighter-rouge">schema.rs</code> file first and ask the Diesel CLI to
generate the SQL migrations folder, and the <code class="language-plaintext highlighter-rouge">up.sql</code> and <code class="language-plaintext highlighter-rouge">down.sql</code> files.</p>

<p>The following commands will create a folder called <code class="language-plaintext highlighter-rouge">migrations</code> at the top level of the
project. Inside this folder, there will be one folder, for the migration called
<code class="language-plaintext highlighter-rouge">create_tables</code>. The folder will look like <code class="language-plaintext highlighter-rouge">&lt;timestamp&gt;_create_tables</code> and will contain an
<code class="language-plaintext highlighter-rouge">up.sql</code> and <code class="language-plaintext highlighter-rouge">down.sql</code> file.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>diesel <span class="nt">--database-url</span><span class="o">=</span>diesel.db migration generate create_tables
</code></pre></div></div>

<p>Migrations allow us to evolve the database schema over time. Each migration consists of an
<code class="language-plaintext highlighter-rouge">up.sql</code> file to apply the changes and a <code class="language-plaintext highlighter-rouge">down.sql</code> file to revert them. Applying and
immediately reverting a migration should leave your database schema unchanged.</p>

<blockquote>
  <p>If you have multiple migrations, they will be applied in the order they were created.
They are additive. In this example, we create a single migration, and the <code class="language-plaintext highlighter-rouge">up.sql</code> in it
creates two tables. However, we could have split this into two migrations, one for each
table. The <code class="language-plaintext highlighter-rouge">down.sql</code> does not get run when there are multiple migrations. It only gets
run when you run <code class="language-plaintext highlighter-rouge">diesel migration redo</code> or <code class="language-plaintext highlighter-rouge">diesel migration revert</code>.</p>
</blockquote>

<p>Once migrations are created they can be checked into version control. The folder structure
for each table has a timestamp in it, and contains a <code class="language-plaintext highlighter-rouge">up.sql</code> and <code class="language-plaintext highlighter-rouge">down.sql</code> file.</p>

<p>Here’s the <code class="language-plaintext highlighter-rouge">up.sql</code>:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">create</span> <span class="k">table</span> <span class="n">if</span> <span class="k">not</span> <span class="k">exists</span> <span class="n">data_table</span> <span class="p">(</span>
  <span class="n">id</span> <span class="nb">text</span> <span class="k">primary</span> <span class="k">key</span> <span class="k">not</span> <span class="k">null</span><span class="p">,</span>
  <span class="n">name</span> <span class="nb">text</span> <span class="k">not</span> <span class="k">null</span><span class="p">,</span>
  <span class="k">data</span> <span class="nb">text</span> <span class="k">not</span> <span class="k">null</span>
<span class="p">);</span>

<span class="k">create</span> <span class="k">table</span> <span class="n">if</span> <span class="k">not</span> <span class="k">exists</span> <span class="n">file_table</span> <span class="p">(</span>
  <span class="n">id</span> <span class="nb">text</span> <span class="k">primary</span> <span class="k">key</span> <span class="k">not</span> <span class="k">null</span><span class="p">,</span>
  <span class="n">name</span> <span class="nb">text</span> <span class="k">not</span> <span class="k">null</span><span class="p">,</span>
  <span class="k">data</span> <span class="nb">blob</span> <span class="k">not</span> <span class="k">null</span>
<span class="p">);</span>
</code></pre></div></div>

<p>Here’s the <code class="language-plaintext highlighter-rouge">down.sql</code>:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">drop</span> <span class="k">table</span> <span class="n">if</span> <span class="k">exists</span> <span class="n">data_table</span><span class="p">;</span>

<span class="k">drop</span> <span class="k">table</span> <span class="n">if</span> <span class="k">exists</span> <span class="n">file_table</span><span class="p">;</span>
</code></pre></div></div>

<p>Then execute the migrations:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># This executes the `up.sql` file.</span>
diesel <span class="nt">--database-url</span><span class="o">=</span>diesel.db migration run
<span class="c"># This executes the `down.sql`, then `up.sql`.</span>
diesel <span class="nt">--database-url</span><span class="o">=</span>diesel.db migration redo
</code></pre></div></div>

<p>The commands above will create a <code class="language-plaintext highlighter-rouge">diesel.db</code> file in the current directory if it does not
exist.</p>

<p>Note that the <code class="language-plaintext highlighter-rouge">redo</code> command does not work unless the <code class="language-plaintext highlighter-rouge">run</code> command has been executed at
least once. Just to be safe, it is also best to delete the <code class="language-plaintext highlighter-rouge">diesel.db</code> file in order to do
a total reset; then run <code class="language-plaintext highlighter-rouge">run</code> and then <code class="language-plaintext highlighter-rouge">redo</code>.</p>

<h4 id="41-what-is-the-difference-between-redo-and-run">4.1 What is the difference between redo and run?</h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">redo</code> will run the <code class="language-plaintext highlighter-rouge">down.sql</code> and then the <code class="language-plaintext highlighter-rouge">up.sql</code> file.</li>
  <li><code class="language-plaintext highlighter-rouge">run</code> will only run the <code class="language-plaintext highlighter-rouge">up.sql</code> file.</li>
</ul>

<blockquote>
  <p>Both commands will preserve any existing data in the <code class="language-plaintext highlighter-rouge">diesel.db</code> file. Migrations will
not destroy the data in the tables, unless you explicitly write SQL to do so.</p>
</blockquote>

<p>Let’s say you have <code class="language-plaintext highlighter-rouge">run</code> the migration and then you make a change to <code class="language-plaintext highlighter-rouge">up.sql</code> above, and
add a new column. If you run <code class="language-plaintext highlighter-rouge">run</code> again you will <strong>not</strong> see these changes in your
<code class="language-plaintext highlighter-rouge">schema.rs</code> file!</p>

<p>You could run <code class="language-plaintext highlighter-rouge">redo</code>, which will run <code class="language-plaintext highlighter-rouge">down.sql</code> and then <code class="language-plaintext highlighter-rouge">up.sql</code>, and this should drop
the table from the <code class="language-plaintext highlighter-rouge">diesel.db</code> file and then recreate it with the new column.</p>

<p>However, in this scenario it might be best to create a new migration and not modify the
existing one. This way you can keep track of the changes you made to the database schema
over time. Once you create the
<a href="#6-add-a-new-migration-that-changes-existing-tables-by-adding-a-new-column-and-preserve-data">new migration</a>,
you can run <code class="language-plaintext highlighter-rouge">diesel --database-url=diesel.db migration run</code> to apply the changes.</p>

<h4 id="42-location-of-the-generated-schemars-file">4.2. Location of the generated schema.rs file</h4>

<p>This will also generate the <code class="language-plaintext highlighter-rouge">schema.rs</code> file in the <code class="language-plaintext highlighter-rouge">src</code> directory. This file will have
the Rust representation of the tables in the database. You can change the location of this
file by changing the <code class="language-plaintext highlighter-rouge">diesel.toml</code> file and setting the path for the <code class="language-plaintext highlighter-rouge">print_schema:file</code>
key. Here’s an example:</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[print_schema]</span>
<span class="py">file</span> <span class="p">=</span> <span class="s">"src/diesel_sqlite_ex/schema.rs"</span>
</code></pre></div></div>

<h4 id="43-for-the-current-migration-change-the-upsql-file-and-run-it-again">4.3. For the current migration, change the up.sql file and run it again</h4>

<p>If you want to change the current migration, you can edit the <code class="language-plaintext highlighter-rouge">up.sql</code> file and then run
the migration again. You can do this as many times as you want, without having to create a
new migration. This will simply regenerate the <code class="language-plaintext highlighter-rouge">schema.rs</code> file.</p>

<p>Here’s how you can do that:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Edit the up.sql file.</span>
<span class="c"># Run the migration again.</span>
diesel <span class="nt">--database-url</span><span class="o">=</span>diesel.db migration run
</code></pre></div></div>

<h3 id="5-use-the-script-luke">5. Use the script, Luke</h3>

<p>In steps 1 through 5, there are a lot of manual steps. Use the script as follows:</p>

<ol>
  <li>Remove the following files &amp; folders: <code class="language-plaintext highlighter-rouge">diesel.toml</code>, <code class="language-plaintext highlighter-rouge">diesel.db</code>, <code class="language-plaintext highlighter-rouge">migrations</code>,
<code class="language-plaintext highlighter-rouge">src/schema.rs</code>.</li>
  <li>Run <code class="language-plaintext highlighter-rouge">./diesel_setup.sh</code> and it will create the database file, create a migration, which
will generate the <code class="language-plaintext highlighter-rouge">up.sql</code> and <code class="language-plaintext highlighter-rouge">down.sql</code> files. However, the migration will not be run
and no <code class="language-plaintext highlighter-rouge">.db</code> file will be created.</li>
  <li>Edit the <code class="language-plaintext highlighter-rouge">up.sql</code> and <code class="language-plaintext highlighter-rouge">down.sql</code> files to add the SQL for creating and dropping tables.</li>
  <li>Run <code class="language-plaintext highlighter-rouge">./diesel_setup.sh</code> again, and tell it to run the migrations and generate the
<code class="language-plaintext highlighter-rouge">diesel.db</code> and <code class="language-plaintext highlighter-rouge">schema.rs</code> file.
    <ol>
      <li>This runs the <code class="language-plaintext highlighter-rouge">diesel migration run</code> command to exercise the <code class="language-plaintext highlighter-rouge">up.sql</code> file.</li>
      <li>And then runs the <code class="language-plaintext highlighter-rouge">diesel migration redo</code> command to exercise the <code class="language-plaintext highlighter-rouge">down.sql</code> file,
and then the <code class="language-plaintext highlighter-rouge">up.sql</code> file.</li>
      <li>If you want to manually generate the <code class="language-plaintext highlighter-rouge">schema.rs</code> file, you can run
<code class="language-plaintext highlighter-rouge">diesel print-schema &gt; src/schema.rs</code>.</li>
    </ol>
  </li>
</ol>

<h4 id="51-instead-of-raw-sql-write-rust-for-migrations">5.1. Instead of raw SQL, write Rust for migrations</h4>

<p>Alternatively, if you don’t want to write raw SQL to do the migrations, you can just start
with writing the <code class="language-plaintext highlighter-rouge">src/schema.rs</code> file instead and then run
<code class="language-plaintext highlighter-rouge">diesel migration generate --diff-schema create_tables</code> to have it generate the <code class="language-plaintext highlighter-rouge">up.sql</code>
and <code class="language-plaintext highlighter-rouge">down.sql</code> files for you. The script does not currently support this.</p>

<h4 id="52-include-migrations-in-the-final-binary">5.2. Include migrations in the final binary</h4>

<p>When preparing your app for use in production, you may want to run your migrations during
the application’s initialization phase. You may also want to include the migration scripts
as a part of your code, to avoid having to copy them to your deployment location/image
etc.</p>

<p>You can also include the migrations in the final binary of the application you’re building
by using the <a href="https://docs.rs/diesel_migrations/2.2.0/diesel_migrations/macro.embed_migrations.html"><code class="language-plaintext highlighter-rouge">diesel_migration</code> crate’s <code class="language-plaintext highlighter-rouge">embed_migrations!</code>
macro</a>.
This way there is no manual setup required to run the migrations and can be handled by the
binary itself.</p>

<h3 id="6-add-a-new-migration-that-changes-existing-tables-by-adding-a-new-column-and-preserve-data">6. Add a new migration that changes existing tables by adding a new column and preserve data</h3>

<p>Let’s say you have everything working so far, and you want to alter the existing tables by
adding a new column, there are few things to keep in mind:</p>

<ul>
  <li>There’s might be data in the tables, which are in the <code class="language-plaintext highlighter-rouge">diesel.db</code> file.</li>
  <li>You want to preserve this data when you add a new column.</li>
  <li>When you add a new column, you have to backfill the data in the existing rows which were
created when this column didn’t exist.</li>
</ul>

<p>Here are the steps to create a new migration to alter existing tables by adding a new
column <code class="language-plaintext highlighter-rouge">created_at</code>:</p>

<ol>
  <li>
    <p>Create a new migration using:</p>

    <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>diesel <span class="nt">--database-url</span><span class="o">=</span>diesel.db migration generate add_new_column_to_both_tables
</code></pre></div>    </div>
  </li>
  <li>
    <p>Populate <code class="language-plaintext highlighter-rouge">up.sql</code> file in the new migration with the following SQL:</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- Add a new column created_at to data_table. This can't be current_timestamp because</span>
<span class="c1">-- SQLite doesn't support that. The default value must be a constant.</span>
<span class="k">alter</span> <span class="k">table</span>
   <span class="n">data_table</span>
<span class="k">add</span>
   <span class="k">column</span> <span class="n">created_at</span> <span class="nb">timestamp</span> <span class="k">not</span> <span class="k">null</span> <span class="k">default</span> <span class="s1">'1900-01-01 12:12:12'</span><span class="p">;</span>

<span class="c1">-- Add a new column created_at to file_table. This can't be current_timestamp because</span>
<span class="c1">-- SQLite doesn't support that. The default value must be a constant.</span>
<span class="k">alter</span> <span class="k">table</span>
   <span class="n">file_table</span>
<span class="k">add</span>
   <span class="k">column</span> <span class="n">created_at</span> <span class="nb">timestamp</span> <span class="k">not</span> <span class="k">null</span> <span class="k">default</span> <span class="s1">'1900-01-01 12:12:12'</span><span class="p">;</span>

<span class="c1">-- Update the created_at column in data_table &amp; file_table if needed (it is needed if the</span>
<span class="c1">-- row's date is hard coded to '1900-01-01 12:12:12'.</span>
<span class="k">update</span>
   <span class="n">data_table</span>
<span class="k">set</span>
   <span class="n">created_at</span> <span class="o">=</span> <span class="k">current_timestamp</span>
<span class="k">where</span>
   <span class="n">created_at</span> <span class="k">is</span> <span class="s1">'1900-01-01 12:12:12'</span><span class="p">;</span>

<span class="k">update</span>
   <span class="n">file_table</span>
<span class="k">set</span>
   <span class="n">created_at</span> <span class="o">=</span> <span class="k">current_timestamp</span>
<span class="k">where</span>
   <span class="n">created_at</span> <span class="k">is</span> <span class="s1">'1900-01-01 12:12:12'</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Populate the <code class="language-plaintext highlighter-rouge">down.sql</code> file in the new migration with the following SQL:</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- Drop the created_at column from data_table.</span>
<span class="k">alter</span> <span class="k">table</span>
   <span class="n">data_table</span>
<span class="k">drop</span>
   <span class="k">column</span> <span class="n">created_at</span><span class="p">;</span>

<span class="c1">-- Drop the created_at column from file_table.</span>
<span class="k">alter</span> <span class="k">table</span>
   <span class="n">file_table</span>
<span class="k">drop</span>
   <span class="k">column</span> <span class="n">created_at</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Finally run:</p>

    <pre><code class="language-sh1">diesel --database-url=diesel.db migration run
</code></pre>
  </li>
</ol>

<p>Once all this is done, your <code class="language-plaintext highlighter-rouge">diesel.db</code> file will have the new column <code class="language-plaintext highlighter-rouge">created_at</code> in both
tables. However, the <code class="language-plaintext highlighter-rouge">models</code> are still not updated to reflect this change. You can update
the structs in the <code class="language-plaintext highlighter-rouge">models</code> module manually to accommodate these changes. Since the change
is SQL column type <code class="language-plaintext highlighter-rouge">TIMESTAMP</code> related, you can add the following field:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">DataTableRecord</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
   <span class="k">pub</span> <span class="n">created_at</span><span class="p">:</span> <span class="nn">chrono</span><span class="p">::</span><span class="n">NaiveDateTime</span><span class="p">,</span>
   <span class="o">...</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">FileTableRecord</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
   <span class="k">pub</span> <span class="n">created_at</span><span class="p">:</span> <span class="nn">chrono</span><span class="p">::</span><span class="n">NaiveDateTime</span><span class="p">,</span>
   <span class="o">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>See the <a href="#timestamps">timestamps</a> section for more information on handling timestamps in
Diesel, SQLite and Rust.</p>

<h3 id="7-diesel-and-rust">7. Diesel and Rust</h3>

<h4 id="create-a-connection">Create a connection</h4>

<p>We can just specify the path to the database directly when needed, instead of using the
<code class="language-plaintext highlighter-rouge">DATABASE_URL</code> environment variable (and using <code class="language-plaintext highlighter-rouge">.env</code> and and <code class="language-plaintext highlighter-rouge">dotenvy</code> crate). There are
a few ways in which you can specify the database URL:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">path/to/your/file.db</code> - Save the database file in the given path.</li>
  <li><code class="language-plaintext highlighter-rouge">file://file.db</code> - Save the database file in given path.</li>
  <li><code class="language-plaintext highlighter-rouge">:memory:</code> - Create an in-memory database.</li>
</ul>

<p>Here’s an example of this in Rust:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">diesel</span><span class="p">::</span><span class="nn">prelude</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">miette</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

<span class="cd">/// Specify your database URL, eg:</span>
<span class="cd">/// - `path/to/your/file.db` - Save the database file in the given path.</span>
<span class="cd">/// - `file://file.db` - Save the database file in given path.</span>
<span class="cd">/// - `:memory:` - Create an in-memory database.</span>
<span class="cd">///</span>
<span class="cd">/// See [SqliteConnection] for more details.</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">create_connection</span><span class="p">(</span><span class="n">database_url</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">SqliteConnection</span><span class="o">&gt;</span> <span class="p">{</span>
   <span class="nn">SqliteConnection</span><span class="p">::</span><span class="nf">establish</span><span class="p">(</span><span class="n">database_url</span><span class="p">)</span><span class="nf">.into_diagnostic</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="crud-operations">CRUD operations</h4>

<p>This <a href="https://diesel.rs/guides/getting-started.html">example</a> demonstrates how to do CRUD
operations with Diesel and Sqlite. The
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/sql/src/diesel_sqlite_ex/diesel_impl.rs">example</a>
provides examples of implementing CRUD on two different tables, one that holds structured
JSON text data, and another that holds binary data.</p>

<h4 id="timestamps">Timestamps</h4>

<p>To handle SQLite <code class="language-plaintext highlighter-rouge">TIMESTAMP</code> column type in Rust, add the <code class="language-plaintext highlighter-rouge">chrono</code> feature in Diesel (in
your <code class="language-plaintext highlighter-rouge">Cargo.toml</code>). Also add a dependency on the <code class="language-plaintext highlighter-rouge">chrono</code> crate. Here’s a full listing of
the required dependencies for your <code class="language-plaintext highlighter-rouge">Cargo.toml</code>:</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="py">diesel</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"2.2.4"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span>
  <span class="c"># For SQLite support.</span>
  <span class="s">"sqlite"</span><span class="p">,</span>
  <span class="c"># The enables returning clauses for SQLite 3.35 and later.</span>
  <span class="s">"returning_clauses_for_sqlite_3_35"</span><span class="p">,</span>
  <span class="c"># For timestamp support.</span>
  <span class="s">"chrono"</span><span class="p">,</span>
<span class="p">]</span> <span class="p">}</span>

<span class="py">chrono</span> <span class="p">=</span> <span class="s">"0.4"</span>
</code></pre></div></div>

<p>In the code, you can handle timestamps as follows:</p>

<ul>
  <li><kbd>Save</kbd> - Get the timestamp for current time in UTC. Do this in Rust, to create a new
timestamp that will be inserted or updated into the database.
    <ul>
      <li><a href="https://docs.rs/chrono/latest/chrono/offset/struct.Utc.html">chrono::Utc::now()</a>
returns a
<a href="https://docs.rs/chrono/latest/chrono/struct.DateTime.html">chrono::DateTime::naive_utc()</a>s
which is a
<a href="https://docs.rs/chrono/latest/chrono/naive/struct.NaiveDateTime.html">chrono::NaiveDateTime</a>.</li>
    </ul>
  </li>
  <li><kbd>Load</kbd> - Convert the timestamp in the database to a
<a href="https://docs.rs/chrono/latest/chrono/struct.DateTime.html#">chrono::DateTime</a>. Do this
in Rust, to read the timestamp from the database.
    <ul>
      <li>Use
<a href="https://docs.rs/chrono/latest/chrono/struct.DateTime.html#method.from_naive_utc_and_offset">chrono::DateTime::from_naive_utc_and_offset</a>
with the following args:
        <ol>
          <li><a href="https://docs.rs/chrono/latest/chrono/naive/struct.NaiveDateTime.html">chrono::NaiveDateTime</a>
from the previous step.</li>
          <li><code class="language-plaintext highlighter-rouge">0</code> offset for the timezone.</li>
        </ol>
      </li>
    </ul>
  </li>
  <li><kbd>Human readable format</kbd> - Convert a
<a href="https://docs.rs/chrono/latest/chrono/naive/struct.NaiveDateTime.html">chrono::NaiveDateTime</a>
to a human readable string.
    <ul>
      <li>Use the format options in
<a href="https://docs.rs/chrono/latest/chrono/format/strftime/index.html">chrome::NaiveDateTime::format()</a>
to format the timestamp. To get the output <code class="language-plaintext highlighter-rouge">around 10:44pm UTC on Nov 11</code>, you can
use:
        <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">record</span><span class="py">.created_at</span><span class="nf">.format</span><span class="p">(</span><span class="s">"around %I:%M%P UTC on %b %-d"</span><span class="p">)</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h4 id="automatically-run-migrations">Automatically run migrations</h4>

<p>Let’s say that the <code class="language-plaintext highlighter-rouge">diesel.db</code> file is not present, since you have <strong>NOT</strong> done any of the
following:</p>

<ul>
  <li>Run the <code class="language-plaintext highlighter-rouge">diesel_setup.fish</code> script file.</li>
  <li>Run the <code class="language-plaintext highlighter-rouge">diesel setup</code> command.</li>
  <li>Run the <code class="language-plaintext highlighter-rouge">diesel migration run</code> command.</li>
</ul>

<p>Or a <code class="language-plaintext highlighter-rouge">diesel.db</code> file is present, and you just added a new migration <strong>BUT</strong> you didn’t
run it yet.</p>

<p>In this case your application will not work, since the database file is not present, or it
is out of date 🤦.</p>

<p>Thankfully, you can have the migrations run automatically when the application starts, if
the database file is not present, it will be created. If the database file is old, it will
be updated to the latest version 🎉.</p>

<p>In order to make this happen you have to do the following things.</p>

<ol>
  <li>
    <p>Add the <code class="language-plaintext highlighter-rouge">diesel_migrations</code> crate to your <code class="language-plaintext highlighter-rouge">Cargo.toml</code> file:</p>

    <div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># For automatic migrations.</span>
<span class="py">diesel_migrations</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"2.2.0"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"sqlite"</span><span class="p">]</span> <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Add a procedural macro and this function:</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">diesel_migrations</span><span class="p">::{</span><span class="n">embed_migrations</span><span class="p">,</span> <span class="n">EmbeddedMigrations</span><span class="p">,</span> <span class="n">MigrationHarness</span><span class="p">};</span>
<span class="k">pub</span> <span class="k">const</span> <span class="n">MIGRATIONS</span><span class="p">:</span> <span class="n">EmbeddedMigrations</span> <span class="o">=</span> <span class="nd">embed_migrations!</span><span class="p">();</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">try_run_migrations</span><span class="p">(</span>
    <span class="n">connection</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">SqliteConnection</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">result</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span>
    <span class="nb">Vec</span><span class="o">&lt;</span><span class="nn">diesel</span><span class="p">::</span><span class="nn">migration</span><span class="p">::</span><span class="n">MigrationVersion</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span> <span class="o">+</span> <span class="nb">Send</span> <span class="o">+</span> <span class="nb">Sync</span><span class="o">&gt;</span><span class="p">,</span>
<span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">connection</span><span class="nf">.run_pending_migrations</span><span class="p">(</span><span class="n">MIGRATIONS</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Finally, to your <code class="language-plaintext highlighter-rouge">main.rs</code> file, or whatever file and function you want to run before
any database operations are run in your binary, call the function above. For example:</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">connection</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">general_ops</span><span class="p">::</span><span class="nf">create_connection</span><span class="p">(</span><span class="n">DATABASE_URL</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="k">if</span> <span class="nn">migration_ops</span><span class="p">::</span><span class="nf">try_run_migrations</span><span class="p">(</span><span class="n">connection</span><span class="p">)</span><span class="nf">.is_err</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Error running migrations"</span><span class="p">);</span>
    <span class="nn">miette</span><span class="p">::</span><span class="nd">bail!</span><span class="p">(</span><span class="s">"Error running migrations"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Optionally, you can add a <code class="language-plaintext highlighter-rouge">build.rs</code> file at the root of your project to get around
current limitations in Rust’s <code class="language-plaintext highlighter-rouge">proc-macro</code> API. There is currently no way to signal
that a specific proc macro should be rerun if some external file changes or is added.
Which means that <code class="language-plaintext highlighter-rouge">embed_migrations!</code> cannot regenerate the list of embedded migrations
if <strong>ONLY</strong> the migrations are changed. To get around this you can add the following to
your <code class="language-plaintext highlighter-rouge">build.rs</code> file:</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="nd">println!</span><span class="p">(</span><span class="s">"cargo:rerun-if-changed=migrations"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ol>

<p>That’s it! Now your application will automatically run migrations when it starts 🚀.</p>

<h2 id="vscode-and-sqlite-extension">VSCode and SQLite extension</h2>

<ol>
  <li>
    <p>You can install
<a href="https://marketplace.visualstudio.com/items?itemName=qwtel.sqlite-viewer"><code class="language-plaintext highlighter-rouge">qwtel.sqlite-viewer</code></a>
to view SQLite databases in VSCode. Alternatively you can use RustRover as db explorer
is built in.</p>
  </li>
  <li>
    <p>You can install
<a href="https://marketplace.visualstudio.com/items?itemName=adpyke.vscode-sql-formatter"><code class="language-plaintext highlighter-rouge">adpyke.vscode-sql-formatter</code></a>
to format SQL queries in VSCode.</p>
  </li>
</ol>

<h2 id="history">History</h2>

<p>This <a href="https://github.com/r3bl-org/r3bl-private-planning/issues/16">tracking bug</a> has lots
of background information regarding the exploration of SQL, Rust, the best database to
use, and the best driver &amp; ORM combo.</p>

<h2 id="build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</h2>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a></li>
  <li>Playlists
    <ul>
      <li><a href="https://www.youtube.com/watch?v=bolScvh4x7I&amp;list=PLofhE49PEwmw3MKOU1Kn3xbP4FRQR4Mb3">Build with Naz, Linux TTY, process, signals, commands in async Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmza94sS7UmJnN9gSCHTVTfz">Build with Naz, fundamental effective Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmwO69E7eiQ-ewnMME8ydgQ5">Build with Naz, effective async Rust and tokio</a></li>
      <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><category term="DB" /><summary type="html"><![CDATA[SQLite is a great in-process database that supports concurrent processes. We will use Rust and Diesel ORM to create and run migrations, generate schemas and create more than one migration. We will also use Rust to perform CRUD operations and perform auto migrations.]]></summary></entry><entry><title type="html">Build with Naz : TLS (Transport Layer Security) in Rust with tokio, rustls, CFSSL</title><link href="http://developerlife.com/2024/11/28/rust-tls-rustls/" rel="alternate" type="text/html" title="Build with Naz : TLS (Transport Layer Security) in Rust with tokio, rustls, CFSSL" /><published>2024-11-28T00:00:00-06:00</published><updated>2024-11-28T00:00:00-06:00</updated><id>http://developerlife.com/2024/11/28/rust-tls-rustls</id><content type="html" xml:base="http://developerlife.com/2024/11/28/rust-tls-rustls/"><![CDATA[<p><img class="post-hero-image" src="/assets/rust-tls.png" /></p>

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#tls-primer">TLS primer</a></li>
  <li><a href="#rust-and-tls-primer">Rust and TLS primer</a></li>
  <li><a href="#youtube-videos-for-this-article">YouTube videos for this article</a></li>
  <li><a href="#first-create-the-certificates-by-running-gen-certsfish">First, create the certificates by running gen-certs.fish</a>
    <ul>
      <li><a href="#tools-used-by-the-scripts-cfssl">Tools used by the scripts (CFSSL)</a></li>
      <li><a href="#configuration-files-deep-dive">Configuration files deep dive</a></li>
      <li><a href="#run-the-scripts-and-generate-the-certificates">Run the scripts and generate the certificates</a>
        <ul>
          <li><a href="#examine-the-generated-certificates">Examine the generated certificates</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#second-write-and-run-the-code">Second, write and run the code</a></li>
  <li><a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</a></li>
</ul>

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

<h2 id="introduction">Introduction</h2>

<p>This repo contains code for a simple server and client program written in Rust that
communicate over TLS using the <code class="language-plaintext highlighter-rouge">tokio</code> and <code class="language-plaintext highlighter-rouge">rustls</code> libraries.</p>

<ul>
  <li>TLS is used to secure the communication between the server and client.</li>
  <li>It is an added layer on top of the TCP connection.</li>
</ul>

<h2 id="tls-primer">TLS primer</h2>

<p>TLS is a cryptographic protocol designed to provide secure communication over a computer
network. It ensures:</p>

<ul>
  <li><em>Confidentiality:</em> Data is encrypted so that only the intended recipient can read it.</li>
  <li><em>Integrity:</em> Data cannot be altered without detection.</li>
  <li><em>Authentication:</em> The identities of the parties involved can be verified.</li>
</ul>

<p>It consists of both symmetric and asymmetric encryption algorithms. Here’s a brief
overview of both.</p>

<p><strong><kbd>Symmetric Encryption</kbd></strong></p>

<ul>
  <li><em>Definition</em>: Uses the same key for both encryption and decryption.</li>
  <li><em>Examples</em>: AES (Advanced Encryption Standard), DES (Data Encryption Standard).</li>
  <li><em>Benefits</em>:
    <ul>
      <li>Faster than asymmetric encryption.</li>
      <li>Suitable for encrypting large amounts of data.</li>
    </ul>
  </li>
  <li><em>Drawbacks</em>:
    <ul>
      <li>Key distribution can be a challenge; both parties must securely share the key. So
sharing the key between both parties can either happen out of band, or using some
other mechanism (like asymmetric encryption).</li>
    </ul>
  </li>
</ul>

<p><strong><kbd>Asymmetric Encryption</kbd></strong></p>

<ul>
  <li><em>Definition</em>: Uses a pair of keys (public and private) for encryption and decryption.</li>
  <li><em>Examples</em>: RSA, ECC (Elliptic Curve Cryptography).</li>
  <li><em>Benefits</em>:
    <ul>
      <li>Solves the key distribution problem; the public key can be shared openly.</li>
      <li>Provides authentication through digital signatures.</li>
    </ul>
  </li>
  <li><em>Drawbacks</em>:
    <ul>
      <li>Slower than symmetric encryption.</li>
      <li>Not suitable for encrypting large amounts of data directly.</li>
    </ul>
  </li>
</ul>

<p>TLS uses a combination of both symmetric and asymmetric encryption. It uses asymmetric
encryption to establish a secure connection and symmetric encryption to encrypt the data
transferred over the connection.</p>

<p>Additionally the following are required to make the communication secure between the
client and server:</p>

<ol>
  <li>The client needs to have the CA certificate in case you are using self-signed
certificates.</li>
  <li>The server needs to have both the server certificate and the private key.</li>
</ol>

<p>Here’s an overview of how TLS works:</p>

<ul>
  <li><kbd>Handshake</kbd> - The client and server perform a handshake to establish a secure
connection. During this process:
    <ul>
      <li>The client and server agree on the TLS version and cipher suites to use.</li>
      <li>The server presents its digital certificate, which contains its public key.</li>
      <li>The client verifies the server’s certificate against trusted Certificate Authorities
(CAs).</li>
      <li>The client generates a random session key, encrypts it with the server’s public key,
and sends it to the server.</li>
    </ul>
  </li>
  <li><kbd>Session Key</kbd> - Once the server receives the encrypted session key, it decrypts it
using its private key. Both parties now have the same session key, which is used for
symmetric encryption of the data transmitted during the session.</li>
  <li><kbd>Data Transmission</kbd> - All data sent between the client and server is encrypted using
the session key, ensuring confidentiality and integrity.</li>
</ul>

<h2 id="rust-and-tls-primer">Rust and TLS primer</h2>

<p>Now that we know more about TLS, how do we access it in Rust? Rust has 2 main
implementations for TLS:</p>

<ol>
  <li>
    <p><a href="https://docs.rs/rustls/latest/rustls/"><code class="language-plaintext highlighter-rouge">rustls</code></a>: A modern, safe, and fast TLS library
written in Rust. This does not have any dependencies on OpenSSL, or any C code, or any
OS specific code. It is a pure Rust implementation.</p>

    <ul>
      <li>This <a href="https://www.youtube.com/watch?v=eVuKCu6BMBQ&amp;list=WL&amp;index=6">video</a> goes over
the process of writing Rust code using <code class="language-plaintext highlighter-rouge">tokio</code> and <code class="language-plaintext highlighter-rouge">rustls</code>.</li>
      <li>This
<a href="https://github.com/dionysus-oss/netrusting/blob/c5364a2e31ef3871b8e968364c575f6f0d7cd8b8/rcat/README.md">repo</a>
has a good example of how to use <code class="language-plaintext highlighter-rouge">tokio</code> and <code class="language-plaintext highlighter-rouge">rustls</code> together.</li>
    </ul>
  </li>
  <li>
    <p><a href="https://docs.rs/tokio-native-tls/latest/tokio_native_tls/"><code class="language-plaintext highlighter-rouge">native-tls</code></a>: A thin
wrapper around the platform’s native TLS implementation. It uses OpenSSL on Unix-like
systems and SChannel on Windows.</p>
  </li>
</ol>

<h2 id="youtube-videos-for-this-article">YouTube videos for this article</h2>

<p>If you like to learn via video, please watch the companion video on the <a href="https://www.youtube.com/@developerlifecom">developerlife.com
YouTube channel</a> where I live code the entire
program from scratch. You can follow along there, step by step if you like, in addition to
this article and <a href="https://github.com/nazmulidris/rust-scratch/tree/main/tls">repo</a>.</p>

<!-- rust tls -->
<iframe src="https://www.youtube.com/embed/NeTZGyc9l7E?si=Pg-1t8k8uyzv9fiD" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<blockquote>
  <p>The code in the video and this tutorial are all in <a href="https://github.com/nazmulidris/rust-scratch/tree/main/tls">this GitHub
repo</a>.</p>
</blockquote>

<h2 id="first-create-the-certificates-by-running-gen-certsfish">First, create the certificates by running gen-certs.fish</h2>

<p>All the scripts and certificate related files are in the <code class="language-plaintext highlighter-rouge">certs</code> folder:</p>

<ol>
  <li>The main script is <code class="language-plaintext highlighter-rouge">gen-certs.fish</code>. It generates the CA and server certificates. It
also uses the script below to get the CFSSL binaries.</li>
  <li>The <code class="language-plaintext highlighter-rouge">get-cfssl-binaries.fish</code> script downloads the CFSSL binaries if needed. If they
are already downloaded, it does nothing.</li>
</ol>

<h3 id="tools-used-by-the-scripts-cfssl">Tools used by the scripts (CFSSL)</h3>

<ul>
  <li>The <a href="https://github.com/cloudflare/cfssl">CFSSL</a> tool is used to generate the
certificates.</li>
  <li>Learn more about the tool in this <a href="https://blog.cloudflare.com/introducing-cfssl/">blog
post</a>.</li>
  <li>You can get the prebuilt binaries <a href="https://github.com/cloudflare/cfssl/releases">here</a>.</li>
  <li>This <a href="https://www.youtube.com/watch?v=iqBXe80QaGw&amp;list=WL&amp;index=2&amp;t=13s">video</a> goes
over the process of setting up TLS with CFSSL.</li>
</ul>

<h3 id="configuration-files-deep-dive">Configuration files deep dive</h3>

<p>There are 3 JSON files that are used to generate the certificates:</p>

<p><kbd>`ca-config.json`</kbd>: The configuration for the CA.</p>

<ul>
  <li>The main node is <code class="language-plaintext highlighter-rouge">signing</code> which has the <code class="language-plaintext highlighter-rouge">profiles</code> node. You can have multiple
profiles. In this case, I create a single profile named <code class="language-plaintext highlighter-rouge">server</code>, which is a name I just
made up.
    <ul>
      <li>The node named <code class="language-plaintext highlighter-rouge">server</code>, which is a made up name of a profile, is used to generate the
server certificate. This is a name that I created, it is not a reserved keyword, it
has no special meaning. It is used in the
<code class="language-plaintext highlighter-rouge">cfssl gencert ... -profile=server server-csr.json</code> command and used to tie all the
generated files together.
        <ul>
          <li>The <code class="language-plaintext highlighter-rouge">expiry</code> node sets the expiration date for a certificate. I changed it 10 years
or <code class="language-plaintext highlighter-rouge">87600h</code>.</li>
          <li>The <code class="language-plaintext highlighter-rouge">usages</code> node sets the key usage for the certificate. I set it to <code class="language-plaintext highlighter-rouge">signing</code>,
<code class="language-plaintext highlighter-rouge">key encipherment</code>, <code class="language-plaintext highlighter-rouge">server auth</code>, and <code class="language-plaintext highlighter-rouge">client auth</code>.</li>
        </ul>
      </li>
      <li>Here’s an example:
        <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
</span><span class="nl">"signing"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="nl">"default"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"expiry"</span><span class="p">:</span><span class="w"> </span><span class="s2">"87600h"</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"profiles"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"server"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"expiry"</span><span class="p">:</span><span class="w"> </span><span class="s2">"87600h"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"usages"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"signing"</span><span class="p">,</span><span class="w"> </span><span class="s2">"key encipherment"</span><span class="p">,</span><span class="w"> </span><span class="s2">"server auth"</span><span class="p">]</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<p><kbd>`server-csr.json`</kbd>: The configuration for the server certificate. This is related to the
<code class="language-plaintext highlighter-rouge">server</code> profile above. The CA will sign the server certificate using the <code class="language-plaintext highlighter-rouge">server</code>
profile.</p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">CN</code> node is the Common Name for this certificate. I set it to <code class="language-plaintext highlighter-rouge">server</code>. This has no
special meaning. It is set to ensure that the <code class="language-plaintext highlighter-rouge">cfssl gencert -ca ca.pem ...</code> commands to
generate the certificates work and can find the information related to the <code class="language-plaintext highlighter-rouge">server</code>,
which matches the profile name.</li>
  <li>The <code class="language-plaintext highlighter-rouge">key</code> node sets the key size and type. I set it to <code class="language-plaintext highlighter-rouge">2048</code> bits and <code class="language-plaintext highlighter-rouge">rsa</code>. This is
important.</li>
  <li>The <code class="language-plaintext highlighter-rouge">hosts</code> node sets the DNS names and IP addresses for the certificate. This is really
important. The client will use a <code class="language-plaintext highlighter-rouge">ServerName</code> in Rust code to connect to the server.
That name must match whatever is in the <code class="language-plaintext highlighter-rouge">hosts</code> array. You can just add another name
there which can be parsed as a DNS name or an IP address. In my case, I have <code class="language-plaintext highlighter-rouge">localhost</code>
and <code class="language-plaintext highlighter-rouge">r3bl.com</code> (which is just made up). However, in the Rust client code to connect to
the server, I can create a
<a href="https://docs.rs/rustls-pki-types/latest/rustls_pki_types/enum.ServerName.html"><code class="language-plaintext highlighter-rouge">ServerName</code></a>
using either <code class="language-plaintext highlighter-rouge">"localhost"</code> or <code class="language-plaintext highlighter-rouge">"r3bl.com"</code>.</li>
  <li>Here’s an example:
    <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"CN"</span><span class="p">:</span><span class="w"> </span><span class="s2">"server"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"hosts"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"localhost"</span><span class="p">,</span><span class="w"> </span><span class="s2">"r3bl.com"</span><span class="p">],</span><span class="w">
  </span><span class="nl">"key"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"algo"</span><span class="p">:</span><span class="w"> </span><span class="s2">"rsa"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"size"</span><span class="p">:</span><span class="w"> </span><span class="mi">2048</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"names"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"C"</span><span class="p">:</span><span class="w"> </span><span class="s2">"US"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"ST"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Texas"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"L"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Austin"</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>    </div>
  </li>
</ul>

<p><kbd>`ca-csr.json`</kbd>: The Certificate Signing Request (CSR) for the CA.</p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">CN</code> node is the Common Name for the CA. I set it to <code class="language-plaintext highlighter-rouge">ca</code>. This has no special
meaning. It is just to make sure that the <code class="language-plaintext highlighter-rouge">cfssl gencert -initca ca-csr.json</code> commands
to generate the certificates work and can find the information related to the CA.</li>
  <li>The <code class="language-plaintext highlighter-rouge">key</code> node sets the key size and type. I set it to <code class="language-plaintext highlighter-rouge">2048</code> bits and <code class="language-plaintext highlighter-rouge">rsa</code>. This is
important.</li>
  <li>Here’s an example:
    <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"CN"</span><span class="p">:</span><span class="w"> </span><span class="s2">"ca"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"key"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"algo"</span><span class="p">:</span><span class="w"> </span><span class="s2">"rsa"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"size"</span><span class="p">:</span><span class="w"> </span><span class="mi">2048</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"names"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"C"</span><span class="p">:</span><span class="w"> </span><span class="s2">"US"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"ST"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Texas"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"L"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Austin"</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>    </div>
  </li>
</ul>

<p>Each of these files are modified from some default values to the desired values. They all
started life using the following commands:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">./cfssl print-defaults config &gt; ca-config.json</code></li>
  <li><code class="language-plaintext highlighter-rouge">./cfssl print-defaults csr &gt; ca-csr.json</code></li>
  <li><code class="language-plaintext highlighter-rouge">./cfssl print-defaults csr &gt; server-csr.json</code></li>
</ul>

<h3 id="run-the-scripts-and-generate-the-certificates">Run the scripts and generate the certificates</h3>

<p>Run the following commands to generate the certificates in the <code class="language-plaintext highlighter-rouge">certs/generated</code> folder:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>certs
./gen-certs.fish
</code></pre></div></div>

<p>Running this script will generate the following files:</p>

<ol>
  <li>Generate root certificate (CA) and sign it. The <code class="language-plaintext highlighter-rouge">ca</code> string in the filenames comes from
the <code class="language-plaintext highlighter-rouge">cfssl gencert ... | cfssljson -bare ca</code> command. If you change the string <code class="language-plaintext highlighter-rouge">ca</code> in
the command, it will change the filenames that are produced.</li>
</ol>

<table>
  <thead>
    <tr>
      <th>File</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ca.csr</code></td>
      <td>Certificate signing request</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ca-key.pem</code></td>
      <td>Private key</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ca.pem</code></td>
      <td>Public key; used in the Rust client code</td>
    </tr>
  </tbody>
</table>

<ol>
  <li>Generate server certificate (and private key) and sign it with the CA. The <code class="language-plaintext highlighter-rouge">server</code>
string in the filenames comes from the <code class="language-plaintext highlighter-rouge">cfssl gencert ... | cfssljson -bare server</code>
command. If you change the string <code class="language-plaintext highlighter-rouge">server</code> in the command, it will change the filenames
that are produced.</li>
</ol>

<table>
  <thead>
    <tr>
      <th>File</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">server.csr</code></td>
      <td>Certificate signing request</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">server-key.pem</code></td>
      <td>Private key; used in the Rust server code</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">server.pem</code></td>
      <td>Public key; used in the Rust server code</td>
    </tr>
  </tbody>
</table>

<h4 id="examine-the-generated-certificates">Examine the generated certificates</h4>

<ol>
  <li>Look in the <code class="language-plaintext highlighter-rouge">certs/generated/</code> folder to see the generated certificates. You can
examine them using the <code class="language-plaintext highlighter-rouge">openssl</code> command:</li>
</ol>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl x509 <span class="nt">-noout</span> <span class="nt">-text</span> <span class="nt">-in</span> generated/ca.pem
</code></pre></div></div>

<p>Look for the following lines which confirm that this is a CA certificate, and some other
configuration properties provided in the <code class="language-plaintext highlighter-rouge">ca-config.json</code> file:</p>

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Issuer: C=US, ST=TX, L=Austin, CN=ca</code></td>
      <td>The CA’s own details, from <code class="language-plaintext highlighter-rouge">ca-config.json</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Not After: ...</code></td>
      <td>Expiration date</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Public-Key: (2048 bit)</code></td>
      <td>Key size and type from <code class="language-plaintext highlighter-rouge">ca-csr.json</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">CA:TRUE</code></td>
      <td>This is a CA (root certificate)</td>
    </tr>
  </tbody>
</table>

<ol>
  <li>Look in the <code class="language-plaintext highlighter-rouge">certs/generated</code> folder to see the server certificates. You can examine
them using the <code class="language-plaintext highlighter-rouge">openssl</code> command:</li>
</ol>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl x509 <span class="nt">-noout</span> <span class="nt">-text</span> <span class="nt">-in</span> generated/server.pem
</code></pre></div></div>

<p>Look for the following lines which confirm that this is a server certificate, and some
other configuration properties provided in the <code class="language-plaintext highlighter-rouge">server-csr.json</code> file:</p>

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Issuer: C=US, ST=Texas, L=Austin, CN=ca</code></td>
      <td>Issued by the CA above</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Subject: C=US, ST=Texas, L=Austin, CN=server</code></td>
      <td>The server’s own details</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Not After : ...</code></td>
      <td>Expiration date</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">CA:FALSE</code></td>
      <td>Not a root certificate</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">TLS Web Server Authentication</code></td>
      <td>Extended Key Usage for server authentication</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">DNS:localhost, IP Address:127.0.0.1</code></td>
      <td>This is from <code class="language-plaintext highlighter-rouge">server-csr.json</code>. The Rust client code uses this in <code class="language-plaintext highlighter-rouge">ServerName</code> to make a TLS connection</td>
    </tr>
  </tbody>
</table>

<ol>
  <li>Finally verify the server certificate against the CA certificate:</li>
</ol>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl verify <span class="nt">-CAfile</span> generated/ca.pem generated/server.pem
</code></pre></div></div>

<p>If the certificate is valid, you will see the following output: <code class="language-plaintext highlighter-rouge">generated/server.pem: OK</code></p>

<h2 id="second-write-and-run-the-code">Second, write and run the code</h2>

<p>Once the certificates are generated, the next step is to write the server and client code.
Here’s the mental model for doing this.</p>

<ul>
  <li>
    <p><kbd>Client code</kbd></p>

    <ul>
      <li>
        <p><strong>Certificate concerns</strong>:</p>

        <ul>
          <li>The client code will need to load the root certificate store, inside of which will
reside the CA (certificate authority) certificate chain, that we have generated (the
<code class="language-plaintext highlighter-rouge">ca.pem</code> file).</li>
          <li>The client will also need to know the server’s hostname, which is used to verify the
server’s certificate. This has to match the <code class="language-plaintext highlighter-rouge">hosts</code> entry in the <code class="language-plaintext highlighter-rouge">server-csr.json</code>
config file. This entry has to be in the form of a <code class="language-plaintext highlighter-rouge">ServerName</code> in the Rust code,
which is a DNS or IP address parsable format.</li>
        </ul>
      </li>
      <li>
        <p><strong>Code concerns</strong>:</p>

        <ul>
          <li>The certificate and key files above is used to generate a <code class="language-plaintext highlighter-rouge">ClientConfig</code> struct,
from the <code class="language-plaintext highlighter-rouge">rustls</code> crate. It is then used to create a <code class="language-plaintext highlighter-rouge">TlsConnector</code> struct.</li>
          <li>The unsecure connection of type <code class="language-plaintext highlighter-rouge">TcpStream</code> will be created as per usual using
<code class="language-plaintext highlighter-rouge">TcpStream::connect()</code>. However, this will then be wrapped in a <code class="language-plaintext highlighter-rouge">TlsConnector</code> which
will make it a secure connection. The reader and writer halves are split from this
<code class="language-plaintext highlighter-rouge">TlsStream</code> struct. And the reader and writer halves are used as per usual.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><kbd>Server code</kbd></p>

    <ul>
      <li>
        <p><strong>Certificate concerns</strong>:</p>

        <ul>
          <li>The server code will need to load the server’s certificate and private key, which we
have generated (the <code class="language-plaintext highlighter-rouge">server.pem</code> and <code class="language-plaintext highlighter-rouge">server-key.pem</code> files).
            <ul>
              <li>This server certificate is signed by the CA certificate. Since we are using
self-signed certificates, only the client will need to load the CA certificate to
verify the server certificate. And not the server.
                <ul>
                  <li>This is because the server is self-signed and doesn’t need to verify any
incoming certificates.</li>
                  <li>If we weren’t using self-signed certificates, the client would just have to load
the root certificate store that’s available publicly (like Mozilla root
certificates).</li>
                </ul>
              </li>
              <li>The server will not need to load the root certificate store, inside of which will
reside the CA certificate chain, that we have generated (the <code class="language-plaintext highlighter-rouge">ca.pem</code> file).</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <p><strong>Code concerns</strong>:</p>

        <ul>
          <li>The certificate and key files above are used to generate a <code class="language-plaintext highlighter-rouge">ServerConfig</code> struct,
from the <code class="language-plaintext highlighter-rouge">rustls</code> crate. It is then used to create a <code class="language-plaintext highlighter-rouge">TlsAcceptor</code> struct.</li>
          <li>The server will create a <code class="language-plaintext highlighter-rouge">TcpListener</code> and accept incoming connections. Each
connection will be wrapped in a <code class="language-plaintext highlighter-rouge">TlsAcceptor</code> which will make it a secure
connection. The reader and writer halves are split from this <code class="language-plaintext highlighter-rouge">TlsStream</code> struct. And
the reader and writer halves are used as per usual.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>Here’s some more information about mapping the Rust code to the TLS files:</p>

<ul>
  <li><a href="https://gemini.google.com/app/6f8efc1d6a468cbf">Rust code using <code class="language-plaintext highlighter-rouge">rustls</code> and TLS certificate &amp; key files</a></li>
</ul>

<p>For details on the actual, code, here are some files from the <code class="language-plaintext highlighter-rouge">tls</code> repo:</p>

<ul>
  <li><a href="https://github.com/nazmulidris/rust-scratch/blob/main/tls/src/bin/client.rs"><code class="language-plaintext highlighter-rouge">client.rs</code></a></li>
  <li><a href="https://github.com/nazmulidris/rust-scratch/blob/main/tls/src/bin/server.rs"><code class="language-plaintext highlighter-rouge">server.rs</code></a></li>
  <li><a href="https://github.com/nazmulidris/rust-scratch/blob/main/tls/src/tls.rs"><code class="language-plaintext highlighter-rouge">tls.rs</code></a></li>
</ul>

<p>Here are the files for the TLS configuration and certificate generation:</p>

<ul>
  <li><a href="https://github.com/nazmulidris/rust-scratch/tree/main/tls/certs/config"><code class="language-plaintext highlighter-rouge">certs/config</code></a></li>
  <li><a href="https://github.com/nazmulidris/rust-scratch/tree/main/tls/certs"><code class="language-plaintext highlighter-rouge">fish</code> scripts to generate the certificates</a></li>
</ul>

<h2 id="build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</h2>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a></li>
  <li>Playlists
    <ul>
      <li><a href="https://www.youtube.com/watch?v=bolScvh4x7I&amp;list=PLofhE49PEwmw3MKOU1Kn3xbP4FRQR4Mb3">Build with Naz, Linux TTY, process, signals, commands in async Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmza94sS7UmJnN9gSCHTVTfz">Build with Naz, fundamental effective Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmwO69E7eiQ-ewnMME8ydgQ5">Build with Naz, effective async Rust and tokio</a></li>
      <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><summary type="html"><![CDATA[TLS is the backbone of web security. We will explore using TLS with Rust, and CFSSL to create a certificate authority to issue self signed certificates & keys. We will also create a server and client that communicate securely over the network using tokio and upgrade insecure TcpStream to TLSStream, and work with TLSAcceptor and TLSConnector.]]></summary></entry><entry><title type="html">Build with Naz : Rust lifetimes</title><link href="http://developerlife.com/2024/09/02/rust-lifetimes/" rel="alternate" type="text/html" title="Build with Naz : Rust lifetimes" /><published>2024-09-02T00:00:00-05:00</published><updated>2024-09-02T00:00:00-05:00</updated><id>http://developerlife.com/2024/09/02/rust-lifetimes</id><content type="html" xml:base="http://developerlife.com/2024/09/02/rust-lifetimes/"><![CDATA[<p><img class="post-hero-image" src="/assets/lifetimes.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#what-is-subtyping-and-variance">What is subtyping and variance?</a>
    <ul>
      <li><a href="#subtyping">Subtyping</a></li>
      <li><a href="#variance">Variance</a></li>
    </ul>
  </li>
  <li><a href="#more-resources-on-rust-lifetimes">More resources on Rust lifetimes</a></li>
  <li><a href="#youtube-videos-for-this-article">YouTube videos for this article</a></li>
  <li><a href="#learn-rust-lifetimes-by-example">Learn Rust lifetimes by example</a>
    <ul>
      <li><a href="#example-1-references">Example 1: References</a></li>
      <li><a href="#example-2-aliasing">Example 2: Aliasing</a></li>
      <li><a href="#example-3-lifetimes">Example 3: Lifetimes</a></li>
      <li><a href="#example-4-input-slices">Example 4: Input slices</a></li>
      <li><a href="#example-5-splitting-borrows-on-structs">Example 5: Splitting borrows on structs</a></li>
      <li><a href="#example-6-clone-on-write-cow">Example 6: Clone on write Cow</a></li>
      <li><a href="#example-7-subtyping-and-variance">Example 7: Subtyping and variance</a></li>
    </ul>
  </li>
  <li><a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</a></li>
</ul>

<!-- /TOC -->

<h2 id="what-is-subtyping-and-variance">What is subtyping and variance?</h2>
<p><a id="markdown-what-is-subtyping-and-variance%3F" name="what-is-subtyping-and-variance%3F"></a></p>

<p>Subtyping and variance are important concepts in Rust’s algebraic type system. They allow
us to express relationships between types, and equivalence without using inheritance. Rust
also includes lifetimes in the type definitions themselves! So they become an integral
part of the a type.</p>

<h3 id="subtyping">Subtyping</h3>
<p><a id="markdown-subtyping" name="subtyping"></a></p>

<p>In Rust, subtyping refers to the relationship between two types where one type can be used
in place of the other.</p>

<ol>
  <li>This means that if a type <code class="language-plaintext highlighter-rouge">Sub</code> is a subtype of type <code class="language-plaintext highlighter-rouge">Super</code>, then any code that
expects a <code class="language-plaintext highlighter-rouge">Super</code> can also accept an <code class="language-plaintext highlighter-rouge">Sub</code>. They are equivalent.</li>
  <li>Just like inheritance, the opposite is not true. Any code expecting a <code class="language-plaintext highlighter-rouge">Sub</code> cannot
accept a <code class="language-plaintext highlighter-rouge">Super</code>. They are not equivalent.</li>
</ol>

<p>Consider the following code snippet:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">Cat</span> <span class="p">{</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">breed</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Display</span> <span class="k">for</span> <span class="n">Cat</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span>
    <span class="p">{</span>
        <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"Cat: {} ({})"</span><span class="p">,</span> <span class="k">self</span><span class="py">.name</span><span class="p">,</span> <span class="k">self</span><span class="py">.breed</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Dog</span> <span class="p">{</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">breed</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Display</span> <span class="k">for</span> <span class="n">Dog</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span>
    <span class="p">{</span>
        <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"Dog: {} ({})"</span><span class="p">,</span> <span class="k">self</span><span class="py">.name</span><span class="p">,</span> <span class="k">self</span><span class="py">.breed</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cd">/// Since Display is a trait bound in the print_animal function,</span>
<span class="cd">/// both &amp;Cat and &amp;Dog can be used as arguments because they are</span>
<span class="cd">/// both subtypes of &amp;dyn Display.</span>
<span class="k">fn</span> <span class="n">print_animal</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Display</span><span class="o">&gt;</span><span class="p">(</span><span class="n">animal</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">animal</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">cat</span> <span class="o">=</span> <span class="n">Cat</span> <span class="p">{</span>
        <span class="n">name</span><span class="p">:</span> <span class="s">"Sparky"</span><span class="nf">.to_string</span><span class="p">(),</span>
        <span class="n">breed</span><span class="p">:</span> <span class="s">"Siamese"</span><span class="nf">.to_string</span><span class="p">()</span> <span class="p">};</span>
    <span class="k">let</span> <span class="n">dog</span> <span class="o">=</span> <span class="n">Dog</span> <span class="p">{</span>
        <span class="n">name</span><span class="p">:</span> <span class="s">"Buddy"</span><span class="nf">.to_string</span><span class="p">(),</span>
        <span class="n">breed</span><span class="p">:</span> <span class="s">"Golden Retriever"</span><span class="nf">.to_string</span><span class="p">()</span> <span class="p">};</span>

    <span class="nf">print_animal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cat</span><span class="p">);</span> <span class="c1">// Prints "Cat: Sparky (Siamese)"</span>
    <span class="nf">print_animal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dog</span><span class="p">);</span> <span class="c1">// Prints "Dog: Buddy (Golden Retriever)"</span>

    <span class="k">let</span> <span class="n">animals</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="k">dyn</span> <span class="n">Display</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="o">&amp;</span><span class="n">cat</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dog</span><span class="p">];</span>
    <span class="k">for</span> <span class="n">animal</span> <span class="k">in</span> <span class="n">animals</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">animal</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In this example:</p>

<ul>
  <li>In the function <code class="language-plaintext highlighter-rouge">print_animal&lt;T&gt;(animal: &amp;T)</code>, the super type of <code class="language-plaintext highlighter-rouge">T</code> is <code class="language-plaintext highlighter-rouge">Display</code>. This
means that this function accepts any type that implements the <code class="language-plaintext highlighter-rouge">Display</code> trait.</li>
  <li>So, we can pass both <code class="language-plaintext highlighter-rouge">&amp;Cat</code> and <code class="language-plaintext highlighter-rouge">&amp;Dog</code> to the <code class="language-plaintext highlighter-rouge">print_animal()</code> function. Since both
<code class="language-plaintext highlighter-rouge">Cat</code> and <code class="language-plaintext highlighter-rouge">Dog</code> implement the <code class="language-plaintext highlighter-rouge">Display</code> trait.</li>
  <li>The <code class="language-plaintext highlighter-rouge">animals</code> vector can hold references to any type that implements the <code class="language-plaintext highlighter-rouge">Display</code>
trait, so we can store both <code class="language-plaintext highlighter-rouge">Cat</code> and <code class="language-plaintext highlighter-rouge">Dog</code> instances in it.
    <ul>
      <li>We use <code class="language-plaintext highlighter-rouge">&amp;dyn Display</code> as the type since we want to use <a href="https://doc.rust-lang.org/stable/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">trait
objects</a>.</li>
      <li>And we can’t use <code class="language-plaintext highlighter-rouge">&amp;impl Animal</code> since <a href="https://doc.rust-lang.org/stable/book/ch10-02-traits.html#clearer-trait-bounds-with-where-clauses">this
syntax</a>
expects only a single type.</li>
    </ul>
  </li>
</ul>

<p>A real world example of this is the <code class="language-plaintext highlighter-rouge">Copy</code> and <code class="language-plaintext highlighter-rouge">Clone</code> traits:</p>

<ul>
  <li><a href="https://doc.rust-lang.org/1.80.1/src/core/marker.rs.html#403">https://doc.rust-lang.org/1.80.1/src/core/marker.rs.html#403</a></li>
  <li>A type that is <code class="language-plaintext highlighter-rouge">Copy</code> is also <code class="language-plaintext highlighter-rouge">Clone</code>.</li>
  <li>But a type that is <code class="language-plaintext highlighter-rouge">Clone</code> is not necessarily <code class="language-plaintext highlighter-rouge">Copy</code>.</li>
</ul>

<h3 id="variance">Variance</h3>
<p><a id="markdown-variance" name="variance"></a></p>

<p>In Rust, variance describes how subtyping relationships are preserved when dealing with
<strong>generic</strong> types. Lifetime annotations are part of the generics system. There are three
types of variance:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Covariance</code>: A generic type <code class="language-plaintext highlighter-rouge">T</code> is covariant if, when <code class="language-plaintext highlighter-rouge">Sub</code> is a subtype of <code class="language-plaintext highlighter-rouge">Super</code>,
<code class="language-plaintext highlighter-rouge">T&lt;Sub&gt;</code> is also a subtype of <code class="language-plaintext highlighter-rouge">T&lt;Super&gt;</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">Invariance</code>: A generic type <code class="language-plaintext highlighter-rouge">T</code> is invariant if there is <strong>no</strong> subtyping relationship
 between <code class="language-plaintext highlighter-rouge">T&lt;Sub&gt;</code> and <code class="language-plaintext highlighter-rouge">T&lt;Super&gt;</code> when <code class="language-plaintext highlighter-rouge">Sub</code> is a subtype of <code class="language-plaintext highlighter-rouge">Super</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">Contravariance</code>: A generic type <code class="language-plaintext highlighter-rouge">T</code> is contravariant if, when <code class="language-plaintext highlighter-rouge">Sub</code> is a subtype of <code class="language-plaintext highlighter-rouge">Super</code>,
<code class="language-plaintext highlighter-rouge">T&lt;Super&gt;</code> is a subtype of <code class="language-plaintext highlighter-rouge">T&lt;Sub&gt;</code>.</li>
</ul>

<p>Here are some examples:</p>

<ul>
  <li><strong>Covariance:</strong> The <code class="language-plaintext highlighter-rouge">&amp;T</code> type is covariant. This means that if <code class="language-plaintext highlighter-rouge">Sub</code> is a subtype of
<code class="language-plaintext highlighter-rouge">Super</code>, then <code class="language-plaintext highlighter-rouge">&amp;Sub</code> is a subtype of <code class="language-plaintext highlighter-rouge">&amp;Super</code>. This is useful for references. In the
code, <code class="language-plaintext highlighter-rouge">Cat</code> and <code class="language-plaintext highlighter-rouge">Dog</code> both implement the <code class="language-plaintext highlighter-rouge">Display</code> trait. Since <code class="language-plaintext highlighter-rouge">Display</code> is a trait
bound in the <code class="language-plaintext highlighter-rouge">print_animal</code> function, both <code class="language-plaintext highlighter-rouge">&amp;Cat</code> and <code class="language-plaintext highlighter-rouge">&amp;Dog</code> can be used as arguments
because they are both subtypes of <code class="language-plaintext highlighter-rouge">&amp;dyn Display</code>.</li>
  <li><strong>Invariance:</strong> The <code class="language-plaintext highlighter-rouge">&amp;mut T</code> type is invariant. This means that if <code class="language-plaintext highlighter-rouge">Sub</code> is a subtype of
<code class="language-plaintext highlighter-rouge">Super</code>, there is no subtyping relationship between <code class="language-plaintext highlighter-rouge">&amp;mut Sub</code> and <code class="language-plaintext highlighter-rouge">&amp;mut Super</code>. Also,
the <code class="language-plaintext highlighter-rouge">UnsafeCell&lt;T&gt;</code> type is invariant. This means that there is no subtyping
relationship between <code class="language-plaintext highlighter-rouge">UnsafeCell&lt;Sub&gt;</code> and <code class="language-plaintext highlighter-rouge">UnsafeCell&lt;Super&gt;</code> when <code class="language-plaintext highlighter-rouge">Sub</code> is a subtype
of <code class="language-plaintext highlighter-rouge">Super</code>. This is because <code class="language-plaintext highlighter-rouge">UnsafeCell</code> is used to bypass Rust’s safety checks, so it
must be invariant. Both <code class="language-plaintext highlighter-rouge">&amp;mut T</code> and <code class="language-plaintext highlighter-rouge">UnsafeCell&lt;T&gt;</code> are invariant in Rust because they
are related to unsafe operations or mutable references, which require stricter type
constraints to ensure safety.</li>
  <li><strong>Contravariance:</strong> The <code class="language-plaintext highlighter-rouge">Fn(T)</code> type is contravariant. This means that if <code class="language-plaintext highlighter-rouge">Sub</code> is a
subtype of <code class="language-plaintext highlighter-rouge">Super</code>, then <code class="language-plaintext highlighter-rouge">Fn(Super)</code> is a subtype of <code class="language-plaintext highlighter-rouge">Fn(Sub)</code>. This is useful for
functions that take a callback as an argument.</li>
</ul>

<p>Here is a table of some other generic types and their variances:</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th style="text-align: center">‘a</th>
      <th style="text-align: center">T</th>
      <th style="text-align: center">U</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;'a T </code></td>
      <td style="text-align: center">covariant</td>
      <td style="text-align: center">covariant</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;'a mut T</code></td>
      <td style="text-align: center">covariant</td>
      <td style="text-align: center">invariant</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">covariant</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">covariant</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">UnsafeCell&lt;T&gt;</code></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">invariant</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Cell&lt;T&gt;</code></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">invariant</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">fn(T) -&gt; U</code></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"><strong>contra</strong>variant</td>
      <td style="text-align: center">covariant</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">*const T</code></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">covariant</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">*mut T</code></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">invariant</td>
      <td style="text-align: center"> </td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>This table is from <a href="https://doc.rust-lang.org/nomicon/subtyping.html#variance">Rustonomicon -
Variance</a>.</p>
</blockquote>

<h2 id="more-resources-on-rust-lifetimes">More resources on Rust lifetimes</h2>
<p><a id="markdown-more-resources-on-rust-lifetimes" name="more-resources-on-rust-lifetimes"></a></p>

<ul>
  <li><a href="https://doc.rust-lang.org/nomicon/subtyping.html">Rustonomicon - Subtyping and variance with lifetimes</a>.</li>
  <li><a href="https://rustc-dev-guide.rust-lang.org/variance.html">Rust compiler - Subtyping and variance implementation in the compiler</a>.</li>
  <li><a href="https://doc.rust-lang.org/nomicon/ownership.html">Rustonomicon - Ownership</a>.</li>
</ul>

<h2 id="youtube-videos-for-this-article">YouTube videos for this article</h2>
<p><a id="markdown-youtube-videos-for-this-article" name="youtube-videos-for-this-article"></a></p>

<p>This article has short examples on how to get to know Rust lifetimes deeply. If you like
to learn via video, please watch the companion video on the <a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube
channel</a>.</p>

<!-- rust subtyping and variance -->
<iframe src="https://www.youtube.com/embed/HRlpYXi4E-M?si=cSc_Ew5RHQ-ffFWJ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<!-- rust lifetimes -->
<iframe src="https://www.youtube.com/embed/eIJxAEcle7E?si=4Wn3X2mT7Pd8uvGx" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<p><br /></p>

<h2 id="learn-rust-lifetimes-by-example">Learn Rust lifetimes by example</h2>
<p><a id="markdown-learn-rust-lifetimes-by-example" name="learn-rust-lifetimes-by-example"></a></p>

<p>Let’s create some examples to illustrate how to use Rust lifetimes. You can run
<code class="language-plaintext highlighter-rouge">cargo new --bin lifetimes</code> to create a new binary crate.</p>

<blockquote>
  <p>The code in the video and this tutorial are all in <a href="https://github.com/nazmulidris/rust-scratch/blob/main/lifetimes/">this GitHub
repo</a>.</p>
</blockquote>

<h3 id="example-1-references">Example 1: References</h3>
<p><a id="markdown-example-1%3A-references" name="example-1%3A-references"></a></p>

<p>First add <code class="language-plaintext highlighter-rouge">mod ex_1_references;</code> to <code class="language-plaintext highlighter-rouge">lib.rs</code>. Then you can add the following code to the
<code class="language-plaintext highlighter-rouge">src/ex_1_references.rs</code> file.</p>

<blockquote>
  <p>The code for this example is
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/lifetimes/src/ex_1_references.rs">here</a>.</p>
</blockquote>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">ex_1_references</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">try_to_use_after_free</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="nb">str</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{} is a number"</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
        <span class="c1">// return &amp;s; /* 🧨 won't compile! */</span>
        <span class="nd">unreachable!</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">try_to_modify_referent</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">data</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span> <span class="cm">/* referent */</span>
        <span class="k">let</span> <span class="n">ref_to_first_item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="cm">/* reference */</span>
        <span class="c1">// data.push(4); /* 🧨 won't compile */</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"first_item: {}"</span><span class="p">,</span> <span class="n">ref_to_first_item</span><span class="p">);</span>
        <span class="cm">/* ref_to_first_item reference still in scope */</span>
        <span class="c1">// drop(ref_to_first_item);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The main things to note about this code:</p>

<ul>
  <li>Rust requires any <em>references</em> to freeze:
    <ul>
      <li>the referent and its owners.</li>
    </ul>
  </li>
  <li>While a <em>reference</em> is <strong>in scope</strong>, Rust will not allow you to:
    <ul>
      <li>change the referent and its owners.</li>
    </ul>
  </li>
  <li><a href="https://doc.rust-lang.org/nomicon/ownership.html">More info</a>.</li>
</ul>

<h3 id="example-2-aliasing">Example 2: Aliasing</h3>
<p><a id="markdown-example-2%3A-aliasing" name="example-2%3A-aliasing"></a></p>

<p>Let’s review some background info on references. There are two kinds of reference:</p>

<ol>
  <li>Shared reference: <code class="language-plaintext highlighter-rouge">&amp;</code></li>
  <li>Mutable reference: <code class="language-plaintext highlighter-rouge">&amp;mut</code></li>
</ol>

<p>Here are the rules of references:</p>

<ol>
  <li>A reference cannot outlive its referent.</li>
  <li>A <strong>mutable reference</strong> cannot be aliased.</li>
</ol>

<p>Aliasing:</p>

<ol>
  <li>Variables and pointers alias if they refer to overlapping regions of memory.</li>
  <li>The definition of “alias” that Rust will use likely involves some notion of
 <strong>liveness</strong> and <strong>mutation</strong>: we don’t actually care if aliasing occurs if there
 aren’t any actual writes to memory happening.</li>
</ol>

<p>Here’s more info:</p>
<ul>
  <li><a href="https://doc.rust-lang.org/nomicon/references.html">https://doc.rust-lang.org/nomicon/references.html</a></li>
  <li><a href="https://doc.rust-lang.org/nomicon/aliasing.html">https://doc.rust-lang.org/nomicon/aliasing.html</a></li>
</ul>

<blockquote>
  <p>The code for this example is
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/lifetimes/src/ex_2_aliasing.rs">here</a>.</p>
</blockquote>

<p>Add <code class="language-plaintext highlighter-rouge">mod ex_2_aliasing;</code> to <code class="language-plaintext highlighter-rouge">lib.rs</code>. Then you can add the following code to the
<code class="language-plaintext highlighter-rouge">src/ex_2_aliasing.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">ex_2_aliasing</span><span class="p">()</span> <span class="p">{</span>
    <span class="cd">/// `input_ref` and `output_ref` can't overlap or alias, and thus</span>
    <span class="cd">/// can't clobber each other.</span>
    <span class="k">fn</span> <span class="nf">compute</span><span class="p">(</span><span class="n">input_ref</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">usize</span><span class="p">,</span> <span class="n">output_ref</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="o">*</span><span class="n">input_ref</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">output_ref</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="o">*</span><span class="n">input_ref</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">output_ref</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// This is safe to do because `input` and `output` don't overlap.</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">input</span> <span class="o">=</span> <span class="mi">10usize</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">output</span> <span class="o">=</span> <span class="mi">1usize</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">input_address</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">input</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">usize</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">output_address</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">output</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">usize</span><span class="p">;</span>

        <span class="nf">compute</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">output</span><span class="p">);</span>

        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
        <span class="nd">assert_ne!</span><span class="p">(</span><span class="n">input_address</span><span class="p">,</span> <span class="n">output_address</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Try and clobber `input` with `output`.</span>
    <span class="c1">// - Rust won't allow `input` and `output` to overlap aka alias.</span>
    <span class="c1">// - Rust won't allow the `&amp;mut output` to be aliased!</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">output</span> <span class="o">=</span> <span class="mi">1usize</span><span class="p">;</span>
        <span class="c1">// compute(&amp;output, &amp;mut output); /* 🧨 won't compile! */</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="example-3-lifetimes">Example 3: Lifetimes</h3>
<p><a id="markdown-example-3%3A-lifetimes" name="example-3%3A-lifetimes"></a></p>

<p>Rust enforces a set of rules that govern how references are used via <strong>lifetimes</strong>.</p>

<p>Lifetimes are named regions of code that a reference must be valid for.</p>
<ul>
  <li>For simple programs, lifetimes coincide with lexical scope.</li>
  <li>Those regions may be fairly complex, as they correspond to paths of execution in the
  program.</li>
  <li>There may even be holes in these paths of execution, as it’s possible to invalidate
  a reference as long as it’s reinitialized before it’s used again.</li>
  <li>Types which contain references (or pretend to) may also be tagged with lifetimes so
  that Rust can prevent them from being invalidated as well.</li>
</ul>

<p>Inside a function, Rust doesn’t let you explicitly name lifetimes. And each let
statement implicitly introduces a scope. However, once you cross the function
boundary, you need to start talking about lifetimes.</p>

<p>More info:</p>
<ul>
  <li><a href="https://doc.rust-lang.org/nomicon/lifetimes.html#the-area-covered-by-a-lifetime">https://doc.rust-lang.org/nomicon/lifetimes.html#the-area-covered-by-a-lifetime</a></li>
  <li><a href="https://doc.rust-lang.org/nomicon/lifetime-mismatch.html">https://doc.rust-lang.org/nomicon/lifetime-mismatch.html</a></li>
</ul>

<blockquote>
  <p>The code for this example is
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/lifetimes/src/ex_3_lifetimes.rs">here</a>.</p>
</blockquote>

<p>Add <code class="language-plaintext highlighter-rouge">mod ex_3_lifetimes;</code> to <code class="language-plaintext highlighter-rouge">lib.rs</code>. Then you can add the following code to the
<code class="language-plaintext highlighter-rouge">src/ex_3_lifetimes.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[rustfmt::skip]</span>
<span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">ex_3_lifetimes_1</span><span class="p">()</span> <span class="p">{</span>
    <span class="cd">/// 'fn is          &lt;  'input.</span>
    <span class="cd">/// 'fn needs to be &gt;= 'input.</span>
    <span class="cd">///</span>
    <span class="cd">/// - 'fn is the lifetime of the referent. It is short.</span>
    <span class="cd">/// - 'input is the lifetime of the reference. It is long.</span>
    <span class="k">fn</span> <span class="n">try_to_make_reference_outlive_referent</span><span class="o">&lt;</span><span class="nv">'input</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="n">param</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'input</span> <span class="nb">usize</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'input</span> <span class="nb">str</span> <span class="p">{</span>
        <span class="c1">// 'fn: {</span>
            <span class="k">let</span> <span class="n">referent</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">param</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">reference</span> <span class="o">=</span> <span class="o">&amp;</span><span class="cm">/*'fn*/</span><span class="n">referent</span><span class="p">;</span>
            <span class="c1">// return reference; /* 🧨 does not compile! */</span>
            <span class="nd">unreachable!</span><span class="p">()</span>
        <span class="c1">// }</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="n">fix_try_to_make_reference_outlive_referent</span><span class="o">&lt;</span><span class="nv">'input</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="n">param</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'input</span> <span class="nb">usize</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'input</span> <span class="nb">str</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">param</span> <span class="p">{</span>
            <span class="mi">0</span> <span class="k">=&gt;</span> <span class="cm">/* &amp;'static */</span> <span class="s">"zero"</span><span class="p">,</span>
            <span class="mi">1</span> <span class="k">=&gt;</span> <span class="cm">/* &amp;'static */</span> <span class="s">"one"</span><span class="p">,</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="cm">/* &amp;'static */</span> <span class="s">"many"</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">assert_eq!</span><span class="p">(</span>
        <span class="nf">fix_try_to_make_reference_outlive_referent</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">0</span><span class="p">),</span> <span class="s">"zero"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notes on the code above:</p>

<ul>
  <li>The string literals “zero”, “one”, and “many” are stored in a special section of memory
that is accessible throughout the entire program execution. This means that these string
literals are available for the entire duration of the program, hence they have the
<code class="language-plaintext highlighter-rouge">'static</code> lifetime.</li>
</ul>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">ex_3_lifetimes.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[rustfmt::skip]</span>
<span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">ex_3_lifetimes_2</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">try_to_modify_referent</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">data</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span> <span class="cm">/* referent */</span>
        <span class="c1">// 'first: {</span>
            <span class="cm">/* reference */</span>
            <span class="k">let</span> <span class="n">ref_to_first_item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="cm">/*'first*/</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="c1">//   'second: {</span>
            <span class="c1">//        /* 🧨 won't compile */</span>
            <span class="c1">//        Vec::push(&amp;/*'second*/mut data, 4);</span>
            <span class="c1">//    }</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"first_item: {}"</span><span class="p">,</span> <span class="n">ref_to_first_item</span><span class="p">);</span>
            <span class="cm">/* reference still in scope */</span>
        <span class="c1">// }</span>
        <span class="c1">// drop(ref_to_first_item);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notes on the code above:</p>

<ul>
  <li>
    <p>Rust doesn’t understand that <code class="language-plaintext highlighter-rouge">ref_to_first_item</code> is a reference to a subpath of
<code class="language-plaintext highlighter-rouge">data</code>. It doesn’t understand [<code class="language-plaintext highlighter-rouge">Vec</code>] at all. 🤯</p>
  </li>
  <li>Here’s what it sees:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">ref_to_first_item</code> which is <code class="language-plaintext highlighter-rouge">&amp;'first data</code> has to live for <code class="language-plaintext highlighter-rouge">'first</code> in order to
be printed.</li>
      <li>When we try to call push, it then sees us try to make an <code class="language-plaintext highlighter-rouge">&amp;'second mut data</code>.</li>
      <li>It knows that <code class="language-plaintext highlighter-rouge">'second</code> is contained within <code class="language-plaintext highlighter-rouge">'first</code>, and rejects our program
because the <code class="language-plaintext highlighter-rouge">&amp;'first data</code> must still be alive! And we can’t alias a <strong>mutable
reference</strong>.</li>
    </ul>
  </li>
  <li>The lifetime system is much more coarse than the reference semantics we’re
actually interested in preserving.</li>
</ul>

<h3 id="example-4-input-slices">Example 4: Input slices</h3>
<p><a id="markdown-example-4%3A-input-slices" name="example-4%3A-input-slices"></a></p>

<p>We can use lifetimes and slices to work with data without modifying it. This pattern shows
up a lot when working with parsers (eg: <code class="language-plaintext highlighter-rouge">nom</code>) and general string manipulation.</p>

<p>Real world examples:</p>
<ul>
  <li><a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/core/src/tui_core/graphemes">https://github.com/r3bl-org/r3bl-open-core/tree/main/core/src/tui_core/graphemes</a></li>
  <li><a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/core/src/tui_core/graphemes/access.rs#L173">https://github.com/r3bl-org/r3bl-open-core/blob/main/core/src/tui_core/graphemes/access.rs#L173</a></li>
</ul>

<blockquote>
  <p>The code for this example is
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/lifetimes/src/ex_4_input_slices.rs">here</a>.</p>
</blockquote>

<p>First add <code class="language-plaintext highlighter-rouge">mod ex_4_input_slices;</code> to <code class="language-plaintext highlighter-rouge">lib.rs</code>. Then you can add the following code to the
<code class="language-plaintext highlighter-rouge">src/ex_4_input_slices.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[rustfmt::skip]</span>
<span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">ex_4_input_slices</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 'fn {</span>
        <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"foo bar baz"</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">middle_word</span><span class="p">:</span> <span class="o">&amp;</span> <span class="cm">/*'fn*/</span> <span class="nb">str</span> <span class="o">=</span> <span class="nf">middle_word</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">middle_word</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">);</span>
    <span class="c1">// }</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">middle_word</span><span class="o">&lt;</span><span class="nv">'input</span><span class="o">&gt;</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'input</span> <span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'input</span> <span class="nb">str</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">input</span><span class="nf">.split_whitespace</span><span class="p">();</span>

    <span class="k">let</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">middle_word_index</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">iter_clone</span> <span class="o">=</span> <span class="n">iter</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">word_count</span> <span class="o">=</span> <span class="n">iter_clone</span><span class="nf">.count</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">middle_word_index</span> <span class="o">=</span> <span class="n">word_count</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="p">(</span><span class="n">word_count</span><span class="p">,</span> <span class="n">middle_word_index</span><span class="p">)</span>
    <span class="p">};</span>

    <span class="k">let</span> <span class="p">(</span><span class="n">middle_word_len</span><span class="p">,</span> <span class="n">len_until_middle_word</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">middle_word_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">len_until_middle_word</span> <span class="o">=</span> <span class="n">iter</span>
            <span class="nf">.enumerate</span><span class="p">()</span>
            <span class="c1">// Go as far as the middle word.</span>
            <span class="nf">.take_while</span><span class="p">(|(</span><span class="n">index</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="o">*</span><span class="n">index</span> <span class="o">&lt;=</span> <span class="n">middle_word_index</span><span class="p">)</span>
            <span class="nf">.map</span><span class="p">(|(</span><span class="n">index</span><span class="p">,</span> <span class="n">word</span><span class="p">)|</span> <span class="p">{</span>
                <span class="c1">// At middle word.</span>
                <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="n">middle_word_index</span> <span class="p">{</span>
                    <span class="n">middle_word_len</span> <span class="o">=</span> <span class="n">word</span><span class="nf">.len</span><span class="p">();</span>
                    <span class="mi">0</span>
                <span class="p">}</span>
                <span class="c1">// Before middle word.</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="n">word</span><span class="nf">.len</span><span class="p">()</span>
                <span class="p">}</span>
            <span class="p">})</span>
            <span class="py">.sum</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">();</span>

        <span class="p">(</span><span class="n">middle_word_len</span><span class="p">,</span> <span class="n">len_until_middle_word</span><span class="p">)</span>
    <span class="p">};</span>

    <span class="k">let</span> <span class="p">(</span><span class="n">start_index</span><span class="p">,</span> <span class="n">end_index</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">start_index</span> <span class="o">=</span> <span class="n">len_until_middle_word</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">end_index</span> <span class="o">=</span> <span class="n">len_until_middle_word</span> <span class="o">+</span> <span class="n">middle_word_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">(</span><span class="n">start_index</span><span class="p">,</span> <span class="n">end_index</span><span class="p">)</span>
    <span class="p">};</span>

    <span class="o">&amp;</span><span class="cm">/*'input*/</span><span class="n">input</span><span class="p">[</span><span class="n">start_index</span><span class="o">..</span><span class="n">end_index</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="example-5-splitting-borrows-on-structs">Example 5: Splitting borrows on structs</h3>
<p><a id="markdown-example-5%3A-splitting-borrows-on-structs" name="example-5%3A-splitting-borrows-on-structs"></a></p>

<p>The mutual exclusion property of mutable references can be very limiting when working with
a composite structure.</p>

<p>The borrow checker understand structs sufficiently to know that it’s possible to borrow
disjoint fields of a struct simultaneously.</p>

<p><code class="language-plaintext highlighter-rouge">ex_5_splitting_borrows_on_structs.rs</code> will demonstrate this.</p>

<blockquote>
  <p>The code for this example is
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/lifetimes/src/ex_5_splitting_borrows_on_structs.rs">here</a>.</p>
</blockquote>

<p>First add <code class="language-plaintext highlighter-rouge">mod ex_5_splitting_borrows_on_structs;</code> to <code class="language-plaintext highlighter-rouge">lib.rs</code>. Then you can add the
following code to the <code class="language-plaintext highlighter-rouge">src/ex_5_splitting_borrows_on_structs.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">ex_5_splitting_borrows_on_structs</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Data</span> <span class="p">{</span>
        <span class="n">a</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">b</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">change_field_by_ref</span><span class="p">(</span><span class="n">field</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">field</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">data</span> <span class="o">=</span> <span class="n">Data</span> <span class="p">{</span> <span class="n">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="mi">2</span> <span class="p">};</span>

    <span class="k">let</span> <span class="n">a_ref</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">data</span><span class="py">.a</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">b_ref</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">data</span><span class="py">.b</span><span class="p">;</span>

    <span class="nf">change_field_by_ref</span><span class="p">(</span><span class="n">a_ref</span><span class="p">);</span>
    <span class="nf">change_field_by_ref</span><span class="p">(</span><span class="n">b_ref</span><span class="p">);</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">data</span><span class="py">.a</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">data</span><span class="py">.b</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The next example shows a struct that only contains references. As long as the owned struct
and the references live for the same lifetime, it all works. Add the following code to the
same file:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">ex_5_splitting_borrows_on_structs_2</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Data</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">field_usize</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">field_str</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">impl</span> <span class="n">Data</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="n">new</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span>
            <span class="n">str_param</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span> <span class="n">usize_param</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="nb">usize</span>
        <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Data</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span>
        <span class="p">{</span>
            <span class="n">Data</span> <span class="p">{</span>
                <span class="n">field_usize</span><span class="p">:</span> <span class="n">usize_param</span><span class="p">,</span>
                <span class="n">field_str</span><span class="p">:</span> <span class="n">str_param</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">fn</span> <span class="nf">change_field_usize</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">*</span><span class="k">self</span><span class="py">.field_usize</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">fn</span> <span class="nf">change_field_str</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.field_str</span> <span class="o">=</span> <span class="s">"new value"</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">str_arg</span> <span class="o">=</span> <span class="s">"old value"</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">usize_arg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">data</span> <span class="o">=</span> <span class="nn">Data</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">str_arg</span><span class="p">,</span> <span class="n">usize_arg</span><span class="p">);</span>

    <span class="n">data</span><span class="nf">.change_field_usize</span><span class="p">();</span>
    <span class="n">data</span><span class="nf">.change_field_str</span><span class="p">();</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="py">.field_usize</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">data</span><span class="py">.field_str</span><span class="p">,</span> <span class="s">"new value"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="example-6-clone-on-write-cow">Example 6: Clone on write (Cow)</h3>
<p><a id="markdown-example-6%3A-clone-on-write-cow" name="example-6%3A-clone-on-write-cow"></a></p>

<p>The <a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code class="language-plaintext highlighter-rouge">Cow</code></a> type is a smart pointer
that can be used to work with both owned and borrowed data.</p>
<ul>
  <li>It is useful when you want to avoid unnecessary allocations and copying.</li>
  <li>You can also use it in functions where you might need to mutate the argument; in which
case the data will be <strong>lazily cloned</strong> when mutation or ownership is required.</li>
</ul>

<blockquote>
  <p>The code for this example is
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/lifetimes/src/ex_6_cow.rs">here</a>.</p>
</blockquote>

<p>First add <code class="language-plaintext highlighter-rouge">mod ex_6_cow;</code> to <code class="language-plaintext highlighter-rouge">lib.rs</code>. Then you can add the following code to the
<code class="language-plaintext highlighter-rouge">src/ex_6_cow.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">ex_6_cow</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">borrow</span><span class="p">::</span><span class="n">Cow</span><span class="p">;</span>

    <span class="k">fn</span> <span class="n">capitalize</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="n">Cow</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="nb">str</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Cow</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="nb">str</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">input</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">input</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">input</span><span class="nf">.chars</span><span class="p">()</span><span class="nf">.all</span><span class="p">(</span><span class="nn">char</span><span class="p">::</span><span class="n">is_uppercase</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">input</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">cloned</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">input</span><span class="nf">.len</span><span class="p">());</span>
        <span class="n">cloned</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input</span><span class="p">[</span><span class="o">..</span><span class="mi">1</span><span class="p">]</span><span class="nf">.to_uppercase</span><span class="p">());</span>
        <span class="n">cloned</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]);</span>
        <span class="nn">Cow</span><span class="p">::</span><span class="nf">Owned</span><span class="p">(</span><span class="n">cloned</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">borrowed_data</span> <span class="o">=</span> <span class="nn">Cow</span><span class="p">::</span><span class="nf">Borrowed</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">owned_data</span> <span class="o">=</span> <span class="nn">Cow</span><span class="p">::</span><span class="nf">Owned</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"world"</span><span class="p">));</span>

    <span class="k">let</span> <span class="n">capitalized_borrowed_data</span> <span class="o">=</span> <span class="nf">capitalize</span><span class="p">(</span><span class="n">borrowed_data</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">capitalized_owned_data</span> <span class="o">=</span> <span class="nf">capitalize</span><span class="p">(</span><span class="n">owned_data</span><span class="p">);</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">capitalized_borrowed_data</span><span class="p">,</span> <span class="s">"Hello"</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">capitalized_owned_data</span><span class="p">,</span> <span class="s">"World"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notes on the code:</p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">capitalize</code> function takes a <code class="language-plaintext highlighter-rouge">Cow</code> as an argument. It also returns a <code class="language-plaintext highlighter-rouge">Cow</code>.</li>
  <li>The <code class="language-plaintext highlighter-rouge">Cow</code> type is an enum that can hold either a borrowed reference or an owned value.</li>
  <li>The <code class="language-plaintext highlighter-rouge">capitalize</code> function will return the input unchanged if it is already capitalized.
Otherwise it allocates a new capitalized string, moves into into a <code class="language-plaintext highlighter-rouge">Cow</code> and returns it
as an owned value.</li>
</ul>

<p>Next, add the following code to the same file:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">ex_6_cow_2</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">borrow</span><span class="p">::</span><span class="n">Cow</span><span class="p">;</span>

    <span class="k">fn</span> <span class="n">capitalize_mut</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Cow</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="nb">str</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">input</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">input</span><span class="nf">.chars</span><span class="p">()</span><span class="nf">.all</span><span class="p">(</span><span class="nn">char</span><span class="p">::</span><span class="n">is_uppercase</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">cloned</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">input</span><span class="nf">.len</span><span class="p">());</span>
        <span class="n">cloned</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input</span><span class="p">[</span><span class="o">..</span><span class="mi">1</span><span class="p">]</span><span class="nf">.to_uppercase</span><span class="p">());</span>
        <span class="n">cloned</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]);</span>
        <span class="o">*</span><span class="n">input</span> <span class="o">=</span> <span class="nn">Cow</span><span class="p">::</span><span class="nf">Owned</span><span class="p">(</span><span class="n">cloned</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">borrowed_data</span> <span class="o">=</span> <span class="nn">Cow</span><span class="p">::</span><span class="nf">Borrowed</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">owned_data</span> <span class="o">=</span> <span class="nn">Cow</span><span class="p">::</span><span class="nf">Owned</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"world"</span><span class="p">));</span>

    <span class="nf">capitalize_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">borrowed_data</span><span class="p">);</span>
    <span class="nf">capitalize_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">owned_data</span><span class="p">);</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">borrowed_data</span><span class="p">,</span> <span class="s">"Hello"</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">owned_data</span><span class="p">,</span> <span class="s">"World"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notes on the code:</p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">capitalize_mut</code> function takes a mutable reference to a <code class="language-plaintext highlighter-rouge">Cow</code> as an argument.</li>
  <li>It will mutate the input in place if it is not already capitalized. This requires
cloning the input string.</li>
</ul>

<h3 id="example-7-subtyping-and-variance">Example 7: Subtyping and variance</h3>
<p><a id="markdown-example-7%3A-subtyping-and-variance" name="example-7%3A-subtyping-and-variance"></a></p>

<blockquote>
  <p>Please refer to the <a href="#what-is-subtyping-and-variance">Subtyping and variance</a> section for
more information, before following this example.</p>
</blockquote>

<p>Let’s define that <code class="language-plaintext highlighter-rouge">Sub</code> is a subtype of Super (ie <code class="language-plaintext highlighter-rouge">Sub : Super</code>).</p>
<ul>
  <li>What this is suggesting to us is that the set of requirements that <code class="language-plaintext highlighter-rouge">Super</code> defines
are completely satisfied by <code class="language-plaintext highlighter-rouge">Sub</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">Sub</code> may then have more requirements.</li>
  <li>That is, <code class="language-plaintext highlighter-rouge">Sub</code> &gt; <code class="language-plaintext highlighter-rouge">Super</code>.</li>
</ul>

<p>Replacing this with lifetimes, <code class="language-plaintext highlighter-rouge">'long : 'short</code> if and only if</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">'long</code> defines a region of code that completely contains <code class="language-plaintext highlighter-rouge">'short</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">'long</code> may define a region larger than <code class="language-plaintext highlighter-rouge">'short</code>, but that still fits our
definition.</li>
  <li>That is, <code class="language-plaintext highlighter-rouge">'long</code> &gt; <code class="language-plaintext highlighter-rouge">'short</code>.</li>
</ul>

<p>More info:</p>
<ul>
  <li><a href="https://doc.rust-lang.org/nomicon/subtyping.html">https://doc.rust-lang.org/nomicon/subtyping.html</a></li>
</ul>

<blockquote>
  <p>The code for this example is
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/lifetimes/src/ex_7_subtyping_and_variance.rs">here</a>.</p>
</blockquote>

<p>First add <code class="language-plaintext highlighter-rouge">mod ex_7_subtyping_and_variance;</code> to <code class="language-plaintext highlighter-rouge">lib.rs</code>. Then you can add the following code to the
<code class="language-plaintext highlighter-rouge">src/ex_7_subtyping_and_variance.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[rustfmt::skip]</span>
<span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">subtyping</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">debug</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"a: {}, b: {}"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">hello</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="nb">str</span> <span class="o">=</span> <span class="s">"hello"</span><span class="p">;</span>

    <span class="c1">// 'short {</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">world</span> <span class="o">=</span> <span class="s">"world"</span><span class="nf">.to_string</span><span class="p">();</span>
        <span class="nf">debug</span><span class="p">(</span>
            <span class="cm">/*&amp;'static*/</span> <span class="n">hello</span><span class="p">,</span>
            <span class="o">&amp;</span><span class="cm">/*'short*/</span>  <span class="n">world</span>
        <span class="p">);</span>
        <span class="c1">// Why does this work?</span>
        <span class="c1">// 1) `&amp;'static str` : `&amp;'short str`</span>
        <span class="c1">//       ↑                ↑</span>
        <span class="c1">//     Subtype          Super type</span>
        <span class="c1">// 2) `hello` silently downgrades from `&amp;'static str`</span>
        <span class="c1">//    into `&amp;'short str`</span>
    <span class="p">}</span>
    <span class="c1">// }</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notes on the code above:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">fn debug(a, b)</code>:
    <ul>
      <li>Since: <code class="language-plaintext highlighter-rouge">&amp;'a T</code> is covariant over <code class="language-plaintext highlighter-rouge">'a</code>, we are allowed to perform subtyping.</li>
      <li>And: <code class="language-plaintext highlighter-rouge">&amp;'static str</code> is a subtype of <code class="language-plaintext highlighter-rouge">&amp;'short str</code>.</li>
      <li>And since:
        <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'static : 'short
  ↑       ↑
 Sub     Super
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>Here’s a short table with the rules:</p>

    <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>|                 | `'a`     | `T` |
|-----------------|----------|-----|
| `&amp;'a T`         | C        | C   |
| `&amp;'a mut T`     | C        | I   |
</code></pre></div>    </div>
  </li>
</ul>

<p>Now, add the following code to the same file:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// More info:</span>
<span class="cd">/// - &lt;https://doc.rust-lang.org/nomicon/subtyping.html&gt;</span>
<span class="nd">#[rustfmt::skip]</span>
<span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">variance</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">assign</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">reference</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="n">T</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">reference</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">hello</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="nb">str</span> <span class="o">=</span> <span class="s">"hello"</span><span class="p">;</span>

    <span class="c1">// 'short {</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">world</span> <span class="o">=</span> <span class="s">"world"</span><span class="nf">.to_string</span><span class="p">();</span>
        <span class="cm">/* 🧨 does not compile! Due to invariance, the 2 args are
           different types!
        */</span>
        <span class="c1">// assign(</span>
        <span class="c1">//     &amp;mut/*&amp;'static*/ hello,</span>
        <span class="c1">//     &amp;/*'short*/      world</span>
        <span class="c1">// );</span>

        <span class="c1">// `&amp;mut T` is invariant over `T`, meaning, these are</span>
        <span class="c1">// incompatible:</span>
        <span class="c1">//</span>
        <span class="c1">// 1. 1st arg: `&amp;mut &amp;'static str`, which is `&amp;mut T`</span>
        <span class="c1">//    where `T = &amp;'static str`.</span>
        <span class="c1">// 2. 2nd arg: `&amp;'short str`, and it is expecting</span>
        <span class="c1">//    `T = &amp;'static str`. This `T` does not match!</span>
        <span class="c1">//</span>
        <span class="c1">// This means that:</span>
        <span class="c1">// - `&amp;mut &amp;'static str` cannot be a subtype of `&amp;'short str`</span>
        <span class="c1">// - even if `'static` **is** a subtype of `'short`</span>
    <span class="p">}</span>
    <span class="c1">// }</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notes on the code:</p>

<ol>
  <li>Take a mutable reference and a value and overwrite the <strong>referent</strong> with it.</li>
  <li>It clearly says in its signature the referent and the value must be the
 <strong>exact</strong> same type.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">&amp;mut T</code> is invariant over <code class="language-plaintext highlighter-rouge">T</code>, meaning,</li>
      <li><code class="language-plaintext highlighter-rouge">&amp;mut &amp;'long T</code> is <strong>NOT</strong> a subtype of <code class="language-plaintext highlighter-rouge">&amp;'short T</code>,</li>
      <li>Even when:
        <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'long : 'short
↑       ↑
Sub     Super
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>Here’s a short table with the rules:
    <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>|                 | `'a`     | `T` |
|-----------------|----------|-----|
| `&amp;'a T`         | C        | C   |
| `&amp;'a mut T`     | C        | I   |
</code></pre></div>    </div>
  </li>
</ol>

<h2 id="build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</h2>
<p><a id="markdown-build-with-naz-video-series-on-developerlife.com-youtube-channel" name="build-with-naz-video-series-on-developerlife.com-youtube-channel"></a></p>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a></li>
  <li>Playlists
    <ul>
      <li><a href="https://www.youtube.com/watch?v=bolScvh4x7I&amp;list=PLofhE49PEwmw3MKOU1Kn3xbP4FRQR4Mb3">Build with Naz, Linux TTY, process, signals, commands in async Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmza94sS7UmJnN9gSCHTVTfz">Build with Naz, fundamental effective Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmwO69E7eiQ-ewnMME8ydgQ5">Build with Naz, effective async Rust and tokio</a></li>
      <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><summary type="html"><![CDATA[Rust lifetimes are key part of the type system which allows the Rust compiler to make its memory safety guarantees. We will explore subtyping, variance, references, memory aliasing, splitting borrows, and clone on write in this article, its video, and repo.]]></summary></entry><entry><title type="html">Build with Naz : Explore Linux TTY, process, signals w/ Rust</title><link href="http://developerlife.com/2024/08/20/tty-linux-async-rust/" rel="alternate" type="text/html" title="Build with Naz : Explore Linux TTY, process, signals w/ Rust" /><published>2024-08-20T10:00:00-05:00</published><updated>2024-08-20T10:00:00-05:00</updated><id>http://developerlife.com/2024/08/20/tty-linux-async-rust</id><content type="html" xml:base="http://developerlife.com/2024/08/20/tty-linux-async-rust/"><![CDATA[<p><img class="post-hero-image" src="/assets/linux-tty-proc-async-rust.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#prerequisite">Prerequisite</a></li>
  <li><a href="#github-repo-for-this-article">GitHub repo for this article</a></li>
  <li><a href="#related-youtube-videos-for-this-article">Related YouTube videos for this article</a>
    <ul>
      <li><a href="#part-1--3--background-info">Part 1 / 3 : background info</a></li>
      <li><a href="#part-2--3--examples-of-send--recieve-signals-proc-spawn-and-ipc">Part 2 / 3 : examples of send &amp; recieve signals, proc spawn, and IPC</a></li>
      <li><a href="#part-3--3--run-tokioprocesscommand-in-async-rust">Part 3 / 3 : run tokio::process::Command in async Rust</a></li>
    </ul>
  </li>
  <li><a href="#limitations-of-using-tty-in-linux-and-why-we-like-userland-terminal-emulators-pty">Limitations of using TTY in Linux, and why we like userland terminal emulators PTY</a>
    <ul>
      <li><a href="#kernel-tty-">Kernel TTY 👎🏽</a></li>
      <li><a href="#userland-pty-">Userland PTY 👍🏽</a></li>
    </ul>
  </li>
  <li><a href="#examples-of-using-pty-in-linux">Examples of using PTY in Linux</a>
    <ul>
      <li><a href="#using-redirection-to-write-to-another-pty-run-command-in-left-terminal-see-output-in-right-terminal">Using redirection to write to another PTY run command in left terminal, see output in right terminal</a></li>
      <li><a href="#using-redirection-to-read-from-another-pty-type-in-left-terminal-see-it-in-right-terminal">Using redirection to read from another PTY type in left terminal, see it in right terminal</a></li>
      <li><a href="#breaking-things-in-raw-mode">Breaking things in raw mode.</a></li>
    </ul>
  </li>
  <li><a href="#shells-processes-sessions-jobs-ptys-signals">Shells, processes, sessions, jobs, PTYs, signals</a>
    <ul>
      <li><a href="#background-information-knowledgebase">Background information knowledgebase</a>
        <ul>
          <li><a href="#file-descriptors-and-processes-ulimit-stdin-stdout-stderr-pipes">File descriptors and processes, ulimit, stdin, stdout, stderr, pipes</a></li>
          <li><a href="#unix-shells-that-run-in-terminals-to-execute-built-in-and-program-commands">Unix shells that run in terminals to execute built-in and program commands</a>
            <ul>
              <li><a href="#what-is-the-relationship-between-linux-shells-subshells-and-fork-exec-and-wait-patterns">What is the relationship between linux shells, subshells, and fork, exec, and wait patterns?</a></li>
              <li><a href="#does-exec-change-the-current-working-directory-or-affect-environment-variables-in-the-parent">Does exec change the current working directory or affect environment variables in the parent?</a></li>
              <li><a href="#then-how-does-the-cd-command-change-the-current-working-directory-of-a-shell">Then how does the cd command change the current working directory of a shell?</a></li>
              <li><a href="#how-do-subshells-work-in-the-case-where-i-dont-the-shells-environment-to-be-affected-at-all">How do subshells work, in the case where I don’t the shell’s environment to be affected at all?</a></li>
              <li><a href="#deep-dive-of-all-this-information-in-video-format">Deep dive of all this information in video format</a></li>
            </ul>
          </li>
          <li><a href="#processes-sessions-jobs-ptys-signals-using-c">Processes, sessions, jobs, PTYs, signals using C</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#what-is-devtty">What is /dev/tty?</a>
    <ul>
      <li><a href="#how-is-crossterm-built-on-top-of-stdio-pty-etc">How is crossterm built on top of stdio, PTY, etc?</a></li>
      <li><a href="#how-is-termion-built-on-top-of-stdio-pty-etc">How is termion built on top of stdio, PTY, etc?</a></li>
    </ul>
  </li>
  <li><a href="#list-of-signals">List of signals</a></li>
  <li><a href="#-sending-and-receiving-signals-in-rust">🦀 Sending and receiving signals in Rust</a>
    <ul>
      <li><a href="#example-using-tokio-to-receive-signals">Example using tokio to receive signals</a></li>
      <li><a href="#example-using-signal-hook-and-signal-hook-tokio">Example using signal-hook and signal-hook-tokio</a></li>
    </ul>
  </li>
  <li><a href="#-process-spawning-in-rust">🦀 Process spawning in Rust</a>
    <ul>
      <li><a href="#example-using-procspawn-to-spawn-processes">Example using procspawn to spawn processes</a></li>
      <li><a href="#example-using-procspawn-to-spawn-processes-w-ipc-channel">Example using procspawn to spawn processes w/ ipc-channel</a></li>
    </ul>
  </li>
  <li><a href="#-run-tokioprocesscommand-in-async-rust">🦀 Run tokio:process::Command in async Rust</a>
    <ul>
      <li><a href="#example-running-echo-process-programmatically">Example running echo process programmatically</a></li>
      <li><a href="#example-piping-input-to-cat-process-programmatically">Example piping input to cat process programmatically</a></li>
      <li><a href="#example-programmatically-providing-input-into-stdin-and-getting-output-from-stdout-of-a-process">Example programmatically providing input into stdin and getting output from stdout of a process</a></li>
      <li><a href="#example-programmatically-piping-the-output-of-one-process-into-another">Example programmatically piping the output of one process into another</a></li>
      <li><a href="#example-using-r3bl_terminal_async-to-send-commands-to-a-long-running-bash-child-process">Example using r3bl_terminal_async to send commands to a long running bash child process</a></li>
    </ul>
  </li>
  <li><a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</a></li>
</ul>

<!-- /TOC -->

<h2 id="introduction">Introduction</h2>
<p><a id="markdown-introduction" name="introduction"></a></p>

<p>This article, along with related videos and the repository, explores Linux TTY, shells,
processes, sessions, jobs, PTYs, signals, and more using Rust. It explains <code class="language-plaintext highlighter-rouge">/dev/tty</code> and
describes how terminal libraries like <code class="language-plaintext highlighter-rouge">crossterm</code> and <code class="language-plaintext highlighter-rouge">termion</code> build on top of <code class="language-plaintext highlighter-rouge">stdio</code>
and <code class="language-plaintext highlighter-rouge">/dev/tty</code>. The article provides examples of using Rust to send and receive POSIX
signals, communicate with processes via IPC, and spawn processes. Additionally, it
includes examples of using PTY in Linux and controlling external commands (such as
binaries like <code class="language-plaintext highlighter-rouge">bash</code>) using asynchronous Rust.</p>

<h2 id="prerequisite">Prerequisite</h2>
<p><a id="markdown-prerequisite" name="prerequisite"></a></p>

<p>Read all about TTY history and implementation in Linux
<a href="https://www.linusakesson.net/programming/tty/">here</a> before reading this repo and doing
the exercises here. There is so much background history and information in this article
that is a prerequisite to understanding anything in this repo.</p>

<p>This is a great <a href="https://youtu.be/juGNPLdjLH4?si=0gg4ZPbPbnL2_rQx">YouTube video</a> that
explains the fundamentals of the Linux kernel and device drivers, and how <code class="language-plaintext highlighter-rouge">char</code> device
drivers work. TTYs are <code class="language-plaintext highlighter-rouge">char</code> devices.</p>

<h2 id="github-repo-for-this-article">GitHub repo for this article</h2>
<p><a id="markdown-github-repo-for-this-article" name="github-repo-for-this-article"></a></p>

<p>Here’s the <a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/README.md#list-of-signals"><code class="language-plaintext highlighter-rouge">tty</code>
repo</a>
containing the source code for this article and the videos.</p>

<h2 id="related-youtube-videos-for-this-article">Related YouTube videos for this article</h2>
<p><a id="markdown-related-youtube-videos-for-this-article" name="related-youtube-videos-for-this-article"></a></p>

<p>This article is a companion to the following YouTube videos. If you like to learn via
video, please watch the companion videos on the <a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube
channel</a>. Please
<a href="https://www.youtube.com/@developerlifecom?sub_confirmation=1">subscribe</a> to the channel.</p>

<blockquote>
  <p>⏯️ Here’s the <a href="https://www.youtube.com/watch?v=bolScvh4x7I&amp;list=PLofhE49PEwmw3MKOU1Kn3xbP4FRQR4Mb3">TTY
playlist</a>
containing all these videos.</p>
</blockquote>

<h3 id="part-1--3--background-info">Part 1 / 3 : background info</h3>
<p><a id="markdown-part-1-%2F-3-%3A-background-info" name="part-1-%2F-3-%3A-background-info"></a></p>

<!-- video tty-1 -->
<iframe src="https://www.youtube.com/embed/bolScvh4x7I?si=9Cm95eajpdEym0zX" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<p><br /></p>

<h3 id="part-2--3--examples-of-send--recieve-signals-proc-spawn-and-ipc">Part 2 / 3 : examples of send &amp; recieve signals, proc spawn, and IPC</h3>
<p><a id="markdown-part-2-%2F-3-%3A-examples-of-send-%26-recieve-signals%2C-proc-spawn%2C-and-ipc" name="part-2-%2F-3-%3A-examples-of-send-%26-recieve-signals%2C-proc-spawn%2C-and-ipc"></a></p>

<!-- video tty-2 -->
<iframe src="https://www.youtube.com/embed/58_9yjLI4WA?si=-CZA8vZGnVTJ5ILD" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<p><br /></p>

<h3 id="part-3--3--run-tokioprocesscommand-in-async-rust">Part 3 / 3 : run tokio::process::Command in async Rust</h3>
<p><a id="markdown-part-3-%2F-3-%3A-run-tokio%3A%3Aprocess%3A%3Acommand-in-async-rust" name="part-3-%2F-3-%3A-run-tokio%3A%3Aprocess%3A%3Acommand-in-async-rust"></a></p>

<!-- video tty-3 -->
<iframe src="https://www.youtube.com/embed/8JeL1sGozO4?si=9i1-booV0MoQXRGg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<p><br /></p>

<h2 id="limitations-of-using-tty-in-linux-and-why-we-like-userland-terminal-emulators-pty">Limitations of using TTY in Linux, and why we like userland terminal emulators (PTY)</h2>
<p><a id="markdown-limitations-of-using-tty-in-linux%2C-and-why-we-like-userland-terminal-emulators-pty" name="limitations-of-using-tty-in-linux%2C-and-why-we-like-userland-terminal-emulators-pty"></a></p>

<h3 id="kernel-tty-">Kernel TTY 👎🏽</h3>
<p><a id="markdown-kernel-tty-%F0%9F%91%8E%F0%9F%8F%BD" name="kernel-tty-%F0%9F%91%8E%F0%9F%8F%BD"></a></p>

<p>To switch to TTYs in Linux, press:</p>

<ul>
  <li><kbd>Ctrl + Alt + F3</kbd> to <kbd>Ctrl + Alt + F4</kbd>. To access two TTYs, one on <kbd>F3</kbd>
and the other on <kbd>F4</kbd>.</li>
  <li>To switch back to the TTY in which the GUI is running, press <kbd>Ctrl + Alt + F2</kbd>.</li>
</ul>

<p>In the Linux kernel, the TTY driver and line discipline provide basic line editing (and the
implementation of <code class="language-plaintext highlighter-rouge">cooked</code> or <code class="language-plaintext highlighter-rouge">raw</code> mode), and there is no
<a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter"><code class="language-plaintext highlighter-rouge">UART</code></a> or physical
terminal involved. Instead, a video terminal (a complex state machine including a frame buffer of
characters and graphical character attributes) is emulated in software, and
<a href="https://www.youtube.com/watch?v=aAuw2EVCBBg">[video] rendered to a VGA display</a>.</p>

<blockquote>
  <p>So if you run <code class="language-plaintext highlighter-rouge">edi</code> in a TTY, you will see that the font rendering and colors are different than
in a GUI terminal emulator. However it still runs.</p>
</blockquote>

<h3 id="userland-pty-">Userland PTY 👍🏽</h3>
<p><a id="markdown-userland-pty-%F0%9F%91%8D%F0%9F%8F%BD" name="userland-pty-%F0%9F%91%8D%F0%9F%8F%BD"></a></p>

<p>The (kernel TTY) console subsystem is somewhat rigid. Things get more flexible (and abstract) if we
move the terminal emulation into userland. This is how <code class="language-plaintext highlighter-rouge">xterm</code> and its clones work. To facilitate
moving the terminal emulation into userland, while still keeping the TTY subsystem (session
management and line discipline) intact, the pseudo terminal or PTY was invented. And as you may have
guessed, things get even more complicated when you start running pseudo terminals inside pseudo
terminals, aka <code class="language-plaintext highlighter-rouge">screen</code> or <code class="language-plaintext highlighter-rouge">ssh</code>.</p>

<blockquote>
  <p>The primary use case for r3bl code is to run in this terminal emulator environment in userland and
not the TTY environment supplied by the Linux kernel itself.</p>
</blockquote>

<h2 id="examples-of-using-pty-in-linux">Examples of using PTY in Linux</h2>
<p><a id="markdown-examples-of-using-pty-in-linux" name="examples-of-using-pty-in-linux"></a></p>

<p>Each terminal in Linux is associated with a PTY (pseudo terminal). This is the device provided by
each terminal emulator program instance (aka process) that is currently running on the system. Use
the following command to get a list of all PTYs on the system.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ls</span> /dev/pts
</code></pre></div></div>

<p>Here’s sample output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>crw--w---- nazmul tty  0 B Wed Jul 17 11:36:35 2024  0
crw--w---- nazmul tty  0 B Wed Jul 17 11:38:32 2024  1
crw--w---- nazmul tty  0 B Wed Jul 17 11:38:06 2024  10
crw--w---- nazmul tty  0 B Wed Jul 17 11:23:20 2024  11
crw--w---- nazmul tty  0 B Sun Jul 14 16:19:36 2024  2
crw--w---- nazmul tty  0 B Mon Jul 15 13:22:48 2024  3
crw--w---- nazmul tty  0 B Tue Jul 16 09:58:08 2024  4
crw--w---- nazmul tty  0 B Wed Jul 17 10:34:48 2024  5
crw--w---- nazmul tty  0 B Wed Jul 17 11:30:32 2024  7
crw--w---- nazmul tty  0 B Wed Jul 17 11:36:36 2024  8
crw--w---- nazmul tty  0 B Wed Jul 17 11:30:48 2024  9
c--------- root   root 0 B Sat Jul 13 18:23:41 2024  ptmx
</code></pre></div></div>

<p>So which PTY is associated with the currently open terminal? Run the following command to get the
TTY number of the currently open terminal.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">set </span>my_tty_id <span class="o">(</span><span class="nb">tty</span><span class="o">)</span>
<span class="nb">echo</span> <span class="nv">$my_tty_id</span>
</code></pre></div></div>

<p>It will output something like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/dev/pts/1
</code></pre></div></div>

<p>Each <code class="language-plaintext highlighter-rouge">/dev/pts/*</code> is a file. And you can read / write / redirect to these files just like any other
file.</p>

<p>For the following examples, let’s assume that you have 2 terminal emulator app windows open. One on
the left, and another one on the right.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌────────────────────────────────┐  ┌────────────────────────────────┐
│                                │  │                                │
│    LEFT TERMINAL               │  │    RIGHT TERMINAL              │
│    /dev/pts/1                  │  │    /dev/pts/2                  │
│                                │  │                                │
└────────────────────────────────┘  └────────────────────────────────┘
</code></pre></div></div>

<h3 id="using-redirection-to-write-to-another-pty-run-command-in-left-terminal-see-output-in-right-terminal">Using redirection to write to another PTY (run command in left terminal, see output in right terminal)</h3>
<p><a id="markdown-using-redirection-to-write-to-another-pty-run-command-in-left-terminal%2C-see-output-in-right-terminal" name="using-redirection-to-write-to-another-pty-run-command-in-left-terminal%2C-see-output-in-right-terminal"></a></p>

<p>Let’s say you have 2 terminals open, and one has the PTY number <code class="language-plaintext highlighter-rouge">/dev/pts/1</code> (on the left) and the
other has the TTY number <code class="language-plaintext highlighter-rouge">/dev/pts/2</code> (on the right).</p>

<p>From the left PTY <code class="language-plaintext highlighter-rouge">/dev/pts/1</code>, you can write to the right PTY <code class="language-plaintext highlighter-rouge">/dev/pts/2</code> using the following
command, and you will see “Hello, World!” in the right PTY.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Run this in left terminal /dev/pts/1</span>
<span class="nb">echo</span> <span class="s2">"Hello, World!"</span> <span class="o">&gt;</span> /dev/pts/2 <span class="c"># You will see this in the right terminal /dev/pts/2</span>
</code></pre></div></div>

<h3 id="using-redirection-to-read-from-another-pty-type-in-left-terminal-see-it-in-right-terminal">Using redirection to read from another PTY (type in left terminal, see it in right terminal)</h3>
<p><a id="markdown-using-redirection-to-read-from-another-pty-type-in-left-terminal%2C-see-it-in-right-terminal" name="using-redirection-to-read-from-another-pty-type-in-left-terminal%2C-see-it-in-right-terminal"></a></p>

<p>From the right PTY <code class="language-plaintext highlighter-rouge">/dev/pts/2</code> you can read input from the left PTY <code class="language-plaintext highlighter-rouge">/dev/pts/1</code> using the
following command.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Run this in right terminal /dev/pts/2</span>
<span class="nb">cat</span> /dev/pts/1
</code></pre></div></div>

<p>Type the following in the left PTY.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Run this in left terminal /dev/pts/1</span>
abcdefgh
</code></pre></div></div>

<p>You will see the following output in the right PTY: <code class="language-plaintext highlighter-rouge">abcdefgh</code>.</p>

<h3 id="breaking-things-in-raw-mode">Breaking things in raw mode.</h3>
<p><a id="markdown-breaking-things-in-raw-mode." name="breaking-things-in-raw-mode."></a></p>

<p>On the <strong>right</strong> terminal, run the following commands.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vi &amp;
<span class="nb">jobs</span>
</code></pre></div></div>

<p>Here you will see the job number of the <code class="language-plaintext highlighter-rouge">vi</code> process. And you will see that it is in the background.</p>

<p>If you run <code class="language-plaintext highlighter-rouge">ps l</code> you will see the states of all the processes that are running. If you run <code class="language-plaintext highlighter-rouge">ps -l</code>
you will this information on just the processes spawned in the right terminal. For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 S  1000  540327  540177  0  80   0 - 62854 futex_ pts/8    00:00:01 fish
0 T  1000  554675  540327  0  80   0 -  3023 do_sig pts/8    00:00:00 vi
4 R  1000  554850  540327  0  80   0 -  3478 -      pts/8    00:00:00 ps
</code></pre></div></div>

<p>Now if you bring <code class="language-plaintext highlighter-rouge">vi</code> to the foreground by running <code class="language-plaintext highlighter-rouge">fg</code>. The <code class="language-plaintext highlighter-rouge">vi</code> process is now in raw mode, and
the shell is no longer interpreting the input. It won’t know what to do with input that comes in
over <code class="language-plaintext highlighter-rouge">stdin</code>.</p>

<p>Run <code class="language-plaintext highlighter-rouge">echo "foo" &gt; /dev/pts/2</code> in the <strong>left</strong> terminal, you will see that the <code class="language-plaintext highlighter-rouge">vi</code> process gets
messed up, since it doesn’t really interpret that input (as it’s reading directly from keyboard and
mouse). However, the shell will send that output to <code class="language-plaintext highlighter-rouge">vi</code> and it’s UI will be messed up. The same
thing happens if you use <code class="language-plaintext highlighter-rouge">micro</code> or <code class="language-plaintext highlighter-rouge">nano</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌────────────────────────────────┐  ┌────────────────────────────────┐
│    LEFT TERMINAL               │  │    RIGHT TERMINAL              │
│    /dev/pts/1                  │  │    /dev/pts/2                  │
│                                │  │                                │
│                                │  │  &gt; vi &amp;                        │
│                                │  │  &gt; jobs                        │
│                                │  │  &gt; fg                          │
│  &gt; echo "foo" &gt; /dev/pts/2     │  │  &gt; # vi is messed up           │
└────────────────────────────────┘  └────────────────────────────────┘
</code></pre></div></div>

<p>To terminate the <code class="language-plaintext highlighter-rouge">vi</code> process (or many of them), run <code class="language-plaintext highlighter-rouge">killall -9 vi</code>. That sends the <code class="language-plaintext highlighter-rouge">SIGKILL</code>
signal to all the <code class="language-plaintext highlighter-rouge">vi</code> processes.</p>

<h2 id="shells-processes-sessions-jobs-ptys-signals">Shells, processes, sessions, jobs, PTYs, signals</h2>
<p><a id="markdown-shells%2C-processes%2C-sessions%2C-jobs%2C-ptys%2C-signals" name="shells%2C-processes%2C-sessions%2C-jobs%2C-ptys%2C-signals"></a></p>

<p>Let’s say in a new terminal emulator program <code class="language-plaintext highlighter-rouge">xterm</code>, and then you run the following commands in
<code class="language-plaintext highlighter-rouge">fish</code>:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> &amp;
<span class="nb">ls</span> | <span class="nb">sort</span>
</code></pre></div></div>

<p>What happens here? What sessions and jobs are created? What about the pipe?</p>

<p>There are 4 jobs:</p>

<ol>
  <li>The job that runs <code class="language-plaintext highlighter-rouge">xterm</code> itself.</li>
</ol>

<ul>
  <li>This does not have any <code class="language-plaintext highlighter-rouge">stdin</code>, <code class="language-plaintext highlighter-rouge">stdout</code>, <code class="language-plaintext highlighter-rouge">stderr</code> <code class="language-plaintext highlighter-rouge">fd</code>s associated with it.</li>
  <li>This does not have a PTY associated with it.</li>
</ul>

<ol>
  <li>The job that runs <code class="language-plaintext highlighter-rouge">bash</code> itself.</li>
</ol>

<ul>
  <li>This has <code class="language-plaintext highlighter-rouge">stdin</code>, <code class="language-plaintext highlighter-rouge">stdout</code>, <code class="language-plaintext highlighter-rouge">stderr</code> (from <code class="language-plaintext highlighter-rouge">xterm</code>), lets say, <code class="language-plaintext highlighter-rouge">/dev/pts/0</code>.</li>
  <li>This has a PTY associated with it, lets say, <code class="language-plaintext highlighter-rouge">/dev/pts/0</code>.</li>
</ul>

<ol>
  <li>The job that runs <code class="language-plaintext highlighter-rouge">cat</code> in the background.</li>
</ol>

<ul>
  <li>This has <code class="language-plaintext highlighter-rouge">stdin</code>, <code class="language-plaintext highlighter-rouge">stdout</code>, <code class="language-plaintext highlighter-rouge">stderr</code> (from <code class="language-plaintext highlighter-rouge">xterm</code>), <code class="language-plaintext highlighter-rouge">/dev/pts/0</code>.</li>
  <li>This has a PTY associated with it, <code class="language-plaintext highlighter-rouge">/dev/pts/0</code>.</li>
</ul>

<ol>
  <li>The job that runs <code class="language-plaintext highlighter-rouge">ls | sort</code> pipeline. This job has 2 processes inside of it which are spawned
in parallel due to the pipe: 4.1. The process that runs <code class="language-plaintext highlighter-rouge">ls</code>.
    <ul>
      <li>This has <code class="language-plaintext highlighter-rouge">stdin</code>, <code class="language-plaintext highlighter-rouge">stderr</code> (from <code class="language-plaintext highlighter-rouge">xterm</code>), <code class="language-plaintext highlighter-rouge">/dev/pts/0</code>.</li>
      <li>Due to the pipe <code class="language-plaintext highlighter-rouge">stdout</code> is set to <code class="language-plaintext highlighter-rouge">pipe0</code>.</li>
      <li>This has a PTY associated with it, <code class="language-plaintext highlighter-rouge">/dev/pts/0</code>. 4.2. The process that runs <code class="language-plaintext highlighter-rouge">sort</code>.</li>
      <li>This has <code class="language-plaintext highlighter-rouge">stdout</code>, <code class="language-plaintext highlighter-rouge">stderr</code> (from <code class="language-plaintext highlighter-rouge">xterm</code>), <code class="language-plaintext highlighter-rouge">/dev/pts/0</code>.</li>
      <li>Due to the pipe, this has <code class="language-plaintext highlighter-rouge">stdin</code> set to <code class="language-plaintext highlighter-rouge">pipe0</code>.</li>
      <li>This has a PTY associated with it, <code class="language-plaintext highlighter-rouge">/dev/pts/0</code>.</li>
    </ul>
  </li>
</ol>

<p>The basic idea is that every pipeline is a job, because every process in a pipeline should be
manipulated (stopped, resumed, killed) simultaneously. That’s why <code class="language-plaintext highlighter-rouge">kill</code> allows you to send signals
to entire process groups. By default, <code class="language-plaintext highlighter-rouge">fork</code> places a newly created child process in the same
process group as its parent, so that e.g. a <kbd>^C</kbd> from the keyboard will affect both parent
and child. But the shell, as part of its session leader duties, creates a new process group every
time it launches a pipeline.</p>

<p>The TTY driver keeps track of the foreground process group id, but only in a passive way. The
session leader has to update this information explicitly when necessary. Similarly, the TTY driver
keeps track of the size of the connected terminal, but this information has to be updated
explicitly, by the terminal emulator or even by the user.</p>

<p>Several processes have <code class="language-plaintext highlighter-rouge">/dev/pts/0</code> attached to their standard input. With these constrains:</p>

<ol>
  <li>Only the foreground job (the <code class="language-plaintext highlighter-rouge">ls | sort</code> pipeline) will receive input from the TTY.</li>
  <li>Likewise, only the foreground job will be allowed to write to the TTY device (in the default
configuration).</li>
  <li>If the <code class="language-plaintext highlighter-rouge">cat</code> process were to attempt to write to the TTY, the kernel would suspend it using a
signal.</li>
</ol>

<h3 id="background-information-knowledgebase">Background information (knowledgebase)</h3>
<p><a id="markdown-background-information-knowledgebase" name="background-information-knowledgebase"></a></p>

<p>The following sections are a deep live of the Linux kernel and how it works with processes, file
descriptors, shells, and PTYs.</p>

<h4 id="file-descriptors-and-processes-ulimit-stdin-stdout-stderr-pipes">File descriptors and processes, ulimit, stdin, stdout, stderr, pipes</h4>
<p><a id="markdown-file-descriptors-and-processes%2C-ulimit%2C-stdin%2C-stdout%2C-stderr%2C-pipes" name="file-descriptors-and-processes%2C-ulimit%2C-stdin%2C-stdout%2C-stderr%2C-pipes"></a></p>

<p>Here’s a
<a href="https://youtu.be/rW_NV6rf0rM?si=wcEkGPXnXzKeBn_G">[video] What’s behind a file descriptor in Linux? Also, i/o redirection with <code class="language-plaintext highlighter-rouge">dup2</code>.</a>
that goes into file descriptors, pipes, and process forking in Linux.</p>

<h4 id="unix-shells-that-run-in-terminals-to-execute-built-in-and-program-commands">Unix shells (that run in terminals to execute built-in and program commands)</h4>
<p><a id="markdown-unix-shells-that-run-in-terminals-to-execute-built-in-and-program-commands" name="unix-shells-that-run-in-terminals-to-execute-built-in-and-program-commands"></a></p>

<h5 id="what-is-the-relationship-between-linux-shells-subshells-and-fork-exec-and-wait-patterns">What is the relationship between linux shells, subshells, and fork, exec, and wait patterns?</h5>
<p><a id="markdown-what-is-the-relationship-between-linux-shells%2C-subshells%2C-and-fork%2C-exec%2C-and-wait-patterns%3F" name="what-is-the-relationship-between-linux-shells%2C-subshells%2C-and-fork%2C-exec%2C-and-wait-patterns%3F"></a></p>

<p>In Linux, shells, subshells, and the fork-exec-wait pattern are interconnected concepts that play a
crucial role in process management and execution. Here’s how they relate to each other:</p>

<ol>
  <li>
    <p><strong>Shells</strong>: A shell is a command-line interpreter that allows users to interact with the
operating system. Shells provide a way for users to run commands, launch programs, and manage
processes. Examples of popular shells in Linux include Bash, Zsh, and Fish.</p>
  </li>
  <li>
    <p><strong>Fork-Exec-Wait Pattern</strong>: This pattern is commonly used in shell scripting to spawn new
processes and manage their execution. By forking a new process, executing a different program in
the child process, and then waiting for the child process to finish, the shell can run multiple
commands concurrently and coordinate their execution. If the parent does not wait for the child
process to finish, the child is a zombie process.</p>

    <ul>
      <li><strong>Fork</strong>: When a process wants to execute a new program, it creates a copy of itself using the
<code class="language-plaintext highlighter-rouge">fork()</code> system call. This creates a new process (child process) that is an exact copy of the
original process (parent process) at the time of the <code class="language-plaintext highlighter-rouge">fork()</code> call. It needs to do this since
<code class="language-plaintext highlighter-rouge">exec()</code>, which is called next, will swap the program binaries of the process which calls it!
If it doesn’t spawn a child, then the parent will cease to exist in memory after <code class="language-plaintext highlighter-rouge">exec()</code> is
called.</li>
      <li><strong>Exec</strong>: After forking, the child process uses the <code class="language-plaintext highlighter-rouge">exec()</code> system call to replace its memory
space with a new program. This allows the child process to run a different program than the
parent process. The <code class="language-plaintext highlighter-rouge">exec()</code> system call loads the new program into the child process’s memory
and starts its execution.</li>
      <li><strong>Wait</strong>: After forking and executing a new program, the parent process may need to wait for
the child process to finish its execution. The parent process can use the <code class="language-plaintext highlighter-rouge">wait()</code> system call
to wait for the child process to terminate. This ensures that the parent process does not
continue its execution until the child process has completed its task.</li>
    </ul>
  </li>
  <li>
    <p><strong>Subshells</strong>: A subshell is a separate instance of the shell that is spawned to execute a
command or a group of commands. Subshells are created within the parent shell and can be used to
run commands in a separate environment without affecting the parent shell.</p>
  </li>
</ol>

<blockquote>
  <p>You can learn more about each of these system calls on your Linux machine simply by running
<code class="language-plaintext highlighter-rouge">bash -c "man fork"</code>, <code class="language-plaintext highlighter-rouge">bash -c "man exec"</code>, and <code class="language-plaintext highlighter-rouge">bash -c "man wait"</code>. The <code class="language-plaintext highlighter-rouge">bash -c</code> is needed only
if you’re running some other shell like <code class="language-plaintext highlighter-rouge">fish</code> and not <code class="language-plaintext highlighter-rouge">bash</code>.</p>
</blockquote>

<p>The relationship between these concepts is as follows:</p>

<ul>
  <li>A shell process (the parent) creates a clone of their “self” process using <code class="language-plaintext highlighter-rouge">fork()</code>, called a
child process. And then they use <code class="language-plaintext highlighter-rouge">exec()</code> to replace the memory space of the child process with a
new program. Then the parent process waits for the child process to finish.</li>
  <li>The fork-exec-wait pattern is a common technique used in shells and subshells to spawn new
processes, execute programs, and coordinate their execution.</li>
  <li>Shells can create subshells to run commands in a separate environment. For example if you want to
run <code class="language-plaintext highlighter-rouge">cd</code> (which is a shell built-in command and not a external “program” command) and you don’t
want this to affect the parent shell, you can run it in a subshell.</li>
</ul>

<p>Overall, these concepts work together to facilitate process management, execution, and command
interpretation in a Linux environment.</p>

<h5 id="does-exec-change-the-current-working-directory-or-affect-environment-variables-in-the-parent">Does exec() change the current working directory or affect environment variables in the parent?</h5>
<p><a id="markdown-does-exec-change-the-current-working-directory-or-affect-environment-variables-in-the-parent%3F" name="does-exec-change-the-current-working-directory-or-affect-environment-variables-in-the-parent%3F"></a></p>

<p>Running <code class="language-plaintext highlighter-rouge">exec()</code> on the child process does not change the current working directory of the parent
process.</p>

<p>When a process calls the <code class="language-plaintext highlighter-rouge">exec()</code> system call in Linux, it replaces its current image with a new
program. The <code class="language-plaintext highlighter-rouge">exec()</code> system call loads a new program into the process’s memory space and starts its
execution.</p>

<p>Here’s how <code class="language-plaintext highlighter-rouge">exec()</code> affects the current working directory and environment variables:</p>

<ol>
  <li>
    <p><strong>Current Working Directory</strong>: When a child process calls <code class="language-plaintext highlighter-rouge">exec()</code>, the current working directory
of the parent process remains unchanged. The new program loaded by <code class="language-plaintext highlighter-rouge">exec()</code> will start executing
with the same working directory as the original process. Therefore, the current working directory
of the parent process is not affected by the child’s <code class="language-plaintext highlighter-rouge">exec()</code> call.</p>
  </li>
  <li>
    <p><strong>Environment Variables</strong>: The environment of the new program loaded by <code class="language-plaintext highlighter-rouge">exec()</code> can be set
explicitly by the program itself or inherited from the parent process. If the new program does
not explicitly modify the environment variables, it will inherit the environment variables from
the parent process. Any changes made to environment variables in the child process after the
<code class="language-plaintext highlighter-rouge">exec()</code> call will not affect the environment variables of the parent process.</p>
  </li>
</ol>

<h5 id="then-how-does-the-cd-command-change-the-current-working-directory-of-a-shell">Then how does the cd command change the current working directory of a shell?</h5>
<p><a id="markdown-then-how-does-the-cd-command-change-the-current-working-directory-of-a-shell%3F" name="then-how-does-the-cd-command-change-the-current-working-directory-of-a-shell%3F"></a></p>

<p>The <code class="language-plaintext highlighter-rouge">cd</code> command is a special command called a “shell built-in” command; there are about ~70 of
these. <code class="language-plaintext highlighter-rouge">echo</code>, <code class="language-plaintext highlighter-rouge">source</code> are examples of these “built-in” commands. These commands are built into the
shell itself. It is not a “external executable program” command like <code class="language-plaintext highlighter-rouge">ls</code>. So a shell does not have
to <code class="language-plaintext highlighter-rouge">fork</code> and <code class="language-plaintext highlighter-rouge">exec</code> to run these commands. The shell runs them inside of it’s own “parent” process,
which affects “self”.</p>

<p>If you think about it, <code class="language-plaintext highlighter-rouge">cd</code> has to be a built-in command since we know that child processes can’t
affect the environment of the parent process, and the current working directory is part of a
process’ environment.</p>

<blockquote>
  <p>Watch this <a href="https://youtu.be/GA2mIUQq48s?si=Sfbpre-MeNXlND_b&amp;t=820">video</a> to get an understanding
of <code class="language-plaintext highlighter-rouge">built-in</code> commands vs <code class="language-plaintext highlighter-rouge">external executable program</code> commands.</p>
</blockquote>

<p>Let’s say you want to <code class="language-plaintext highlighter-rouge">cd</code> into a folder but you don’t want this to affect the parent shell. How do
you do this? This is where subshells come into play. If you’re using <code class="language-plaintext highlighter-rouge">fish</code>, then a subshell is like
running <code class="language-plaintext highlighter-rouge">fish -c</code> with whatever is typed in between <code class="language-plaintext highlighter-rouge">""</code>.</p>

<h5 id="how-do-subshells-work-in-the-case-where-i-dont-the-shells-environment-to-be-affected-at-all">How do subshells work, in the case where I don’t the shell’s environment to be affected at all?</h5>
<p><a id="markdown-how-do-subshells-work%2C-in-the-case-where-i-don%E2%80%99t-the-shell%E2%80%99s-environment-to-be-affected-at-all%3F" name="how-do-subshells-work%2C-in-the-case-where-i-don%E2%80%99t-the-shell%E2%80%99s-environment-to-be-affected-at-all%3F"></a></p>

<p>In a Linux shell, a subshell is a separate instance of the shell that is spawned to execute a
command or a group of commands. When a user types a command to execute, the shell creates a subshell
to run that command.</p>

<p>Subshells are useful for various purposes, such as:</p>

<ol>
  <li>Running commands in a separate environment without affecting the parent shell.</li>
  <li>Running commands in parallel to improve performance.</li>
  <li>Running commands that need to be isolated from the parent shell.</li>
</ol>

<p>Subshells are typically created using parentheses <code class="language-plaintext highlighter-rouge">()</code> in <code class="language-plaintext highlighter-rouge">fish</code> or the <code class="language-plaintext highlighter-rouge">$(...)</code> syntax in <code class="language-plaintext highlighter-rouge">bash</code>.
For example, when you run a command within parentheses like this:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>command1<span class="p">;</span> command2<span class="o">)</span>
</code></pre></div></div>

<p>The commands <code class="language-plaintext highlighter-rouge">command1</code> and <code class="language-plaintext highlighter-rouge">command2</code> will be executed in a subshell. Once the commands finish
executing, the subshell exits, and the parent shell continues its operation. If you run the <code class="language-plaintext highlighter-rouge">cd ..</code>
command in a subshell, it won’t change the current working directory of the shell!</p>

<p>Subshells are used to manage sessions and jobs and pipelines. Things like foreground and background
jobs are managed using subshells. And signals are sent to processes using subshells in a pipeline.</p>

<blockquote>
  <p>Watch this <a href="https://youtu.be/N8kT2XRNEAg?si=iiv6i3mO6Lxi8qb1&amp;t=60">video</a> to get an understanding
of subshells, signals, jobs, pipelines, etc.</p>
</blockquote>

<h5 id="deep-dive-of-all-this-information-in-video-format">Deep dive of all this information in video format</h5>
<p><a id="markdown-deep-dive-of-all-this-information-in-video-format" name="deep-dive-of-all-this-information-in-video-format"></a></p>

<p>Here’s a
<a href="https://www.youtube.com/playlist?list=PLFAC320731F539902">[video playlist] Unix terminals and shells</a>
that goes into details about shells, subshells, forking, exec (command), and wait works.</p>

<h4 id="processes-sessions-jobs-ptys-signals-using-c">Processes, sessions, jobs, PTYs, signals using C</h4>
<p><a id="markdown-processes%2C-sessions%2C-jobs%2C-ptys%2C-signals-using-c" name="processes%2C-sessions%2C-jobs%2C-ptys%2C-signals-using-c"></a></p>

<p>Here are some videos on forking processes, zombies, and signals in C:</p>

<ul>
  <li><a href="https://www.youtube.com/watch?v=ss1-REMJ9GA">[video] Create new process in C w/ <code class="language-plaintext highlighter-rouge">fork()</code></a></li>
  <li><a href="https://www.youtube.com/watch?v=83M5-NPDeWs">[video] Send signals to processes in C w/ <code class="language-plaintext highlighter-rouge">kill()</code>, <code class="language-plaintext highlighter-rouge">signal()</code>, <code class="language-plaintext highlighter-rouge">sigaction()</code></a></li>
  <li><a href="https://www.youtube.com/watch?v=xJ8KenZw2ag">[video] Zombie processes in C</a></li>
  <li><a href="https://www.youtube.com/watch?v=_5SCtRNnf9U">[video] Stop process becoming zombie in C</a></li>
</ul>

<h2 id="what-is-devtty">What is /dev/tty?</h2>
<p><a id="markdown-what-is-%2Fdev%2Ftty%3F" name="what-is-%2Fdev%2Ftty%3F"></a></p>

<p><code class="language-plaintext highlighter-rouge">/dev/tty</code> is a special file in Unix-like operating systems that represents the controlling terminal
of the current process. It is a synonym for the controlling terminal device file associated with the
process.</p>

<p>The controlling terminal is the terminal that is currently active and connected to the process,
allowing input and output interactions. It provides a way for processes to interact with the user
through the terminal interface.</p>

<p>The <code class="language-plaintext highlighter-rouge">/dev/tty</code> file can be used to read from or write to the controlling terminal.</p>

<p>In each process, <code class="language-plaintext highlighter-rouge">/dev/tty</code> is a synonym for the controlling terminal associated with the process
group of that process, if any. It is useful for programs or shell procedures that wish to be sure of
writing messages to or reading data from the terminal no matter how output has been redirected. It
can also be used for applications that demand the name of a file for output, when typed output is
desired and it is tiresome to find out what terminal is currently in use.</p>

<ol>
  <li>Definition from
<a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap10.html">IEEE Open Group Base Specifications for POSIX</a>.</li>
  <li>You can see it used in <code class="language-plaintext highlighter-rouge">crossterm</code> crate
<a href="https://github.com/crossterm-rs/crossterm/blob/master/src/terminal/sys/file_descriptor.rs#L143">here</a>.</li>
  <li>Here’s more info about this on
<a href="https://www.baeldung.com/linux/monitor-keyboard-drivers#devtty">baeldung.com</a>.</li>
</ol>

<h3 id="how-is-crossterm-built-on-top-of-stdio-pty-etc">How is crossterm built on top of stdio, PTY, etc?</h3>
<p><a id="markdown-how-is-crossterm-built-on-top-of-stdio%2C-pty%2C-etc%3F" name="how-is-crossterm-built-on-top-of-stdio%2C-pty%2C-etc%3F"></a></p>

<p>The <a href="https://github.com/crossterm-rs/crossterm"><code class="language-plaintext highlighter-rouge">crossterm</code></a> crate is built on top of Tokio’s
<a href="https://docs.rs/mio/latest/mio/guide/index.html"><code class="language-plaintext highlighter-rouge">mio</code></a> crate, which uses Linux
<a href="https://man7.org/linux/man-pages/man7/epoll.7.html"><code class="language-plaintext highlighter-rouge">epoll</code></a> to work with file descriptors in an
async manner.</p>

<ul>
  <li>Here’s <a href="https://docs.rs/mio/latest/mio/struct.Poll.html"><code class="language-plaintext highlighter-rouge">mio</code>’s <code class="language-plaintext highlighter-rouge">Poll</code></a> using <code class="language-plaintext highlighter-rouge">epoll</code> under the
hood.</li>
  <li>Here’s an <a href="https://docs.rs/mio/latest/mio/guide/index.html">example</a> of <code class="language-plaintext highlighter-rouge">mio</code> using Linux <code class="language-plaintext highlighter-rouge">epoll</code>
in order to read from a file descriptor in an async manner.</li>
</ul>

<blockquote>
  <p>Linux <code class="language-plaintext highlighter-rouge">epoll</code> is able to work with <code class="language-plaintext highlighter-rouge">stdio</code> file descriptors (ie, <code class="language-plaintext highlighter-rouge">stdin</code>, <code class="language-plaintext highlighter-rouge">stdout</code>, <code class="language-plaintext highlighter-rouge">stderr</code>), as
well as other file descriptors (network and file system). However, for throughput and performance
(by reducing context switching and being efficient with buffers that hold IO data), Linux
<a href="https://en.wikipedia.org/wiki/Io_uring"><code class="language-plaintext highlighter-rouge">io_uring</code></a> might be more suitable.</p>
</blockquote>

<p>Here are some links to learn more about how <code class="language-plaintext highlighter-rouge">crossterm</code> works with <code class="language-plaintext highlighter-rouge">PTY</code>s and <code class="language-plaintext highlighter-rouge">stdio</code>:</p>

<ul>
  <li><a href="https://github.com/crossterm-rs/crossterm/blob/master/src/terminal/sys/file_descriptor.rs#L143">Get a file descriptor for the TTY <code class="language-plaintext highlighter-rouge">tty_fd()</code></a>.
It uses <a href="https://docs.rs/rustix/latest/rustix/stdio/fn.stdin.html"><code class="language-plaintext highlighter-rouge">rustix::stdio::stdin()</code></a> by
default and falls back on <code class="language-plaintext highlighter-rouge">/dev/tty/</code>.</li>
  <li>This <code class="language-plaintext highlighter-rouge">fd</code> is used by
<a href="https://github.com/crossterm-rs/crossterm/blob/master/src/event/source/unix/mio.rs#L35"><code class="language-plaintext highlighter-rouge">UnixInternalEventSource</code></a>
which creates a <code class="language-plaintext highlighter-rouge">mio::Poll</code> object for the <code class="language-plaintext highlighter-rouge">fd</code>. This <code class="language-plaintext highlighter-rouge">Poll</code> object uses <code class="language-plaintext highlighter-rouge">epoll</code> under the hood.
The
<a href="https://github.com/crossterm-rs/crossterm/blob/master/src/event/source/unix/mio.rs#L72"><code class="language-plaintext highlighter-rouge">EventSource</code> trait impl for <code class="language-plaintext highlighter-rouge">UnixInternalEventSource</code></a>
is used to actually
<a href="https://github.com/crossterm-rs/crossterm/blob/master/src/terminal/sys/file_descriptor.rs#L75">read</a>
the bytes from the <code class="language-plaintext highlighter-rouge">fd</code> (using
<a href="https://docs.rs/rustix/latest/rustix/io/fn.read.html"><code class="language-plaintext highlighter-rouge">rustix::io::read()</code></a>).</li>
  <li>Once a <code class="language-plaintext highlighter-rouge">Poll</code> has been created, a
<a href="https://docs.rs/mio/latest/mio/struct.Registry.html"><code class="language-plaintext highlighter-rouge">mio::Poll::registry()</code></a> must be used to
tell the OS to listen for events on the <code class="language-plaintext highlighter-rouge">fd</code>. A
<a href="https://docs.rs/mio/latest/mio/guide/index.html#2-registering-event-source">source and interest must be registered</a>
with the registry next:
    <ul>
      <li>The <code class="language-plaintext highlighter-rouge">fd</code> <a href="https://docs.rs/mio/latest/mio/unix/struct.SourceFd.html">implements</a> the
<a href="https://docs.rs/mio/latest/mio/event/trait.Source.html"><code class="language-plaintext highlighter-rouge">Source</code> trait</a> which
<a href="https://docs.rs/mio/latest/mio/event/trait.Source.html#implementing-eventsource">allows</a> <code class="language-plaintext highlighter-rouge">mio</code>
to listen for events on the <code class="language-plaintext highlighter-rouge">fd</code>.</li>
      <li>An <code class="language-plaintext highlighter-rouge">Interest::READABLE</code> must also be “registered” with the <code class="language-plaintext highlighter-rouge">registry</code>. For eg, for <code class="language-plaintext highlighter-rouge">stdin</code>, this
tells the OS to listen for input from the keyboard, and wake the <code class="language-plaintext highlighter-rouge">Poll</code> when this is ready.</li>
      <li>A <code class="language-plaintext highlighter-rouge">Token</code> is supplied that can be used when polling for events to see if they’re available on
the source. This happens in the
<a href="https://docs.rs/mio/latest/mio/guide/index.html#3-creating-the-event-loop"><code class="language-plaintext highlighter-rouge">loop</code></a> that calls
<code class="language-plaintext highlighter-rouge">poll()</code> to fill an <code class="language-plaintext highlighter-rouge">Event</code> buffer. If an event in this buffer matches the <code class="language-plaintext highlighter-rouge">Token</code>, then the
<code class="language-plaintext highlighter-rouge">fd</code> is ready for reading.</li>
    </ul>
  </li>
</ul>

<p>You can see all the steps (outlined above) in action, in the following crates:</p>

<ul>
  <li><a href="https://docs.rs/mio/latest/mio/guide/index.html">Guide in <code class="language-plaintext highlighter-rouge">mio</code> docs</a>.</li>
  <li><a href="https://github.com/crossterm-rs/crossterm/blob/master/src/event/source/unix/mio.rs"><code class="language-plaintext highlighter-rouge">mio.rs</code> file in <code class="language-plaintext highlighter-rouge">crossterm</code></a>.</li>
  <li>This <a href="https://github.com/nazmulidris/crossterm/pull/1">PR</a> in my fork of <code class="language-plaintext highlighter-rouge">crossterm</code> has
<code class="language-plaintext highlighter-rouge">println!</code> traces so you can see how <code class="language-plaintext highlighter-rouge">mio</code> is used under the hood by <code class="language-plaintext highlighter-rouge">crossterm</code> to read from
<code class="language-plaintext highlighter-rouge">stdin</code>.</li>
</ul>

<h3 id="how-is-termion-built-on-top-of-stdio-pty-etc">How is termion built on top of stdio, PTY, etc?</h3>
<p><a id="markdown-how-is-termion-built-on-top-of-stdio%2C-pty%2C-etc%3F" name="how-is-termion-built-on-top-of-stdio%2C-pty%2C-etc%3F"></a></p>

<p>Here’s a <a href="https://github.com/nazmulidris/termion/pull/1">PR</a> to explore the examples in <code class="language-plaintext highlighter-rouge">termion</code>
crate. This is a beautifully simple and elegant crate that is much simpler than <code class="language-plaintext highlighter-rouge">crossterm</code>. It
simply uses the standard library and a few other crates to get bytes from <code class="language-plaintext highlighter-rouge">stdin</code> and write bytes to
<code class="language-plaintext highlighter-rouge">stdout</code>. It does not use <code class="language-plaintext highlighter-rouge">mio</code>, and neither does it support <code class="language-plaintext highlighter-rouge">async</code> <code class="language-plaintext highlighter-rouge">EventStream</code>. There is an
“async mode”, which simply spawns another thread and uses a channel to send events to the main
thread.</p>

<h2 id="list-of-signals">List of signals</h2>
<p><a id="markdown-list-of-signals" name="list-of-signals"></a></p>

<p>Here are the reference docs on signals:
<!-- cspell:disable-next-line --></p>
<ul>
  <li><a href="https://en.wikipedia.org/wiki/POSIX">POSIX</a>, pronounced “paw-siks”, <a href="https://en.wikipedia.org/wiki/Signal_(IPC)">signals</a></li>
  <li><a href="https://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html">gnu libc termination signals</a></li>
  <li><a href="https://www.gnu.org/software/libc/manual/html_node/Job-Control-Signals.html">gnu libc job control signals</a></li>
</ul>

<p>Here is a list of all the signals that a process might get:
<a href="https://www.linusakesson.net/programming/tty/#signal-madness:~:text=using%20a%20signal.-,Signal%20madness,-Now%20let%27s%20take">signals</a>.</p>

<p>You can also get a list of them using <code class="language-plaintext highlighter-rouge">kill -l</code>. It is different for <code class="language-plaintext highlighter-rouge">fish</code> and <code class="language-plaintext highlighter-rouge">bash</code>. However,
under the hood, the Linux kernel uses the same signal numbers for all shells.</p>

<!-- cSpell:disable -->

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>fish <span class="nt">-c</span> <span class="s2">"kill -l"</span>
HUP INT QUIT ILL TRAP ABRT BUS FPE KILL USR1 SEGV USR2 PIPE ALRM TERM STKFLT
CHLD CONT STOP TSTP TTIN TTOU URG XCPU XFSZ VTALRM PROF WINCH POLL PWR SYS

<span class="sb">```</span>shell
<span class="nv">$ </span>bash <span class="nt">-c</span> <span class="s2">"kill -l"</span>
 1<span class="o">)</span> SIGHUP	 2<span class="o">)</span> SIGINT	 3<span class="o">)</span> SIGQUIT	 4<span class="o">)</span> SIGILL	 5<span class="o">)</span> SIGTRAP
 6<span class="o">)</span> SIGABRT	 7<span class="o">)</span> SIGBUS	 8<span class="o">)</span> SIGFPE	 9<span class="o">)</span> SIGKILL	10<span class="o">)</span> SIGUSR1
11<span class="o">)</span> SIGSEGV	12<span class="o">)</span> SIGUSR2	13<span class="o">)</span> SIGPIPE	14<span class="o">)</span> SIGALRM	15<span class="o">)</span> SIGTERM
16<span class="o">)</span> SIGSTKFLT	17<span class="o">)</span> SIGCHLD	18<span class="o">)</span> SIGCONT	19<span class="o">)</span> SIGSTOP	20<span class="o">)</span> SIGTSTP
21<span class="o">)</span> SIGTTIN	22<span class="o">)</span> SIGTTOU	23<span class="o">)</span> SIGURG	24<span class="o">)</span> SIGXCPU	25<span class="o">)</span> SIGXFSZ
26<span class="o">)</span> SIGVTALRM	27<span class="o">)</span> SIGPROF	28<span class="o">)</span> SIGWINCH	29<span class="o">)</span> SIGIO	30<span class="o">)</span> SIGPWR
31<span class="o">)</span> SIGSYS	34<span class="o">)</span> SIGRTMIN	35<span class="o">)</span> SIGRTMIN+1	36<span class="o">)</span> SIGRTMIN+2	37<span class="o">)</span> SIGRTMIN+3
38<span class="o">)</span> SIGRTMIN+4	39<span class="o">)</span> SIGRTMIN+5	40<span class="o">)</span> SIGRTMIN+6	41<span class="o">)</span> SIGRTMIN+7	42<span class="o">)</span> SIGRTMIN+8
43<span class="o">)</span> SIGRTMIN+9	44<span class="o">)</span> SIGRTMIN+10	45<span class="o">)</span> SIGRTMIN+11	46<span class="o">)</span> SIGRTMIN+12	47<span class="o">)</span> SIGRTMIN+13
48<span class="o">)</span> SIGRTMIN+14	49<span class="o">)</span> SIGRTMIN+15	50<span class="o">)</span> SIGRTMAX-14	51<span class="o">)</span> SIGRTMAX-13	52<span class="o">)</span> SIGRTMAX-12
53<span class="o">)</span> SIGRTMAX-11	54<span class="o">)</span> SIGRTMAX-10	55<span class="o">)</span> SIGRTMAX-9	56<span class="o">)</span> SIGRTMAX-8	57<span class="o">)</span> SIGRTMAX-7
58<span class="o">)</span> SIGRTMAX-6	59<span class="o">)</span> SIGRTMAX-5	60<span class="o">)</span> SIGRTMAX-4	61<span class="o">)</span> SIGRTMAX-3	62<span class="o">)</span> SIGRTMAX-2
63<span class="o">)</span> SIGRTMAX-1	64<span class="o">)</span> SIGRTMAX
</code></pre></div></div>

<!-- cSpell:enable -->

<p>Here are some important ones.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SIGHUP</code></li>
</ol>

<ul>
  <li>Default action: Terminate</li>
  <li>Possible actions: Terminate, Ignore, Function call</li>
  <li><code class="language-plaintext highlighter-rouge">SIGHUP</code> is sent by the UART driver to the entire session when a hangup condition has been
detected. Normally, this will kill all the processes. Some programs, such as <code class="language-plaintext highlighter-rouge">nohup</code> and <code class="language-plaintext highlighter-rouge">screen</code>,
detach from their session (and TTY), so that their child processes won’t notice a hangup.</li>
</ul>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SIGINT</code></li>
</ol>

<ul>
  <li>Default action: Terminate</li>
  <li>Possible actions: Terminate, Ignore, Function call</li>
  <li><code class="language-plaintext highlighter-rouge">SIGINT</code> is sent by the TTY driver to the current foreground job when the interactive attention
character (typically <kbd>^C</kbd>, which has ASCII code 3) appears in the input stream, unless
this behavior has been turned off. Anybody with access permissions to the TTY device can change
the interactive attention character and toggle this feature; additionally, the session manager
keeps track of the TTY configuration of each job, and updates the TTY whenever there is a job
switch.</li>
</ul>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SIGQUIT</code></li>
</ol>

<ul>
  <li>Default action: Core dump</li>
  <li>Possible actions: Core dump, Ignore, Function call</li>
  <li><code class="language-plaintext highlighter-rouge">SIGQUIT</code> works just like SIGINT, but the quit character is typically <kbd>^\\</kbd> and the
default action is different.</li>
</ul>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SIGPIPE</code></li>
</ol>

<ul>
  <li>Default action: Terminate</li>
  <li>Possible actions: Terminate, Ignore, Function call</li>
  <li>The kernel sends <code class="language-plaintext highlighter-rouge">SIGPIPE</code> to any process which tries to write to a pipe with no readers. This is
useful, because otherwise jobs like <code class="language-plaintext highlighter-rouge">yes | head</code> would never terminate.</li>
</ul>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SIGCHLD</code></li>
</ol>

<ul>
  <li>Default action: Ignore</li>
  <li>Possible actions: Ignore, Function call</li>
  <li>When a process dies or changes state (stop/continue), the kernel sends a <code class="language-plaintext highlighter-rouge">SIGCHLD</code> to its parent
process. The <code class="language-plaintext highlighter-rouge">SIGCHLD</code> signal carries additional information, namely the process id, the user id,
the exit status (or termination signal) of the terminated process and some execution time
statistics. The session leader (shell) keeps track of its jobs using this signal.</li>
</ul>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SIGSTOP</code></li>
</ol>

<ul>
  <li>Default action: Suspend</li>
  <li>Possible actions: Suspend</li>
  <li>This signal will unconditionally suspend the recipient, i.e. its signal action can’t be
reconfigured. Please note, however, that <code class="language-plaintext highlighter-rouge">SIGSTOP</code> isn’t sent by the kernel during job control.
Instead, <kbd>^Z</kbd> typically triggers a <code class="language-plaintext highlighter-rouge">SIGTSTP</code>, which can be intercepted by the
application. The application may then e.g. move the cursor to the bottom of the screen or
otherwise put the terminal in a known state, and subsequently put itself to sleep using <code class="language-plaintext highlighter-rouge">SIGSTOP</code>.</li>
</ul>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SIGCONT</code></li>
</ol>

<ul>
  <li>Default action: Wake up</li>
  <li>Possible actions: Wake up, Wake up + Function call</li>
  <li><code class="language-plaintext highlighter-rouge">SIGCONT</code> will un-suspend a stopped process. It is sent explicitly by the shell when the user
invokes the <code class="language-plaintext highlighter-rouge">fg</code> command. Since <code class="language-plaintext highlighter-rouge">SIGSTOP</code> can’t be intercepted by an application, an unexpected
<code class="language-plaintext highlighter-rouge">SIGCONT</code> signal might indicate that the process was suspended some time ago, and then
un-suspended.</li>
</ul>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SIGTSTP</code></li>
</ol>

<ul>
  <li>Default action: Suspend</li>
  <li>Possible actions: Suspend, Ignore, Function call</li>
  <li><code class="language-plaintext highlighter-rouge">SIGTSTP</code> works just like <code class="language-plaintext highlighter-rouge">SIGINT</code> and <code class="language-plaintext highlighter-rouge">SIGQUIT</code>, but the magic character is typically
<kbd>^Z</kbd> and the default action is to suspend the process.</li>
</ul>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SIGTTIN</code></li>
</ol>

<ul>
  <li>Default action: Suspend</li>
  <li>Possible actions: Suspend, Ignore, Function call</li>
  <li>If a process within a background job tries to read from a TTY device, the TTY sends a <code class="language-plaintext highlighter-rouge">SIGTTIN</code>
signal to the entire job. This will normally suspend the job.</li>
</ul>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SIGTTOU</code></li>
</ol>

<ul>
  <li>Default action: Suspend</li>
  <li>Possible actions: Suspend, Ignore, Function call</li>
  <li>If a process within a background job tries to write to a TTY device, the TTY sends a <code class="language-plaintext highlighter-rouge">SIGTTOU</code>
signal to the entire job. This will normally suspend the job. It is possible to turn off this
feature on a per-TTY basis.</li>
</ul>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SIGWINCH</code></li>
</ol>

<ul>
  <li>Default action: Ignore</li>
  <li>Possible actions: Ignore, Function call</li>
  <li>As mentioned, the TTY device keeps track of the terminal size, but this information needs to be
updated manually. Whenever that happens, the TTY device sends <code class="language-plaintext highlighter-rouge">SIGWINCH</code> to the foreground job.
Well-behaving interactive applications, such as editors, react upon this, fetch the new terminal
size from the TTY device and redraw themselves accordingly.</li>
</ul>

<h2 id="-sending-and-receiving-signals-in-rust">🦀 Sending and receiving signals in Rust</h2>
<p><a id="markdown-%F0%9F%A6%80-sending-and-receiving-signals-in-rust" name="%F0%9F%A6%80-sending-and-receiving-signals-in-rust"></a></p>

<table>
  <thead>
    <tr>
      <th>crate</th>
      <th>recv</th>
      <th>send</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="https://docs.rs/tokio/latest/tokio/signal">https://docs.rs/tokio/latest/tokio/signal</a></td>
      <td>🟢</td>
      <td>🔴</td>
    </tr>
    <tr>
      <td><a href="https://crates.io/crates/ctrlc">https://crates.io/crates/ctrlc</a></td>
      <td>🟢</td>
      <td>🔴</td>
    </tr>
    <tr>
      <td><a href="https://crates.io/crates/signal-hook">https://crates.io/crates/signal-hook</a></td>
      <td>🟢</td>
      <td>🟢 *</td>
    </tr>
    <tr>
      <td><a href="https://docs.rs/nix/latest/nix/">https://docs.rs/nix/latest/nix/</a></td>
      <td>🟢</td>
      <td>🟢</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>*: Via
<a href="https://docs.rs/signal-hook/latest/signal_hook/low_level/fn.raise.html"><code class="language-plaintext highlighter-rouge">signal_hook::low_level::raise</code></a>.</p>
</blockquote>

<h4 id="example-using-tokio-to-receive-signals">Example using tokio to receive signals</h4>
<p><a id="markdown-example-using-tokio-to-receive-signals" name="example-using-tokio-to-receive-signals"></a></p>

<p>Please watch the live coding <a href="#related-youtube-videos-for-this-article">videos</a> to get a
deep dive into what each line of code does.</p>

<p>Please clone this <a href="https://github.com/nazmulidris/rust-scratch">repo</a> to your computer to
play w/ the examples in the <a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/README.md"><code class="language-plaintext highlighter-rouge">rust-scratch/tty</code>
crate</a> shown below.</p>

<p><a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/src/receive_signal.rs"><code class="language-plaintext highlighter-rouge">receive_signal.rs</code></a>.
<code class="language-plaintext highlighter-rouge">tokio</code> has limited handling of signals. You can only receive certain signals, not send
them.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">miette</span><span class="p">::</span><span class="n">IntoDiagnostic</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">r3bl_rs_utils_core</span><span class="p">::</span><span class="n">ok</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">signal</span><span class="p">::</span><span class="n">unix</span><span class="p">;</span>

<span class="nd">#[tokio::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">signal</span> <span class="o">=</span> <span class="nn">unix</span><span class="p">::</span><span class="nn">SignalKind</span><span class="p">::</span><span class="nf">window_change</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">stream</span> <span class="o">=</span> <span class="nn">unix</span><span class="p">::</span><span class="nf">signal</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">tick_interval</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">interval</span><span class="p">(</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">500</span><span class="p">));</span>

    <span class="k">let</span> <span class="n">sleep_future</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nd">pin!</span><span class="p">(</span><span class="n">sleep_future</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">pid</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nf">id</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"PID: {}"</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>

    <span class="c1">// Copy child PID to clipboard.</span>
    <span class="c1">// Use `ClipboardProvider` trait.</span>
    <span class="k">use</span> <span class="nn">cli_clipboard</span><span class="p">::</span><span class="n">ClipboardProvider</span> <span class="k">as</span> <span class="n">_</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">ctx</span> <span class="o">=</span> <span class="nn">cli_clipboard</span><span class="p">::</span><span class="nn">ClipboardContext</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span>
        <span class="nf">.map_err</span><span class="p">(|</span><span class="n">e</span><span class="p">|</span> <span class="nn">miette</span><span class="p">::</span><span class="nd">miette!</span><span class="p">(</span>
            <span class="s">"couldn't create clip context: {}"</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
    <span class="n">ctx</span><span class="nf">.set_contents</span><span class="p">(</span><span class="n">pid</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.to_owned</span><span class="p">())</span>
        <span class="nf">.map_err</span><span class="p">(|</span><span class="n">e</span><span class="p">|</span> <span class="nn">miette</span><span class="p">::</span><span class="nd">miette!</span><span class="p">(</span>
            <span class="s">"couldn't set clip contents: {}"</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
    <span class="n">ctx</span><span class="nf">.get_contents</span><span class="p">()</span>
        <span class="nf">.map_err</span><span class="p">(|</span><span class="n">e</span><span class="p">|</span> <span class="nn">miette</span><span class="p">::</span><span class="nd">miette!</span><span class="p">(</span>
            <span class="s">"couldn't get clip contents: {}"</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span> <span class="p">{</span>
            <span class="c1">// Respond to window change signal.</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">stream</span><span class="nf">.recv</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">SIGWINCH received"</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// Sleep for 5 seconds &amp; terminate the program if running.</span>
            <span class="n">_</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">sleep_future</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Slept for 5 seconds"</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// Run at each tick interval.</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">tick_interval</span><span class="nf">.tick</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"Tick"</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="c1">// Respond to ctrl-c signal.</span>
            <span class="n">_</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">signal</span><span class="p">::</span><span class="nf">ctrl_c</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Ctrl-C received"</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">ok!</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here are some notes on the code:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">tokio::signal::ctrl_c</code> is a utility function that creates a future that completes
when <code class="language-plaintext highlighter-rouge">ctrl-c</code> is pressed. There is <strong>NO</strong> need to write a signal stream for this like
so:
    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">signal</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">signal</span><span class="p">::</span><span class="nn">unix</span><span class="p">::</span><span class="nn">SignalKind</span><span class="p">::</span><span class="nf">interrupt</span><span class="p">();</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">stream_sigterm</span> <span class="o">=</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nn">signal</span><span class="p">::</span><span class="nn">unix</span><span class="p">::</span><span class="nf">signal</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
<span class="k">loop</span> <span class="p">{</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span> <span class="p">{</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">stream_sigterm</span><span class="nf">.recv</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">SIGINT received"</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li><code class="language-plaintext highlighter-rouge">tokio::signal::unix::signal</code> is a lower level function that you can use to create a
stream of signals of a given type (e.g., <code class="language-plaintext highlighter-rouge">tokio::signal::unix::SignalKind</code>). Some
examples are:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">tokio::signal::unix::SignalKind::hangup</code></li>
      <li><code class="language-plaintext highlighter-rouge">tokio::signal::unix::SignalKind::interrupt</code></li>
      <li><code class="language-plaintext highlighter-rouge">tokio::signal::unix::SignalKind::pipe</code></li>
    </ul>
  </li>
  <li>There are limitations to what <code class="language-plaintext highlighter-rouge">tokio::signal::unix::SignalKind::from_raw</code> can do:
    <ul>
      <li>For example you can’t just pass in <code class="language-plaintext highlighter-rouge">SIGSTOP</code> ie <code class="language-plaintext highlighter-rouge">19</code> and expect it to work. This
is an <a href="https://docs.rs/signal-hook/latest/signal_hook/#limitations">OS
limitation</a> for both
<code class="language-plaintext highlighter-rouge">SIGKILL</code> or <code class="language-plaintext highlighter-rouge">SIGSTOP</code>.</li>
      <li>Here’s a list of POSIX signals that are
<a href="https://docs.rs/signal-hook/latest/signal_hook/low_level/fn.register.html#panics"><code class="language-plaintext highlighter-rouge">FORBIDDEN</code></a>
from the <code class="language-plaintext highlighter-rouge">signal_hook</code> crate.</li>
      <li>You can just pass the signal number directly to
<code class="language-plaintext highlighter-rouge">tokio::signal::unix::SignalKind::from_raw</code>.</li>
      <li>However, if you’re doing more sophisticated things you might need to use the
<a href="https://github.com/vorner/signal-hook">signal-hook</a> crate (which not only
supports sending and receiving signals, but also has async adapters for <code class="language-plaintext highlighter-rouge">tokio</code>).</li>
      <li>Here are relevant docs:
        <ul>
          <li><a href="https://docs.rs/tokio/latest/tokio/signal/index.html">tokio::signal</a></li>
          <li><a href="https://docs.rs/tokio/latest/tokio/signal/unix/fn.signal.html">tokio::signal::unix::signal</a></li>
          <li><a href="https://docs.rs/tokio/latest/tokio/signal/unix/struct.SignalKind.html">tokio::signal::unix::SignalKind</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>See it in action:</p>

<ul>
  <li>Run the binary: <code class="language-plaintext highlighter-rouge">cargo run --bin send_receive_signal</code></li>
  <li>Send signals to the process:
    <ul>
      <li>To get a list of all the signals that you can send to a process, you can run the
following command: <code class="language-plaintext highlighter-rouge">kill -L</code></li>
      <li>To send Ctrl+C, aka, <code class="language-plaintext highlighter-rouge">SIGINT</code>, aka <code class="language-plaintext highlighter-rouge">tokio::signal::unix::SignalKind::interrupt</code>, to
the process, you can run the following command: <code class="language-plaintext highlighter-rouge">kill -2 &lt;PID&gt;</code> or <code class="language-plaintext highlighter-rouge">kill -INT &lt;PID&gt;</code></li>
      <li>To send <code class="language-plaintext highlighter-rouge">SIGWINCH</code>, aka <code class="language-plaintext highlighter-rouge">tokio::signal::unix::SignalKind::window_change</code> to the
process, simply change the terminal window size of the terminal that the process is
running in. Or run the following command: <code class="language-plaintext highlighter-rouge">kill -28 &lt;PID&gt;</code> or <code class="language-plaintext highlighter-rouge">kill -WINCH &lt;PID&gt;</code></li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>Other crate choices to receive signals:</p>

  <ul>
    <li><a href="https://crates.io/crates/ctrlc"><code class="language-plaintext highlighter-rouge">ctrlc</code></a></li>
    <li><a href="https://crates.io/crates/signal-hook"><code class="language-plaintext highlighter-rouge">signal-hook</code></a></li>
  </ul>
</blockquote>

<h4 id="example-using-signal-hook-and-signal-hook-tokio">Example using signal-hook and signal-hook-tokio</h4>
<p><a id="markdown-example-using-signal-hook-and-signal-hook-tokio" name="example-using-signal-hook-and-signal-hook-tokio"></a></p>

<p>Please watch the live coding <a href="#related-youtube-videos-for-this-article">videos</a> to get a
deep dive into what each line of code does.</p>

<p>Please clone this <a href="https://github.com/nazmulidris/rust-scratch">repo</a> to your computer to
play w/ the examples in the <a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/README.md"><code class="language-plaintext highlighter-rouge">rust-scratch/tty</code>
crate</a> shown below.</p>

<p><a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/src/send_and_receive_signal.rs"><code class="language-plaintext highlighter-rouge">send_and_receive_signal.rs</code></a>
allows you to both send and receive signals in a process.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">futures</span><span class="p">::</span><span class="nn">stream</span><span class="p">::</span><span class="n">StreamExt</span> <span class="k">as</span> <span class="n">_</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">miette</span><span class="p">::</span><span class="n">IntoDiagnostic</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">r3bl_rs_utils_core</span><span class="p">::</span><span class="n">ok</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">signal_hook</span><span class="p">::</span><span class="nn">consts</span><span class="p">::</span><span class="nn">signal</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">signal_hook_tokio</span><span class="p">::</span><span class="n">Signals</span><span class="p">;</span>

<span class="nd">#[tokio::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">pid</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nf">id</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"PID: {}"</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>

    <span class="c1">// Broadcast channel to shutdown the process.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">sender_shutdown_channel</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">broadcast</span><span class="p">::</span><span class="nn">channel</span><span class="p">::</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="c1">// Register signal handlers.</span>
    <span class="k">let</span> <span class="n">signals_stream</span><span class="p">:</span> <span class="n">Signals</span> <span class="o">=</span>
        <span class="nn">Signals</span><span class="p">::</span><span class="nf">new</span><span class="p">([</span><span class="n">SIGHUP</span><span class="p">,</span> <span class="n">SIGTERM</span><span class="p">,</span> <span class="n">SIGINT</span><span class="p">,</span> <span class="n">SIGQUIT</span><span class="p">])</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">signals_handle</span> <span class="o">=</span> <span class="n">signals_stream</span><span class="nf">.handle</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">join_handle_monitor_signals_task</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span>
        <span class="nf">handle_signals_task</span><span class="p">(</span>
            <span class="n">signals_stream</span><span class="p">,</span>
            <span class="n">sender_shutdown_channel</span><span class="nf">.clone</span><span class="p">(),</span>
        <span class="p">));</span>

    <span class="nf">run_main_event_loop</span><span class="p">(</span><span class="n">sender_shutdown_channel</span><span class="nf">.clone</span><span class="p">())</span><span class="k">.await</span><span class="p">;</span>

    <span class="c1">// Cleanup tasks after shutdown.</span>
    <span class="n">signals_handle</span><span class="nf">.close</span><span class="p">();</span>
    <span class="n">join_handle_monitor_signals_task</span><span class="k">.await</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="nd">ok!</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">async</span> <span class="k">fn</span> <span class="nf">run_main_event_loop</span><span class="p">(</span>
    <span class="n">sender_shutdown_channel</span><span class="p">:</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">broadcast</span><span class="p">::</span><span class="n">Sender</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span>
    <span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">receiver_shutdown_channel</span> <span class="o">=</span>
        <span class="n">sender_shutdown_channel</span><span class="nf">.subscribe</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">tick_interval</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">interval</span><span class="p">(</span>
        <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">500</span><span class="p">));</span>

    <span class="c1">// Wait for 1 sec &amp; then send SIGTERM signal.</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span>
            <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="k">.await</span><span class="p">;</span>
        <span class="n">_</span> <span class="o">=</span> <span class="nn">signal_hook</span><span class="p">::</span><span class="nn">low_level</span><span class="p">::</span><span class="nf">raise</span><span class="p">(</span><span class="n">SIGTERM</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"🧨 Sent SIGTERM signal"</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span> <span class="p">{</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">tick_interval</span><span class="nf">.tick</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"Tick"</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">receiver_shutdown_channel</span><span class="nf">.recv</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"Received shutdown signal"</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">async</span> <span class="k">fn</span> <span class="nf">handle_signals_task</span><span class="p">(</span>
    <span class="k">mut</span> <span class="n">signals_stream</span><span class="p">:</span> <span class="n">Signals</span><span class="p">,</span>
    <span class="n">sender_shutdown_channel</span><span class="p">:</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">broadcast</span><span class="p">::</span><span class="n">Sender</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span> <span class="o">=</span> <span class="n">signals_stream</span><span class="nf">.next</span><span class="p">()</span><span class="k">.await</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">signal</span> <span class="p">{</span>
            <span class="n">SIGHUP</span> <span class="p">|</span> <span class="n">SIGTERM</span> <span class="p">|</span> <span class="n">SIGINT</span> <span class="p">|</span> <span class="n">SIGQUIT</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"📥 Received signal: {:?}"</span><span class="p">,</span> <span class="n">signal</span><span class="p">);</span>
                <span class="n">_</span> <span class="o">=</span> <span class="n">sender_shutdown_channel</span><span class="nf">.send</span><span class="p">(());</span>
            <span class="p">}</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">unreachable!</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notes on the code:</p>

<ul>
  <li>Example of how to send and receive Linux (POSIX, Unix) signals in a process
It uses the following crates to make this happen:
    <ul>
      <li><a href="https://docs.rs/signal-hook/">signal-hook</a></li>
      <li><a href="https://docs.rs/signal-hook-tokio/latest/signal_hook_tokio/">signal-hook-tokio</a></li>
    </ul>
  </li>
  <li>Signal handler registration limitations (to receive signals)
POSIX allows signal handlers to be overridden in a process. This is a powerful feature
that can be used to implement a wide variety of functionality.
    <ul>
      <li>However, there are
<a href="https://docs.rs/signal-hook/latest/signal_hook/#limitations">limitations</a> around
overriding signal handlers in a process. For example, POSIX compliant operating
systems will not allow you to override the
<a href="https://docs.rs/signal-hook/latest/signal_hook/consts/signal/constant.SIGKILL.html"><code class="language-plaintext highlighter-rouge">SIGKILL</code></a>
or
<a href="https://docs.rs/signal-hook/latest/signal_hook/consts/signal/constant.SIGSTOP.html"><code class="language-plaintext highlighter-rouge">SIGSTOP</code></a>
signals.</li>
      <li>Here’s a full list of
<a href="https://docs.rs/signal-hook/latest/signal_hook/low_level/fn.register.html#panics"><code class="language-plaintext highlighter-rouge">FORBIDDEN</code></a>
signals that will <code class="language-plaintext highlighter-rouge">panic</code> the <code class="language-plaintext highlighter-rouge">register</code> function, if used.</li>
    </ul>
  </li>
  <li>The following dependencies need to be added to the <code class="language-plaintext highlighter-rouge">Cargo.toml</code> file for this to work:
    <div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="py">signal-hook</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.3.17"</span> <span class="p">}</span>
<span class="py">signal-hook-tokio</span> <span class="o">=</span> <span class="p">{</span>
    <span class="py">version</span> <span class="p">=</span> <span class="s">"0.3.1"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"futures-v0_3"</span><span class="p">]</span> <span class="p">}</span>
<span class="py">futures</span> <span class="p">=</span> <span class="s">"0.3.30"</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>See it in action:</p>

<ul>
  <li>Run the binary: <code class="language-plaintext highlighter-rouge">cargo run --bin send_and_receive_signal</code></li>
</ul>

<h2 id="-process-spawning-in-rust">🦀 Process spawning in Rust</h2>
<p><a id="markdown-%F0%9F%A6%80-process-spawning-in-rust" name="%F0%9F%A6%80-process-spawning-in-rust"></a></p>

<p>Please watch the live coding <a href="#related-youtube-videos-for-this-article">videos</a> to get a
deep dive into what each line of code does.</p>

<p>Please clone this <a href="https://github.com/nazmulidris/rust-scratch">repo</a> to your computer to
play w/ the examples in the <a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/README.md"><code class="language-plaintext highlighter-rouge">rust-scratch/tty</code>
crate</a> shown below.</p>

<h4 id="example-using-procspawn-to-spawn-processes">Example using procspawn to spawn processes</h4>
<p><a id="markdown-example-using-procspawn-to-spawn-processes" name="example-using-procspawn-to-spawn-processes"></a></p>

<p><a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/src/procspawn.rs"><code class="language-plaintext highlighter-rouge">procspawn.rs</code></a>
can be used to spawn child processes in Rust with great flexibility and control.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">miette</span><span class="p">::</span><span class="n">IntoDiagnostic</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">r3bl_rs_utils_core</span><span class="p">::</span><span class="n">ok</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// A spawned process will execute every line of code up to here.</span>
    <span class="nn">procspawn</span><span class="p">::</span><span class="nf">init</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">pid_parent</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nf">id</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">args</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i64</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">sum</span><span class="p">,</span> <span class="n">pid_child</span><span class="p">,</span> <span class="n">pid_child_from_clip</span><span class="p">)</span> <span class="o">=</span> <span class="nf">configure_builder</span><span class="p">()</span>
        <span class="nf">.spawn</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">run_in_child_process</span><span class="p">)</span>
        <span class="nf">.join</span><span class="p">()</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"Parent PID: {}"</span><span class="p">,</span> <span class="n">pid_parent</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"Child PID: {}, sum: {}, pid from clip: {}"</span><span class="p">,</span>
        <span class="n">pid_child</span><span class="p">,</span> <span class="n">sum</span><span class="p">,</span> <span class="n">pid_child_from_clip</span>
    <span class="p">);</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">sum</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">pid_child</span><span class="p">,</span> <span class="n">pid_child_from_clip</span><span class="p">);</span>

    <span class="nd">ok!</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// Create a new builder with stderr &amp; stdout that's null.</span>
<span class="k">fn</span> <span class="nf">configure_builder</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">procspawn</span><span class="p">::</span><span class="n">Builder</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">it</span> <span class="o">=</span> <span class="nn">procspawn</span><span class="p">::</span><span class="nn">Builder</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="n">it</span><span class="nf">.stderr</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">null</span><span class="p">());</span> <span class="c1">// Suppress stderr.</span>
    <span class="n">it</span><span class="nf">.stdout</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">null</span><span class="p">());</span> <span class="c1">// Suppress stdout.</span>
    <span class="n">it</span>
<span class="p">}</span>

<span class="c1">// This function will be executed in a child process.</span>
<span class="k">fn</span> <span class="nf">run_in_child_process</span><span class="p">(</span>
    <span class="cm">/* serde */</span> <span class="n">param</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i64</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">result</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span>
    <span class="cm">/* serde - Ok variant */</span>
    <span class="p">(</span>
        <span class="cm">/* sum */</span> <span class="nb">i64</span><span class="p">,</span>
        <span class="cm">/* pid */</span> <span class="nb">String</span><span class="p">,</span>
        <span class="cm">/* pid from clip */</span> <span class="nb">String</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="cm">/* serde - Err variant */</span>
    <span class="n">ClipboardError</span><span class="p">,</span>
<span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">pid_child</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nf">id</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">param</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.sum</span><span class="p">();</span>

    <span class="c1">// Copy child pid to the clipboard.</span>
    <span class="c1">// Import `ClipboardProvider` trait.</span>
    <span class="k">use</span> <span class="nn">cli_clipboard</span><span class="p">::</span><span class="n">ClipboardProvider</span> <span class="k">as</span> <span class="n">_</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">ctx</span> <span class="o">=</span> <span class="nn">cli_clipboard</span><span class="p">::</span><span class="nn">ClipboardContext</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span>
        <span class="nf">.map_err</span><span class="p">(|</span><span class="n">_</span><span class="p">|</span> <span class="nn">ClipboardError</span><span class="p">::</span><span class="n">ContextUnavailable</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="n">ctx</span><span class="nf">.set_contents</span><span class="p">(</span><span class="n">pid_child</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.to_owned</span><span class="p">())</span>
        <span class="nf">.map_err</span><span class="p">(|</span><span class="n">_</span><span class="p">|</span> <span class="nn">ClipboardError</span><span class="p">::</span><span class="n">SetContents</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">pid_child_from_clip</span> <span class="o">=</span> <span class="n">ctx</span>
        <span class="nf">.get_contents</span><span class="p">()</span>
        <span class="nf">.map_err</span><span class="p">(|</span><span class="n">_</span><span class="p">|</span> <span class="nn">ClipboardError</span><span class="p">::</span><span class="n">GetContents</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">((</span><span class="n">sum</span><span class="p">,</span> <span class="n">pid_child</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="n">pid_child_from_clip</span><span class="p">))</span>
<span class="p">}</span>

<span class="nd">#[derive(</span>
    <span class="nd">Debug,</span> <span class="nd">serde::Deserialize,</span> <span class="nd">serde::Serialize,</span> <span class="nd">thiserror::Error</span>
<span class="nd">)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">ClipboardError</span> <span class="p">{</span>
    <span class="nd">#[error(</span><span class="s">"clipboard context unavailable"</span><span class="nd">)]</span>
    <span class="n">ContextUnavailable</span><span class="p">,</span>

    <span class="nd">#[error(</span><span class="s">"could not get clipboard contents"</span><span class="nd">)]</span>
    <span class="n">GetContents</span><span class="p">,</span>

    <span class="nd">#[error(</span><span class="s">"could not set clipboard contents"</span><span class="nd">)]</span>
    <span class="n">SetContents</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notes on the code:</p>

<ul>
  <li>The <a href="https://docs.rs/procspawn/latest/procspawn/"><code class="language-plaintext highlighter-rouge">procspawn</code></a> crate provides the
ability to spawn processes with a function similar to <code class="language-plaintext highlighter-rouge">thread::spawn</code>.</li>
  <li>Unlike <code class="language-plaintext highlighter-rouge">thread::spawn</code> data cannot be passed by the use of closures.</li>
  <li>Instead if must be explicitly passed as serializable object (specifically it must be
<code class="language-plaintext highlighter-rouge">serde</code> serializable). Internally, the data is serialized using
<a href="https://docs.rs/procspawn/latest/procspawn/#bincode-limitations"><code class="language-plaintext highlighter-rouge">bincode</code></a>.</li>
  <li>The return value from the spawned closure also must be serializable and can then be
retrieved from the returned join handle.</li>
  <li>If the spawned function causes a panic it will also be serialized across the process
boundaries.</li>
  <li>Great <a href="https://github.com/mitsuhiko/procspawn/tree/master/examples">examples</a> from the
official docs.</li>
</ul>

<p>See it in action:</p>

<ul>
  <li>Run the binary: <code class="language-plaintext highlighter-rouge">cargo run --bin procspawn</code></li>
</ul>

<h4 id="example-using-procspawn-to-spawn-processes-w-ipc-channel">Example using procspawn to spawn processes w/ ipc-channel</h4>
<p><a id="markdown-example-using-procspawn-to-spawn-processes-w%2F-ipc-channel" name="example-using-procspawn-to-spawn-processes-w%2F-ipc-channel"></a></p>

<p><a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/src/procspawn_ipc_channel.rs"><code class="language-plaintext highlighter-rouge">procspawn_ipc_channel.rs</code></a>
can be used to manage complex IPC communication between parent and child processes.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">miette</span><span class="p">::</span><span class="n">IntoDiagnostic</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">r3bl_rs_utils_core</span><span class="p">::</span><span class="n">ok</span><span class="p">;</span>

<span class="k">type</span> <span class="n">Message</span> <span class="o">=</span> <span class="nb">String</span><span class="p">;</span>

<span class="k">const</span> <span class="n">MSG_1</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="p">;</span>
<span class="k">const</span> <span class="n">MSG_2</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">"World"</span><span class="p">;</span>
<span class="k">const</span> <span class="n">END_MSG</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">"END"</span><span class="p">;</span>
<span class="k">const</span> <span class="n">SHUTDOWN_MSG</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">"SHUTDOWN"</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// A spawned process will execute every line of code up to here.</span>
    <span class="nn">procspawn</span><span class="p">::</span><span class="nf">init</span><span class="p">();</span>

    <span class="c1">// Create a channel to send messages across processes.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">receiver</span><span class="p">)</span> <span class="o">=</span> <span class="nn">ipc_channel</span><span class="p">::</span><span class="nn">ipc</span><span class="p">::</span><span class="nn">channel</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span><span class="p">()</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Spawn a child process that will receive messages from the</span>
    <span class="c1">// parent process.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">join_handle</span> <span class="o">=</span> <span class="nf">configure_builder</span><span class="p">()</span><span class="nf">.spawn</span><span class="p">(</span>
        <span class="cm">/* arg from parent process */</span> <span class="n">receiver</span><span class="p">,</span>
        <span class="cm">/* param to child process; closure runs in child process */</span>
        <span class="n">run_in_child_process</span><span class="p">,</span>
    <span class="p">);</span>

    <span class="nf">parent_send_messages</span><span class="p">(</span><span class="n">sender</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Read the stdout, until EOF, of the child process into `buf`.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">buf</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="c1">// Import `Read` trait for `read_to_string`.</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="n">Read</span> <span class="k">as</span> <span class="n">_</span><span class="p">;</span>
    <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">stdout</span><span class="p">)</span> <span class="o">=</span> <span class="n">join_handle</span><span class="nf">.stdout</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nn">miette</span><span class="p">::</span><span class="nd">bail!</span><span class="p">(</span><span class="s">"Failed to get stdout"</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="k">let</span> <span class="n">bytes_read</span> <span class="o">=</span> <span class="n">stdout</span><span class="nf">.read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">buf</span><span class="p">)</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"Output from child process: {:?}, bytes_read: {}"</span><span class="p">,</span>
        <span class="n">buf</span><span class="p">,</span> <span class="n">bytes_read</span>
    <span class="p">);</span>

    <span class="c1">// Make assertions.</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{MSG_1}</span><span class="se">\n</span><span class="s">{MSG_2}</span><span class="se">\n</span><span class="s">{END_MSG}</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>

    <span class="c1">// Wait for the child process to exit and get its return value.</span>
    <span class="n">join_handle</span><span class="nf">.join</span><span class="p">()</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="nd">ok!</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">parent_send_messages</span><span class="p">(</span>
    <span class="n">sender</span><span class="p">:</span> <span class="nn">ipc_channel</span><span class="p">::</span><span class="nn">ipc</span><span class="p">::</span><span class="n">IpcSender</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="n">sender</span><span class="nf">.send</span><span class="p">(</span><span class="n">MSG_1</span><span class="nf">.to_string</span><span class="p">())</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="n">sender</span><span class="nf">.send</span><span class="p">(</span><span class="n">MSG_2</span><span class="nf">.to_string</span><span class="p">())</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="n">sender</span><span class="nf">.send</span><span class="p">(</span><span class="n">SHUTDOWN_MSG</span><span class="nf">.to_string</span><span class="p">())</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="nd">ok!</span><span class="p">()</span>
<span class="p">}</span>

<span class="cd">/// This function will be executed in the child process. It gets</span>
<span class="cd">/// [Message]s from the parent process and processes them.</span>
<span class="k">fn</span> <span class="nf">run_in_child_process</span><span class="p">(</span>
    <span class="n">receiver</span><span class="p">:</span> <span class="nn">ipc_channel</span><span class="p">::</span><span class="nn">ipc</span><span class="p">::</span><span class="n">IpcReceiver</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="k">let</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">=</span> <span class="n">receiver</span><span class="nf">.recv</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">msg</span> <span class="o">==</span> <span class="n">SHUTDOWN_MSG</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// Print the message to stdout.</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Print `END_MSG` to stdout.</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{END_MSG}"</span><span class="p">);</span>
<span class="p">}</span>

<span class="cd">/// Create a new builder with stdout piped and stderr muted.</span>
<span class="k">fn</span> <span class="nf">configure_builder</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">procspawn</span><span class="p">::</span><span class="n">Builder</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">it</span> <span class="o">=</span> <span class="nn">procspawn</span><span class="p">::</span><span class="nn">Builder</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="n">it</span><span class="nf">.stdout</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">piped</span><span class="p">());</span>
    <span class="n">it</span><span class="nf">.stderr</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">null</span><span class="p">());</span>
    <span class="n">it</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notes on the code:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ipc_channel::ipc::channel</code> is used to send messages across processes via IPC. These
messages must be serializable.</li>
  <li>The parent process sends messages to the child process. This happens over an
ipc_channel sender.</li>
  <li>The child process receives messages from the parent process. This happens over an
ipc_channel receiver. The receiver is passed across process boundaries from
the parent to the child process.</li>
</ul>

<p>See it in action:</p>

<ul>
  <li>Run the binary: <code class="language-plaintext highlighter-rouge">cargo run --bin procspawn_ipc_channel</code></li>
</ul>

<blockquote>
  <p>Here’s the <a href="https://crates.io/crates/procspawn"><code class="language-plaintext highlighter-rouge">procspawn</code> crate</a> that we can use for this.</p>
</blockquote>

<h2 id="-run-tokioprocesscommand-in-async-rust">🦀 Run tokio:process::Command in async Rust</h2>
<p><a id="markdown-%F0%9F%A6%80-run-tokio%3Aprocess%3A%3Acommand-in-async-rust" name="%F0%9F%A6%80-run-tokio%3Aprocess%3A%3Acommand-in-async-rust"></a></p>

<p>Please watch the live coding <a href="#related-youtube-videos-for-this-article">videos</a> to get a
deep dive into what each line of code does.</p>

<blockquote>
  <p>In <code class="language-plaintext highlighter-rouge">tokio</code> a good place to start is
<a href="https://docs.rs/tokio/latest/tokio/process/index.html"><code class="language-plaintext highlighter-rouge">tokio::process</code></a> which mimics
the <code class="language-plaintext highlighter-rouge">std::process</code> module.</p>
</blockquote>

<h3 id="example-running-echo-process-programmatically">Example running echo process programmatically</h3>
<p><a id="markdown-example-running-echo-process-programmatically" name="example-running-echo-process-programmatically"></a></p>

<p>Please clone this <a href="https://github.com/nazmulidris/rust-scratch">repo</a> to your computer to
play w/ the examples in the <a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/README.md"><code class="language-plaintext highlighter-rouge">rust-scratch/tty</code>
crate</a> shown below.</p>

<p><a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/src/async_command_exec_1.rs"><code class="language-plaintext highlighter-rouge">async_command_exec_1.rs</code></a></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">crossterm</span><span class="p">::</span><span class="nn">style</span><span class="p">::</span><span class="n">Stylize</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">miette</span><span class="p">::</span><span class="n">IntoDiagnostic</span><span class="p">;</span>

<span class="nd">#[tokio::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">run_command_no_capture</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">run_command_capture_output</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="c1">// - Run `echo hello world` and wait for it to complete.</span>
<span class="c1">// - Do not capture the output or provide the input.</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">run_command_no_capture</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"run_command_no_capture"</span><span class="nf">.blue</span><span class="p">());</span>

    <span class="c1">// Without redirection, the output of the command will be</span>
    <span class="c1">// inherited from the process that starts the command. So</span>
    <span class="c1">// if this is running in a terminal, the output will be</span>
    <span class="c1">// printed to the terminal.</span>
    <span class="c1">//</span>
    <span class="c1">// Even though `spawn()` is called this child / command</span>
    <span class="c1">// doesn't make any progress until you call `wait().await`.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">command</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">command</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Command</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"echo"</span><span class="p">);</span>
        <span class="n">command</span>
            <span class="nf">.args</span><span class="p">([</span><span class="s">"hello"</span><span class="p">,</span> <span class="s">"world"</span><span class="p">])</span>
            <span class="nf">.stdin</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">inherit</span><span class="p">())</span>
            <span class="nf">.stdout</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">inherit</span><span class="p">())</span>
            <span class="nf">.stderr</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">inherit</span><span class="p">());</span>
        <span class="n">command</span>
    <span class="p">};</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">child</span> <span class="o">=</span> <span class="n">command</span><span class="nf">.spawn</span><span class="p">()</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Wait for the command to complete. Don't capture the output,</span>
    <span class="c1">// it will go to `stdout` of the process running this program.</span>
    <span class="k">let</span> <span class="n">exit_status</span> <span class="o">=</span> <span class="n">child</span><span class="nf">.wait</span><span class="p">()</span><span class="k">.await</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="n">exit_status</span><span class="nf">.success</span><span class="p">());</span>

    <span class="c1">// Print the exit status of the command.</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"exit status: {}"</span><span class="p">,</span> <span class="n">exit_status</span><span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="c1">// - Run `echo hello world` and wait for it to complete.</span>
<span class="c1">// - Capture its output and do not provide the input.</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">run_command_capture_output</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"run_command_capture_output"</span><span class="nf">.blue</span><span class="p">());</span>

    <span class="c1">// Redirect the output of the command to a pipe `Stdio::piped()`.</span>
    <span class="c1">//</span>
    <span class="c1">// Even though `spawn()` is called this child / command doesn't</span>
    <span class="c1">// make any progress until you call `wait_with_out().await`.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">command</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">command</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Command</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"echo"</span><span class="p">);</span>
        <span class="n">command</span>
            <span class="nf">.args</span><span class="p">([</span><span class="s">"hello"</span><span class="p">,</span> <span class="s">"world"</span><span class="p">])</span>
            <span class="nf">.stdin</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">null</span><span class="p">())</span>
            <span class="nf">.stdout</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">piped</span><span class="p">())</span>
            <span class="nf">.stderr</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">null</span><span class="p">());</span>
        <span class="n">command</span>
    <span class="p">};</span>
    <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="n">command</span><span class="nf">.spawn</span><span class="p">()</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Wait for the command to complete and capture the output.</span>
    <span class="c1">// - Calling `wait()` consumes the child process, so we can't</span>
    <span class="c1">//   call `output.stdout` on it after this.</span>
    <span class="c1">// - That's why we use `wait_with_output()`, which actually</span>
    <span class="c1">//   returns a different type than `wait()`; this is also a</span>
    <span class="c1">//   great use of type state pattern.</span>
    <span class="k">let</span> <span class="n">output</span> <span class="o">=</span> <span class="n">child</span><span class="nf">.wait_with_output</span><span class="p">()</span><span class="k">.await</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="nd">assert!</span><span class="p">(</span><span class="n">output</span><span class="py">.status</span><span class="nf">.success</span><span class="p">());</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">output</span><span class="py">.stdout</span><span class="p">,</span> <span class="s">b"hello world</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notes on the code:</p>

<ul>
  <li>Run a command and wait for it to complete. Do not capture the output or provide the
input.</li>
  <li>Run a command and capture the output. Do not provide the input. This example uses the
<a href="https://docs.rs/tokio/latest/tokio/process/index.html"><code class="language-plaintext highlighter-rouge">tokio::process::Command</code></a>
struct to execute a command asynchronously.</li>
  <li>In both cases, the pattern is the same:
    <ol>
      <li>Create a <code class="language-plaintext highlighter-rouge">tokio::process::Command</code>.</li>
      <li>Configure it with the desired <code class="language-plaintext highlighter-rouge">stdin</code> and <code class="language-plaintext highlighter-rouge">stdout</code>.</li>
      <li>Spawn the command. Note this doesn’t make any progress until you call
<code class="language-plaintext highlighter-rouge">wait().await</code> or <code class="language-plaintext highlighter-rouge">wait_with_output().await</code>.</li>
      <li>Wait for the command to complete with or without output capture.</li>
    </ol>
  </li>
</ul>

<p>See it in action:</p>

<ul>
  <li>Run the binary: <code class="language-plaintext highlighter-rouge">cargo run --bin async_command_exec_1</code></li>
  <li>You should see something like the following in your terminal
    <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hello world
exit status: exit status: 0
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="example-piping-input-to-cat-process-programmatically">Example piping input to cat process programmatically</h3>
<p><a id="markdown-example-piping-input-to-cat-process-programmatically" name="example-piping-input-to-cat-process-programmatically"></a></p>

<p>Please clone this <a href="https://github.com/nazmulidris/rust-scratch">repo</a> to your computer to
play w/ the examples in the <a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/README.md"><code class="language-plaintext highlighter-rouge">rust-scratch/tty</code>
crate</a> shown below.</p>

<p><a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/src/async_command_exec_2.rs"><code class="language-plaintext highlighter-rouge">async_command_exec_2.rs</code></a></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">crossterm</span><span class="p">::</span><span class="nn">style</span><span class="p">::</span><span class="n">Stylize</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">miette</span><span class="p">::</span><span class="n">IntoDiagnostic</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">r3bl_rs_utils_core</span><span class="p">::</span><span class="n">ok</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="n">Stdio</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">io</span><span class="p">::{</span><span class="n">AsyncBufReadExt</span><span class="p">,</span> <span class="n">BufReader</span><span class="p">};</span>

<span class="cd">/// This variant requires the use of `tokio::spawn` to wait for the</span>
<span class="cd">/// child process to complete.</span>
<span class="nd">#[tokio::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Create a child process that runs `cat`.</span>
    <span class="c1">// - Send the output of `cat` back to this child process.</span>
    <span class="c1">// - This child / command does not make progress until</span>
    <span class="c1">//   `wait().await` is called.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">child</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Command</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"cat"</span><span class="p">)</span>
        <span class="nf">.stdin</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">inherit</span><span class="p">())</span>
        <span class="nf">.stdout</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">piped</span><span class="p">())</span>
        <span class="nf">.stderr</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">inherit</span><span class="p">())</span>
        <span class="nf">.spawn</span><span class="p">()</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Get the stdout of the child process. Do this before the next</span>
    <span class="c1">// step, because the `child` struct is moved into the closure.</span>
    <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">child_stdout</span><span class="p">)</span> <span class="o">=</span> <span class="n">child</span><span class="py">.stdout</span><span class="nf">.take</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nn">miette</span><span class="p">::</span><span class="nd">bail!</span><span class="p">(</span><span class="s">"Failed to capture stdout of child process"</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="c1">// 🚀 Ensure the child process is spawned in the runtime, so it</span>
    <span class="c1">// can make progress on its own while we await any output.</span>
    <span class="k">let</span> <span class="n">child_task_join_handle</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">result_exit_status</span> <span class="o">=</span> <span class="n">child</span><span class="nf">.wait</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>
        <span class="nd">println!</span><span class="p">(</span>
            <span class="s">"{}"</span><span class="p">,</span>
            <span class="nd">format!</span><span class="p">(</span>
                <span class="s">"Child process exited with status: {:?}"</span><span class="p">,</span>
                <span class="n">result_exit_status</span>
            <span class="p">)</span><span class="nf">.green</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">});</span>

    <span class="c1">// As long as there is a line to be read from the child process,</span>
    <span class="c1">// print it to the terminal.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">child_stdout_reader</span> <span class="o">=</span> <span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">child_stdout</span><span class="p">)</span><span class="nf">.lines</span><span class="p">();</span>
    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">=</span> <span class="n">child_stdout_reader</span>
        <span class="nf">.next_line</span><span class="p">()</span><span class="k">.await</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span>
    <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"❯ {}"</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span><span class="nf">.cyan</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="c1">// Wait for the child task to complete.</span>
    <span class="n">child_task_join_handle</span><span class="k">.await</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="nd">ok!</span><span class="p">()</span>
<span class="p">}</span>

<span class="cd">/// This is a simpler version of the `main` function above. It</span>
<span class="cd">/// doesn't need to use `tokio::spawn` to wait for the child</span>
<span class="cd">/// process to complete.</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main_simpler</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Create a child process that runs `cat`.</span>
    <span class="c1">// - Send the output of `cat` back to this child process.</span>
    <span class="c1">// - This child / command does not make progress until</span>
    <span class="c1">//   `wait().await` is called.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">child</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Command</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"cat"</span><span class="p">)</span>
        <span class="nf">.stdin</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">inherit</span><span class="p">())</span>
        <span class="nf">.stdout</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">piped</span><span class="p">())</span>
        <span class="nf">.stderr</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">inherit</span><span class="p">())</span>
        <span class="nf">.spawn</span><span class="p">()</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Get the stdout of the child process. Do this before the next</span>
    <span class="c1">// step, because the `child` struct is moved into the closure.</span>
    <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">child_stdout</span><span class="p">)</span> <span class="o">=</span> <span class="n">child</span><span class="py">.stdout</span><span class="nf">.take</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nn">miette</span><span class="p">::</span><span class="nd">bail!</span><span class="p">(</span><span class="s">"Failed to capture stdout of child process"</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="c1">// As long as there is a line to be read from the child process,</span>
    <span class="c1">// print it to the terminal.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">child_stdout_reader</span> <span class="o">=</span> <span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">child_stdout</span><span class="p">)</span><span class="nf">.lines</span><span class="p">();</span>
    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">=</span> <span class="n">child_stdout_reader</span>
        <span class="nf">.next_line</span><span class="p">()</span><span class="k">.await</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span>
    <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"❯ {}"</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span><span class="nf">.cyan</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="c1">// Simultaneously waits for the child to exit and collect all</span>
    <span class="c1">// remaining output on the stdout/stderr handles, returning an</span>
    <span class="c1">// Output instance.</span>
    <span class="k">let</span> <span class="n">output</span> <span class="o">=</span> <span class="n">child</span><span class="nf">.wait_with_output</span><span class="p">()</span><span class="k">.await</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"{}"</span><span class="p">,</span>
        <span class="nd">format!</span><span class="p">(</span>
            <span class="s">"Child process exited with status: {:?}"</span><span class="p">,</span> <span class="n">output</span><span class="py">.status</span>
        <span class="p">)</span><span class="nf">.green</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="nd">ok!</span><span class="p">()</span>
<span class="p">}</span>

<span class="cd">/// The nature of this function is different to the 2 above. For eg,</span>
<span class="cd">/// if you run this function in a terminal, you have to terminate</span>
<span class="cd">/// the input using `Ctrl-D` (EOF) if you want to see anything</span>
<span class="cd">/// displayed in the terminal output. In the two variants above,</span>
<span class="cd">/// output is captured in an "interactive" manner, as it comes</span>
<span class="cd">///  in from the stdin.</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main_non_interactive</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Create a child process that runs `cat`.</span>
    <span class="c1">// - Send the output of `cat` back to this child process.</span>
    <span class="c1">// - This child / command does not make progress until</span>
    <span class="c1">// `wait().await` is called.</span>
    <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Command</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"cat"</span><span class="p">)</span>
        <span class="nf">.stdin</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">inherit</span><span class="p">())</span>
        <span class="nf">.stdout</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">piped</span><span class="p">())</span>
        <span class="nf">.stderr</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">inherit</span><span class="p">())</span>
        <span class="nf">.spawn</span><span class="p">()</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Simultaneously waits for the child to exit and collect</span>
    <span class="c1">// all remaining output on the stdout/stderr handles,</span>
    <span class="c1">// returning an Output instance.</span>
    <span class="k">let</span> <span class="n">output</span> <span class="o">=</span> <span class="n">child</span><span class="nf">.wait_with_output</span><span class="p">()</span><span class="k">.await</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"{}"</span><span class="p">,</span>
        <span class="nd">format!</span><span class="p">(</span>
            <span class="s">"Child process exited with status: {:?}"</span><span class="p">,</span> <span class="n">output</span><span class="py">.status</span>
        <span class="p">)</span><span class="nf">.green</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="c1">// Print the output.stdout to terminal.</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_lossy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">output</span><span class="py">.stdout</span><span class="p">));</span>

    <span class="nd">ok!</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notes on the code:</p>

<ul>
  <li>This example uses the
<a href="https://docs.rs/tokio/latest/tokio/process/index.html"><code class="language-plaintext highlighter-rouge">tokio::process::Command</code></a>
struct to execute a command asynchronously, and then pipes the output of this command,
back to itself. Then prints the output one line at a time.</li>
  <li>To run this program, pipe some input (from the shell) into this program.
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"hello world</span><span class="se">\n</span><span class="s2">foo</span><span class="se">\n</span><span class="s2">bar</span><span class="se">\n</span><span class="s2">"</span> <span class="se">\</span>
  | cargo run <span class="nt">--bin</span> async_command_exec_2
</code></pre></div>    </div>
  </li>
  <li>This process will then run <code class="language-plaintext highlighter-rouge">cat</code> and capture the output from <code class="language-plaintext highlighter-rouge">cat</code>.</li>
  <li>It will then print the output from <code class="language-plaintext highlighter-rouge">cat</code> one line at time to the terminal.</li>
  <li>Flow diagram of the program:
    <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Terminal emulator running fish/bash shell
┌────────────────────────────────────────────────────────────────┐
│&gt; echo -e "foo\nbar\nbaz" | cargo run --bin async_command_exec_2│
└──────▲─────────────────────▲───────────────────────────────────┘
        │                     │        Pipeline above runs
        │                     │        in parallel
   external                 external
   process                  process
   command (fork &amp; exec)    command (fork &amp; exec)
                              │
                              ├────► create async Command for `cat`
                              │      with stdout = `Stdio::piped()`
                              │      to capture the output of `cmd`
                              │      back into this program
                              │
                              ├────► the stdin for this Command is
                              │      inherited from the current
                              │      process which is provided by
                              │      process the terminal &amp; `pipe`
                              │
                              ├────► `cmd.spawn()` then sets up the
                              │      `cat` process to run with the
                              │      given stdin &amp; stdout and
                              │      returns a `Child` struct
                              │
                              ├────► 🚀 instead of waiting
                              │      "normally", we must use
                              │      `tokio::spawn` to call
                              │      `child.wait().await` on the
                              │      child so it can make progress
                              │      while we wait for its output
                              │      below (in the current task)
                              │
                              └────► in our current task, we can
                                     now access `stdout` WHILE the
                                     child task is making progress
                                     above
</code></pre></div>    </div>
  </li>
  <li>How to kill child process:
    <ul>
      <li>Note that similar to the behavior to the standard library, and unlike the futures
paradigm of dropping-implies-cancellation, a spawned process will, by default,
continue to execute even after the <code class="language-plaintext highlighter-rouge">tokio::process::Child</code> handle has been dropped.
More info in the
<a href="https://docs.rs/tokio/latest/tokio/process/index.html#caveats">docs</a>. To change this
behavior you can use <code class="language-plaintext highlighter-rouge">tokio::process::Command::kill_on_drop</code> which isn’t really
recommended.</li>
      <li>Instead, to kill a child process, you can do the following:
        <ul>
          <li><code class="language-plaintext highlighter-rouge">tokio::process::Child::kill</code> - This forces the child process to exit.</li>
          <li><code class="language-plaintext highlighter-rouge">tokio::process::Child::wait</code> - This waits for the child process to cleanly exit.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>See it in action:</p>

<ul>
  <li>Run the binary: <code class="language-plaintext highlighter-rouge">echo -e "foo\nbar\nbaz" | cargo run --bin async_command_exec_2</code></li>
  <li>Or run the binary: <code class="language-plaintext highlighter-rouge">cargo run --bin async_command_exec_2</code> and then type some input
into the terminal and then press <code class="language-plaintext highlighter-rouge">Ctrl-D</code> to terminate the input.</li>
</ul>

<h3 id="example-programmatically-providing-input-into-stdin-and-getting-output-from-stdout-of-a-process">Example programmatically providing input into stdin and getting output from stdout of a process</h3>
<p><a id="markdown-example-programmatically-providing-input-into-stdin-and-getting-output-from-stdout-of-a-process" name="example-programmatically-providing-input-into-stdin-and-getting-output-from-stdout-of-a-process"></a></p>

<p>Please clone this <a href="https://github.com/nazmulidris/rust-scratch">repo</a> to your computer to
play w/ the examples in the <a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/README.md"><code class="language-plaintext highlighter-rouge">rust-scratch/tty</code>
crate</a> shown below.</p>

<p><a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/src/async_command_exec_3.rs"><code class="language-plaintext highlighter-rouge">async_command_exec_3.rs</code></a></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">crossterm</span><span class="p">::</span><span class="nn">style</span><span class="p">::</span><span class="n">Stylize</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">miette</span><span class="p">::</span><span class="n">IntoDiagnostic</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">r3bl_rs_utils_core</span><span class="p">::</span><span class="n">ok</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="n">Stdio</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">tokio</span><span class="p">::{</span>
    <span class="nn">io</span><span class="p">::{</span><span class="n">AsyncBufReadExt</span><span class="p">,</span> <span class="n">AsyncWriteExt</span><span class="p">,</span> <span class="n">BufReader</span><span class="p">},</span>
    <span class="nn">process</span><span class="p">::{</span><span class="n">Child</span><span class="p">,</span> <span class="n">ChildStdin</span><span class="p">,</span> <span class="n">ChildStdout</span><span class="p">},</span>
    <span class="nn">task</span><span class="p">::</span><span class="n">JoinHandle</span><span class="p">,</span>
<span class="p">};</span>

<span class="nd">#[tokio::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Create a child process that runs `cat`.</span>
    <span class="c1">// 1. Send the output of `cat` back to this child process.</span>
    <span class="c1">// 2. Send the input to `cat` from this child process.</span>
    <span class="c1">// 3. This child / command does not make progress until</span>
    <span class="c1">//    `wait().await` is called.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">child</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Command</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"cat"</span><span class="p">)</span>
        <span class="nf">.stdin</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">piped</span><span class="p">())</span>
        <span class="nf">.stdout</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">piped</span><span class="p">())</span>
        <span class="nf">.stderr</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">null</span><span class="p">())</span>
        <span class="nf">.spawn</span><span class="p">()</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// These are the bytes that will be sent to the `stdin` of the</span>
    <span class="c1">// child process.</span>
    <span class="k">let</span> <span class="n">input</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"hello"</span><span class="p">,</span> <span class="s">"nadia!"</span><span class="p">];</span>

    <span class="c1">// Get the stdout &amp; stdin of the child process. Do this before</span>
    <span class="c1">// the next step, because the `child` struct is moved into</span>
    <span class="c1">// the closure.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="n">stdin</span><span class="p">):</span> <span class="p">(</span><span class="n">ChildStdout</span><span class="p">,</span> <span class="n">ChildStdin</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">stdout</span><span class="p">)</span> <span class="o">=</span> <span class="n">child</span><span class="py">.stdout</span><span class="nf">.take</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nn">miette</span><span class="p">::</span><span class="nd">bail!</span><span class="p">(</span><span class="s">"Child process did not have a stdout"</span><span class="p">);</span>
        <span class="p">};</span>
        <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">stdin</span><span class="p">)</span> <span class="o">=</span> <span class="n">child</span><span class="py">.stdin</span><span class="nf">.take</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nn">miette</span><span class="p">::</span><span class="nd">bail!</span><span class="p">(</span><span class="s">"Child process did not have a stdin"</span><span class="p">);</span>
        <span class="p">};</span>
        <span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="n">stdin</span><span class="p">)</span>
    <span class="p">};</span>

    <span class="c1">// Spawn tasks to:</span>
    <span class="k">let</span> <span class="n">join_handle_child_task</span> <span class="o">=</span> <span class="nf">spawn_child_process</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">join_handle_provide_input_task</span> <span class="o">=</span>
        <span class="nf">spawn_provide_input</span><span class="p">(</span><span class="n">stdin</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>

    <span class="c1">// Read the output of the child process, on the current thread.</span>
    <span class="n">_</span> <span class="o">=</span> <span class="nf">read_stdout</span><span class="p">(</span><span class="n">stdout</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>

    <span class="c1">// Wait for the child process to complete.</span>
    <span class="n">_</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nd">join!</span><span class="p">(</span>
        <span class="n">join_handle_child_task</span><span class="p">,</span> <span class="n">join_handle_provide_input_task</span><span class="p">);</span>

    <span class="c1">// Make assertions.</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">input</span><span class="nf">.join</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span> <span class="s">"hello</span><span class="se">\n</span><span class="s">nadia!"</span><span class="p">);</span>

    <span class="nd">ok!</span><span class="p">()</span>
<span class="p">}</span>

<span class="cd">/// As long as there is a line to be read from the child process,</span>
<span class="cd">/// print it to the terminal.</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">read_stdout</span><span class="p">(</span><span class="n">stdout</span><span class="p">:</span> <span class="n">ChildStdout</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">output</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">stdout_reader</span> <span class="o">=</span> <span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">stdout</span><span class="p">)</span><span class="nf">.lines</span><span class="p">();</span>
    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">=</span> <span class="n">stdout_reader</span>
        <span class="nf">.next_line</span><span class="p">()</span><span class="k">.await</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span>
    <span class="p">{</span>
        <span class="n">output</span><span class="nf">.push</span><span class="p">(</span><span class="n">line</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="nd">println!</span><span class="p">(</span>
            <span class="s">"🧵 read_stdout -&gt; {}"</span><span class="p">,</span>
            <span class="nd">format!</span><span class="p">(</span><span class="s">"🫲  {}"</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span><span class="nf">.cyan</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="nd">ok!</span><span class="p">()</span>
<span class="p">}</span>

<span class="cd">/// 🚀 Ensure the child process is spawned in the runtime, so it</span>
<span class="cd">/// can make progress on its own while we await any output.</span>
<span class="k">fn</span> <span class="nf">spawn_child_process</span><span class="p">(</span><span class="k">mut</span> <span class="n">child</span><span class="p">:</span> <span class="n">Child</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">JoinHandle</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">result_exit_status</span> <span class="o">=</span> <span class="n">child</span><span class="nf">.wait</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>
        <span class="nd">println!</span><span class="p">(</span>
            <span class="s">"{}"</span><span class="p">,</span>
            <span class="nd">format!</span><span class="p">(</span>
                <span class="s">"🚀 spawn_child_process -&gt; exit w/ status: {:?}"</span><span class="p">,</span>
                <span class="n">result_exit_status</span>
            <span class="p">)</span>
            <span class="nf">.green</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="cd">/// 🚀 Provide input to the child process.</span>
<span class="k">fn</span> <span class="nf">spawn_provide_input</span><span class="p">(</span>
    <span class="k">mut</span> <span class="n">stdin</span><span class="p">:</span> <span class="n">ChildStdin</span><span class="p">,</span> <span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="o">&amp;</span><span class="nb">str</span><span class="p">]</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="n">JoinHandle</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">input</span> <span class="o">=</span> <span class="n">input</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">s</span><span class="p">|</span> <span class="n">s</span><span class="nf">.to_string</span><span class="p">())</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;&gt;</span><span class="p">()</span>
        <span class="nf">.join</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="c1">// Write the input to the `stdin` of the child process.</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">stdin</span><span class="nf">.write_all</span><span class="p">(</span><span class="n">input</span><span class="nf">.as_bytes</span><span class="p">())</span><span class="k">.await</span><span class="p">;</span>

        <span class="c1">// Drop the handle to signal EOF to the child process.</span>
        <span class="nf">drop</span><span class="p">(</span><span class="n">stdin</span><span class="p">);</span>

        <span class="nd">println!</span><span class="p">(</span>
            <span class="s">"{}: {}"</span><span class="p">,</span>
            <span class="s">"🚀 spawn_provide_input -&gt; EOF to child 🫱  stdin"</span>
                <span class="nf">.green</span><span class="p">(),</span>
            <span class="nd">format!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">input</span><span class="p">)</span><span class="nf">.blue</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">})</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notes on the code:</p>

<ul>
  <li>This example is similar to <code class="language-plaintext highlighter-rouge">async_command_exec_2.rs</code>, except that there is no need to
pipe input from the shell into this program. It does the following:
    <ol>
      <li>Programmatically provides data to the <code class="language-plaintext highlighter-rouge">cat</code> command via <code class="language-plaintext highlighter-rouge">stdin</code>.</li>
      <li>Programmatically captures the output of <code class="language-plaintext highlighter-rouge">cat</code> via <code class="language-plaintext highlighter-rouge">stdout</code>.</li>
    </ol>
  </li>
  <li>Flow diagram of the program:
    <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Terminal emulator running fish/bash shell
┌────────────────────────────────────────┐
│ &gt; cargo run --bin async_command_exec_3 │
└───▲────────────────────────────────────┘
    ├────► create async Command for `cat`
    │      with stdout = `Stdio::piped()` to
    │      capture the output of `cmd`
    │      back into this program
    │
    ├────► set stdin = `Stdio::piped()` to provide
    │      input to the `cat` command asynchronously
    │
    ├────► `cmd.spawn()` then sets up the `cat` process
    │      to run with the given stdin &amp; stdout and
    │      returns a `Child` struct
    │
    ├────► 🚀 instead of waiting "normally", we must use
    │      `tokio::spawn` to call `child.wait().await`
    │      on the child so it can make progress while
    │      we wait for its output below (in the current task)
    │
    ├────► 🚀 also use `tokio::spawn` to call
    │      `child.stdin.write_all()` to provide input
    │      to the `cat` command
    │
    └────► in our current task, we can now access `stdout`
           WHILE the child task is making progress above
</code></pre></div>    </div>
  </li>
  <li>How to kill child process:
    <ul>
      <li>Note that similar to the behavior to the standard library, and unlike the futures
paradigm of dropping-implies-cancellation, a spawned process will, by default,
continue to execute even after the <code class="language-plaintext highlighter-rouge">tokio::process::Child</code> handle has been dropped.
More info in the
<a href="https://docs.rs/tokio/latest/tokio/process/index.html#caveats">docs</a>. To change this
behavior you can use <code class="language-plaintext highlighter-rouge">tokio::process::Command::kill_on_drop</code> which isn’t really
recommended.</li>
      <li>Instead, to kill a child process, you can do the following:
        <ul>
          <li><code class="language-plaintext highlighter-rouge">tokio::process::Child::kill</code> - This forces the child process to exit.</li>
          <li><code class="language-plaintext highlighter-rouge">tokio::process::Child::wait</code> - This waits for the child process to cleanly exit.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>See it in action:</p>

<ul>
  <li>Run the binary: <code class="language-plaintext highlighter-rouge">cargo run --bin async_command_exec_3</code></li>
  <li>It should produce output that looks something like the following:
    <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🚀 spawn_provide_input -&gt; Finished providing input + EOF to child process 🫱  stdin: "hello\nnadia!"
🧵 read_stdout -&gt; 🫲  hello
🧵 read_stdout -&gt; 🫲  nadia!
🚀 spawn_child_process -&gt; Child process exited with status: Ok(ExitStatus(unix_wait_status(0)))
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="example-programmatically-piping-the-output-of-one-process-into-another">Example programmatically piping the output of one process into another</h3>
<p><a id="markdown-example-programmatically-piping-the-output-of-one-process-into-another" name="example-programmatically-piping-the-output-of-one-process-into-another"></a></p>

<p>Please clone this <a href="https://github.com/nazmulidris/rust-scratch">repo</a> to your computer to
play w/ the examples in the <a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/README.md"><code class="language-plaintext highlighter-rouge">rust-scratch/tty</code>
crate</a> shown below.</p>

<p><a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/src/async_command_exec_4.rs"><code class="language-plaintext highlighter-rouge">async_command_exec_4.rs</code></a></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">crossterm</span><span class="p">::</span><span class="nn">style</span><span class="p">::</span><span class="n">Stylize</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">miette</span><span class="p">::</span><span class="n">IntoDiagnostic</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">r3bl_rs_utils_core</span><span class="p">::</span><span class="n">ok</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="n">Stdio</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">tokio</span><span class="p">::{</span><span class="nn">io</span><span class="p">::</span><span class="n">AsyncReadExt</span><span class="p">,</span> <span class="nn">process</span><span class="p">::</span><span class="n">Command</span><span class="p">};</span>

<span class="k">type</span> <span class="n">EchoResult</span> <span class="o">=</span> <span class="p">(</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="n">ChildStdout</span><span class="p">,</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">task</span><span class="p">::</span><span class="n">JoinHandle</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">type</span> <span class="n">TrResult</span> <span class="o">=</span> <span class="p">(</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="n">ChildStdout</span><span class="p">,</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">task</span><span class="p">::</span><span class="n">JoinHandle</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">);</span>

<span class="k">const</span> <span class="n">INPUT</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">"hello world"</span><span class="p">;</span>

<span class="nd">#[tokio::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Spawn the `echo` command &amp; get its `stdout`.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">child_stdout_echo</span><span class="p">,</span> <span class="n">join_handle_echo</span><span class="p">):</span> <span class="n">EchoResult</span> <span class="o">=</span>
        <span class="nf">spawn_child_echo_and_get_stdout</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Spawn the `tr` command &amp; provide the `stdout` of `echo` to</span>
    <span class="c1">// its `stdin`.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">child_stdout_tr</span><span class="p">,</span> <span class="n">join_handle_tr</span><span class="p">):</span> <span class="n">TrResult</span> <span class="o">=</span>
        <span class="nf">spawn_child_tr_and_provide_stdin</span><span class="p">(</span><span class="n">child_stdout_echo</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Wait for both child processes to complete.</span>
    <span class="n">_</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nd">try_join!</span><span class="p">(</span><span class="n">join_handle_echo</span><span class="p">,</span> <span class="n">join_handle_tr</span><span class="p">);</span>

    <span class="c1">// Read the output of the `tr` command from `child_stdout_tr`.</span>
    <span class="k">let</span> <span class="n">output</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">buf</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">child_stdout_tr</span><span class="p">)</span>
            <span class="nf">.read_to_end</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">buf</span><span class="p">)</span>
            <span class="k">.await</span>
            <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
        <span class="n">buf</span>
    <span class="p">};</span>

    <span class="c1">// Make assertions.</span>
    <span class="k">let</span> <span class="n">expected_output</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{INPUT}</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span><span class="nf">.to_uppercase</span><span class="p">();</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">expected_output</span><span class="p">,</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_lossy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">output</span><span class="p">));</span>

    <span class="c1">// Print the output of the `tr` command.</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"{}: {}"</span><span class="p">,</span>
        <span class="s">"output"</span><span class="nf">.blue</span><span class="p">(),</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_lossy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">output</span><span class="p">))</span><span class="nf">.green</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="nd">ok!</span><span class="p">()</span>
<span class="p">}</span>

<span class="cd">/// 🚀 Spawn `echo` command &amp; get its `stdout`. We will pipe this</span>
<span class="cd">/// into the `stdin` of `tr`.</span>
<span class="cd">///</span>
<span class="cd">/// Return a tuple of:</span>
<span class="cd">/// 1. `stdout` of `echo`: [tokio::process::ChildStdout].</span>
<span class="cd">/// 2. [tokio::task::JoinHandle] of `echo` [tokio::process::Child]</span>
<span class="cd">///    process, spawned by the [tokio::process::Command] that</span>
<span class="cd">///    starts `echo`.</span>
<span class="k">fn</span> <span class="nf">spawn_child_echo_and_get_stdout</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">EchoResult</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Spawn the child process for `echo`.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">child_echo</span> <span class="o">=</span> <span class="nn">Command</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"echo"</span><span class="p">)</span>
        <span class="nf">.arg</span><span class="p">(</span><span class="n">INPUT</span><span class="p">)</span>
        <span class="nf">.stdout</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">piped</span><span class="p">())</span>
        <span class="nf">.stdin</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">null</span><span class="p">())</span>
        <span class="nf">.stderr</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">null</span><span class="p">())</span>
        <span class="nf">.spawn</span><span class="p">()</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Take the `stdout` of the child process.</span>
    <span class="k">let</span> <span class="n">child_stdout</span> <span class="o">=</span> <span class="n">child_echo</span><span class="py">.stdout</span><span class="nf">.take</span><span class="p">()</span>
        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">miette</span><span class="p">::</span><span class="nd">miette!</span><span class="p">(</span>
            <span class="s">"Failed to capture stdout of `echo` child process"</span>
        <span class="p">))</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Ensure the child process is spawned in the runtime, so it can</span>
    <span class="c1">// make progress on its own while we await any output.</span>
    <span class="k">let</span> <span class="n">join_handle</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">child_echo</span><span class="nf">.wait</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>
    <span class="p">});</span>

    <span class="c1">// Return the `stdout` of `echo` and the `JoinHandle` of the</span>
    <span class="c1">// `echo` child process.</span>
    <span class="nf">Ok</span><span class="p">((</span><span class="n">child_stdout</span><span class="p">,</span> <span class="n">join_handle</span><span class="p">))</span>
<span class="p">}</span>

<span class="cd">/// 🚀 Spawn `tr` command &amp; pass the given</span>
<span class="cd">/// [tokio::process::ChildStdout] to its `stdin`.</span>
<span class="cd">///</span>
<span class="cd">/// Return a tuple of:</span>
<span class="cd">/// 1. `stdout` of `tr`: [tokio::process::ChildStdout].</span>
<span class="cd">/// 2. [tokio::task::JoinHandle] of `tr` [tokio::process::Child]</span>
<span class="cd">///    process, spawned by the [tokio::process::Command] that</span>
<span class="cd">///    starts `tr`.</span>
<span class="k">fn</span> <span class="nf">spawn_child_tr_and_provide_stdin</span><span class="p">(</span>
    <span class="n">stdout_from_other_child</span><span class="p">:</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="n">ChildStdout</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">TrResult</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Convert `stdout_from_other_child`: tokio::process::ChildStdout</span>
    <span class="c1">// into tokio::process::ChildStdin, so it can be provided to the</span>
    <span class="c1">// `stdin` of the `tr` command.</span>
    <span class="k">let</span> <span class="n">stdout_from_other_child</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="n">Stdio</span> <span class="o">=</span>
        <span class="n">stdout_from_other_child</span><span class="nf">.try_into</span><span class="p">()</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Spawn child process.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">child_tr</span> <span class="o">=</span> <span class="nn">Command</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"tr"</span><span class="p">)</span>
        <span class="nf">.arg</span><span class="p">(</span><span class="s">"a-z"</span><span class="p">)</span>
        <span class="nf">.arg</span><span class="p">(</span><span class="s">"A-Z"</span><span class="p">)</span>
        <span class="nf">.stdin</span><span class="p">(</span><span class="n">stdout_from_other_child</span><span class="p">)</span>
        <span class="nf">.stdout</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">piped</span><span class="p">())</span>
        <span class="nf">.stderr</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">null</span><span class="p">())</span>
        <span class="nf">.spawn</span><span class="p">()</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Take the `stdout` of the child process.</span>
    <span class="k">let</span> <span class="n">child_stdout</span> <span class="o">=</span> <span class="n">child_tr</span><span class="py">.stdout</span><span class="nf">.take</span><span class="p">()</span><span class="nf">.ok_or</span><span class="p">(</span><span class="nn">miette</span><span class="p">::</span><span class="nd">miette!</span><span class="p">(</span>
        <span class="s">"Failed to capture stdout of `tr` child process"</span>
    <span class="p">))</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Ensure the child process is spawned in the runtime, so it can</span>
    <span class="c1">// make progress on its own while we await any output.</span>
    <span class="k">let</span> <span class="n">join_handle</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">child_tr</span><span class="nf">.wait</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>
    <span class="p">});</span>

    <span class="nf">Ok</span><span class="p">((</span><span class="n">child_stdout</span><span class="p">,</span> <span class="n">join_handle</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notes on the code:</p>

<ul>
  <li>In this example, we will will orchestrate two processes and make a pipe between them
programmatically (we are used to doing this using <code class="language-plaintext highlighter-rouge">|</code> in shells). We will replicate
the following functionality in this program: <code class="language-plaintext highlighter-rouge">echo hello world | tr a-z A-Z</code>.
    <ol>
      <li>Spawn the <code class="language-plaintext highlighter-rouge">echo</code> command, with arg <code class="language-plaintext highlighter-rouge">hello world</code> and get its <code class="language-plaintext highlighter-rouge">stdout</code>.</li>
      <li>Then we will provide this <code class="language-plaintext highlighter-rouge">stdout</code> to the <code class="language-plaintext highlighter-rouge">stdin</code> of the <code class="language-plaintext highlighter-rouge">tr</code> command, with arg
<code class="language-plaintext highlighter-rouge">a-z A-Z</code> and spawn it.</li>
      <li>Finally we join the <code class="language-plaintext highlighter-rouge">echo</code> and <code class="language-plaintext highlighter-rouge">tr</code> child processes and wait for them both to
complete.</li>
    </ol>
  </li>
</ul>

<p>See it in action:</p>

<ul>
  <li>Run the binary: <code class="language-plaintext highlighter-rouge">cargo run --bin async_command_exec_4</code></li>
  <li>You should see output that looks something like the following:
    <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>output: HELLO WORLD
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="example-using-r3bl_terminal_async-to-send-commands-to-a-long-running-bash-child-process">Example using r3bl_terminal_async to send commands to a long running bash child process</h3>
<p><a id="markdown-example-using-r3bl_terminal_async-to-send-commands-to-a-long-running-bash-child-process" name="example-using-r3bl_terminal_async-to-send-commands-to-a-long-running-bash-child-process"></a></p>

<p>The following example is in the <a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/terminal_async"><code class="language-plaintext highlighter-rouge">r3bl_terminal_async</code>
repo</a>. Please clone that repo to your computer to
play w/ the following example:</p>

<p><a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/terminal_async/examples/shell_async.rs"><code class="language-plaintext highlighter-rouge">shell_async.rs</code></a></p>

<p>You can clone the <a href="https://github.com/r3bl-org/r3bl-open-core"><code class="language-plaintext highlighter-rouge">r3bl-open-core</code></a> repo to your computer
and then run the following command to run the example:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/r3bl-org/r3bl-open-core
<span class="nb">cd </span>r3bl-open-core/terminal_async
cargo run <span class="nt">--example</span> shell_async
</code></pre></div></div>

<p>Type the following commands to have a go at this.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">msg</span><span class="o">=</span><span class="s2">"hello nadia!"</span>
<span class="nb">echo</span> <span class="nv">$msg</span>
</code></pre></div></div>

<p>You should see something like the following.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[1606192] &gt; msg="hello nadia!"
[1606192] &gt; echo $msg
hello nadia!
[1606192] &gt;
</code></pre></div></div>

<p>Clean up any left over processes:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>killall <span class="nt">-9</span> bash shell_async
</code></pre></div></div>

<h2 id="build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</h2>
<p><a id="markdown-build-with-naz-video-series-on-developerlife.com-youtube-channel" name="build-with-naz-video-series-on-developerlife.com-youtube-channel"></a></p>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a></li>
  <li>Playlists
    <ul>
      <li><a href="https://www.youtube.com/watch?v=bolScvh4x7I&amp;list=PLofhE49PEwmw3MKOU1Kn3xbP4FRQR4Mb3">Build with Naz, Linux TTY, process, signals, commands in async Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmza94sS7UmJnN9gSCHTVTfz">Build with Naz, fundamental effective Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmwO69E7eiQ-ewnMME8ydgQ5">Build with Naz, effective async Rust and tokio</a></li>
      <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><category term="TUI" /><summary type="html"><![CDATA[This article, along with related videos and the repository, explores Linux TTY, shells, processes, sessions, jobs, PTYs, signals, and more using Rust. It explains /dev/tty and describes how terminal libraries like crossterm and termion build on top of stdio and /dev/tty. The article provides examples of using Rust to send and receive POSIX signals, communicate with processes via IPC, and spawn processes. Additionally, it includes examples of using PTY in Linux and controlling external commands (such as binaries like bash) using asynchronous Rust.]]></summary></entry><entry><title type="html">Build with Naz : Box and Pin exploration in Rust</title><link href="http://developerlife.com/2024/07/16/pin-box-dynamic-duo/" rel="alternate" type="text/html" title="Build with Naz : Box and Pin exploration in Rust" /><published>2024-07-16T10:00:00-05:00</published><updated>2024-07-16T10:00:00-05:00</updated><id>http://developerlife.com/2024/07/16/pin-box-dynamic-duo</id><content type="html" xml:base="http://developerlife.com/2024/07/16/pin-box-dynamic-duo/"><![CDATA[<p><img class="post-hero-image" src="/assets/box-and-pin.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#why-do-we-need-both-box-and-pin">Why do we need both Box and Pin?</a></li>
  <li><a href="#formatting-pointers">Formatting pointers</a></li>
  <li><a href="#what-is-a-smart-pointer">What is a smart pointer?</a></li>
  <li><a href="#youtube-video-for-this-article">YouTube video for this article</a></li>
  <li><a href="#examples-rust-box-smart-pointer-and-pin">Examples Rust Box smart pointer, and Pin</a>
    <ul>
      <li><a href="#example-1-getting-the-address-of-variables-on-the-stack-and-heap">Example 1: Getting the address of variables on the stack and heap</a></li>
      <li><a href="#example-2-what-does-box-move-do">Example 2: What does Box move do?</a></li>
      <li><a href="#example-3-how-do-we-swap-the-contents-of-two-boxes">Example 3: How do we swap the contents of two boxes?</a></li>
      <li><a href="#example-4-what-does-pining-a-box-do">Example 4: What does pining a box do?</a></li>
    </ul>
  </li>
  <li><a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</a></li>
</ul>

<!-- /TOC -->

<h2 id="introduction">Introduction</h2>
<p><a id="markdown-introduction" name="introduction"></a></p>

<p>This tutorial, video, and repo are a deep dive into Rust <code class="language-plaintext highlighter-rouge">Pin</code> and <code class="language-plaintext highlighter-rouge">Box</code> types, along with
concepts of ownership and borrowing. We will also cover a lot of background information on
the concepts of operating system process, memory allocation and access, stack, and heap.
The examples we create are designed to demonstrate  the different semantics around the use
of boxes and pinned boxes in Rust.</p>

<h2 id="why-do-we-need-both-box-and-pin">Why do we need both Box and Pin?</h2>
<p><a id="markdown-why-do-we-need-both-box-and-pin%3F" name="why-do-we-need-both-box-and-pin%3F"></a></p>

<p>It is common to use <code class="language-plaintext highlighter-rouge">Pin</code> for <code class="language-plaintext highlighter-rouge">tokio::select!</code> macro branches in <a href="https://developerlife.com/2024/05/19/effective-async-rust/">Rust async
code</a>. And <code class="language-plaintext highlighter-rouge">Box</code> is used
commonly for <a href="https://developerlife.com/2024/04/28/rust-polymorphism-dyn-impl-trait-objects-for-testing-and-extensibiity/">trait
pointers</a>.</p>

<p>This article, video, and repo illustrate the concepts (moving a box, swapping box
contents, and pinning a box) by example. Lots of pretty formatted output is generated so
that you can run tests and see what’s happening (and make sense of it).</p>

<h2 id="formatting-pointers">Formatting pointers</h2>
<p><a id="markdown-formatting-pointers" name="formatting-pointers"></a></p>

<p>To format pointers in Rust, we can use the formatting trait
<a href="https://doc.rust-lang.org/std/fmt/#formatting-traits"><code class="language-plaintext highlighter-rouge">{:p}</code></a>. You can format a
pointer by using two approaches:</p>
<ol>
  <li>Get the address of the pointer using [<code class="language-plaintext highlighter-rouge">std::ptr::addr_of!</code>] and then format it
using <code class="language-plaintext highlighter-rouge">{:p}</code>. Eg: <code class="language-plaintext highlighter-rouge">let x = 1; println!("{:p}", std::ptr::addr_of!(x));</code></li>
  <li>Get a reference to the pointer using <code class="language-plaintext highlighter-rouge">&amp;</code> and then format it using <code class="language-plaintext highlighter-rouge">{:p}</code>. Eg: <code class="language-plaintext highlighter-rouge">let
x = 1; println!("{:p}", &amp;x);</code></li>
</ol>

<h2 id="what-is-a-smart-pointer">What is a smart pointer?</h2>
<p><a id="markdown-what-is-a-smart-pointer%3F" name="what-is-a-smart-pointer%3F"></a></p>

<p>Smart pointers in Rust are data structures that act like pointers but also have additional
metadata and capabilities. They provide a level of abstraction over raw pointers, offering
features like ownership management, reference counting, and more. Smart pointers often
manage ownership of the data they point to, ensuring proper deallocation when no longer
needed.</p>

<blockquote>
  <p>For a great visualization of memory allocation, stack and heap please read this
<a href="https://courses.grainger.illinois.edu/cs225/fa2022/resources/stack-heap/">article</a>.</p>
</blockquote>

<h2 id="youtube-video-for-this-article">YouTube video for this article</h2>
<p><a id="markdown-youtube-video-for-this-article" name="youtube-video-for-this-article"></a></p>

<p>This blog post has examples from this live coding video. If you like
to learn via video, please watch the companion video on the <a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube
channel</a>.</p>

<!-- video on tokio-async-cancel-safety -->
<iframe src="https://www.youtube.com/embed/SZtZkM2Ujhs?si=6wtfI_Q8ORpKUU_G" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<p><br /></p>

<h2 id="examples-rust-box-smart-pointer-and-pin">Examples Rust Box smart pointer, and Pin</h2>
<p><a id="markdown-examples-rust-box-smart-pointer%2C-and-pin" name="examples-rust-box-smart-pointer%2C-and-pin"></a></p>

<p>Let’s create some examples to illustrate how <code class="language-plaintext highlighter-rouge">Box</code> and <code class="language-plaintext highlighter-rouge">Pin</code> and pointers to stack
allocations and heap allocations work in Rust. You can run <code class="language-plaintext highlighter-rouge">cargo new --lib box-and-pin</code>
to create a new library crate.</p>

<blockquote>
  <p>💡 You can get the code from the
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/box-and-pin/"><code class="language-plaintext highlighter-rouge">rust-scratch</code></a> repo.</p>
</blockquote>

<p>Then add the following to the <code class="language-plaintext highlighter-rouge">Cargo.toml</code> file that’s generated. These pull in all the
dependencies that we need for these examples.</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[package]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"box-and-pin"</span>
<span class="py">version</span> <span class="p">=</span> <span class="s">"0.1.0"</span>
<span class="py">edition</span> <span class="p">=</span> <span class="s">"2021"</span>

<span class="nn">[dependencies]</span>
<span class="py">crossterm</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.27.0"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"event-stream"</span><span class="p">]</span> <span class="p">}</span>
<span class="py">serial_test</span> <span class="p">=</span> <span class="s">"3.1.1"</span>
</code></pre></div></div>

<p>Here are the dependencies we are using:</p>
<ol>
  <li>The <code class="language-plaintext highlighter-rouge">serial_test</code> dep allows us to run Rust tests serially, so that we can examine the
output of each test, without it being clobbered by other test output running in
parallel.</li>
  <li>The <code class="language-plaintext highlighter-rouge">crossterm</code> dep allows us to generate colorful <code class="language-plaintext highlighter-rouge">println!</code> output in the terminal
which will help us visualize what is going on with the pointers and memory allocations.</li>
</ol>

<p>We are going to add all the examples below as tests to the <code class="language-plaintext highlighter-rouge">lib.rs</code> file in this crate.</p>

<h3 id="example-1-getting-the-address-of-variables-on-the-stack-and-heap">Example 1: Getting the address of variables on the stack and heap</h3>
<p><a id="markdown-example-1%3A-getting-the-address-of-variables-on-the-stack-and-heap" name="example-1%3A-getting-the-address-of-variables-on-the-stack-and-heap"></a></p>

<p>Let’s add the following imports and macros to the top of the <code class="language-plaintext highlighter-rouge">lib.rs</code> file. These will
help us print output from the tests, so that we can track where a pointer is located in
memory and what the size of the thing it points to is. There are two macros, one for a
reference or pointer, and another one for pinned pointers. And we have an assertion
function that can return true if all 3 arguments are equal.</p>

<div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">crossterm</span><span class="p">::</span><span class="nn">style</span><span class="p">::</span><span class="n">Stylize</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">serial_test</span><span class="p">::</span><span class="n">serial</span><span class="p">;</span>

<span class="cd">/// Given a pointer `$p`, it prints:</span>
<span class="cd">/// 1. it's address,</span>
<span class="cd">/// 2. and size of the thing it points to (in bytes).</span>
<span class="nd">macro_rules!</span> <span class="n">print_ptr_addr_size</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$p</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"{:p}┆{}b"</span><span class="p">,</span> <span class="nv">$p</span><span class="p">,</span> <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">size_of_val</span><span class="p">(</span><span class="nv">$p</span><span class="p">))</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="cd">/// Given a pinned pointer `$p`, it prints:</span>
<span class="cd">/// 1. it's address,</span>
<span class="cd">/// 2. and size of the thing it points to (in bytes).</span>
<span class="nd">macro_rules!</span> <span class="n">print_pin_addr_size</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$p</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"{:p}┆{}b"</span><span class="p">,</span> <span class="nv">$p</span><span class="p">,</span> <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">size_of_val</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="nv">$p</span><span class="p">)))</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">assert_three_equal</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">PartialEq</span> <span class="o">+</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="s">"a and b are not equal"</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="s">"a and c are not equal"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So, before we start with the examples, let’s add a test that demonstrates how to get the
address of a variable on the stack and heap. Add the following code to your <code class="language-plaintext highlighter-rouge">lib.rs</code> file.</p>

<div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[test]</span>
<span class="nd">#[serial]</span>
<span class="k">fn</span> <span class="nf">print_ptr_addr_size</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Using `std::ptr::addr_of!` to get the memory address of a variable.</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">100u8</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">x_addr</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ptr</span><span class="p">::</span><span class="nd">addr_of!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"x: {}, x_addr  : {}"</span><span class="p">,</span>
        <span class="n">x</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">(),</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">x_addr</span><span class="p">)</span><span class="nf">.red</span><span class="p">()</span><span class="nf">.italic</span><span class="p">(),</span>
    <span class="p">);</span>

    <span class="c1">// Using `format!` to get the memory address of a variable.</span>
    <span class="k">let</span> <span class="n">x_addr_2</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{:p}"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"x: {}, x_addr_2: {}"</span><span class="p">,</span>
        <span class="n">x</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">(),</span>
        <span class="n">x_addr_2</span><span class="nf">.red</span><span class="p">()</span><span class="nf">.italic</span><span class="p">()</span><span class="nf">.on_black</span><span class="p">(),</span>
    <span class="p">);</span>

    <span class="c1">// Get size of `x` in bytes.</span>
    <span class="k">let</span> <span class="n">x_size</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">size_of_val</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"x: {}, x_size  : {}b"</span><span class="p">,</span>
        <span class="n">x</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">(),</span>
        <span class="n">x_size</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.magenta</span><span class="p">()</span><span class="nf">.italic</span><span class="p">()</span><span class="nf">.on_black</span><span class="p">(),</span>
    <span class="p">);</span>

    <span class="c1">// Using `print_ptr_addr_size!` to get the memory address of a variable.</span>
    <span class="k">let</span> <span class="n">x_addr_3</span> <span class="o">=</span> <span class="nd">print_ptr_addr_size!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"x: {}, x_addr_3: {}"</span><span class="p">,</span>
        <span class="n">x</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">(),</span>
        <span class="n">x_addr_3</span><span class="nf">.red</span><span class="p">()</span><span class="nf">.italic</span><span class="p">()</span><span class="nf">.on_black</span><span class="p">(),</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here’s the output of the test above, after you run <code class="language-plaintext highlighter-rouge">cargo watch -x "test --lib -- --show-output print"</code>.</p>

<pre class="pre-manual-highlight">
---- print_ptr_addr_size stdout ----
x: <span style="color:#81A1C1"><u style="text-decoration-style:solid">100</u></span>, x_addr  : <span style="color:#BF616A"><i>0x7e17cd9feb97</i></span>
x: <span style="color:#81A1C1"><u style="text-decoration-style:solid">100</u></span>, x_addr_2: <span style="background-color:#3B4252"><span style="color:#BF616A"><i>0x7e17cd9feb97</i></span></span>
x: <span style="color:#81A1C1"><u style="text-decoration-style:solid">100</u></span>, x_size  : <span style="background-color:#3B4252"><span style="color:#B48EAD"><i>1</i></span></span>b
x: <span style="color:#81A1C1"><u style="text-decoration-style:solid">100</u></span>, x_addr_3: <span style="background-color:#3B4252"><span style="color:#BF616A"><i>0x7e17cd9feb97┆1b</i></span></span>
</pre>

<p>Let’s walk through the output above:</p>
<ol>
  <li>We have a variable <code class="language-plaintext highlighter-rouge">x</code> that is a <code class="language-plaintext highlighter-rouge">u8</code> with a value of <code class="language-plaintext highlighter-rouge">100</code>. This is a stack
allocation. It occupies 1 byte of memory (its size).</li>
  <li>We get the address of <code class="language-plaintext highlighter-rouge">x</code> using <code class="language-plaintext highlighter-rouge">std::ptr::addr_of!(x)</code> and <code class="language-plaintext highlighter-rouge">format!("{:p}", &amp;x)</code>.</li>
  <li>We get the size of <code class="language-plaintext highlighter-rouge">x</code> in bytes using <code class="language-plaintext highlighter-rouge">std::mem::size_of_val(&amp;x)</code>. The size is 1 byte.</li>
  <li>We get the address of <code class="language-plaintext highlighter-rouge">x</code> and the size of <code class="language-plaintext highlighter-rouge">x</code> using the <code class="language-plaintext highlighter-rouge">print_ptr_addr_size!</code> macro.</li>
</ol>

<h3 id="example-2-what-does-box-move-do">Example 2: What does Box move do?</h3>
<p><a id="markdown-example-2%3A-what-does-box-move-do%3F" name="example-2%3A-what-does-box-move-do%3F"></a></p>

<p>Add the following snippet to the <code class="language-plaintext highlighter-rouge">lib.rs</code> file next. This
<a href="https://courses.grainger.illinois.edu/cs225/fa2022/resources/stack-heap/">link</a> provids
lots of great diagrams on how stack and heap memory works in an operating system.</p>

<div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// &lt;https://courses.grainger.illinois.edu/cs225/fa2022/resources/stack-heap/&gt;</span>
<span class="nd">#[test]</span>
<span class="nd">#[serial]</span>
<span class="k">fn</span> <span class="nf">move_a_box</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">b_1</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">255u8</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">b_1_addr</span> <span class="o">=</span> <span class="nd">print_ptr_addr_size!</span><span class="p">(</span><span class="n">b_1</span><span class="nf">.as_ref</span><span class="p">());</span> <span class="c1">// Pointee (heap)</span>
    <span class="k">let</span> <span class="n">b_1_ptr_addr</span> <span class="o">=</span> <span class="nd">print_ptr_addr_size!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b_1</span><span class="p">);</span> <span class="c1">// Pointer (stack)</span>

    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"1. {}: {}, {} (pointee, heap): {}, {} (ptr, stack): {}"</span><span class="p">,</span>
        <span class="s">"b_1"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="n">b_1</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">(),</span>
        <span class="s">"b_1_addr"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="n">b_1_addr</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.magenta</span><span class="p">()</span><span class="nf">.italic</span><span class="p">()</span><span class="nf">.on_black</span><span class="p">(),</span>
        <span class="s">"b_1_ptr_addr"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="n">b_1_ptr_addr</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.magenta</span><span class="p">()</span><span class="nf">.italic</span><span class="p">()</span><span class="nf">.on_black</span><span class="p">(),</span>
    <span class="p">);</span>

    <span class="k">let</span> <span class="n">b_2</span> <span class="o">=</span> <span class="n">b_1</span><span class="p">;</span>
    <span class="c1">// println!("{b_1:p}"); // ⛔ error: use of moved value: `b_1`</span>
    <span class="k">let</span> <span class="n">b_2_addr</span> <span class="o">=</span> <span class="nd">print_ptr_addr_size!</span><span class="p">(</span><span class="n">b_2</span><span class="nf">.as_ref</span><span class="p">());</span> <span class="c1">// Pointee (heap)</span>
    <span class="k">let</span> <span class="n">b_2_ptr_addr</span> <span class="o">=</span> <span class="nd">print_ptr_addr_size!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b_2</span><span class="p">);</span> <span class="c1">// Pointer (stack)</span>

    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"2. {}: {}, {} (pointee, heap): {}, {} (ptr, stack): {}"</span><span class="p">,</span>
        <span class="s">"b_2"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="n">b_2</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">(),</span>
        <span class="s">"b_2_addr"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="n">b_2_addr</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.magenta</span><span class="p">()</span><span class="nf">.italic</span><span class="p">()</span><span class="nf">.on_black</span><span class="p">(),</span>
        <span class="s">"b_2_ptr_addr"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="n">b_2_ptr_addr</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.magenta</span><span class="p">()</span><span class="nf">.italic</span><span class="p">()</span><span class="nf">.on_black</span><span class="p">(),</span>
    <span class="p">);</span>

    <span class="c1">// The heap memory allocation does not change (does not move). Pointee does not move.</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">b_1_addr</span><span class="p">,</span> <span class="n">b_2_addr</span><span class="p">);</span>

    <span class="c1">// The stack memory allocation does change (does move). Boxes aka pointers have move.</span>
    <span class="nd">assert_ne!</span><span class="p">(</span><span class="n">b_1_ptr_addr</span><span class="p">,</span> <span class="n">b_2_ptr_addr</span><span class="p">);</span>

    <span class="c1">// When b_2 is dropped, the heap allocation is deallocated. This is why Box is a smart pointer.</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Let’s walk through the output above:</p>
<ol>
  <li>We have a <code class="language-plaintext highlighter-rouge">Box</code> <code class="language-plaintext highlighter-rouge">b_1</code> that points to a heap allocation of a <code class="language-plaintext highlighter-rouge">u8</code> with a value of <code class="language-plaintext highlighter-rouge">255</code>.
<code class="language-plaintext highlighter-rouge">b_1</code> is a variable on the stack that points to a heap allocation. We get the address
of the pointee and the pointer using the <code class="language-plaintext highlighter-rouge">print_ptr_addr_size!</code> macro with
<code class="language-plaintext highlighter-rouge">b_1.as_ref()</code>. And we get the address of the pointer by passing <code class="language-plaintext highlighter-rouge">&amp;b_1</code> to
<code class="language-plaintext highlighter-rouge">print_ptr_addr_size!</code>.</li>
  <li>We move <code class="language-plaintext highlighter-rouge">b_1</code> into <code class="language-plaintext highlighter-rouge">b_2</code>. The heap memory allocation does not change (does not move).
The pointee does not move. But the stack memory allocation does change (does move).
Boxes aka pointers have moved. The <code class="language-plaintext highlighter-rouge">b_1</code> variable gets dropped. We can get the address
of the pointee using <code class="language-plaintext highlighter-rouge">print_ptr_addr_size!</code> macro with <code class="language-plaintext highlighter-rouge">b_2.as_ref()</code>. We can get the
address of the pointer using <code class="language-plaintext highlighter-rouge">print_ptr_addr_size!</code> macro with <code class="language-plaintext highlighter-rouge">&amp;b_2</code>.</li>
  <li>In the assertions, we check that the heap memory allocation does <strong>not</strong> change (does
not move). And we check that the stack memory allocation <strong>does</strong> change (does move).</li>
</ol>

<h3 id="example-3-how-do-we-swap-the-contents-of-two-boxes">Example 3: How do we swap the contents of two boxes?</h3>
<p><a id="markdown-example-3%3A-how-do-we-swap-the-contents-of-two-boxes%3F" name="example-3%3A-how-do-we-swap-the-contents-of-two-boxes%3F"></a></p>

<p>Add the following snippet to the <code class="language-plaintext highlighter-rouge">lib.rs</code> file next.</p>

<div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[test]</span>
<span class="nd">#[serial]</span>
<span class="k">fn</span> <span class="nf">swap_box_contents</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">b_1</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">100u8</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">b_2</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">200u8</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">og_b_1_addr</span> <span class="o">=</span> <span class="nd">print_ptr_addr_size!</span><span class="p">(</span><span class="n">b_1</span><span class="nf">.as_ref</span><span class="p">());</span>
    <span class="k">let</span> <span class="n">og_b_2_addr</span> <span class="o">=</span> <span class="nd">print_ptr_addr_size!</span><span class="p">(</span><span class="n">b_2</span><span class="nf">.as_ref</span><span class="p">());</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="o">*</span><span class="n">b_1</span><span class="p">,</span> <span class="mi">100u8</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="o">*</span><span class="n">b_2</span><span class="p">,</span> <span class="mi">200u8</span><span class="p">);</span>

    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"1. {}: {}, {} (pointee, heap): {}, {} (ptr, stack): {}"</span><span class="p">,</span>
        <span class="s">"b_1"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="n">b_1</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">(),</span>
        <span class="s">"b_1_addr"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="n">og_b_1_addr</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.red</span><span class="p">()</span><span class="nf">.italic</span><span class="p">()</span><span class="nf">.on_black</span><span class="p">(),</span>
        <span class="s">"b_1_ptr_addr"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="nd">print_ptr_addr_size!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b_1</span><span class="p">)</span>
            <span class="nf">.clone</span><span class="p">()</span>
            <span class="nf">.magenta</span><span class="p">()</span>
            <span class="nf">.italic</span><span class="p">()</span>
            <span class="nf">.on_black</span><span class="p">(),</span>
    <span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"2. {}: {}, {} (pointee, heap): {}, {} (ptr, stack): {}"</span><span class="p">,</span>
        <span class="s">"b_2"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="n">b_2</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">(),</span>
        <span class="s">"b_2_addr"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="n">og_b_2_addr</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.magenta</span><span class="p">()</span><span class="nf">.italic</span><span class="p">()</span><span class="nf">.on_black</span><span class="p">(),</span>
        <span class="s">"b_2_ptr_addr"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="nd">print_ptr_addr_size!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b_2</span><span class="p">)</span>
            <span class="nf">.clone</span><span class="p">()</span>
            <span class="nf">.cyan</span><span class="p">()</span>
            <span class="nf">.italic</span><span class="p">()</span>
            <span class="nf">.on_black</span><span class="p">(),</span>
    <span class="p">);</span>

    <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">b_1</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">b_2</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"Swapped b_1 and b_2"</span><span class="nf">.cyan</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">());</span>

    <span class="k">let</span> <span class="n">new_b_1_addr</span> <span class="o">=</span> <span class="nd">print_ptr_addr_size!</span><span class="p">(</span><span class="n">b_1</span><span class="nf">.as_ref</span><span class="p">());</span>
    <span class="k">let</span> <span class="n">new_b_2_addr</span> <span class="o">=</span> <span class="nd">print_ptr_addr_size!</span><span class="p">(</span><span class="n">b_2</span><span class="nf">.as_ref</span><span class="p">());</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="o">*</span><span class="n">b_1</span><span class="p">,</span> <span class="mi">200u8</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="o">*</span><span class="n">b_2</span><span class="p">,</span> <span class="mi">100u8</span><span class="p">);</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">og_b_1_addr</span><span class="p">,</span> <span class="n">new_b_2_addr</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">og_b_2_addr</span><span class="p">,</span> <span class="n">new_b_1_addr</span><span class="p">);</span>

    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"3. {}: {}, {} (pointee, heap): {}, {} (ptr, stack): {}"</span><span class="p">,</span>
        <span class="s">"b_1"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="n">b_1</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">(),</span>
        <span class="s">"b_1_addr"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="n">new_b_1_addr</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.magenta</span><span class="p">()</span><span class="nf">.italic</span><span class="p">()</span><span class="nf">.on_black</span><span class="p">(),</span>
        <span class="s">"b_1_ptr_addr"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="nd">print_ptr_addr_size!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b_1</span><span class="p">)</span>
            <span class="nf">.clone</span><span class="p">()</span>
            <span class="nf">.magenta</span><span class="p">()</span>
            <span class="nf">.italic</span><span class="p">()</span>
            <span class="nf">.on_black</span><span class="p">(),</span>
    <span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"4. {}: {}, {} (pointee, heap): {}, {} (ptr, stack): {}"</span><span class="p">,</span>
        <span class="s">"b_2"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="n">b_2</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">(),</span>
        <span class="s">"b_2_addr"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="n">new_b_2_addr</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.red</span><span class="p">()</span><span class="nf">.italic</span><span class="p">()</span><span class="nf">.on_black</span><span class="p">(),</span>
        <span class="s">"b_2_ptr_addr"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="nd">print_ptr_addr_size!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b_2</span><span class="p">)</span>
            <span class="nf">.clone</span><span class="p">()</span>
            <span class="nf">.cyan</span><span class="p">()</span>
            <span class="nf">.italic</span><span class="p">()</span>
            <span class="nf">.on_black</span><span class="p">(),</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here’s the output of the test above, after you run <code class="language-plaintext highlighter-rouge">cargo watch -x "test --lib -- --show-output swap"</code>.</p>

<pre class="pre-manual-highlight">
---- swap_box_contents stdout ----
1. <span style="color:#A3BE8C">b_1</span>: <span style="color:#81A1C1"><u style="text-decoration-style:solid">100</u></span>, <span style="color:#A3BE8C">b_1_addr</span> (pointee, heap): <span style="background-color:#3B4252"><span style="color:#BF616A"><i>0x722b38000d10┆1b</i></span></span>, <span style="color:#A3BE8C">b_1_ptr_addr</span> (ptr, stack): <span style="background-color:#3B4252"><span style="color:#B48EAD"><i>0x722b3cbfdad0┆8b</i></span></span>
2. <span style="color:#A3BE8C">b_2</span>: <span style="color:#81A1C1"><u style="text-decoration-style:solid">200</u></span>, <span style="color:#A3BE8C">b_2_addr</span> (pointee, heap): <span style="background-color:#3B4252"><span style="color:#B48EAD"><i>0x722b38001f30┆1b</i></span></span>, <span style="color:#A3BE8C">b_2_ptr_addr</span> (ptr, stack): <span style="background-color:#3B4252"><span style="color:#8FBCBB"><i>0x722b3cbfdad8┆8b</i></span></span>
<span style="color:#8FBCBB"><u style="text-decoration-style:solid">Swapped b_1 and b_2</u></span>
3. <span style="color:#A3BE8C">b_1</span>: <span style="color:#81A1C1"><u style="text-decoration-style:solid">200</u></span>, <span style="color:#A3BE8C">b_1_addr</span> (pointee, heap): <span style="background-color:#3B4252"><span style="color:#B48EAD"><i>0x722b38001f30┆1b</i></span></span>, <span style="color:#A3BE8C">b_1_ptr_addr</span> (ptr, stack): <span style="background-color:#3B4252"><span style="color:#B48EAD"><i>0x722b3cbfdad0┆8b</i></span></span>
4. <span style="color:#A3BE8C">b_2</span>: <span style="color:#81A1C1"><u style="text-decoration-style:solid">100</u></span>, <span style="color:#A3BE8C">b_2_addr</span> (pointee, heap): <span style="background-color:#3B4252"><span style="color:#BF616A"><i>0x722b38000d10┆1b</i></span></span>, <span style="color:#A3BE8C">b_2_ptr_addr</span> (ptr, stack): <span style="background-color:#3B4252"><span style="color:#8FBCBB"><i>0x722b3cbfdad8┆8b</i></span></span>
</pre>

<p>Let’s walk through the output above:</p>
<ol>
  <li>We have two <code class="language-plaintext highlighter-rouge">Box</code>es <code class="language-plaintext highlighter-rouge">b_1</code> and <code class="language-plaintext highlighter-rouge">b_2</code> that point to heap allocations of <code class="language-plaintext highlighter-rouge">u8</code> with values
<code class="language-plaintext highlighter-rouge">100</code> and <code class="language-plaintext highlighter-rouge">200</code> respectively. We get the address of the pointees using
the <code class="language-plaintext highlighter-rouge">print_ptr_addr_size!</code> macro with <code class="language-plaintext highlighter-rouge">b_1.as_ref()</code> and <code class="language-plaintext highlighter-rouge">b_2.as_ref()</code>. We get the
address of the pointers using the <code class="language-plaintext highlighter-rouge">print_ptr_addr_size!</code> macro with <code class="language-plaintext highlighter-rouge">&amp;b_1</code> and <code class="language-plaintext highlighter-rouge">&amp;b_2</code>.</li>
  <li>We swap the contents of <code class="language-plaintext highlighter-rouge">b_1</code> and <code class="language-plaintext highlighter-rouge">b_2</code> using <code class="language-plaintext highlighter-rouge">std::mem::swap(&amp;mut b_1, &amp;mut b_2)</code>.
The values of <code class="language-plaintext highlighter-rouge">b_1</code> and <code class="language-plaintext highlighter-rouge">b_2</code> are now <code class="language-plaintext highlighter-rouge">200</code> and <code class="language-plaintext highlighter-rouge">100</code> respectively.</li>
  <li>We get the new addresses of the pointees using the <code class="language-plaintext highlighter-rouge">print_ptr_addr_size!</code> macro with
<code class="language-plaintext highlighter-rouge">b_1.as_ref()</code> and <code class="language-plaintext highlighter-rouge">b_2.as_ref()</code>. We get the new addresses of the pointers using the
<code class="language-plaintext highlighter-rouge">print_ptr_addr_size!</code> macro with <code class="language-plaintext highlighter-rouge">&amp;b_1</code> and <code class="language-plaintext highlighter-rouge">&amp;b_2</code>.</li>
  <li>In the assertions, we check that the values of <code class="language-plaintext highlighter-rouge">b_1</code> and <code class="language-plaintext highlighter-rouge">b_2</code> are <code class="language-plaintext highlighter-rouge">200</code> and <code class="language-plaintext highlighter-rouge">100</code>
respectively. We check that the addresses of the pointees <strong>have</strong> swapped. And we check
that the addresses of the pointers have <strong>not</strong> swapped.</li>
</ol>

<h3 id="example-4-what-does-pining-a-box-do">Example 4: What does pining a box do?</h3>
<p><a id="markdown-example-4%3A-what-does-pining-a-box-do%3F" name="example-4%3A-what-does-pining-a-box-do%3F"></a></p>

<p>Add the following code to your <code class="language-plaintext highlighter-rouge">lib.rs</code> file.</p>

<div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">box_and_pin_dynamic_duo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">b_1</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">100u8</span><span class="p">);</span>
    <span class="c1">// Pointee.</span>
    <span class="k">let</span> <span class="n">b_1_addr</span> <span class="o">=</span> <span class="nd">print_ptr_addr_size!</span><span class="p">(</span><span class="n">b_1</span><span class="nf">.as_ref</span><span class="p">());</span>

    <span class="k">let</span> <span class="n">p_b_1</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">boxed</span><span class="p">::</span><span class="nn">Box</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">into_pin</span><span class="p">(</span><span class="n">b_1</span><span class="p">);</span>
    <span class="c1">// Pinned.</span>
    <span class="k">let</span> <span class="n">p_b_1_addr</span> <span class="o">=</span> <span class="nd">print_pin_addr_size!</span><span class="p">(</span><span class="n">p_b_1</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">b_2</span> <span class="o">=</span> <span class="n">p_b_1</span><span class="p">;</span>
    <span class="c1">// println!("{}", p_b_1); // ⛔ error: use of moved value: `p_b_1`</span>

    <span class="c1">// Pin does not move.</span>
    <span class="k">let</span> <span class="n">b_2_addr</span> <span class="o">=</span> <span class="nd">print_pin_addr_size!</span><span class="p">(</span><span class="n">b_2</span><span class="p">);</span>

    <span class="c1">// Pointee has not moved!</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">b_1_addr</span><span class="p">,</span> <span class="n">b_2_addr</span><span class="p">);</span>

    <span class="c1">// Pointer has not moved!</span>
    <span class="nf">assert_three_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b_1_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p_b_1_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b_2_addr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When you run the command <code class="language-plaintext highlighter-rouge">cargo watch -x "test --lib -- --show-output dynamic"</code> it doesn’t
really produce any output.</p>

<p>Let’s walk through the code above:</p>
<ol>
  <li>We have a <code class="language-plaintext highlighter-rouge">Box</code> <code class="language-plaintext highlighter-rouge">b_1</code> that points to a heap allocation of a <code class="language-plaintext highlighter-rouge">u8</code> with a value of <code class="language-plaintext highlighter-rouge">100</code>.
We get the address of the pointee using the <code class="language-plaintext highlighter-rouge">print_ptr_addr_size!</code> macro with
<code class="language-plaintext highlighter-rouge">b_1.as_ref()</code>.</li>
  <li>We pin <code class="language-plaintext highlighter-rouge">b_1</code> into <code class="language-plaintext highlighter-rouge">p_b_1</code> using <code class="language-plaintext highlighter-rouge">std::boxed::Box::&lt;u8&gt;::into_pin(b_1)</code>. The pointee
does not move. We get the address of the pinned pointer using the
<code class="language-plaintext highlighter-rouge">print_pin_addr_size!</code> macro with <code class="language-plaintext highlighter-rouge">p_b_1</code>.</li>
  <li>We move <code class="language-plaintext highlighter-rouge">p_b_1</code> into <code class="language-plaintext highlighter-rouge">b_2</code>. The pin does not move. We get the address of the pinned
pointer using the <code class="language-plaintext highlighter-rouge">print_pin_addr_size!</code> macro with <code class="language-plaintext highlighter-rouge">b_2</code>.</li>
  <li>In the assertions, we check that the pointee has <strong>not</strong> moved. And we check that the
pointer has <strong>not</strong> moved.</li>
</ol>

<h2 id="build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</h2>
<p><a id="markdown-build-with-naz-video-series-on-developerlife.com-youtube-channel" name="build-with-naz-video-series-on-developerlife.com-youtube-channel"></a></p>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a></li>
  <li>Playlists
    <ul>
      <li><a href="https://www.youtube.com/watch?v=bolScvh4x7I&amp;list=PLofhE49PEwmw3MKOU1Kn3xbP4FRQR4Mb3">Build with Naz, Linux TTY, process, signals, commands in async Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmza94sS7UmJnN9gSCHTVTfz">Build with Naz, fundamental effective Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmwO69E7eiQ-ewnMME8ydgQ5">Build with Naz, effective async Rust and tokio</a></li>
      <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><category term="TUI" /><summary type="html"><![CDATA[This tutorial, video, and repo are a deep dive into Rust `Pin` and `Box` types, along with concepts of ownership and borrowing. We will also cover a lot of background information on the concepts of operating system process, memory allocation and access, stack, and heap. The examples we create are designed to demonstrate the different semantics around the use of boxes and pinned boxes in Rust.]]></summary></entry><entry><title type="html">Build with Naz : Rust async in practice tokio::select!, actor pattern &amp;amp; cancel safety</title><link href="http://developerlife.com/2024/07/10/rust-async-cancellation-safety-tokio/" rel="alternate" type="text/html" title="Build with Naz : Rust async in practice tokio::select!, actor pattern &amp;amp; cancel safety" /><published>2024-07-10T10:00:00-05:00</published><updated>2024-07-10T10:00:00-05:00</updated><id>http://developerlife.com/2024/07/10/rust-async-cancellation-safety-tokio</id><content type="html" xml:base="http://developerlife.com/2024/07/10/rust-async-cancellation-safety-tokio/"><![CDATA[<p><img class="post-hero-image" src="/assets/tokio-async-cancel-safety.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#what-can-go-wrong-when-racing-futures">What can go wrong when racing futures?</a></li>
  <li><a href="#youtube-video-for-this-article">YouTube video for this article</a></li>
  <li><a href="#examples-of-cancellation-safety-in-async-rust-using-tokioselect">Examples of cancellation safety in async Rust using tokio::select!</a>
    <ul>
      <li><a href="#example-1-right-and-wrong-way-to-sleep-and-interval">Example 1: Right and wrong way to sleep, and interval</a>
        <ul>
          <li><a href="#difference-between-interval-and-sleep">Difference between interval and sleep</a></li>
        </ul>
      </li>
      <li><a href="#example-2-safe-cancel-of-a-future-using-interval-and-mpsc-channel">Example 2: Safe cancel of a future using interval and mpsc channel</a></li>
      <li><a href="#example-3-inducing-cancellation-safety-issues">Example 3: Inducing cancellation safety issues</a></li>
    </ul>
  </li>
  <li><a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</a></li>
</ul>

<!-- /TOC -->

<h2 id="introduction">Introduction</h2>

<p>This tutorial, video, and repo are a deep dive into the concept of cancellation safety in
async code using Tokio and Rust. It affects the <code class="language-plaintext highlighter-rouge">tokio::select!</code> macro, and what happens
to the racing <code class="language-plaintext highlighter-rouge">Future</code>s that don’t win. The examples provided here, along with the video,
will go over both code that is is cancellation safe and code that is not. These examples
reflect real-world patterns, and are a generalized form of them.</p>

<p><code class="language-plaintext highlighter-rouge">tokio::select!</code> might as well have been called <code class="language-plaintext highlighter-rouge">tokio::race!</code> (there’s a <a href="https://en.wikipedia.org/wiki/The_Fast_and_the_Furious:_Tokyo_Drift">The Fast and
Furious : Tokyo
Drift</a> joke in there
somewhere).</p>

<p>It races the given futures in the branches of the macro, and the first one to resolve wins
(it is <code class="language-plaintext highlighter-rouge">Ready</code> when <code class="language-plaintext highlighter-rouge">poll()</code>ed). The other futures are dropped. These futures are run
concurrently, not in parallel, on the same worker thread, since we are not using
<code class="language-plaintext highlighter-rouge">tokio::spawn!</code> or its variants.</p>

<p>Here’s the basic setup:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">loop</span> <span class="p">{</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span><span class="p">{</span>
        <span class="n">branch_1_result</span> <span class="o">=</span> <span class="n">future_1</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="c1">// handle branch_1_result</span>
        <span class="p">},</span>
        <span class="n">branch_2_result</span> <span class="o">=</span> <span class="n">future_2</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="c1">// handle branch_2_result</span>
        <span class="p">},</span>
        <span class="c1">// and so on</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A classic example is that you’re reading something from an <em>async</em> network or file stream.
And you want to have a timeout that breaks out of the <code class="language-plaintext highlighter-rouge">loop</code> if it takes too long. In this
case you might have two branches:</p>
<ol>
  <li>A <code class="language-plaintext highlighter-rouge">tokio::time::sleep()</code> <code class="language-plaintext highlighter-rouge">Future</code> in the timeout branch.</li>
  <li>Some code to get the data asynchronously from the stream in the other branch.</li>
</ol>

<blockquote>
  <p>Another example is that you might be waiting for the user to type something from the
keyboard or mouse (such as a TUI app) and also listen for signals to shut down the app,
or other signals to perform re-rendering of the TUI. You can see this <a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/terminal_window/main_event_loop.rs#L94">in <code class="language-plaintext highlighter-rouge">r3bl_tui</code>
here</a>
and <a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/terminal_async/src/readline_impl/readline.rs#L468">in <code class="language-plaintext highlighter-rouge">r3bl_terminal_async</code>
here</a>.</p>
</blockquote>

<p>Note that all branches must have a <code class="language-plaintext highlighter-rouge">Future</code> to call <code class="language-plaintext highlighter-rouge">.await</code> on. The macro does not
require you to call <code class="language-plaintext highlighter-rouge">.await</code>. The code it generates take care of this.</p>

<blockquote>
  <p>It might be worth your time (if you haven’t already) to read the <a href="https://docs.rs/tokio/latest/tokio/macro.select.html#cancellation-safety">official Tokio
docs</a> on
<code class="language-plaintext highlighter-rouge">tokio::select!</code> macro and the concept of cancellation safety before diving into the
examples below.</p>
</blockquote>

<h2 id="what-can-go-wrong-when-racing-futures">What can go wrong when racing futures?</h2>

<p>If you recall, in Rust, a <code class="language-plaintext highlighter-rouge">Future</code> is just a data structure that doesn’t really do
anything until you <code class="language-plaintext highlighter-rouge">.await</code> it.</p>
<ul>
  <li>The Tokio runtime actually does work on the <code class="language-plaintext highlighter-rouge">Future</code>s by polling them to see whether
they are <code class="language-plaintext highlighter-rouge">Ready</code> or <code class="language-plaintext highlighter-rouge">Pending</code>.</li>
  <li>If they’re not <code class="language-plaintext highlighter-rouge">Ready</code> they go back to waiting until their <code class="language-plaintext highlighter-rouge">Waker</code> is called, and then
Tokio will <code class="language-plaintext highlighter-rouge">poll()</code> them again.</li>
  <li>They are cheap to create, they are stateful, and they can be nested (easily composed).</li>
</ul>

<blockquote>
  <p>Please read our article on <a href="https://developerlife.com/2024/05/19/effective-async-rust/">effective async
Rust</a> to get a better
understanding of how async Rust, and <code class="language-plaintext highlighter-rouge">Future</code>s works and how runtimes are implemented.</p>
</blockquote>

<p>These are some of the great things about Rust <code class="language-plaintext highlighter-rouge">Future</code>s. However, the nature of a Rust
<code class="language-plaintext highlighter-rouge">Future</code> is what may cause a problem with “cancellation safety” in the <code class="language-plaintext highlighter-rouge">tokio::select!</code>
macro.</p>

<p>So what happens to <code class="language-plaintext highlighter-rouge">future_2</code> (the branch reading or writing from an async stream) if the
timeout branch (for <code class="language-plaintext highlighter-rouge">future_1</code>) wins the race?</p>
<ul>
  <li>Is the <code class="language-plaintext highlighter-rouge">future_2</code> in the middle of doing something when this happens?</li>
  <li>And if so, what happens to the work it was doing when it hits the <code class="language-plaintext highlighter-rouge">.await</code> point in its
code, and then stops?</li>
</ul>

<p>This is the crux of the issue with cancellation safety in async Rust code. Lots of <code class="language-plaintext highlighter-rouge">tokio</code>
code is built to be cancellation safe, so if you’re using <code class="language-plaintext highlighter-rouge">mpsc</code> or <code class="language-plaintext highlighter-rouge">broadcast</code> channels,
async streams, etc. you will be fine. However if you’re maintaining state inside the
<code class="language-plaintext highlighter-rouge">future_2</code> and then it is dropped, then this article will help you understand what
happens.</p>

<h2 id="youtube-video-for-this-article">YouTube video for this article</h2>

<p>This blog post has examples from this live coding video. If you like
to learn via video, please watch the companion video on the <a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube
channel</a>.</p>

<!-- video on tokio-async-cancel-safety -->
<iframe src="https://www.youtube.com/embed/cQq5i8J1ELg?si=UDgJdFFQn0-yNXsS" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<p><br /></p>

<h2 id="examples-of-cancellation-safety-in-async-rust-using-tokioselect">Examples of cancellation safety in async Rust using tokio::select!</h2>

<p>Let’s create some examples to illustrate how to use the typestate pattern in Rust. You can run
<code class="language-plaintext highlighter-rouge">cargo new --lib async_cancel_safe</code> to create a new library crate.</p>

<blockquote>
  <p>💡 You can get the code from the
<a href="https://github.com/nazmulidris/rust-scratch/tree/main/async_cancel_safe"><code class="language-plaintext highlighter-rouge">rust-scratch</code></a> repo.</p>
</blockquote>

<p>Then add the following to the <code class="language-plaintext highlighter-rouge">Cargo.toml</code> file that’s generated. These pull in all the
dependencies that we need for these examples.</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[package]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"async_cancel_safe"</span>
<span class="py">version</span> <span class="p">=</span> <span class="s">"0.1.0"</span>
<span class="py">edition</span> <span class="p">=</span> <span class="s">"2021"</span>

<span class="nn">[dependencies]</span>
<span class="py">tokio</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"1.38.0"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"full"</span><span class="p">]</span> <span class="p">}</span>

<span class="c"># Async stream testing.</span>
<span class="py">r3bl_test_fixtures</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.0.2"</span> <span class="p">}</span>
<span class="py">futures-util</span> <span class="p">=</span> <span class="s">"0.3.30"</span>
</code></pre></div></div>

<p>We are going to add all the examples below as tests to the <code class="language-plaintext highlighter-rouge">lib.rs</code> file in this crate.</p>

<h3 id="example-1-right-and-wrong-way-to-sleep-and-interval">Example 1: Right and wrong way to sleep, and interval</h3>

<p>Add the following code to your <code class="language-plaintext highlighter-rouge">lib.rs</code> file. Both these examples show similar ways of using
<code class="language-plaintext highlighter-rouge">tokio::time::sleep(..)</code> incorrectly in a <code class="language-plaintext highlighter-rouge">tokio::select!</code> block.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Equivalent to [test_sleep_right_and_wrong_ways_v2]. This test uses</span>
<span class="cd">/// [`tokio::pin`] and [`tokio::time::sleep`].</span>
<span class="cd">/// Run the test using:</span>
<span class="cd">/// `cargo test -- --nocapture test_sleep_right_and_wrong_ways_v1`</span>
<span class="nd">#[tokio::test]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">test_sleep_right_and_wrong_ways_v1</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">sleep_time</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">duration</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="n">sleep_time</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">sleep</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="n">duration</span><span class="p">);</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nd">pin!</span><span class="p">(</span><span class="n">sleep</span><span class="p">);</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span> <span class="p">{</span>
            <span class="c1">// Branch 1 (right way)</span>
            <span class="c1">// This branch executes a deterministic number of times. The same</span>
            <span class="c1">// sleep future is re-used on each iteration. Once the sleep "expires"</span>
            <span class="c1">// it stays "expired"! This is the desired behavior:</span>
            <span class="c1">// https://docs.rs/tokio/latest/tokio/time/struct.Sleep.html</span>
            <span class="n">_</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">sleep</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"branch 1 - tick : {count}"</span><span class="p">);</span>
                <span class="n">count</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="c1">// Branch 2 (wrong way)</span>
            <span class="c1">// This branch is executed a non deterministic number of times.</span>
            <span class="c1">// This is because the sleep future is not pinned. It is dropped</span>
            <span class="c1">// when the other branch is executed. Then on the next iteration,</span>
            <span class="c1">// a new sleep future is created.</span>
            <span class="n">_</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"branch 2 - sleep"</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cd">/// Equivalent to [test_sleep_right_and_wrong_ways_v1]. This test uses</span>
<span class="cd">/// [`tokio::time::interval()`]</span>
<span class="cd">/// Run the test using:</span>
<span class="cd">/// `cargo test -- --nocapture test_sleep_right_and_wrong_ways_v2`</span>
<span class="nd">#[tokio::test]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">test_sleep_right_and_wrong_ways_v2</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">sleep_time</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">duration</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="n">sleep_time</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">interval</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">interval</span><span class="p">(</span><span class="n">duration</span><span class="p">);</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span> <span class="p">{</span>
            <span class="c1">// Branch 1 (right way)</span>
            <span class="c1">// This branch executes a deterministic number of times. The same</span>
            <span class="c1">// sleep future is re-used on each iteration.</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">interval</span><span class="nf">.tick</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"branch 1 - tick : {count}"</span><span class="p">);</span>
                <span class="n">count</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="c1">// Branch 2 (wrong way)</span>
            <span class="c1">// This branch is executed a non deterministic number of times.</span>
            <span class="c1">// This is because the sleep future is not pinned. It is dropped</span>
            <span class="c1">// when the other branch is executed. Then on the next iteration,</span>
            <span class="c1">// a new sleep future is created.</span>
            <span class="n">_</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"branch 2 - sleep"</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>You can run these tests to see what they do by running the following in your terminal:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">cargo test -- --nocapture test_sleep_right_and_wrong_ways_v1</code></li>
  <li><code class="language-plaintext highlighter-rouge">cargo test -- --nocapture test_sleep_right_and_wrong_ways_v2</code></li>
</ul>

<p>They are flaky and its not possible to really make accurate assertions at the end of
each of these tests.</p>

<p>Let’s break down <code class="language-plaintext highlighter-rouge">v1</code> first to see what is happening. Here’s the output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---- test_sleep_right_and_wrong_ways_v1 stdout ----
branch 2 - sleep : 5, elapsed: 101 ms
branch 1 - tick : 5, elapsed: 101 ms
branch 1 - tick : 4, elapsed: 101 ms
branch 1 - tick : 3, elapsed: 101 ms
branch 1 - tick : 2, elapsed: 101 ms
branch 1 - tick : 1, elapsed: 101 msk
</code></pre></div></div>

<ul>
  <li>Branch 1 (right way): This branch executes a deterministic number of times. The same
sleep future is re-used on each iteration. This is achieved using the <code class="language-plaintext highlighter-rouge">tokio::pin!</code>
macro. Here are the <a href="https://docs.rs/tokio/latest/tokio/time/struct.Sleep.html">docs</a> on
how to use <code class="language-plaintext highlighter-rouge">Sleep</code> in <code class="language-plaintext highlighter-rouge">tokio::select!</code> blocks. Since futures are stateful, ensuring that
the same one is re-used between iterations of the <code class="language-plaintext highlighter-rouge">loop</code> ensures that state isn’t lost
when the other branch is executed, or when this branch finishes and its future is
dropped. Notice that the first time in <code class="language-plaintext highlighter-rouge">branch 1</code> the code waits for 100ms, and then the
subsequent 4 iterations of the loop do not wait at all! This is because the <code class="language-plaintext highlighter-rouge">sleep</code>
future is in a <code class="language-plaintext highlighter-rouge">Ready</code> state after the first iteration, and effectively, we only wait
100ms in this loop. For those familiar with Javascript, this is akin to <code class="language-plaintext highlighter-rouge">setTimeout</code> and
not <code class="language-plaintext highlighter-rouge">setInterval</code> semantics.</li>
  <li>Branch 2 (wrong way): This branch is executed a non deterministic number of times. This
is because the sleep future is not pinned. It is dropped when the other branch is
executed. Then on the next iteration, a <strong>new</strong> sleep future is created. This means that
the state of the future is lost, and its behavior with providing a reliable delay is
non deterministic.</li>
</ul>

<p>Let’s break down <code class="language-plaintext highlighter-rouge">v2</code> next.</p>

<ul>
  <li>Branch 1 (right way): This branch executes a deterministic number of times. However, we
are using <code class="language-plaintext highlighter-rouge">tokio::time::interval()</code> this time around. It is re-used between many
iterations of the <code class="language-plaintext highlighter-rouge">loop</code>. This function returns a <code class="language-plaintext highlighter-rouge">Interval</code> struct that has a <code class="language-plaintext highlighter-rouge">tick()</code>
method that returns a <code class="language-plaintext highlighter-rouge">Future</code> that resolves when the interval has elapsed.</li>
  <li>Branch 2 (wrong way): Same as before.</li>
</ul>

<h4 id="difference-between-interval-and-sleep">Difference between interval and sleep</h4>

<p>This is the mental model that I’ve developed for using these.</p>

<ol>
  <li>If your intention is to have a single timeout then, <code class="language-plaintext highlighter-rouge">sleep</code> might be the way to go. You
create and <code class="language-plaintext highlighter-rouge">tokio::pin!</code> the <code class="language-plaintext highlighter-rouge">sleep</code> future, and then re-use it in the <code class="language-plaintext highlighter-rouge">loop</code>. Once
this timeout expires, then you can handle your timeout condition in that branch.</li>
  <li>If your intention is to have a re-usable timer that ticks on a regular interval, then
<code class="language-plaintext highlighter-rouge">interval</code> is the way to go. You create the <code class="language-plaintext highlighter-rouge">interval</code> outside the <code class="language-plaintext highlighter-rouge">loop</code>, and then
call <code class="language-plaintext highlighter-rouge">tick()</code> on it in the <code class="language-plaintext highlighter-rouge">loop</code>. This will give you a <code class="language-plaintext highlighter-rouge">Future</code> that resolves when the
interval has elapsed. And you can safely use this same <code class="language-plaintext highlighter-rouge">Interval</code> repeatedly in the
loop. And even accumulate how many times it runs to decide when to break.</li>
</ol>

<h3 id="example-2-safe-cancel-of-a-future-using-interval-and-mpsc-channel">Example 2: Safe cancel of a future using interval and mpsc channel</h3>

<p>Add the following snippet to your <code class="language-plaintext highlighter-rouge">lib.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Run the test using:</span>
<span class="cd">/// `cargo test -- --nocapture test_safe_cancel_example`</span>
<span class="nd">#[tokio::test]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">test_safe_cancel_example</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">sleep_time</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">duration</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="n">sleep_time</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">interval</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">interval</span><span class="p">(</span><span class="n">duration</span><span class="p">);</span>

    <span class="c1">// Shutdown channel.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="k">mut</span> <span class="n">rx</span><span class="p">)</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">mpsc</span><span class="p">::</span><span class="nf">channel</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">vec</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span> <span class="p">{</span>
            <span class="c1">// Branch 1.</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">interval</span><span class="nf">.tick</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"branch 1 - tick : count {}"</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

                <span class="n">vec</span><span class="nf">.push</span><span class="p">(</span><span class="n">count</span><span class="p">);</span>
                <span class="n">count</span> <span class="o">=</span> <span class="n">count</span><span class="nf">.saturating_sub</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

                <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="n">_</span> <span class="o">=</span> <span class="n">tx</span><span class="nf">.try_send</span><span class="p">(());</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="c1">// Branch 2.</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">rx</span><span class="nf">.recv</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"branch 2 =&gt; shut down"</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When you run this test using <code class="language-plaintext highlighter-rouge">cargo test -- --nocapture test_safe_cancel_example</code>, you should
get this output in your terminal:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>running 1 test
branch 1 - tick : count 5
branch 1 - tick : count 4
branch 1 - tick : count 3
branch 1 - tick : count 2
branch 1 - tick : count 1
branch 2 =&gt; shut down
</code></pre></div></div>

<p>Let’s break down what’s happening in this test.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Branch 1</code> - The <code class="language-plaintext highlighter-rouge">interval</code> is created outside the <code class="language-plaintext highlighter-rouge">loop</code> and is used to create a
<code class="language-plaintext highlighter-rouge">Future</code> that resolves when the interval has elapsed. This happens in <code class="language-plaintext highlighter-rouge">Branch 1</code> and we
let this branch run <code class="language-plaintext highlighter-rouge">5</code> times before sending a message on the <code class="language-plaintext highlighter-rouge">tx</code> channel.</li>
  <li><code class="language-plaintext highlighter-rouge">Branch 2</code> - The <code class="language-plaintext highlighter-rouge">tx</code> channel is used to send a message to the <code class="language-plaintext highlighter-rouge">rx</code> channel. This is
done in <code class="language-plaintext highlighter-rouge">Branch 1</code> when <code class="language-plaintext highlighter-rouge">count</code> reaches <code class="language-plaintext highlighter-rouge">0</code>. The <code class="language-plaintext highlighter-rouge">rx</code> channel is used to receive a
message. This is done in <code class="language-plaintext highlighter-rouge">Branch 2</code> and when a message is received, we break out of the
<code class="language-plaintext highlighter-rouge">loop</code>.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">Branch 1</code> runs 5 times, and <code class="language-plaintext highlighter-rouge">Branch 1</code> runs 1 time and breaks out of the loop. If you
look at the <code class="language-plaintext highlighter-rouge">vec</code> that we accumulate outside of the <code class="language-plaintext highlighter-rouge">loop</code> this contains what we expect.</p>

<h3 id="example-3-inducing-cancellation-safety-issues">Example 3: Inducing cancellation safety issues</h3>

<p>This is the example we have all been waiting for. Let’s start with copying the
following snippet in your <code class="language-plaintext highlighter-rouge">lib.rs</code> file. We will create a new module here.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="k">pub</span> <span class="k">mod</span> <span class="n">test_unsafe_cancel_example</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">r3bl_test_fixtures</span><span class="p">::{</span><span class="n">gen_input_stream_with_delay</span><span class="p">,</span> <span class="n">PinnedInputStream</span><span class="p">};</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_input_vec</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_stream_delay</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="n">Duration</span> <span class="p">{</span>
        <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">get_input_stream</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">PinnedInputStream</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">gen_input_stream_with_delay</span><span class="p">(</span><span class="nf">get_input_vec</span><span class="p">(),</span> <span class="nf">get_stream_delay</span><span class="p">())</span>
    <span class="p">}</span>

    <span class="cd">/// This is just to see how to use the async stream [gen_input_stream()].</span>
    <span class="nd">#[tokio::test]</span>
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">test_generate_event_stream_pinned</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">use</span> <span class="nn">futures_util</span><span class="p">::</span><span class="n">StreamExt</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">stream</span> <span class="o">=</span> <span class="nf">get_stream</span><span class="p">();</span>

        <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">=</span> <span class="n">stream</span><span class="nf">.next</span><span class="p">()</span><span class="k">.await</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">lhs</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">rhs</span> <span class="o">=</span> <span class="nf">get_input_vec</span><span class="p">()[</span><span class="n">count</span><span class="p">];</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// &lt;more stuff to add later&gt;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Let’s break down what’s happening here.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">get_input_vec()</code> - This function returns a <code class="language-plaintext highlighter-rouge">Vec&lt;usize&gt;</code> that we will use to generate
events in the <code class="language-plaintext highlighter-rouge">gen_input_stream()</code> function. This is meant to simulate the stream of
<code class="language-plaintext highlighter-rouge">usize</code> values that may be generated from reading a file or a network source. Or even
write to a file or network source. We could have just made these <code class="language-plaintext highlighter-rouge">u8</code>, but this is a
made up test, so we are using <code class="language-plaintext highlighter-rouge">usize</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">gen_input_stream()</code> - This is where things get interesting. This function creates an
async stream that yields the values from the <code class="language-plaintext highlighter-rouge">Vec&lt;usize&gt;</code> returned by <code class="language-plaintext highlighter-rouge">get_input_vec()</code>.
It waits for <code class="language-plaintext highlighter-rouge">100ms</code> between each value that it yields. This is to simulate the delay
that might be present when reading from a file or network source. Note the trait magic
and imports that are used to make this work; to get the details on this, check our
article on <a href="https://developerlife.com/2024/04/28/rust-polymorphism-dyn-impl-trait-objects-for-testing-and-extensibiity/">trait pointers and
testing</a>.</li>
  <li>These two functions are our test fixture to simulate a slow async stream. Now, let’s
test the test fixtures in <code class="language-plaintext highlighter-rouge">test_generate_event_stream_pinned()</code>. This test simply reads
from the async stream and compares the values that it reads with the values that are
expected from the <code class="language-plaintext highlighter-rouge">Vec&lt;usize&gt;</code> returned by <code class="language-plaintext highlighter-rouge">get_input_vec()</code>.</li>
</ul>

<blockquote>
  <p>You can get the <code class="language-plaintext highlighter-rouge">r3bl_test_fixtures</code> <a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/test_fixtures">source
here</a>. You can get
the crate from <a href="https://crates.io/crates/r3bl_test_fixtures">crates.io</a>.</p>
</blockquote>

<p>In <code class="language-plaintext highlighter-rouge">lib.rs</code> replace the <code class="language-plaintext highlighter-rouge">// &lt;more stuff to add later&gt;</code> with the following code:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// There is no need to [futures_util::FutureExt::fuse()] the items in each</span>
<span class="cd">/// [tokio::select!] branch. This is because Tokio's event loop is designed to handle</span>
<span class="cd">/// this efficiently by remembering the state of each future across iterations.</span>
<span class="cd">///</span>
<span class="cd">/// More info: &lt;https://gemini.google.com/app/e55fd62339b674fb&gt;</span>
<span class="nd">#[rustfmt::skip]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">read_3_items_not_cancel_safe</span><span class="p">(</span><span class="n">stream</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">PinnedInputStream</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">use</span> <span class="nn">futures_util</span><span class="p">::</span><span class="n">StreamExt</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">vec</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"branch 2 =&gt; entering read_3_items_not_cancel_safe"</span><span class="p">);</span>

    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">3</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">item</span> <span class="o">=</span> <span class="n">stream</span><span class="nf">.next</span><span class="p">()</span> <span class="cm">/* .fuse() */</span> <span class="k">.await</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"branch 2 =&gt; read_3_items_not_cancel_safe got item: {item}"</span><span class="p">);</span>
        <span class="n">vec</span><span class="nf">.push</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"branch 2 =&gt; vec so far contains: {vec:?}"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">vec</span>
<span class="p">}</span>

<span class="cd">/// There is no need to [futures_util::FutureExt::fuse()] the items in each</span>
<span class="cd">/// [tokio::select!] branch. This is because Tokio's event loop is designed to handle</span>
<span class="cd">/// this efficiently by remembering the state of each future across iterations.</span>
<span class="cd">///</span>
<span class="cd">/// More info: &lt;https://gemini.google.com/app/e55fd62339b674fb&gt;</span>
<span class="nd">#[tokio::test]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">test_unsafe_cancel_stream</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">futures_util</span><span class="p">::</span><span class="n">StreamExt</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">stream</span> <span class="o">=</span> <span class="nf">get_input_stream</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">sleep_time</span> <span class="o">=</span> <span class="mi">300</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">duration</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="n">sleep_time</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">sleep</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="n">duration</span><span class="p">);</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nd">pin!</span><span class="p">(</span><span class="n">sleep</span><span class="p">);</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span> <span class="p">{</span>
            <span class="c1">// Branch 1 - Timeout.</span>
            <span class="n">_</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">sleep</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"branch 1 - time is up - end"</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// Branch 2 - Read from stream.</span>
            <span class="n">it</span> <span class="o">=</span> <span class="nf">read_3_items_not_cancel_safe</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">stream</span><span class="p">)</span> <span class="cm">/* .fuse() */</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"branch 2 - got 3 items: {it:?}"</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"loop exited"</span><span class="p">);</span>

    <span class="c1">// Only [1, 2] is consumed by Branch 2 before the timeout happens</span>
    <span class="c1">// in Branch 1.</span>
    <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="n">stream</span><span class="nf">.next</span><span class="p">()</span><span class="k">.await</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When you run this test using <code class="language-plaintext highlighter-rouge">cargo test -- --nocapture test_unsafe_cancel_stream</code>, you
can expect the following output in your terminal.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>branch 2 =&gt; entering read_3_items_not_cancel_safe
yielding item: 1
branch 2 =&gt; read_3_items_not_cancel_safe got item: 1
branch 2 =&gt; vec so far contains: [1]
yielding item: 2
branch 2 =&gt; read_3_items_not_cancel_safe got item: 2
branch 2 =&gt; vec so far contains: [1, 2]
branch 1 - time is up - end
loop exited
yielding item: 3
</code></pre></div></div>

<p>So let’s break down what’s happening in this test.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Branch 1</code> - This branch is a timeout branch. It waits for <code class="language-plaintext highlighter-rouge">300ms</code> before breaking out
of the loop. This is to simulate a timeout that might happen when reading from a file or
network source. With this delay, we ensure that <code class="language-plaintext highlighter-rouge">Branch 2</code> doesn’t get to read all the
values from the async stream. And thus we induce a cancellation safety issue, due the
way <code class="language-plaintext highlighter-rouge">read_3_items_not_cancel_safe()</code> is implemented.</li>
  <li><code class="language-plaintext highlighter-rouge">Branch 2</code> - This branch needs to reads <code class="language-plaintext highlighter-rouge">3</code> items from the async stream before
resolving. This is done in a loop that reads <code class="language-plaintext highlighter-rouge">3</code> items in
<code class="language-plaintext highlighter-rouge">read_3_items_not_cancel_safe()</code>. This is not safe because if the timeout branch wins
the race, then the stream is dropped and the <code class="language-plaintext highlighter-rouge">read_3_items_not_cancel_safe()</code> future is
dropped, along with the contained <code class="language-plaintext highlighter-rouge">vec</code>! This means that the stream is dropped before
all the items are read from it. This is the cancellation safety issue that we are
inducing in this test.</li>
</ul>

<p>There are many ways to resolve this. The key is not to hold state inside of a <code class="language-plaintext highlighter-rouge">Future</code>
that you don’t want to lose if the <code class="language-plaintext highlighter-rouge">Future</code> is dropped. You can use <code class="language-plaintext highlighter-rouge">mpsc</code> channels or a
pinned <code class="language-plaintext highlighter-rouge">Vec</code> to get around this issue.</p>

<blockquote>
  <p>Note that in the case of a graceful shutdown, where you might not care about what data
in some buffer is dropped, then this is not a problem.</p>
</blockquote>

<h2 id="build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</h2>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a></li>
  <li>Playlists
    <ul>
      <li><a href="https://www.youtube.com/watch?v=bolScvh4x7I&amp;list=PLofhE49PEwmw3MKOU1Kn3xbP4FRQR4Mb3">Build with Naz, Linux TTY, process, signals, commands in async Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmza94sS7UmJnN9gSCHTVTfz">Build with Naz, fundamental effective Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmwO69E7eiQ-ewnMME8ydgQ5">Build with Naz, effective async Rust and tokio</a></li>
      <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><category term="TUI" /><summary type="html"><![CDATA[This tutorial, video, and repo are a deep dive into the concept of cancellation safety in async code using Tokio and Rust. It affects the `tokio::select!` macro, and what happens to the racing `Future`s that don't win. The examples provided here, along with the video, will go over both code that is is cancellation safe and code that is not. These examples reflect real-world patterns, and are a generalized form of them.]]></summary></entry><entry><title type="html">Build with Naz : Ubuntu 24.04 setup and config for dev productivity</title><link href="http://developerlife.com/2024/07/08/ubuntu24/" rel="alternate" type="text/html" title="Build with Naz : Ubuntu 24.04 setup and config for dev productivity" /><published>2024-07-08T10:00:00-05:00</published><updated>2024-07-08T10:00:00-05:00</updated><id>http://developerlife.com/2024/07/08/ubuntu24</id><content type="html" xml:base="http://developerlife.com/2024/07/08/ubuntu24/"><![CDATA[<p><img class="post-hero-image" src="/assets/ubuntu24.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#related-videos">Related videos</a></li>
  <li><a href="#what-comes-with-the-scripts">What comes with the scripts</a></li>
  <li><a href="#running-the-scripts">Running the scripts</a></li>
  <li><a href="#gnome-extensions">Gnome Extensions</a></li>
  <li><a href="#keyboard-remapping">Keyboard remapping</a>
    <ul>
      <li><a href="#tilix-and-quake-mode">Tilix and quake mode</a></li>
      <li><a href="#remap-superq">Remap Super+Q</a></li>
      <li><a href="#remap-caps-lock-to-ctrl">Remap Caps Lock to Ctrl</a></li>
    </ul>
  </li>
  <li><a href="#chrome-issues-w-wayland">Chrome issues w/ Wayland</a></li>
  <li><a href="#libfuse2-and-appimage-issues">libfuse2 and AppImage issues</a>
    <ul>
      <li><a href="#approach-1---simple">Approach 1 - simple</a></li>
      <li><a href="#approach-2---complex">Approach 2 - complex</a></li>
    </ul>
  </li>
  <li><a href="#settings---key-mappings">Settings -&gt; Key mappings</a></li>
  <li><a href="#obs-studio-issues">OBS Studio issues</a></li>
  <li><a href="#fontconfig">Fontconfig</a></li>
  <li><a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</a></li>
</ul>

<!-- /TOC -->

<h2 id="introduction">Introduction</h2>
<p><a id="markdown-introduction" name="introduction"></a></p>

<p>I’ve provided scripts for setting up a new Ubuntu 24.04 desktop machine. They have been
tested on a fresh install of Ubuntu 24.04 LTS. They contain all the software that is
needed for Rust development, OBS Studio use, and general developer productivity. They are
highly opinionated for my use case, but you can modify them to suit your needs. I’ve also
recently migrated from Pop_OS! 22.04.</p>

<h2 id="related-videos">Related videos</h2>
<p><a id="markdown-related-videos" name="related-videos"></a></p>

<p>This video shows what the scripts do after you run them, and how they make your Ubuntu
24.04 desktop environment look and feel. This article is really a companion to the video.</p>

<!-- linux keyboard productivity guide -->
<iframe src="https://www.youtube.com/embed/iNSnvfguChU?si=kxcIa6lI9ZX2WfHz" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<p><br />
This video is all about keyboard customization and productivity on Linux. It’s a great
companion to the scripts that I’ve provided in this article. It is highly reliant on the
use of the <a href="https://ultimatehackingkeyboard.com/">UHK v2 keyboard</a>.</p>

<!-- video on ubuntu24 -->
<iframe src="https://www.youtube.com/embed/zGljNewTc0I?si=D5-5P0afPVBw-3IB" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<p><br /></p>

<h2 id="what-comes-with-the-scripts">What comes with the scripts</h2>
<p><a id="markdown-what-comes-with-the-scripts" name="what-comes-with-the-scripts"></a></p>

<blockquote>
  <p>💡 You can get the scripts from the
<a href="https://github.com/nazmulidris/rust-scratch/tree/main/ubuntu24"><code class="language-plaintext highlighter-rouge">rust-scratch</code></a> repo.</p>
</blockquote>

<p>Here is a non exhaustive list of software that will be installed:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">fish</code> as the default login shell. All the configuration scripts are written in <code class="language-plaintext highlighter-rouge">fish</code>.
 <code class="language-plaintext highlighter-rouge">bass</code> is also installed to allow for running <code class="language-plaintext highlighter-rouge">bash</code> scripts in <code class="language-plaintext highlighter-rouge">fish</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">rustup</code>, <code class="language-plaintext highlighter-rouge">brew</code>, and <code class="language-plaintext highlighter-rouge">flatpak</code> with <code class="language-plaintext highlighter-rouge">flathub</code> as package managers.</li>
  <li><code class="language-plaintext highlighter-rouge">docker</code> and <code class="language-plaintext highlighter-rouge">docker-compose</code> for containerization.</li>
  <li><code class="language-plaintext highlighter-rouge">obs-studio</code> for screen recording and streaming.</li>
  <li><code class="language-plaintext highlighter-rouge">vlc</code>, <code class="language-plaintext highlighter-rouge">mpv</code> for media playback.</li>
  <li><code class="language-plaintext highlighter-rouge">chrome</code> for web browsing.</li>
  <li><code class="language-plaintext highlighter-rouge">vscode</code> for code editing.</li>
  <li>Lots of Gnome extensions for desktop customization.</li>
  <li><code class="language-plaintext highlighter-rouge">nerd-fonts</code> for terminal font customization. Along with <code class="language-plaintext highlighter-rouge">guake</code> and <code class="language-plaintext highlighter-rouge">tilix</code> for
 terminal emulators. Along with <code class="language-plaintext highlighter-rouge">tmux</code> for terminal multiplexing.</li>
</ol>

<blockquote>
  <p>To download Ubuntu 24.04, visit the <a href="https://ubuntu.com/download/desktop">Ubuntu
website</a> and prepare a USB drive with the ISO file
for installation. You can use <a href="https://flathub.org/apps/com.system76.Popsicle">Popsicle</a>
to create a bootable USB drive.</p>
</blockquote>

<h2 id="running-the-scripts">Running the scripts</h2>
<p><a id="markdown-running-the-scripts" name="running-the-scripts"></a></p>

<p>Lots of customized font configurations are included in the scripts. You can clone the repo
and run the scripts, or just copy the links below and run them in your terminal.</p>

<p>You can run the following commands to get this on your machine. The first script
<code class="language-plaintext highlighter-rouge">0-bootstrap.bash</code> has to be installed first. It installs <code class="language-plaintext highlighter-rouge">fish</code> shell and makes it the
default and installs <code class="language-plaintext highlighter-rouge">flatpak</code> and <code class="language-plaintext highlighter-rouge">flatpak flathub</code>. It also installs <code class="language-plaintext highlighter-rouge">bass</code> to allow
running bash scripts in fish. The remainder of the scripts can be run in any order.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> curl git
<span class="nb">cd</span> ~/Downloads/
git clone https://github.com/nazmulidris/rust-scratch/
<span class="nb">cd </span>rust-scratch/ubuntu24/
./0-bootstrap.bash
<span class="c"># You will need to reboot after running the 0-bootstrap.bash script</span>
</code></pre></div></div>

<p>Once you reboot, you can run the following scripts.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> ~/Downloads/rust-scratch/ubuntu24/
./1-install.fish
./2-install-docker.bash
./3-install-fonts.fish
</code></pre></div></div>

<p>You can see the contents of the scripts by clicking on the links below:</p>

<ol>
  <li><a href="https://raw.githubusercontent.com/nazmulidris/rust-scratch/main/ubuntu24/0-bootstrap.bash">https://raw.githubusercontent.com/nazmulidris/rust-scratch/main/ubuntu24/0-bootstrap.bash</a></li>
  <li><a href="https://raw.githubusercontent.com/nazmulidris/rust-scratch/main/ubuntu24/1-install.fish">https://raw.githubusercontent.com/nazmulidris/rust-scratch/main/ubuntu24/1-install.fish</a></li>
  <li><a href="https://raw.githubusercontent.com/nazmulidris/rust-scratch/main/ubuntu24/2-install-docker.bash">https://raw.githubusercontent.com/nazmulidris/rust-scratch/main/ubuntu24/2-install-docker.bash</a></li>
  <li><a href="https://raw.githubusercontent.com/nazmulidris/rust-scratch/main/ubuntu24/3-install-fonts.fish">https://raw.githubusercontent.com/nazmulidris/rust-scratch/main/ubuntu24/3-install-fonts.fish</a></li>
</ol>

<p>Optional scripts:</p>
<ol>
  <li><a href="https://github.com/nazmulidris/rust-scratch/blob/main/ubuntu24/install-agent-into-bin.fish">https://github.com/nazmulidris/rust-scratch/blob/main/ubuntu24/install-agent-into-bin.fish</a></li>
  <li><a href="https://github.com/nazmulidris/rust-scratch/blob/main/ubuntu24/fix-gnome-session-path-env-var-linuxbrew.fish">https://github.com/nazmulidris/rust-scratch/blob/main/ubuntu24/fix-gnome-session-path-env-var-linuxbrew.fish</a></li>
  <li><a href="https://github.com/nazmulidris/rust-scratch/blob/main/ubuntu24/fix-usr-local-bin-symlinks.fish">https://github.com/nazmulidris/rust-scratch/blob/main/ubuntu24/fix-usr-local-bin-symlinks.fish</a></li>
</ol>

<h2 id="gnome-extensions">Gnome Extensions</h2>
<p><a id="markdown-gnome-extensions" name="gnome-extensions"></a></p>

<ul>
  <li><a href="https://extensions.gnome.org/extension/4548/tactile/">Tactile tiling support</a></li>
  <li><a href="https://extensions.gnome.org/extension/7065/tiling-shell/">Tiling shell tiling support</a></li>
  <li><a href="https://extensions.gnome.org/extension/5660/weather-or-not/">Weather in top bar</a></li>
  <li><a href="https://extensions.gnome.org/extension/1460/vitals/">Vitals in top bar</a></li>
  <li><a href="https://extensions.gnome.org/extension/6242/emoji-copy/">Emoji chooser in top bar</a></li>
  <li><a href="https://extensions.gnome.org/extension/4839/clipboard-history/">Clipboard history</a></li>
  <li><a href="https://extensions.gnome.org/extension/4679/burn-my-windows/">Burn my windows animation for window open and close</a></li>
  <li><a href="https://extensions.gnome.org/extension/3843/just-perfection/">Just Perfection ultra GNOME customization</a></li>
</ul>

<h2 id="keyboard-remapping">Keyboard remapping</h2>
<p><a id="markdown-keyboard-remapping" name="keyboard-remapping"></a></p>

<h3 id="tilix-and-quake-mode">Tilix and quake mode</h3>
<p><a id="markdown-tilix-and-quake-mode" name="tilix-and-quake-mode"></a></p>

<p><code class="language-plaintext highlighter-rouge">tilix</code> and its <code class="language-plaintext highlighter-rouge">quake mode</code> is disabled in Wayland. I recommend the following
instead <a href="https://garrettmills.dev/blog/2023/04/28/down-the-rabbit-hole-of-linux-terminal-emulators/"><code class="language-plaintext highlighter-rouge">ddterm</code></a>
which you can install as a GNOME Extension <a href="https://extensions.gnome.org/extension/3780/ddterm/">here</a>. It
works really well.</p>

<p>Also, instead of <code class="language-plaintext highlighter-rouge">tilix</code>, I recommend using <code class="language-plaintext highlighter-rouge">terminator</code>. <code class="language-plaintext highlighter-rouge">tilix</code> is great but as of end
of year 2024 it doesn’t have a maintainer. <code class="language-plaintext highlighter-rouge">terminator</code> is maintained by GNOME
organization itself. You can get it
<a href="https://github.com/gnome-terminator/terminator">here</a>.</p>

<p>You can also use
<a href="https://lukaszwrobel.pl/blog/tmux-tutorial-split-terminal-windows-easily/"><code class="language-plaintext highlighter-rouge">tmux</code></a> to
manage panes in terminals that don’t support tiling. Howvever, <code class="language-plaintext highlighter-rouge">tmux</code> is not fast. If you
run TUI apps, their colors will be off, and frame rates down, so consider this when
choosing <code class="language-plaintext highlighter-rouge">tmux</code>.</p>

<h3 id="remap-superq">Remap Super+Q</h3>
<p><a id="markdown-remap-super%2Bq" name="remap-super%2Bq"></a></p>

<p>The following links show you how to remove the default binding for the <kbd>Super+Q</kbd>
key to close the current window. This is useful if you want to use that binding to launch
<code class="language-plaintext highlighter-rouge">ddterm</code>.</p>

<ul>
  <li><a href="https://askubuntu.com/questions/977876/changing-command-super-q">https://askubuntu.com/questions/977876/changing-command-super-q</a></li>
  <li><a href="https://flameshot.org/docs/guide/wayland-help/">https://flameshot.org/docs/guide/wayland-help/</a></li>
  <li><a href="https://github.com/Ulauncher/Ulauncher/wiki/Hotkey-In-Wayland">https://github.com/Ulauncher/Ulauncher/wiki/Hotkey-In-Wayland</a></li>
  <li><a href="https://askubuntu.com/questions/26056/where-are-gnome-keyboard-shortcuts-stored">https://askubuntu.com/questions/26056/where-are-gnome-keyboard-shortcuts-stored</a></li>
</ul>

<h3 id="remap-caps-lock-to-ctrl">Remap Caps Lock to Ctrl</h3>
<p><a id="markdown-remap-caps-lock-to-ctrl" name="remap-caps-lock-to-ctrl"></a></p>

<p>Here’s a snippet to allow you map your <kbd>Caps Lock</kbd> key to the <kbd>Ctrl</kbd>
key:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function </span>remapCapsLockKey
    <span class="nb">echo</span> <span class="s2">"Remapping caps lock key"</span>
    <span class="c"># https://opensource.com/article/21/5/remap-caps-lock-key-linux</span>
    dconf write /org/gnome/desktop/input-sources/xkb-options <span class="s2">"['caps:ctrl_modifier']"</span>
    <span class="c"># dconf write /org/gnome/desktop/input-sources/xkb-options "['caps:ctrl']"</span>
end
</code></pre></div></div>

<h2 id="chrome-issues-w-wayland">Chrome issues w/ Wayland</h2>
<p><a id="markdown-chrome-issues-w%2F-wayland" name="chrome-issues-w%2F-wayland"></a></p>

<p>If you find Chrome to be blurry (or AppImages or Electron apps), then you may need to
do the following to fix this in Wayland:</p>

<ul>
  <li>Navigate to <code class="language-plaintext highlighter-rouge">chrome://flags</code></li>
  <li>Change <code class="language-plaintext highlighter-rouge">Preferred Ozone Platform</code> from <code class="language-plaintext highlighter-rouge">default</code> to <code class="language-plaintext highlighter-rouge">wayland</code></li>
  <li><a href="https://askubuntu.com/a/1502896/872482">More info</a></li>
</ul>

<h2 id="libfuse2-and-appimage-issues">libfuse2 and AppImage issues</h2>
<p><a id="markdown-libfuse2-and-appimage-issues" name="libfuse2-and-appimage-issues"></a></p>

<p>On Ubuntu 24.04 I ran into some issues w/ <code class="language-plaintext highlighter-rouge">libfuse2</code> and running <code class="language-plaintext highlighter-rouge">AppImage</code>s.</p>

<ul>
  <li>Ubuntu 24 does not come w/ <code class="language-plaintext highlighter-rouge">libfuse2</code> out of the box (for good reasons), and instead it
has <code class="language-plaintext highlighter-rouge">libfuse3</code>.</li>
  <li>And <code class="language-plaintext highlighter-rouge">AppImage</code> currently only supports <code class="language-plaintext highlighter-rouge">libfuse2</code>.</li>
</ul>

<h3 id="approach-1---simple">Approach 1 - simple</h3>
<p><a id="markdown-approach-1---simple" name="approach-1---simple"></a></p>

<p>Instead of installing <code class="language-plaintext highlighter-rouge">libfuse2</code>, however, if you don’t want to do that you can simply run
the your <code class="language-plaintext highlighter-rouge">XYZ.AppImage</code> using the following command (once it’s been marked as executable):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>chmod +x XYZ.AppImage
./XYZ.AppImage \
  --no-sandbox --enable-features=UseOzonePlatform,WaylandWindowDecorations \
  --ozone-platform-hint=auto
</code></pre></div></div>

<p>Explanation of the flags:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">--no-sandbox</code> - removes the need for libfuse2</li>
  <li><code class="language-plaintext highlighter-rouge">--enable-features=UseOzonePlatform,WaylandWindowDecorations</code> - tells chromium in
electron to do things for Wayland.</li>
  <li><code class="language-plaintext highlighter-rouge">--ozone-platform-hint=auto</code> - tells chromium to use Wayland if it is available. This
setting is set to <code class="language-plaintext highlighter-rouge">X11</code> by default. If you see blurry windows in Chrome, you may need to set
this in your Chrome too (using <code class="language-plaintext highlighter-rouge">chrome://flags/</code>).</li>
</ul>

<p>Here’s an example of my <code class="language-plaintext highlighter-rouge">~/.local/share/applications/uhk-agent.desktop</code> file, which I use
to run the <a href="https://forum.ultimatehackingkeyboard.com/t/run-agent-appimage-in-wayland-eg-on-ubuntu-24/1364"><code class="language-plaintext highlighter-rouge">uhk-agent</code>
AppImage</a>
w/ the above flags:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Desktop Entry]
Type=Application
Name=UHK Agent
Comment=Launch UHK Agent
Categories=Utilities;
Icon=/home/nazmul/bin/uhk-agent.png
Exec=/home/nazmul/bin/UHK.Agent.AppImage --no-sandbox --enable-features=UseOzonePlatform,WaylandWindowDecorations --ozone-platform-hint=auto
Terminal=false
</code></pre></div></div>

<h3 id="approach-2---complex">Approach 2 - complex</h3>
<p><a id="markdown-approach-2---complex" name="approach-2---complex"></a></p>

<p>Here’s another approach to run <code class="language-plaintext highlighter-rouge">AppImage</code>s, which is more complex:</p>

<ul>
  <li><a href="https://github.com/AppImage/AppImageKit/wiki/FUSE"><code class="language-plaintext highlighter-rouge">libfuse2</code></a> is not included with
Ubuntu 24.04. <code class="language-plaintext highlighter-rouge">AppImage</code>s are difficult to run (since they need <code class="language-plaintext highlighter-rouge">libfuse2</code> installed).</li>
  <li>To run them, have to pass an extra flag in the terminal or <code class="language-plaintext highlighter-rouge">.desktop</code> file(eg for
<code class="language-plaintext highlighter-rouge">uhk-agent</code>). here’s a workaround (to keep from installing <code class="language-plaintext highlighter-rouge">libfuse2</code>).</li>
</ul>

<p>Here’s an example of the command to run the <a href="https://ultimatehackingkeyboard.com/agent"><code class="language-plaintext highlighter-rouge">uhk-agent</code>
AppImage</a>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/UHK.Agent-4.2.0-linux-x86_64.AppImage <span class="nt">--appimage-extract</span>
<span class="nb">cd </span>squashfs-root
./uhk-agent <span class="nt">--no-sandox</span>
</code></pre></div></div>

<p>Here’s a
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/ubuntu24/install-agent-into-bin.fish">script</a>
that uses this complex approach to unpack an <code class="language-plaintext highlighter-rouge">AppImage</code> into the <code class="language-plaintext highlighter-rouge">~/bin</code> folder so you can
run it.</p>

<h2 id="settings---key-mappings">Settings -&gt; Key mappings</h2>
<p><a id="markdown-settings--%3E-key-mappings" name="settings--%3E-key-mappings"></a></p>

<ul>
  <li>To create keyboard shortcuts that launch a shell command, wrap it in <code class="language-plaintext highlighter-rouge">sh -c $CMD</code>. This
is what must be done for <code class="language-plaintext highlighter-rouge">flameshot</code>, and <code class="language-plaintext highlighter-rouge">ulauncher</code>.</li>
  <li>Bind <code class="language-plaintext highlighter-rouge">ulauncher-toggle</code> to the settings -&gt; keyboard shortcuts in gnome.</li>
</ul>

<h2 id="obs-studio-issues">OBS Studio issues</h2>
<p><a id="markdown-obs-studio-issues" name="obs-studio-issues"></a></p>

<p><code class="language-plaintext highlighter-rouge">obs-studio</code> has some UI issues, and dialog boxes are quite glitchy and don’t display
properly. keyboard shortcuts can’t be reliably used when the <code class="language-plaintext highlighter-rouge">obs-studio</code> window is not in
focus. can’t really bind to settings -&gt; keyboard shortcuts either, since there’s no
command to stop recording; start recording will spawn a new process.</p>

<h2 id="fontconfig">Fontconfig</h2>
<p><a id="markdown-fontconfig" name="fontconfig"></a></p>

<p>Custom font install using script. optional - <code class="language-plaintext highlighter-rouge">~/.config/fontconfig/fonts.conf</code> change
for system fonts that affect all apps. also <code class="language-plaintext highlighter-rouge">gnome-tweaks</code> to change fonts, and other
settings.</p>

<ul>
  <li><a href="https://jichu4n.com/posts/how-to-set-default-fonts-and-font-aliases-on-linux/">https://jichu4n.com/posts/how-to-set-default-fonts-and-font-aliases-on-linux/</a></li>
  <li><a href="https://www.freedesktop.org/software/fontconfig/fontconfig-user.html">https://www.freedesktop.org/software/fontconfig/fontconfig-user.html</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Fontconfig">https://en.wikipedia.org/wiki/Fontconfig</a></li>
</ul>

<h2 id="build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</h2>
<p><a id="markdown-build-with-naz-video-series-on-developerlife.com-youtube-channel" name="build-with-naz-video-series-on-developerlife.com-youtube-channel"></a></p>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a></li>
  <li>Playlists
    <ul>
      <li><a href="https://www.youtube.com/watch?v=bolScvh4x7I&amp;list=PLofhE49PEwmw3MKOU1Kn3xbP4FRQR4Mb3">Build with Naz, Linux TTY, process, signals, commands in async Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmza94sS7UmJnN9gSCHTVTfz">Build with Naz, fundamental effective Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmwO69E7eiQ-ewnMME8ydgQ5">Build with Naz, effective async Rust and tokio</a></li>
      <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="Linux" /><category term="Misc" /><category term="Productivity" /><summary type="html"><![CDATA[I've provided scripts for setting up a new Ubuntu 24.04 desktop machine. They have been tested on a fresh install of Ubuntu 24.04 LTS. They contain all the software that is needed for Rust development, OBS Studio use, and general developer productivity. They are highly opinionated for my use case, but you can modify them to suit your needs.]]></summary></entry><entry><title type="html">Build with Naz : Markdown parser in Rust and nom from r3bl_tui</title><link href="http://developerlife.com/2024/06/28/md-parser-rust-from-r3bl-tui/" rel="alternate" type="text/html" title="Build with Naz : Markdown parser in Rust and nom from r3bl_tui" /><published>2024-06-28T10:00:00-05:00</published><updated>2024-06-28T10:00:00-05:00</updated><id>http://developerlife.com/2024/06/28/md-parser-rust-from-r3bl-tui</id><content type="html" xml:base="http://developerlife.com/2024/06/28/md-parser-rust-from-r3bl-tui/"><![CDATA[<p><img class="post-hero-image" src="/assets/rust-tui-md-parser.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#nom-crate-review">nom crate review</a></li>
  <li><a href="#a-real-production-grade-markdown-parser-example">A real production grade Markdown parser example</a></li>
  <li><a href="#related-video">Related video</a></li>
  <li><a href="#architecture-and-parsing-order">Architecture and parsing order</a></li>
  <li><a href="#references">References</a></li>
</ul>

<!-- /TOC -->

<h2 id="introduction">Introduction</h2>
<p><a id="markdown-introduction" name="introduction"></a></p>

<p>This tutorial, and video are a deep dive in a real Markdown parser written using nom in
Rust. This MD Parser is part of the <a href="https://crates.io/crates/r3bl_tui"><code class="language-plaintext highlighter-rouge">r3bl_tui</code></a> crate,
which is part of the <code class="language-plaintext highlighter-rouge">r3bl-open-core</code> repo. It goes over the architecture of thinking
about building complex parsers and the nitty gritty details the runtime nature and
behavior when combining nom parsers.</p>

<p>The <a href="https://crates.io/crates/r3bl_tui"><code class="language-plaintext highlighter-rouge">r3bl_tui</code></a> crate is a Text User Interface (TUI)
crate that is used in the <a href="https://r3bl.com">R3BL</a> suite of products. It is a very
powerful and flexible TUI crate that is used to build a variety of different applications.
It comes with a full featured Markdown editor component, and the parser that’s the focus
on this tutorial is used by that editor component to parse an input string slice into a
Markdown document model (AST representation in memory).</p>

<h2 id="nom-crate-review">nom crate review</h2>
<p><a id="markdown-nom-crate-review" name="nom-crate-review"></a></p>

<p><a href="https://crates.io/crates/nom"><code class="language-plaintext highlighter-rouge">nom</code></a> is a parser combinator library for Rust. You can write small
functions that parse a specific part of your input, and then combine them to build a parser that
parses the whole input. <code class="language-plaintext highlighter-rouge">nom</code> is very efficient and fast, it does not allocate memory when parsing if
it doesn’t have to, and it makes it very easy for you to do the same. <code class="language-plaintext highlighter-rouge">nom</code> uses streaming mode or
complete mode, and in this tutorial &amp; code examples provided we will be using complete mode.</p>

<p>Roughly the way it works is that you tell <code class="language-plaintext highlighter-rouge">nom</code> how to parse a bunch of bytes in a way that matches
some pattern that is valid for your data. It will try to parse as much as it can from the input, and
the rest of the input will be returned to you.</p>

<p>You express the pattern that you’re looking for by combining parsers. <code class="language-plaintext highlighter-rouge">nom</code> has a whole bunch of these
that come out of the box. And a huge part of learning <code class="language-plaintext highlighter-rouge">nom</code> is figuring out what these built in
parsers are and how to combine them to build a parser that does what you want.</p>

<p>Errors are a key part of it being able to apply a variety of different parsers to the same input. If
a parser fails, <code class="language-plaintext highlighter-rouge">nom</code> will return an error, and the rest of the input will be returned to you. This
allows you to combine parsers in a way that you can try to parse a bunch of different things, and if
one of them fails, you can try the next one. This is very useful when you are trying to parse a
bunch of different things, and you don’t know which one you are going to get.</p>

<blockquote>
  <p>We have a video and article on developerlife where you can learn more about <code class="language-plaintext highlighter-rouge">nom</code> and how to use it.</p>
  <ul>
    <li><a href="https://youtu.be/v3tMwr_ysPg">Video on nom fundamentals</a>.</li>
    <li><a href="https://developerlife.com/2023/02/20/guide-to-nom-parsing/">Article on nom fundamentals</a>.</li>
  </ul>
</blockquote>

<h2 id="a-real-production-grade-markdown-parser-example">A real production grade Markdown parser example</h2>
<p><a id="markdown-a-real-production-grade-markdown-parser-example" name="a-real-production-grade-markdown-parser-example"></a></p>

<p>The production
<a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/tui/src/tui/md_parser"><code class="language-plaintext highlighter-rouge">md_parser</code></a>
module in the <code class="language-plaintext highlighter-rouge">r3bl-open-core</code> repo contains a fully functional Markdown parser (that you
can use in your projects that need a Markdown parser). This parser supports standard
Markdown syntax as well as some extensions that are
added to make it work w/ <a href="https://r3bl.com">R3BL</a> products. It makes a great starting
point to study how a relatively complex parser is written. There are lots of tests that
you can follow along to understand what the code is doing.</p>

<blockquote>
  <p>💡 You can get the source code for the production Markdown parser used in <code class="language-plaintext highlighter-rouge">r3bl_tui</code> from the
<a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/tui/src/tui/md_parser"><code class="language-plaintext highlighter-rouge">r3bl-open-core</code></a>
repo.</p>

  <p>🌟 Please star this repo on github if you like it 🙏.</p>
</blockquote>

<p>The main entry point (function) for this Markdown parsing module is
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/parse_markdown.rs"><code class="language-plaintext highlighter-rouge">parse_markdown()</code></a>.</p>
<ul>
  <li>It takes a string slice.</li>
  <li>And returns a vector of <a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/types.rs"><code class="language-plaintext highlighter-rouge">MdBlock</code>s</a>.</li>
</ul>

<p>Here are some entry points into the codebase.</p>

<ol>
  <li>The main function
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/parse_markdown.rs"><code class="language-plaintext highlighter-rouge">parse_markdown()</code></a>
that does the parsing of a string slice into a
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/types.rs"><code class="language-plaintext highlighter-rouge">MdDocument</code></a>.
The tests are provided alongside the code itself. And you can follow along to see how
other smaller parsers are used to build up this big one that parses the whole of the
Markdown document.</li>
  <li>The
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/types.rs"><code class="language-plaintext highlighter-rouge">types</code></a> module
contain all the types that are used to represent the Markdown document model, such as <code class="language-plaintext highlighter-rouge">MdDocument</code>, <code class="language-plaintext highlighter-rouge">MdBlock</code>,
<code class="language-plaintext highlighter-rouge">MdLineFragment</code> and all the other intermediate types &amp; enums required for parsing.</li>
  <li>All the parsers related to parsing metadata specific for <a href="https://r3bl.com">R3BL</a>
applications which are not standard Markdown can be found in
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/extended/parse_metadata_kv.rs#L1"><code class="language-plaintext highlighter-rouge">parse_metadata_kv</code></a>
and
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/extended/parse_metadata_kcsv.rs#L1"><code class="language-plaintext highlighter-rouge">parse_metadata_kcsv</code></a>.</li>
  <li>All the parsers that are related to parsing the main “blocks” of Markdown, such as
order lists, unordered lists, code blocks, text blocks, heading blocks, can be
found <a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/block/mod.rs#L3"><code class="language-plaintext highlighter-rouge">block</code></a>.</li>
  <li>All the parsers that are related to parsing a single line of Markdown text, such as
links, bold, italic, etc. can be found
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/fragment/mod.rs#L1"><code class="language-plaintext highlighter-rouge">fragment</code></a>.</li>
</ol>

<h2 id="related-video">Related video</h2>
<p><a id="markdown-related-video" name="related-video"></a></p>

<p>If you like to consume content via video, then you can watch this video that covers the same content
as this article, but in a live coding format.</p>

<!-- video on nom -->
<iframe src="https://www.youtube.com/embed/SbwvSHZRb1E?si=8UFyEKyF8sHnam-K" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<blockquote>
  <p>💡 You can get the source code for the production Markdown parser used in <code class="language-plaintext highlighter-rouge">r3bl_tui</code> from the
<a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/tui/src/tui/md_parser"><code class="language-plaintext highlighter-rouge">r3bl-open-core</code></a>
repo.</p>
</blockquote>

<h2 id="architecture-and-parsing-order">Architecture and parsing order</h2>
<p><a id="markdown-architecture-and-parsing-order" name="architecture-and-parsing-order"></a></p>

<p>This diagram showcases the order in which the parsers are called and how they are
composed together to parse a Markdown document.</p>

<!--
diagram:
https://asciiflow.com/#/share/eJzdlL9qwzAQxl%2Fl0JRChhLo0Gz9M3Rop2YUCNUWsYgsGfkcxxhD6dyhQwh9ltKnyZNUtus0hAYrJaXQQyAZf%2F6d7rN0JdE8FmSsM6WGRPFCWDImJSULSsbnZ6MhJYVbjZoVigW6B0oSK42VWMB6%2BbxePv7T8UKpBojkNAJwlT5Bwm0qWMztLDS5HpxACTsR8wTQAEYCAmOtCHBX0aIacgvdTDHXxengG3331U8LWb0B3IWXygQzmHMrucZ9e4DPGlGiEmzOVSZcmb0xqeV99W3YfJoyJVP0ITu2k%2Fd617F5hpGx3viLVu7HDjkeYAlcO7n3vh%2Fqn8MiwUOpp8wkyIRR%2B9PctMJD2Kk7tujjy30tvHU6f3ZgQj9PrpywPYfe7O62sbr5sFxixIxtZpMh0yJ3Nek6%2B8S9%2F8q0h%2B114vpii71679jVMcgde6u%2FLv%2B6C%2F7eeG1cVCY%2FjnVdUFKR6gNnN4sV)
-->

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>priority ┌────────────────────────────────────────────────────────────────────┐
  high   │ parse_markdown() {           map to the correct                    │
    │    │   many0(                     ───────────────────►  MdBlock variant │
    │    │     parse_title_value()                              Title         │
    │    │     parse_tags_list()                                Tags          │
    │    │     parse_authors_list()                             Authors       │
    │    │     parse_date_value()                               Date          │
    │    │     parse_block_heading_opt_eol()                    Heading       │
    │    │     parse_block_smart_list()                         SmartList     │
    │    │     parse_block_code()                               CodeBlock     │
    │    │     parse_block_m..n_text_with_or_without_new_line() Text          │
    │    │   )                                                                │
    ▼    │ }                                                                  │
priority └────────────────────────────────────────────────────────────────────┘
  low
</code></pre></div></div>

<p>The parsing strategy in most cases is to parse the most specific thing first and then
parse the more general thing later. We often use the existence of <code class="language-plaintext highlighter-rouge">\n</code> (or <code class="language-plaintext highlighter-rouge">eol</code>) to
decide how far forwards we need to go into the input. And sometimes <code class="language-plaintext highlighter-rouge">\n</code> doesn’t exist
and we simply use the entire input (or end of input or <code class="language-plaintext highlighter-rouge">eoi</code>). You might see functions
that have these suffixes in their names. Another term you might see is
<code class="language-plaintext highlighter-rouge">with_or_without_new_line</code> which makes the parsing strategy explicit in the name.</p>

<p>The nature of <code class="language-plaintext highlighter-rouge">nom</code> parsers is to simply error out when they don’t match. And leave
the <code class="language-plaintext highlighter-rouge">input</code> untouched, so that another parser have a go at it again. The nature of
these parsing functions is kind of recursive in nature. So it’s important identify
edge and exit cases up front before diving into the parsing logic. You will see this
used in parsers which look for something more specific, if its not found, they error
out, and allow less specific parsers to have a go at it, and so on.</p>

<h2 id="the-priority-of-parsers">The priority of parsers</h2>

<p>As we drill down into the implementation further, we see that the parsers are
prioritized in the order of their specificity. The most specific parsers are called
first and the least specific parsers are called last. This is done to ensure that the
most specific parsers get a chance to parse the input first. And if they fail, then
the less specific parsers get a chance to parse the input.</p>

<!--
diagram:
https://asciiflow.com/#/share/eJytlFFuwjAMhq8S5QkkHtD2MjhLJCsNBqK6CUpTUYaQpp2h4iB7RDtNT7I0sK1ABYNhVapdJ1%2F%2F2G7X3MgM%2BdgURANOcoWOj%2Fla8FLw8ejleSD4KnhPo2HwPJY%2BBIIvpMsRErIqhUy6dGKXBposLLWfg3XxbgsPBpdA2mCvz9bs3IQwjGXSrIa9juxtFlmM7bVp07wVpk7OMjQ%2Bh8J4TYCWGnVodRB0nRWsWVZX7%2F9VtvmNHkBrRXVV1dVbvd0xSf7OIh4TI3X7cSjkdwUh99KFOsYGF2aCLlfWIaBzYE27zx20cOILtMbv4LS05QtUWpJ%2BxclVWiJV6nUYzC5ipMXNLmdN3X6u7e4Kl3DqQWdy9pAzR1rY3CnzZpqao0oTW4ax9zZkXHu6u7r7%2BSfaMTaxlnr9SFPSq3kYODop4Sl1QVIffgzGnvf2ROO%2BL4cnFz%2FPiyb4hm%2B%2BAFpUbMk%3D)
-->

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>parse_block_markdown_text_with_or_without_new_line() {
  many0(
    parse_inline_fragments_until_eol_or_eoi()
       )   │
}          │                                           ──map to the correct──►
           └─► alt(                                     MdLineFragment variant

             ▲ p..e_f..t_s..s_with_underscore_err_on_new_line()  Italic
             │ p..e_f..t_s..s_with_star_err_on_new_line()        Bold
specialized  │ p..e_f..t_s..s_with_backtick_err_on_new_line()    InlineCode
parsers ────►│ p..e_f..t_s..s_with_left_image_err_on_new_line()  Image
             │ p..e_f..t_s..s_with_left_link_err_on_new_line()   Link
             │ p..e_f..t_s..s_with_checkbox_into_str()           Plain
             ▼ p..e_f..t_s..s_with_checkbox_checkbox_into_bool() Checkbox
catch all────► p..e_f..t_plain_text_no_new_line()                Plain
parser
               )
</code></pre></div></div>

<p>The last one on the list in the diagram above is
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/block/parse_block_markdown_text_until_eol_or_eoi.rs"><code class="language-plaintext highlighter-rouge">parse_block_markdown_text_with_or_without_new_line()</code></a>.
Let’s zoom into this function and see how it is composed.</p>

<h2 id="the-catch-all-parser-which-is-the-most-complicated-and-the-lowest-priority">The “catch all” parser, which is the most complicated, and the lowest priority</h2>

<p>The most complicated parser is the “catch all” parser or the “plain text” parser. This
parser is the last one in the chain and it simply consumes the rest of the input and
turns it into a <code class="language-plaintext highlighter-rouge">MdBlock::Text</code>. This parser is the most complicated because it has to
deal with all the edge cases and exit cases that other parsers have not dealt with.
Such as special characters like <code class="language-plaintext highlighter-rouge">`</code>, <code class="language-plaintext highlighter-rouge">*</code>, <code class="language-plaintext highlighter-rouge">_</code>, etc. They are all listed here:</p>

<ul>
  <li>If the input does not start with a special char in this
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/fragment/plain_parser_catch_all.rs"><code class="language-plaintext highlighter-rouge">get_sp_char_set_2()</code></a>,
then this is the “Normal case”. In this case the input is split at the first occurrence
of a special char in
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/fragment/plain_parser_catch_all.rs"><code class="language-plaintext highlighter-rouge">get_sp_char_set_3()</code></a>.
The “before” part is <code class="language-plaintext highlighter-rouge">MdLineFragment::Plain</code> and the “after” part is parsed again by a
more specific parser.</li>
  <li>If the input starts with a special char in this <a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/fragment/plain_parser_catch_all.rs"><code class="language-plaintext highlighter-rouge">get_sp_char_set_2()</code></a> and it is not
in the <code class="language-plaintext highlighter-rouge">get_sp_char_set_1()</code> with only 1 occurrence, then the behavior is different
“Edge case -&gt; Normal case”. Otherwise the behavior is “Edge case -&gt; Special case”.
    <ul>
      <li>“Edge case -&gt; Normal case” takes all the characters until <code class="language-plaintext highlighter-rouge">\n</code> or end of input and
turns it into a <code class="language-plaintext highlighter-rouge">MdLineFragment::Plain</code>.</li>
      <li>“Edge case -&gt; Special case” splits the <code class="language-plaintext highlighter-rouge">input</code> before and after the special char.
The “before” part is turned into a <code class="language-plaintext highlighter-rouge">MdLineFragment::Plain</code> and the “after” part is
parsed again by a more specific parser.</li>
    </ul>
  </li>
</ul>

<p>The reason this parser gets called repeatedly is because it is the last one in the chain.
Its the lowest priority parser called by
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/fragment/parse_fragments_in_a_line.rs"><code class="language-plaintext highlighter-rouge">parse_inline_fragments_until_eol_or_eoi()</code></a>,
which itself is called:</p>
<ol>
  <li>Repeatedly in a loop by
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/block/parse_block_markdown_text_until_eol_or_eoi.rs"><code class="language-plaintext highlighter-rouge">parse_block_markdown_text_with_or_without_new_line()</code></a>.</li>
  <li>And by
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/block/parse_block_markdown_text_until_eol_or_eoi.rs#L80"><code class="language-plaintext highlighter-rouge">parse_block_markdown_text_with_checkbox_policy_with_or_without_new_line()</code></a>.</li>
</ol>

<h2 id="visualize-the-parsers-running-on-real-input">Visualize the parsers running on real input</h2>

<p>Let’s run some tests from the <code class="language-plaintext highlighter-rouge">md_parser</code> module with the
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/mod.rs#L34"><code class="language-plaintext highlighter-rouge">DEBUG_MD_PARSER_STDOUT</code></a>
flag set to <code class="language-plaintext highlighter-rouge">true</code>.</p>

<p>This will allow us to see the output of the parsers as they run on
real input. This is a great way to understand how the parsers are working and what they
are doing. This helps build an intuition around what happens at runtime which might not
match what you think is happening when you read the code.</p>

<ol>
  <li>The test we will run are in this file:
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/block/parse_block_markdown_text_until_eol_or_eoi.rs#L81"><code class="language-plaintext highlighter-rouge">tui/src/tui/md_parser/block/parse_block_markdown_text_until_eol_or_eoi.rs</code></a>.</li>
  <li>The test suite itself is called
<code class="language-plaintext highlighter-rouge">tests_parse_block_markdown_text_with_or_without_new_line</code>.</li>
  <li>And the function under test is
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/block/parse_block_markdown_text_until_eol_or_eoi.rs#L24"><code class="language-plaintext highlighter-rouge">parse_block_markdown_text_with_or_without_new_line()</code></a>.</li>
</ol>

<p>For convenience, here’s a copy of the test that we will run (in this
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/block/parse_block_markdown_text_until_eol_or_eoi.rs#L101">file</a>):</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">test_parse_hyperlink_markdown_text_1</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">input</span> <span class="o">=</span> <span class="s">"This is a _hyperlink: [foo](http://google.com)."</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="nf">parse_block_markdown_text_with_or_without_new_line</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
    <span class="nd">assert_eq2!</span><span class="p">(</span>
        <span class="n">it</span><span class="p">,</span>
        <span class="nf">Ok</span><span class="p">((</span>
            <span class="s">""</span><span class="p">,</span>
            <span class="nd">list!</span><span class="p">[</span>
                <span class="nn">MdLineFragment</span><span class="p">::</span><span class="nf">Plain</span><span class="p">(</span><span class="s">"This is a "</span><span class="p">,),</span>
                <span class="nn">MdLineFragment</span><span class="p">::</span><span class="nf">Plain</span><span class="p">(</span><span class="s">"_"</span><span class="p">,),</span>
                <span class="nn">MdLineFragment</span><span class="p">::</span><span class="nf">Plain</span><span class="p">(</span><span class="s">"hyperlink: "</span><span class="p">,),</span>
                <span class="nn">MdLineFragment</span><span class="p">::</span><span class="nf">Link</span><span class="p">(</span><span class="n">HyperlinkData</span> <span class="p">{</span>
                    <span class="n">text</span><span class="p">:</span> <span class="s">"foo"</span><span class="p">,</span>
                    <span class="n">url</span><span class="p">:</span> <span class="s">"http://google.com"</span><span class="p">,</span>
                <span class="p">},),</span>
                <span class="nn">MdLineFragment</span><span class="p">::</span><span class="nf">Plain</span><span class="p">(</span><span class="s">"."</span><span class="p">,),</span>
            <span class="p">],</span>
        <span class="p">))</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>You can see from the <code class="language-plaintext highlighter-rouge">assert_eq2!()</code> statements that the input <code class="language-plaintext highlighter-rouge">"This is a _hyperlink:
[foo](http://google.com)."</code> is turned into a abstract syntax tree (AST) which looks like
this:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span>
    <span class="nn">MdLineFragment</span><span class="p">::</span><span class="nf">Plain</span><span class="p">(</span><span class="s">"This is a "</span><span class="p">,),</span>
    <span class="nn">MdLineFragment</span><span class="p">::</span><span class="nf">Plain</span><span class="p">(</span><span class="s">"_"</span><span class="p">,),</span>
    <span class="nn">MdLineFragment</span><span class="p">::</span><span class="nf">Plain</span><span class="p">(</span><span class="s">"hyperlink: "</span><span class="p">,),</span>
    <span class="nn">MdLineFragment</span><span class="p">::</span><span class="nf">Link</span><span class="p">(</span><span class="n">HyperlinkData</span> <span class="p">{</span>
        <span class="n">text</span><span class="p">:</span> <span class="s">"foo"</span><span class="p">,</span>
        <span class="n">url</span><span class="p">:</span> <span class="s">"http://google.com"</span><span class="p">,</span>
    <span class="p">},),</span>
    <span class="nn">MdLineFragment</span><span class="p">::</span><span class="nf">Plain</span><span class="p">(</span><span class="s">"."</span><span class="p">,),</span>
<span class="p">]</span>
</code></pre></div></div>

<p>Note the “strange” way in which <code class="language-plaintext highlighter-rouge">"_"</code> is handled. Instead of what we might expect <code class="language-plaintext highlighter-rouge">Plain("This is a _ hyperlink: ")</code>.
But we get 3 fragments instead of one. This is because of the lowest priority parser handles special characters
so that more specific parsers (higher priority) can have a go at it. So it doesn’t prematurely mark them as <code class="language-plaintext highlighter-rouge">Plain</code>.</p>

<p>Here are the commands to run one of the tests (make sure to run this in the <code class="language-plaintext highlighter-rouge">tui</code> subfolder):</p>

<pre class="pre-manual-highlight">
<span style="color:#F8F8F2">cargo</span> <span style="color:#FF79C6">test</span> <span style="color:#FF79C6">--</span> <span style="color:#FF79C6">--nocapture</span> <span style="color:#FF79C6">test_parse_hyperlink_markdown_text_1</span>
</pre>

<p>Here’s the output, which you can walk through to see the parsing algorithms in action:</p>

<pre class="pre-manual-highlight">
<span style="color:#A3BE8C">■■</span> specialized parser _:
input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;, delim: &quot;_&quot;
count: 1, starts_w: false, input=delim: false
<span style="color:#BF616A">⬢⬢</span> parser error out for input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;

<span style="color:#A3BE8C">■■</span> specialized parser *:
input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;, delim: &quot;*&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">⬢⬢</span> parser error out for input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;

<span style="color:#A3BE8C">■■</span> specialized parser `:
input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;, delim: &quot;`&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">⬢⬢</span> parser error out for input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;

<span style="color:#A3BE8C">■■</span> specialized parser take text between delims err on new line:
input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;, start_delim: &quot;![&quot;, end_delim: &quot;]&quot;
<span style="color:#BF616A">⬢⬢</span> parser error out for input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;

<span style="color:#BF616A">⬢⬢</span> specialized parser error out with image:
input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;, delim: &quot;![&quot;

<span style="color:#A3BE8C">■■</span> specialized parser take text between delims err on new line:
input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;, start_delim: &quot;[&quot;, end_delim: &quot;]&quot;
<span style="color:#BF616A">⬢⬢</span> parser error out for input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;

<span style="color:#BF616A">⬢⬢</span> specialized parser error out with link:
input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;, delim: &quot;[&quot;
<span style="color:#BF616A">⬢⬢</span> specialized parser for checkbox: Err(Error(Error { input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;, code: Tag }))

<span style="color:#B48EAD">██</span> plain parser, input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;
<span style="color:#81A1C1">▲▲</span> normal case :: Ok((&quot;_hyperlink: [foo](http://google.com).&quot;, &quot;This is a &quot;))

<span style="color:#A3BE8C">■■</span> specialized parser _:
input: &quot;_hyperlink: [foo](http://google.com).&quot;, delim: &quot;_&quot;
count: 1, starts_w: true, input=delim: false
<span style="color:#BF616A">⬢⬢</span> parser error out for input: &quot;_hyperlink: [foo](http://google.com).&quot;

<span style="color:#A3BE8C">■■</span> specialized parser *:
input: &quot;_hyperlink: [foo](http://google.com).&quot;, delim: &quot;*&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">⬢⬢</span> parser error out for input: &quot;_hyperlink: [foo](http://google.com).&quot;

<span style="color:#A3BE8C">■■</span> specialized parser `:
input: &quot;_hyperlink: [foo](http://google.com).&quot;, delim: &quot;`&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">⬢⬢</span> parser error out for input: &quot;_hyperlink: [foo](http://google.com).&quot;

<span style="color:#A3BE8C">■■</span> specialized parser take text between delims err on new line:
input: &quot;_hyperlink: [foo](http://google.com).&quot;, start_delim: &quot;![&quot;, end_delim: &quot;]&quot;
<span style="color:#BF616A">⬢⬢</span> parser error out for input: &quot;_hyperlink: [foo](http://google.com).&quot;

<span style="color:#BF616A">⬢⬢</span> specialized parser error out with image:
input: &quot;_hyperlink: [foo](http://google.com).&quot;, delim: &quot;![&quot;

<span style="color:#A3BE8C">■■</span> specialized parser take text between delims err on new line:
input: &quot;_hyperlink: [foo](http://google.com).&quot;, start_delim: &quot;[&quot;, end_delim: &quot;]&quot;
<span style="color:#BF616A">⬢⬢</span> parser error out for input: &quot;_hyperlink: [foo](http://google.com).&quot;

<span style="color:#BF616A">⬢⬢</span> specialized parser error out with link:
input: &quot;_hyperlink: [foo](http://google.com).&quot;, delim: &quot;[&quot;
<span style="color:#BF616A">⬢⬢</span> specialized parser for checkbox: Err(Error(Error { input: &quot;_hyperlink: [foo](http://google.com).&quot;, code: Tag }))

<span style="color:#B48EAD">██</span> plain parser, input: &quot;_hyperlink: [foo](http://google.com).&quot;
<span style="color:#81A1C1">▲▲</span> edge case -&gt; special case :: rem: &quot;hyperlink: [foo](http://google.com).&quot;, output: &quot;_&quot;

<span style="color:#A3BE8C">■■</span> specialized parser _:
input: &quot;hyperlink: [foo](http://google.com).&quot;, delim: &quot;_&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">⬢⬢</span> parser error out for input: &quot;hyperlink: [foo](http://google.com).&quot;

<span style="color:#A3BE8C">■■</span> specialized parser *:
input: &quot;hyperlink: [foo](http://google.com).&quot;, delim: &quot;*&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">⬢⬢</span> parser error out for input: &quot;hyperlink: [foo](http://google.com).&quot;

<span style="color:#A3BE8C">■■</span> specialized parser `:
input: &quot;hyperlink: [foo](http://google.com).&quot;, delim: &quot;`&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">⬢⬢</span> parser error out for input: &quot;hyperlink: [foo](http://google.com).&quot;

<span style="color:#A3BE8C">■■</span> specialized parser take text between delims err on new line:
input: &quot;hyperlink: [foo](http://google.com).&quot;, start_delim: &quot;![&quot;, end_delim: &quot;]&quot;
<span style="color:#BF616A">⬢⬢</span> parser error out for input: &quot;hyperlink: [foo](http://google.com).&quot;

<span style="color:#BF616A">⬢⬢</span> specialized parser error out with image:
input: &quot;hyperlink: [foo](http://google.com).&quot;, delim: &quot;![&quot;

<span style="color:#A3BE8C">■■</span> specialized parser take text between delims err on new line:
input: &quot;hyperlink: [foo](http://google.com).&quot;, start_delim: &quot;[&quot;, end_delim: &quot;]&quot;
<span style="color:#BF616A">⬢⬢</span> parser error out for input: &quot;hyperlink: [foo](http://google.com).&quot;

<span style="color:#BF616A">⬢⬢</span> specialized parser error out with link:
input: &quot;hyperlink: [foo](http://google.com).&quot;, delim: &quot;[&quot;
<span style="color:#BF616A">⬢⬢</span> specialized parser for checkbox: Err(Error(Error { input: &quot;hyperlink: [foo](http://google.com).&quot;, code: Tag }))

<span style="color:#B48EAD">██</span> plain parser, input: &quot;hyperlink: [foo](http://google.com).&quot;
<span style="color:#81A1C1">▲▲</span> normal case :: Ok((&quot;[foo](http://google.com).&quot;, &quot;hyperlink: &quot;))

<span style="color:#A3BE8C">■■</span> specialized parser _:
input: &quot;[foo](http://google.com).&quot;, delim: &quot;_&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">⬢⬢</span> parser error out for input: &quot;[foo](http://google.com).&quot;

<span style="color:#A3BE8C">■■</span> specialized parser *:
input: &quot;[foo](http://google.com).&quot;, delim: &quot;*&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">⬢⬢</span> parser error out for input: &quot;[foo](http://google.com).&quot;

<span style="color:#A3BE8C">■■</span> specialized parser `:
input: &quot;[foo](http://google.com).&quot;, delim: &quot;`&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">⬢⬢</span> parser error out for input: &quot;[foo](http://google.com).&quot;

<span style="color:#A3BE8C">■■</span> specialized parser take text between delims err on new line:
input: &quot;[foo](http://google.com).&quot;, start_delim: &quot;![&quot;, end_delim: &quot;]&quot;
<span style="color:#BF616A">⬢⬢</span> parser error out for input: &quot;[foo](http://google.com).&quot;

<span style="color:#BF616A">⬢⬢</span> specialized parser error out with image:
input: &quot;[foo](http://google.com).&quot;, delim: &quot;![&quot;

<span style="color:#A3BE8C">■■</span> specialized parser take text between delims err on new line:
input: &quot;[foo](http://google.com).&quot;, start_delim: &quot;[&quot;, end_delim: &quot;]&quot;

<span style="color:#A3BE8C">■■</span> specialized parser take text between delims err on new line:
input: &quot;(http://google.com).&quot;, start_delim: &quot;(&quot;, end_delim: &quot;)&quot;
<span style="color:#81A1C1">▲▲</span> specialized parser for link: Ok((&quot;.&quot;, HyperlinkData { text: &quot;foo&quot;, url: &quot;http://google.com&quot; }))

<span style="color:#A3BE8C">■■</span> specialized parser _:
input: &quot;.&quot;, delim: &quot;_&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">⬢⬢</span> parser error out for input: &quot;.&quot;

<span style="color:#A3BE8C">■■</span> specialized parser *:
input: &quot;.&quot;, delim: &quot;*&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">⬢⬢</span> parser error out for input: &quot;.&quot;

<span style="color:#A3BE8C">■■</span> specialized parser `:
input: &quot;.&quot;, delim: &quot;`&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">⬢⬢</span> parser error out for input: &quot;.&quot;

<span style="color:#A3BE8C">■■</span> specialized parser take text between delims err on new line:
input: &quot;.&quot;, start_delim: &quot;![&quot;, end_delim: &quot;]&quot;
<span style="color:#BF616A">⬢⬢</span> parser error out for input: &quot;.&quot;

<span style="color:#BF616A">⬢⬢</span> specialized parser error out with image:
input: &quot;.&quot;, delim: &quot;![&quot;

<span style="color:#A3BE8C">■■</span> specialized parser take text between delims err on new line:
input: &quot;.&quot;, start_delim: &quot;[&quot;, end_delim: &quot;]&quot;
<span style="color:#BF616A">⬢⬢</span> parser error out for input: &quot;.&quot;

<span style="color:#BF616A">⬢⬢</span> specialized parser error out with link:
input: &quot;.&quot;, delim: &quot;[&quot;
<span style="color:#BF616A">⬢⬢</span> specialized parser for checkbox: Err(Error(Error { input: &quot;.&quot;, code: Tag }))

<span style="color:#B48EAD">██</span> plain parser, input: &quot;.&quot;
<span style="color:#81A1C1">▲▲</span> normal case :: Ok((&quot;&quot;, &quot;.&quot;))

<span style="color:#A3BE8C">■■</span> specialized parser _:
input: &quot;&quot;, delim: &quot;_&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">⬢⬢</span> parser error out for input: &quot;&quot;

<span style="color:#A3BE8C">■■</span> specialized parser *:
input: &quot;&quot;, delim: &quot;*&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">⬢⬢</span> parser error out for input: &quot;&quot;

<span style="color:#A3BE8C">■■</span> specialized parser `:
input: &quot;&quot;, delim: &quot;`&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">⬢⬢</span> parser error out for input: &quot;&quot;

<span style="color:#A3BE8C">■■</span> specialized parser take text between delims err on new line:
input: &quot;&quot;, start_delim: &quot;![&quot;, end_delim: &quot;]&quot;
<span style="color:#BF616A">⬢⬢</span> parser error out for input: &quot;&quot;

<span style="color:#BF616A">⬢⬢</span> specialized parser error out with image:
input: &quot;&quot;, delim: &quot;![&quot;

<span style="color:#A3BE8C">■■</span> specialized parser take text between delims err on new line:
input: &quot;&quot;, start_delim: &quot;[&quot;, end_delim: &quot;]&quot;
<span style="color:#BF616A">⬢⬢</span> parser error out for input: &quot;&quot;

<span style="color:#BF616A">⬢⬢</span> specialized parser error out with link:
input: &quot;&quot;, delim: &quot;[&quot;
<span style="color:#BF616A">⬢⬢</span> specialized parser for checkbox: Err(Error(Error { input: &quot;&quot;, code: Tag }))

<span style="color:#B48EAD">██</span> plain parser, input: &quot;&quot;
<span style="color:#BF616A">⬢⬢</span> normal case :: Err(Error(Error { input: &quot;&quot;, code: Eof }))
</pre>

<h2 id="see-this-in-action-in-r3bl-cmdr">See this in action in r3bl-cmdr</h2>

<p>If you want to use a TUI app that uses this Markdown Parser, run the following commands:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo <span class="nb">install </span>r3bl-cmdr
edi <span class="nt">--help</span>
</code></pre></div></div>

<p>This will install the <code class="language-plaintext highlighter-rouge">r3bl-cmdr</code> binary and run <code class="language-plaintext highlighter-rouge">edi</code>, which is a TUI Markdown editor
that you can use on any OS (Mac, Windows, Linux).</p>

<h2 id="references">References</h2>
<p><a id="markdown-references" name="references"></a></p>

<p><code class="language-plaintext highlighter-rouge">nom</code> is a huge topic. This tutorial takes a hands on approach to learning <code class="language-plaintext highlighter-rouge">nom</code>. However, the resources
listed below are very useful for learning <code class="language-plaintext highlighter-rouge">nom</code>. Think of them as a reference guide and deep dive into
how the <code class="language-plaintext highlighter-rouge">nom</code> library works.</p>

<ul>
  <li>Useful:
    <ul>
      <li>Source code examples (fantastic way to learn <code class="language-plaintext highlighter-rouge">nom</code>):
        <ul>
          <li><a href="https://github.com/dimfeld/export-logseq-notes/tree/master/src">export-logseq-notes repo</a></li>
        </ul>
      </li>
      <li>Videos:
        <ul>
          <li><a href="https://youtu.be/EXEMm5173SM">Intro from the author 7yrs old</a></li>
          <li><code class="language-plaintext highlighter-rouge">nom</code> 7 deep dive videos:
            <ul>
              <li><a href="https://youtu.be/Igajh2Vliog">Parsing name, age, and preference from natural language input</a></li>
              <li><a href="https://youtu.be/Xm4jrjohDN8">Parsing number ranges</a></li>
              <li><a href="https://youtu.be/6b2ymQWldoE">Parsing lines of text</a></li>
            </ul>
          </li>
          <li><code class="language-plaintext highlighter-rouge">nom</code> 6 videos (deep dive into how nom combinators themselves are constructed):
            <ul>
              <li><a href="https://youtu.be/zHF6j1LvngA">Deep dive, Part 1</a></li>
              <li><a href="https://youtu.be/9GLFJcSO08Y">Deep dive, Part 2</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Tutorials:
        <ul>
          <li><a href="https://codeandbitters.com/lets-build-a-parser/">Build a JSON parser using <code class="language-plaintext highlighter-rouge">nom</code> 7</a></li>
          <li><a href="https://github.com/benkay86/nom-tutorial">Excellent beginner to advanced</a></li>
          <li><a href="https://github.com/rust-bakery/nom/blob/main/doc/making_a_new_parser_from_scratch.md">Write a parser from scratch</a></li>
        </ul>
      </li>
      <li>Reference docs:
        <ul>
          <li><a href="https://tfpk.github.io/nominomicon/introduction.html">nominomicon</a></li>
          <li><a href="https://github.com/rust-bakery/nom/blob/main/doc/choosing_a_combinator.md">What combinator or parser to use?</a></li>
          <li><a href="https://docs.rs/nom/7.1.3/nom/">docs.rs</a></li>
          <li><a href="https://github.com/rust-bakery/nom/blob/main/doc/upgrading_to_nom_5.md">Upgrading to <code class="language-plaintext highlighter-rouge">nom</code> 5.0</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Less useful:
    <ul>
      <li><a href="https://github.com/rust-bakery/nom">README</a></li>
      <li><a href="https://crates.io/crates/nom"><code class="language-plaintext highlighter-rouge">nom</code> crate</a></li>
    </ul>
  </li>
</ul>

<h2 id="build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</h2>
<p><a id="markdown-build-with-naz-video-series-on-developerlife.com-youtube-channel" name="build-with-naz-video-series-on-developerlife.com-youtube-channel"></a></p>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a></li>
  <li>Playlists
    <ul>
      <li><a href="https://www.youtube.com/watch?v=bolScvh4x7I&amp;list=PLofhE49PEwmw3MKOU1Kn3xbP4FRQR4Mb3">Build with Naz, Linux TTY, process, signals, commands in async Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmza94sS7UmJnN9gSCHTVTfz">Build with Naz, fundamental effective Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmwO69E7eiQ-ewnMME8ydgQ5">Build with Naz, effective async Rust and tokio</a></li>
      <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><category term="TUI" /><summary type="html"><![CDATA[This tutorial and video are a deep dive in a real Markdown parser written using nom in Rust. This MD Parser is part of the r3bl_tui crate, which is part of the r3bl-open-core repo. It goes over the architecture of thinking about building complex parsers and the nitty gritty details the runtime nature and behavior when combining nom parsers.]]></summary></entry><entry><title type="html">Build with Naz : Rust error handling with miette</title><link href="http://developerlife.com/2024/06/10/rust-miette-error-handling/" rel="alternate" type="text/html" title="Build with Naz : Rust error handling with miette" /><published>2024-06-10T10:00:00-05:00</published><updated>2024-06-10T10:00:00-05:00</updated><id>http://developerlife.com/2024/06/10/rust-miette-error-handling</id><content type="html" xml:base="http://developerlife.com/2024/06/10/rust-miette-error-handling/"><![CDATA[<p><img class="post-hero-image" src="/assets/rust-miette.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#rust-error-handling-primer">Rust error handling primer</a></li>
  <li><a href="#more-resources-on-rust-error-handling">More resources on Rust error handling</a></li>
  <li><a href="#youtube-video-for-this-article">YouTube video for this article</a></li>
  <li><a href="#examples-of-rust-error-handling-with-miette">Examples of Rust error handling with miette</a>
    <ul>
      <li><a href="#example-1-simple-miette-usage">Example 1: Simple miette usage</a></li>
      <li><a href="#example-2-complex-miette-usage">Example 2: Complex miette usage</a></li>
      <li><a href="#parting-thoughts">Parting thoughts</a></li>
    </ul>
  </li>
  <li><a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</a></li>
</ul>

<!-- /TOC -->

<h2 id="introduction">Introduction</h2>
<p><a id="markdown-introduction" name="introduction"></a></p>

<p>miette is an excellent crate that can make error handling in Rust powerful, flexible,
and easy to use. It provides a way to create custom error types, add context to errors,
and display errors in a user-friendly way. In this article, video, and repo, we’ll
explore how to use miette to improve error handling in your Rust applications.</p>

<h2 id="rust-error-handling-primer">Rust error handling primer</h2>
<p><a id="markdown-rust-error-handling-primer" name="rust-error-handling-primer"></a></p>

<p>Rust has a powerful error handling system that is based on the
<a href="https://doc.rust-lang.org/std/result/"><code class="language-plaintext highlighter-rouge">Result</code></a> and <code class="language-plaintext highlighter-rouge">Option</code> types. For this tutorial we
will focus on the <code class="language-plaintext highlighter-rouge">Result</code> type, which is an enum that has two variants: <code class="language-plaintext highlighter-rouge">Ok</code> and <code class="language-plaintext highlighter-rouge">Err</code>.
The <code class="language-plaintext highlighter-rouge">Ok</code> variant is used to represent a successful result, while the <code class="language-plaintext highlighter-rouge">Err</code> variant is used
to represent an error.</p>

<p>The <a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code class="language-plaintext highlighter-rouge">Error</code></a> trait in Rust has to
be implemented for types that can be used as errors. The <code class="language-plaintext highlighter-rouge">Error</code> trait has a method called
<code class="language-plaintext highlighter-rouge">source</code> that returns a reference to the underlying cause of the error. This trait has two
supertraits: <code class="language-plaintext highlighter-rouge">Debug</code> and <code class="language-plaintext highlighter-rouge">Display</code>. The <code class="language-plaintext highlighter-rouge">Debug</code> trait is used to format the error for
debugging purposes (for the operator), while the <code class="language-plaintext highlighter-rouge">Display</code> trait is used to format the
error for displaying to the user.</p>

<p>The <code class="language-plaintext highlighter-rouge">?</code> operator can be used in order to propagate errors up the call stack. This operator
is used to unwrap the <code class="language-plaintext highlighter-rouge">Result</code> type and provide the inner value of the <code class="language-plaintext highlighter-rouge">Ok</code> variant.
Otherwise it returns from the function with the error, if it is the <code class="language-plaintext highlighter-rouge">Err</code> variant. This
operator can only be used in functions that return a <code class="language-plaintext highlighter-rouge">Result</code> type. Here’s an example:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Fails and produces output:</span>
<span class="cd">/// ```text</span>
<span class="cd">/// Error: ParseIntError { kind: InvalidDigit }</span>
<span class="cd">/// ```</span>
<span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">test</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">return_error_result</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">u32</span><span class="p">,</span> <span class="nn">std</span><span class="p">::</span><span class="nn">num</span><span class="p">::</span><span class="n">ParseIntError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="s">"1.2"</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">run</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="c1">// It is as if the `?` is turned into the following code.</span>
        <span class="c1">// let result = match result {</span>
        <span class="c1">//     Ok(value) =&gt; value,</span>
        <span class="c1">//     Err(err) =&gt; return Err(Box::new(err)),</span>
        <span class="c1">// }</span>
        <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">return_error_result</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

        <span class="c1">// The following lines will never be executed, since the previous</span>
        <span class="c1">// line will return from the function with an error.</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Result: {}"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>

    <span class="nf">run</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In the rest of the tutorial (and accompanying video), we will build upon this knowledge
and introduce <code class="language-plaintext highlighter-rouge">miette</code>, a crate that can make error handling in Rust powerful, flexible,
and easy to use. We will also learn more about the <code class="language-plaintext highlighter-rouge">thiserror</code> crate, which can be used to
easily create custom error types in Rust.</p>

<h2 id="more-resources-on-rust-error-handling">More resources on Rust error handling</h2>
<p><a id="markdown-more-resources-on-rust-error-handling" name="more-resources-on-rust-error-handling"></a></p>

<ul>
  <li><a href="https://docs.rs/thiserror/latest/thiserror/"><code class="language-plaintext highlighter-rouge">thiserror</code> crate</a>.</li>
  <li><a href="https://docs.rs/miette/latest/miette/"><code class="language-plaintext highlighter-rouge">miette</code> crate</a>.</li>
  <li><a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code class="language-plaintext highlighter-rouge">Error</code> trait</a>.</li>
  <li><a href="https://doc.rust-lang.org/std/result/"><code class="language-plaintext highlighter-rouge">Result</code> enum</a>.</li>
</ul>

<h2 id="youtube-video-for-this-article">YouTube video for this article</h2>
<p><a id="markdown-youtube-video-for-this-article" name="youtube-video-for-this-article"></a></p>

<p>This blog post has short examples on how to use <code class="language-plaintext highlighter-rouge">miette</code> to enhance Rust error handling. If
you like to learn via video, please watch the companion video on the <a href="https://www.youtube.com/@developerlifecom">developerlife.com
YouTube channel</a>.</p>

<!-- rust error handling with miette -->
<iframe src="https://www.youtube.com/embed/TmLF7vI8lKk?si=Xh5belp5zD-w-J3P" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<p><br /></p>

<h2 id="examples-of-rust-error-handling-with-miette">Examples of Rust error handling with miette</h2>
<p><a id="markdown-examples-of-rust-error-handling-with-miette" name="examples-of-rust-error-handling-with-miette"></a></p>

<p>Let’s create some examples to illustrate how to use <code class="language-plaintext highlighter-rouge">miette</code> to enhance Rust error
handling. You can run <code class="language-plaintext highlighter-rouge">cargo new --lib error-miette</code> to create a new library crate.</p>

<blockquote>
  <p>The code in the video and this tutorial are all in <a href="https://github.com/nazmulidris/rust-scratch/blob/main/error-miette/src/lib.rs">this GitHub
repo</a>.</p>
</blockquote>

<p>Then add the following to the <code class="language-plaintext highlighter-rouge">Cargo.toml</code> file that’s generated. These pull in all the
dependencies that we need for these examples.</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[package]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"error-miette"</span>
<span class="py">version</span> <span class="p">=</span> <span class="s">"0.1.0"</span>
<span class="py">edition</span> <span class="p">=</span> <span class="s">"2021"</span>

<span class="nn">[dependencies]</span>

<span class="c"># Pretty terminal output.</span>
<span class="py">crossterm</span> <span class="p">=</span> <span class="s">"0.27.0"</span>

<span class="c"># Error handling.</span>
<span class="py">thiserror</span> <span class="p">=</span> <span class="s">"1.0.61"</span>
<span class="py">miette</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"7.2.0"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"fancy"</span><span class="p">]</span> <span class="p">}</span>
<span class="py">pretty_assertions</span> <span class="p">=</span> <span class="s">"1.4.0"</span>
</code></pre></div></div>

<h3 id="example-1-simple-miette-usage">Example 1: Simple miette usage</h3>
<p><a id="markdown-example-1%3A-simple-miette-usage" name="example-1%3A-simple-miette-usage"></a></p>

<p>Then you can add the following code to the <code class="language-plaintext highlighter-rouge">src/lib.rs</code> file. You can note the following things
in the code:</p>
<ul>
  <li>We define a custom error type called <code class="language-plaintext highlighter-rouge">UnderlyingDatabaseError</code> using the <code class="language-plaintext highlighter-rouge">thiserror</code> crate.</li>
  <li>We define a function called <code class="language-plaintext highlighter-rouge">return_error_result</code> that returns a <code class="language-plaintext highlighter-rouge">Result&lt;u32, std::num::ParseIntError&gt;</code>.</li>
  <li>We write a test called <code class="language-plaintext highlighter-rouge">test_into_diagnostic</code> that demonstrates how to use <code class="language-plaintext highlighter-rouge">miette</code> to
add context to errors and display them in a user-friendly way. The test also
demonstrates how to use the <code class="language-plaintext highlighter-rouge">wrap_err</code> and <code class="language-plaintext highlighter-rouge">context</code> methods to add context to errors.
And how they are displayed in the error report (in the inverse order in which they were
added).</li>
  <li>We also demonstrate how to use the <code class="language-plaintext highlighter-rouge">into_diagnostic</code> method to convert a <code class="language-plaintext highlighter-rouge">Result</code> into a
<code class="language-plaintext highlighter-rouge">miette::Result</code>.</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="k">pub</span> <span class="k">mod</span> <span class="n">simple_miette_usage</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">crossterm</span><span class="p">::</span><span class="nn">style</span><span class="p">::</span><span class="n">Stylize</span><span class="p">;</span>
    <span class="k">use</span> <span class="nn">miette</span><span class="p">::{</span><span class="n">Context</span><span class="p">,</span> <span class="n">IntoDiagnostic</span><span class="p">};</span>

    <span class="nd">#[derive(Debug,</span> <span class="nd">thiserror::Error)]</span>
    <span class="k">pub</span> <span class="k">enum</span> <span class="n">UnderlyingDatabaseError</span> <span class="p">{</span>
        <span class="nd">#[error(</span><span class="s">"database corrupted"</span><span class="nd">)]</span>
        <span class="n">DatabaseCorrupted</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">return_error_result</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">u32</span><span class="p">,</span> <span class="nn">std</span><span class="p">::</span><span class="nn">num</span><span class="p">::</span><span class="n">ParseIntError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="s">"1.2"</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">test_into_diagnostic</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">error_result</span><span class="p">:</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">u32</span><span class="p">,</span> <span class="nn">std</span><span class="p">::</span><span class="nn">num</span><span class="p">::</span><span class="n">ParseIntError</span><span class="o">&gt;</span> <span class="o">=</span>
            <span class="nf">return_error_result</span><span class="p">();</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">error_result</span><span class="nf">.is_err</span><span class="p">());</span>

        <span class="c1">// The following line will return from this test.</span>
        <span class="c1">// let it: u32 = error_result.into_diagnostic()?;</span>

        <span class="k">let</span> <span class="n">new_miette_result</span><span class="p">:</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">error_result</span>
            <span class="nf">.into_diagnostic</span><span class="p">()</span>
            <span class="nf">.context</span><span class="p">(</span><span class="s">"🍍 foo bar baz"</span><span class="p">)</span>
            <span class="nf">.wrap_err</span><span class="p">(</span><span class="nn">miette</span><span class="p">::</span><span class="nd">miette!</span><span class="p">(</span><span class="s">"custom string error"</span><span class="p">))</span>
            <span class="nf">.wrap_err</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="nn">ErrorKind</span><span class="p">::</span><span class="n">NotFound</span><span class="p">)</span>
            <span class="nf">.wrap_err</span><span class="p">(</span><span class="nn">UnderlyingDatabaseError</span><span class="p">::</span><span class="n">DatabaseCorrupted</span><span class="p">)</span>
            <span class="nf">.wrap_err</span><span class="p">(</span><span class="s">"🎃 this is additional context about the failure"</span><span class="p">);</span>

        <span class="nd">assert!</span><span class="p">(</span><span class="n">new_miette_result</span><span class="nf">.is_err</span><span class="p">());</span>

        <span class="nd">println!</span><span class="p">(</span>
            <span class="s">"{}:</span><span class="se">\n</span><span class="s">{:?}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="s">"debug output"</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.bold</span><span class="p">(),</span>
            <span class="n">new_miette_result</span>
        <span class="p">);</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Err</span><span class="p">(</span><span class="k">ref</span> <span class="n">miette_report</span><span class="p">)</span> <span class="o">=</span> <span class="n">new_miette_result</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span>
                <span class="s">"{}:</span><span class="se">\n</span><span class="s">{:?}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                <span class="s">"miette report"</span><span class="nf">.red</span><span class="p">()</span><span class="nf">.bold</span><span class="p">(),</span>
                <span class="n">miette_report</span><span class="nf">.to_string</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">miette_report</span><span class="nf">.chain</span><span class="p">();</span>

            <span class="c1">// First.</span>
            <span class="nn">pretty_assertions</span><span class="p">::</span><span class="nd">assert_eq!</span><span class="p">(</span>
                <span class="n">iter</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="s">"🎃 this is additional context about the failure"</span>
                    <span class="nf">.to_string</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="c1">// Second.</span>
            <span class="nn">pretty_assertions</span><span class="p">::</span><span class="nd">assert_eq!</span><span class="p">(</span>
                <span class="n">iter</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="s">"database corrupted"</span><span class="nf">.to_string</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="c1">// Third.</span>
            <span class="nn">pretty_assertions</span><span class="p">::</span><span class="nd">assert_eq!</span><span class="p">(</span>
                <span class="n">iter</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="s">"entity not found"</span><span class="nf">.to_string</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="c1">// Fourth.</span>
            <span class="nn">pretty_assertions</span><span class="p">::</span><span class="nd">assert_eq!</span><span class="p">(</span>
                <span class="n">iter</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="s">"custom string error"</span><span class="nf">.to_string</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="c1">// Fifth.</span>
            <span class="nn">pretty_assertions</span><span class="p">::</span><span class="nd">assert_eq!</span><span class="p">(</span>
                <span class="n">iter</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="s">"🍍 foo bar baz"</span><span class="nf">.to_string</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="c1">// Final.</span>
            <span class="nn">pretty_assertions</span><span class="p">::</span><span class="nd">assert_eq!</span><span class="p">(</span>
                <span class="n">iter</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="s">"invalid digit found in string"</span><span class="nf">.to_string</span><span class="p">()</span>
            <span class="p">);</span>
        <span class="p">}</span>

        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">test_convert_report_into_error</span><span class="p">()</span> <span class="k">-&gt;</span>
        <span class="nn">std</span><span class="p">::</span><span class="nn">result</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">miette_result</span><span class="p">:</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span> <span class="o">=</span>
            <span class="nf">return_error_result</span><span class="p">()</span>
                <span class="nf">.into_diagnostic</span><span class="p">()</span>
                <span class="nf">.wrap_err</span><span class="p">(</span><span class="nn">miette</span><span class="p">::</span><span class="nn">Report</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span>
                    <span class="s">"wrapper for the source parse int error"</span><span class="p">,</span>
                <span class="p">));</span>

        <span class="c1">// let converted_result: Result&lt;u32, Box&lt;dyn Error&gt;&gt; =</span>
        <span class="c1">//     miette_result.map_err(|report| report.into());</span>

        <span class="k">let</span> <span class="n">converted_result</span><span class="p">:</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">result</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;&gt;</span> <span class="o">=</span>
            <span class="k">match</span> <span class="n">miette_result</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(()),</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">miette_report</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">boxed_error</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span> <span class="o">=</span>
                        <span class="n">miette_report</span><span class="nf">.into</span><span class="p">();</span>
                    <span class="nf">Err</span><span class="p">(</span><span class="n">boxed_error</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">};</span>

        <span class="nd">println!</span><span class="p">(</span>
            <span class="s">"{}:</span><span class="se">\n</span><span class="s">{:?}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="s">"debug output"</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.bold</span><span class="p">(),</span>
            <span class="n">converted_result</span>
        <span class="p">);</span>

        <span class="nd">assert!</span><span class="p">(</span><span class="n">converted_result</span><span class="nf">.is_err</span><span class="p">());</span>

        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="example-2-complex-miette-usage">Example 2: Complex miette usage</h3>
<p><a id="markdown-example-2%3A-complex-miette-usage" name="example-2%3A-complex-miette-usage"></a></p>

<p>Next, we will add the following code to the <code class="language-plaintext highlighter-rouge">src/lib.rs</code> file. You can note the following
things in the code:</p>

<ul>
  <li>We define a custom error type called <code class="language-plaintext highlighter-rouge">KvStoreError</code> using the <code class="language-plaintext highlighter-rouge">thiserror</code> crate.</li>
  <li>We define two variants for the <code class="language-plaintext highlighter-rouge">KvStoreError</code> enum: <code class="language-plaintext highlighter-rouge">CouldNotCreateDbFolder</code> and
<code class="language-plaintext highlighter-rouge">CouldNotGetOrCreateEnvOrOpenStore</code>. The latter variant has a field called <code class="language-plaintext highlighter-rouge">source</code> that
is of type <code class="language-plaintext highlighter-rouge">UnderlyingDatabaseError</code>, which is defined in the previous example.</li>
  <li>We define two functions called <code class="language-plaintext highlighter-rouge">return_flat_err</code> and <code class="language-plaintext highlighter-rouge">return_nested_err</code> that return
<code class="language-plaintext highlighter-rouge">miette::Result&lt;(), KvStoreError&gt;</code>.</li>
  <li>We write two tests called <code class="language-plaintext highlighter-rouge">fails_with_flat_err</code> and <code class="language-plaintext highlighter-rouge">fails_with_nested_err</code> that
demonstrate how to use <code class="language-plaintext highlighter-rouge">miette</code> to add context to errors and display them in a
user-friendly way. The tests also demonstrate how to use the <code class="language-plaintext highlighter-rouge">from</code> attribute to convert
an error of one type into an error of another type.</li>
  <li>We also demonstrate how to use the <code class="language-plaintext highlighter-rouge">#[diagnostic]</code> attribute to add a code and help URL
to the error type.</li>
  <li>We also demonstrate how to use the <code class="language-plaintext highlighter-rouge">#[from]</code> attribute to convert an error of one type
into an error of another type.</li>
  <li>We also demonstrate how to use the <code class="language-plaintext highlighter-rouge">#[error]</code> attribute to add a custom error message to
the error type.</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="k">pub</span> <span class="k">mod</span> <span class="n">complex_miette_usage</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span><span class="p">;</span>

    <span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="nn">simple_miette_usage</span><span class="p">::</span><span class="n">UnderlyingDatabaseError</span><span class="p">;</span>
    <span class="k">use</span> <span class="nn">pretty_assertions</span><span class="p">::</span><span class="n">assert_eq</span><span class="p">;</span>

    <span class="nd">#[derive(thiserror::Error,</span> <span class="nd">Debug,</span> <span class="nd">miette::Diagnostic)]</span>
    <span class="k">pub</span> <span class="k">enum</span> <span class="n">KvStoreError</span> <span class="p">{</span>
        <span class="nd">#[diagnostic(</span>
            <span class="nd">code(MyErrorCode::FileSystemError),</span>
            <span class="nd">help(</span><span class="s">"https://docs.rs/rkv/latest/rkv/enum.StoreError.html"</span><span class="nd">),</span>
            <span class="c1">// url(docsrs) /* Works if this code was on crates.io / docs.rs */</span>
        <span class="nd">)]</span>
        <span class="nd">#[error(</span><span class="s">"📂 Could not create db folder: '{db_folder_path}' on disk"</span><span class="nd">)]</span>
        <span class="n">CouldNotCreateDbFolder</span> <span class="p">{</span> <span class="n">db_folder_path</span><span class="p">:</span> <span class="nb">String</span> <span class="p">},</span>

        <span class="nd">#[diagnostic(</span>
            <span class="nd">code(MyErrorCode::StoreCreateOrAccessError),</span>
            <span class="nd">help(</span><span class="s">"https://docs.rs/rkv/latest/rkv/enum.StoreError.html"</span><span class="nd">),</span>
            <span class="c1">// url(docsrs) /* Works if this code was on crates.io / docs.rs */</span>
        <span class="nd">)]</span>
        <span class="nd">#[error(</span><span class="s">"💾 Could not get or create environment, or open store"</span><span class="nd">)]</span>
        <span class="n">CouldNotGetOrCreateEnvOrOpenStore</span> <span class="p">{</span>
            <span class="nd">#[from]</span>
            <span class="n">source</span><span class="p">:</span> <span class="n">UnderlyingDatabaseError</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">return_flat_err</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">KvStoreError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nn">Result</span><span class="p">::</span><span class="nf">Err</span><span class="p">(</span><span class="nn">KvStoreError</span><span class="p">::</span><span class="n">CouldNotCreateDbFolder</span> <span class="p">{</span>
            <span class="n">db_folder_path</span><span class="p">:</span> <span class="s">"some/path/to/db"</span><span class="nf">.to_string</span><span class="p">(),</span>
        <span class="p">})</span>
    <span class="p">}</span>

    <span class="cd">/// This test will not run! It will fail and demonstrate the default</span>
    <span class="cd">/// [report handler](miette::ReportHandler) of the `miette` crate.</span>
    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">fails_with_flat_err</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">return_flat_err</span><span class="p">();</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Err</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">result</span> <span class="p">{</span>
            <span class="nd">assert_eq!</span><span class="p">(</span>
                <span class="nd">format!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">error</span><span class="p">),</span>
                <span class="s">"CouldNotCreateDbFolder { db_folder_path: </span><span class="se">\"</span><span class="s">some/path/to/db</span><span class="se">\"</span><span class="s"> }"</span>
            <span class="p">);</span>
        <span class="p">}</span>

        <span class="n">result</span><span class="o">?</span><span class="p">;</span>

        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">return_nested_err</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">KvStoreError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// Variant 1 - Very verbose.</span>
        <span class="k">let</span> <span class="n">store_error</span> <span class="o">=</span> <span class="nn">UnderlyingDatabaseError</span><span class="p">::</span><span class="n">DatabaseCorrupted</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">rkv_error</span> <span class="o">=</span> <span class="nn">KvStoreError</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">store_error</span><span class="p">);</span>
        <span class="nn">Result</span><span class="p">::</span><span class="nf">Err</span><span class="p">(</span><span class="n">rkv_error</span><span class="p">)</span>

        <span class="c1">// Variant 2.</span>
        <span class="c1">// Result::Err(KvStoreError::CouldNotGetOrCreateEnvOrOpenStore {</span>
        <span class="c1">//     source: UnderlyingDatabaseError::DatabaseCorrupted,</span>
        <span class="c1">// })</span>
    <span class="p">}</span>

    <span class="cd">/// This test will not run! It will fail and demonstrate the default</span>
    <span class="cd">/// [report handler](miette::ReportHandler) of the `miette` crate.</span>
    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">fails_with_nested_err</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">return_nested_err</span><span class="p">();</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Err</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">result</span> <span class="p">{</span>
            <span class="nd">assert_eq!</span><span class="p">(</span>
                <span class="nd">format!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">error</span><span class="p">),</span>
                <span class="s">"CouldNotGetOrCreateEnvOrOpenStore { source: DatabaseCorrupted }"</span>
            <span class="p">);</span>
        <span class="p">}</span>

        <span class="n">result</span><span class="o">?</span><span class="p">;</span>

        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="parting-thoughts">Parting thoughts</h3>
<p><a id="markdown-parting-thoughts" name="parting-thoughts"></a></p>

<p>For more sophisticated error handling examples, please check out the following links:</p>

<ul>
  <li><a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/terminal_async/src/public_api/terminal_async.rs#L57"><code class="language-plaintext highlighter-rouge">terminal_async.rs</code> in <code class="language-plaintext highlighter-rouge">r3bl_terminal_async</code>
crate</a>.</li>
  <li><a href="https://github.com/nazmulidris/rust-scratch/blob/main/tcp-api-server/src/standalone/kv.rs#L137"><code class="language-plaintext highlighter-rouge">kv.rs</code> in <code class="language-plaintext highlighter-rouge">tcp-api-server</code>
crate</a>.</li>
  <li><a href="https://github.com/nazmulidris/rust-scratch/blob/main/tcp-api-server/src/standalone/miette_setup_global_report_handler.rs">Custom global report handler for <code class="language-plaintext highlighter-rouge">miette</code> in <code class="language-plaintext highlighter-rouge">tcp-api-server</code>
crate</a>.</li>
</ul>

<h2 id="build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</h2>
<p><a id="markdown-build-with-naz-video-series-on-developerlife.com-youtube-channel" name="build-with-naz-video-series-on-developerlife.com-youtube-channel"></a></p>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a></li>
  <li>Playlists
    <ul>
      <li><a href="https://www.youtube.com/watch?v=bolScvh4x7I&amp;list=PLofhE49PEwmw3MKOU1Kn3xbP4FRQR4Mb3">Build with Naz, Linux TTY, process, signals, commands in async Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmza94sS7UmJnN9gSCHTVTfz">Build with Naz, fundamental effective Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmwO69E7eiQ-ewnMME8ydgQ5">Build with Naz, effective async Rust and tokio</a></li>
      <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><summary type="html"><![CDATA[miette is an excellent crate that can make error handling in Rust powerful, flexible, and easy to use. It provides a way to create custom error types, add context to errors, and display errors in a user-friendly way. In this article, video, and repo, we'll explore how to use miette to improve error handling in your Rust applications.]]></summary></entry></feed>