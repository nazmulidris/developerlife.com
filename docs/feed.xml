<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://developerlife.com/feed.xml" rel="self" type="application/atom+xml" /><link href="http://developerlife.com/" rel="alternate" type="text/html" /><updated>2024-09-13T19:11:22-05:00</updated><id>http://developerlife.com/feed.xml</id><title type="html">developerlife.com</title><subtitle>Rust, TUI, Android, Web, Desktop, Cloud technologies, and UX engineering and design tutorials.</subtitle><author><name>Nazmul Idris</name></author><entry><title type="html">Build with Naz : Rust lifetimes</title><link href="http://developerlife.com/2024/09/02/rust-lifetimes/" rel="alternate" type="text/html" title="Build with Naz : Rust lifetimes" /><published>2024-09-02T00:00:00-05:00</published><updated>2024-09-02T00:00:00-05:00</updated><id>http://developerlife.com/2024/09/02/rust-lifetimes</id><content type="html" xml:base="http://developerlife.com/2024/09/02/rust-lifetimes/"><![CDATA[<p><img class="post-hero-image" src="/assets/lifetimes.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#what-is-subtyping-and-variance">What is subtyping and variance?</a>
    <ul>
      <li><a href="#subtyping">Subtyping</a></li>
      <li><a href="#variance">Variance</a></li>
    </ul>
  </li>
  <li><a href="#more-resources-on-rust-lifetimes">More resources on Rust lifetimes</a></li>
  <li><a href="#youtube-videos-for-this-article">YouTube videos for this article</a></li>
  <li><a href="#learn-rust-lifetimes-by-example">Learn Rust lifetimes by example</a>
    <ul>
      <li><a href="#example-1-references">Example 1: References</a></li>
      <li><a href="#example-2-aliasing">Example 2: Aliasing</a></li>
      <li><a href="#example-3-lifetimes">Example 3: Lifetimes</a></li>
      <li><a href="#example-4-input-slices">Example 4: Input slices</a></li>
      <li><a href="#example-5-splitting-borrows-on-structs">Example 5: Splitting borrows on structs</a></li>
      <li><a href="#example-6-clone-on-write-cow">Example 6: Clone on write Cow</a></li>
      <li><a href="#example-7-subtyping-and-variance">Example 7: Subtyping and variance</a></li>
    </ul>
  </li>
  <li><a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</a></li>
</ul>

<!-- /TOC -->

<h2 id="what-is-subtyping-and-variance">What is subtyping and variance?</h2>
<p><a id="markdown-what-is-subtyping-and-variance%3F" name="what-is-subtyping-and-variance%3F"></a></p>

<p>Subtyping and variance are important concepts in Rust‚Äôs algebraic type system. They allow
us to express relationships between types, and equivalence without using inheritance. Rust
also includes lifetimes in the type definitions themselves! So they become an integral
part of the a type.</p>

<h3 id="subtyping">Subtyping</h3>
<p><a id="markdown-subtyping" name="subtyping"></a></p>

<p>In Rust, subtyping refers to the relationship between two types where one type can be used
in place of the other.</p>

<ol>
  <li>This means that if a type <code class="language-plaintext highlighter-rouge">Sub</code> is a subtype of type <code class="language-plaintext highlighter-rouge">Super</code>, then any code that
expects a <code class="language-plaintext highlighter-rouge">Super</code> can also accept an <code class="language-plaintext highlighter-rouge">Sub</code>. They are equivalent.</li>
  <li>Just like inheritance, the opposite is not true. Any code expecting a <code class="language-plaintext highlighter-rouge">Sub</code> cannot
accept a <code class="language-plaintext highlighter-rouge">Super</code>. They are not equivalent.</li>
</ol>

<p>Consider the following code snippet:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">Cat</span> <span class="p">{</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">breed</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Display</span> <span class="k">for</span> <span class="n">Cat</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span>
    <span class="p">{</span>
        <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"Cat: {} ({})"</span><span class="p">,</span> <span class="k">self</span><span class="py">.name</span><span class="p">,</span> <span class="k">self</span><span class="py">.breed</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Dog</span> <span class="p">{</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">breed</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Display</span> <span class="k">for</span> <span class="n">Dog</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span>
    <span class="p">{</span>
        <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"Dog: {} ({})"</span><span class="p">,</span> <span class="k">self</span><span class="py">.name</span><span class="p">,</span> <span class="k">self</span><span class="py">.breed</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cd">/// Since Display is a trait bound in the print_animal function,</span>
<span class="cd">/// both &amp;Cat and &amp;Dog can be used as arguments because they are</span>
<span class="cd">/// both subtypes of &amp;dyn Display.</span>
<span class="k">fn</span> <span class="n">print_animal</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Display</span><span class="o">&gt;</span><span class="p">(</span><span class="n">animal</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">animal</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">cat</span> <span class="o">=</span> <span class="n">Cat</span> <span class="p">{</span>
        <span class="n">name</span><span class="p">:</span> <span class="s">"Sparky"</span><span class="nf">.to_string</span><span class="p">(),</span>
        <span class="n">breed</span><span class="p">:</span> <span class="s">"Siamese"</span><span class="nf">.to_string</span><span class="p">()</span> <span class="p">};</span>
    <span class="k">let</span> <span class="n">dog</span> <span class="o">=</span> <span class="n">Dog</span> <span class="p">{</span>
        <span class="n">name</span><span class="p">:</span> <span class="s">"Buddy"</span><span class="nf">.to_string</span><span class="p">(),</span>
        <span class="n">breed</span><span class="p">:</span> <span class="s">"Golden Retriever"</span><span class="nf">.to_string</span><span class="p">()</span> <span class="p">};</span>

    <span class="nf">print_animal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cat</span><span class="p">);</span> <span class="c1">// Prints "Cat: Sparky (Siamese)"</span>
    <span class="nf">print_animal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dog</span><span class="p">);</span> <span class="c1">// Prints "Dog: Buddy (Golden Retriever)"</span>

    <span class="k">let</span> <span class="n">animals</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="k">dyn</span> <span class="n">Display</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="o">&amp;</span><span class="n">cat</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dog</span><span class="p">];</span>
    <span class="k">for</span> <span class="n">animal</span> <span class="k">in</span> <span class="n">animals</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">animal</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In this example:</p>

<ul>
  <li>In the function <code class="language-plaintext highlighter-rouge">print_animal&lt;T&gt;(animal: &amp;T)</code>, the super type of <code class="language-plaintext highlighter-rouge">T</code> is <code class="language-plaintext highlighter-rouge">Display</code>. This
means that this function accepts any type that implements the <code class="language-plaintext highlighter-rouge">Display</code> trait.</li>
  <li>So, we can pass both <code class="language-plaintext highlighter-rouge">&amp;Cat</code> and <code class="language-plaintext highlighter-rouge">&amp;Dog</code> to the <code class="language-plaintext highlighter-rouge">print_animal()</code> function. Since both
<code class="language-plaintext highlighter-rouge">Cat</code> and <code class="language-plaintext highlighter-rouge">Dog</code> implement the <code class="language-plaintext highlighter-rouge">Display</code> trait.</li>
  <li>The <code class="language-plaintext highlighter-rouge">animals</code> vector can hold references to any type that implements the <code class="language-plaintext highlighter-rouge">Display</code>
trait, so we can store both <code class="language-plaintext highlighter-rouge">Cat</code> and <code class="language-plaintext highlighter-rouge">Dog</code> instances in it.
    <ul>
      <li>We use <code class="language-plaintext highlighter-rouge">&amp;dyn Display</code> as the type since we want to use <a href="https://doc.rust-lang.org/stable/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">trait
objects</a>.</li>
      <li>And we can‚Äôt use <code class="language-plaintext highlighter-rouge">&amp;impl Animal</code> since <a href="https://doc.rust-lang.org/stable/book/ch10-02-traits.html#clearer-trait-bounds-with-where-clauses">this
syntax</a>
expects only a single type.</li>
    </ul>
  </li>
</ul>

<p>A real world example of this is the <code class="language-plaintext highlighter-rouge">Copy</code> and <code class="language-plaintext highlighter-rouge">Clone</code> traits:</p>

<ul>
  <li><a href="https://doc.rust-lang.org/1.80.1/src/core/marker.rs.html#403">https://doc.rust-lang.org/1.80.1/src/core/marker.rs.html#403</a></li>
  <li>A type that is <code class="language-plaintext highlighter-rouge">Copy</code> is also <code class="language-plaintext highlighter-rouge">Clone</code>.</li>
  <li>But a type that is <code class="language-plaintext highlighter-rouge">Clone</code> is not necessarily <code class="language-plaintext highlighter-rouge">Copy</code>.</li>
</ul>

<h3 id="variance">Variance</h3>
<p><a id="markdown-variance" name="variance"></a></p>

<p>In Rust, variance describes how subtyping relationships are preserved when dealing with
<strong>generic</strong> types. Lifetime annotations are part of the generics system. There are three
types of variance:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Covariance</code>: A generic type <code class="language-plaintext highlighter-rouge">T</code> is covariant if, when <code class="language-plaintext highlighter-rouge">Sub</code> is a subtype of <code class="language-plaintext highlighter-rouge">Super</code>,
<code class="language-plaintext highlighter-rouge">T&lt;Sub&gt;</code> is also a subtype of <code class="language-plaintext highlighter-rouge">T&lt;Super&gt;</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">Invariance</code>: A generic type <code class="language-plaintext highlighter-rouge">T</code> is invariant if there is <strong>no</strong> subtyping relationship
 between <code class="language-plaintext highlighter-rouge">T&lt;Sub&gt;</code> and <code class="language-plaintext highlighter-rouge">T&lt;Super&gt;</code> when <code class="language-plaintext highlighter-rouge">Sub</code> is a subtype of <code class="language-plaintext highlighter-rouge">Super</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">Contravariance</code>: A generic type <code class="language-plaintext highlighter-rouge">T</code> is contravariant if, when <code class="language-plaintext highlighter-rouge">Sub</code> is a subtype of <code class="language-plaintext highlighter-rouge">Super</code>,
<code class="language-plaintext highlighter-rouge">T&lt;Super&gt;</code> is a subtype of <code class="language-plaintext highlighter-rouge">T&lt;Sub&gt;</code>.</li>
</ul>

<p>Here are some examples:</p>

<ul>
  <li><strong>Covariance:</strong> The <code class="language-plaintext highlighter-rouge">&amp;T</code> type is covariant. This means that if <code class="language-plaintext highlighter-rouge">Sub</code> is a subtype of
<code class="language-plaintext highlighter-rouge">Super</code>, then <code class="language-plaintext highlighter-rouge">&amp;Sub</code> is a subtype of <code class="language-plaintext highlighter-rouge">&amp;Super</code>. This is useful for references. In the
code, <code class="language-plaintext highlighter-rouge">Cat</code> and <code class="language-plaintext highlighter-rouge">Dog</code> both implement the <code class="language-plaintext highlighter-rouge">Display</code> trait. Since <code class="language-plaintext highlighter-rouge">Display</code> is a trait
bound in the <code class="language-plaintext highlighter-rouge">print_animal</code> function, both <code class="language-plaintext highlighter-rouge">&amp;Cat</code> and <code class="language-plaintext highlighter-rouge">&amp;Dog</code> can be used as arguments
because they are both subtypes of <code class="language-plaintext highlighter-rouge">&amp;dyn Display</code>.</li>
  <li><strong>Invariance:</strong> The <code class="language-plaintext highlighter-rouge">&amp;mut T</code> type is invariant. This means that if <code class="language-plaintext highlighter-rouge">Sub</code> is a subtype of
<code class="language-plaintext highlighter-rouge">Super</code>, there is no subtyping relationship between <code class="language-plaintext highlighter-rouge">&amp;mut Sub</code> and <code class="language-plaintext highlighter-rouge">&amp;mut Super</code>. Also,
the <code class="language-plaintext highlighter-rouge">UnsafeCell&lt;T&gt;</code> type is invariant. This means that there is no subtyping
relationship between <code class="language-plaintext highlighter-rouge">UnsafeCell&lt;Sub&gt;</code> and <code class="language-plaintext highlighter-rouge">UnsafeCell&lt;Super&gt;</code> when <code class="language-plaintext highlighter-rouge">Sub</code> is a subtype
of <code class="language-plaintext highlighter-rouge">Super</code>. This is because <code class="language-plaintext highlighter-rouge">UnsafeCell</code> is used to bypass Rust‚Äôs safety checks, so it
must be invariant. Both <code class="language-plaintext highlighter-rouge">&amp;mut T</code> and <code class="language-plaintext highlighter-rouge">UnsafeCell&lt;T&gt;</code> are invariant in Rust because they
are related to unsafe operations or mutable references, which require stricter type
constraints to ensure safety.</li>
  <li><strong>Contravariance:</strong> The <code class="language-plaintext highlighter-rouge">Fn(T)</code> type is contravariant. This means that if <code class="language-plaintext highlighter-rouge">Sub</code> is a
subtype of <code class="language-plaintext highlighter-rouge">Super</code>, then <code class="language-plaintext highlighter-rouge">Fn(Super)</code> is a subtype of <code class="language-plaintext highlighter-rouge">Fn(Sub)</code>. This is useful for
functions that take a callback as an argument.</li>
</ul>

<p>Here is a table of some other generic types and their variances:</p>

<table>
  <thead>
    <tr>
      <th>¬†</th>
      <th style="text-align: center">‚Äòa</th>
      <th style="text-align: center">T</th>
      <th style="text-align: center">U</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;'a T </code></td>
      <td style="text-align: center">covariant</td>
      <td style="text-align: center">covariant</td>
      <td style="text-align: center">¬†</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;'a mut T</code></td>
      <td style="text-align: center">covariant</td>
      <td style="text-align: center">invariant</td>
      <td style="text-align: center">¬†</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code></td>
      <td style="text-align: center">¬†</td>
      <td style="text-align: center">covariant</td>
      <td style="text-align: center">¬†</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code></td>
      <td style="text-align: center">¬†</td>
      <td style="text-align: center">covariant</td>
      <td style="text-align: center">¬†</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">UnsafeCell&lt;T&gt;</code></td>
      <td style="text-align: center">¬†</td>
      <td style="text-align: center">invariant</td>
      <td style="text-align: center">¬†</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Cell&lt;T&gt;</code></td>
      <td style="text-align: center">¬†</td>
      <td style="text-align: center">invariant</td>
      <td style="text-align: center">¬†</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">fn(T) -&gt; U</code></td>
      <td style="text-align: center">¬†</td>
      <td style="text-align: center"><strong>contra</strong>variant</td>
      <td style="text-align: center">covariant</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">*const T</code></td>
      <td style="text-align: center">¬†</td>
      <td style="text-align: center">covariant</td>
      <td style="text-align: center">¬†</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">*mut T</code></td>
      <td style="text-align: center">¬†</td>
      <td style="text-align: center">invariant</td>
      <td style="text-align: center">¬†</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>This table is from <a href="https://doc.rust-lang.org/nomicon/subtyping.html#variance">Rustonomicon -
Variance</a>.</p>
</blockquote>

<h2 id="more-resources-on-rust-lifetimes">More resources on Rust lifetimes</h2>
<p><a id="markdown-more-resources-on-rust-lifetimes" name="more-resources-on-rust-lifetimes"></a></p>

<ul>
  <li><a href="https://doc.rust-lang.org/nomicon/subtyping.html">Rustonomicon - Subtyping and variance with lifetimes</a>.</li>
  <li><a href="https://rustc-dev-guide.rust-lang.org/variance.html">Rust compiler - Subtyping and variance implementation in the compiler</a>.</li>
  <li><a href="https://doc.rust-lang.org/nomicon/ownership.html">Rustonomicon - Ownership</a>.</li>
</ul>

<h2 id="youtube-videos-for-this-article">YouTube videos for this article</h2>
<p><a id="markdown-youtube-videos-for-this-article" name="youtube-videos-for-this-article"></a></p>

<p>This article has short examples on how to get to know Rust lifetimes deeply. If you like
to learn via video, please watch the companion video on the <a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube
channel</a>.</p>

<!-- rust subtyping and variance -->
<iframe src="https://www.youtube.com/embed/HRlpYXi4E-M?si=cSc_Ew5RHQ-ffFWJ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<!-- rust lifetimes -->
<iframe src="https://www.youtube.com/embed/eIJxAEcle7E?si=4Wn3X2mT7Pd8uvGx" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<p><br /></p>

<h2 id="learn-rust-lifetimes-by-example">Learn Rust lifetimes by example</h2>
<p><a id="markdown-learn-rust-lifetimes-by-example" name="learn-rust-lifetimes-by-example"></a></p>

<p>Let‚Äôs create some examples to illustrate how to use Rust lifetimes. You can run
<code class="language-plaintext highlighter-rouge">cargo new --bin lifetimes</code> to create a new binary crate.</p>

<blockquote>
  <p>The code in the video and this tutorial are all in <a href="https://github.com/nazmulidris/rust-scratch/blob/main/lifetimes/">this GitHub
repo</a>.</p>
</blockquote>

<h3 id="example-1-references">Example 1: References</h3>
<p><a id="markdown-example-1%3A-references" name="example-1%3A-references"></a></p>

<p>First add <code class="language-plaintext highlighter-rouge">mod ex_1_references;</code> to <code class="language-plaintext highlighter-rouge">lib.rs</code>. Then you can add the following code to the
<code class="language-plaintext highlighter-rouge">src/ex_1_references.rs</code> file.</p>

<blockquote>
  <p>The code for this example is
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/lifetimes/src/ex_1_references.rs">here</a>.</p>
</blockquote>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">ex_1_references</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">try_to_use_after_free</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="nb">str</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{} is a number"</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
        <span class="c1">// return &amp;s; /* üß® won't compile! */</span>
        <span class="nd">unreachable!</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">try_to_modify_referent</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">data</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span> <span class="cm">/* referent */</span>
        <span class="k">let</span> <span class="n">ref_to_first_item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="cm">/* reference */</span>
        <span class="c1">// data.push(4); /* üß® won't compile */</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"first_item: {}"</span><span class="p">,</span> <span class="n">ref_to_first_item</span><span class="p">);</span>
        <span class="cm">/* ref_to_first_item reference still in scope */</span>
        <span class="c1">// drop(ref_to_first_item);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The main things to note about this code:</p>

<ul>
  <li>Rust requires any <em>references</em> to freeze:
    <ul>
      <li>the referent and its owners.</li>
    </ul>
  </li>
  <li>While a <em>reference</em> is <strong>in scope</strong>, Rust will not allow you to:
    <ul>
      <li>change the referent and its owners.</li>
    </ul>
  </li>
  <li><a href="https://doc.rust-lang.org/nomicon/ownership.html">More info</a>.</li>
</ul>

<h3 id="example-2-aliasing">Example 2: Aliasing</h3>
<p><a id="markdown-example-2%3A-aliasing" name="example-2%3A-aliasing"></a></p>

<p>Let‚Äôs review some background info on references. There are two kinds of reference:</p>

<ol>
  <li>Shared reference: <code class="language-plaintext highlighter-rouge">&amp;</code></li>
  <li>Mutable reference: <code class="language-plaintext highlighter-rouge">&amp;mut</code></li>
</ol>

<p>Here are the rules of references:</p>

<ol>
  <li>A reference cannot outlive its referent.</li>
  <li>A <strong>mutable reference</strong> cannot be aliased.</li>
</ol>

<p>Aliasing:</p>

<ol>
  <li>Variables and pointers alias if they refer to overlapping regions of memory.</li>
  <li>The definition of ‚Äúalias‚Äù that Rust will use likely involves some notion of
 <strong>liveness</strong> and <strong>mutation</strong>: we don‚Äôt actually care if aliasing occurs if there
 aren‚Äôt any actual writes to memory happening.</li>
</ol>

<p>Here‚Äôs more info:</p>
<ul>
  <li><a href="https://doc.rust-lang.org/nomicon/references.html">https://doc.rust-lang.org/nomicon/references.html</a></li>
  <li><a href="https://doc.rust-lang.org/nomicon/aliasing.html">https://doc.rust-lang.org/nomicon/aliasing.html</a></li>
</ul>

<blockquote>
  <p>The code for this example is
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/lifetimes/src/ex_2_aliasing.rs">here</a>.</p>
</blockquote>

<p>Add <code class="language-plaintext highlighter-rouge">mod ex_2_aliasing;</code> to <code class="language-plaintext highlighter-rouge">lib.rs</code>. Then you can add the following code to the
<code class="language-plaintext highlighter-rouge">src/ex_2_aliasing.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">ex_2_aliasing</span><span class="p">()</span> <span class="p">{</span>
    <span class="cd">/// `input_ref` and `output_ref` can't overlap or alias, and thus</span>
    <span class="cd">/// can't clobber each other.</span>
    <span class="k">fn</span> <span class="nf">compute</span><span class="p">(</span><span class="n">input_ref</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">usize</span><span class="p">,</span> <span class="n">output_ref</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="o">*</span><span class="n">input_ref</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">output_ref</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="o">*</span><span class="n">input_ref</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">output_ref</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// This is safe to do because `input` and `output` don't overlap.</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">input</span> <span class="o">=</span> <span class="mi">10usize</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">output</span> <span class="o">=</span> <span class="mi">1usize</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">input_address</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">input</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">usize</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">output_address</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">output</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">usize</span><span class="p">;</span>

        <span class="nf">compute</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">output</span><span class="p">);</span>

        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
        <span class="nd">assert_ne!</span><span class="p">(</span><span class="n">input_address</span><span class="p">,</span> <span class="n">output_address</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Try and clobber `input` with `output`.</span>
    <span class="c1">// - Rust won't allow `input` and `output` to overlap aka alias.</span>
    <span class="c1">// - Rust won't allow the `&amp;mut output` to be aliased!</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">output</span> <span class="o">=</span> <span class="mi">1usize</span><span class="p">;</span>
        <span class="c1">// compute(&amp;output, &amp;mut output); /* üß® won't compile! */</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="example-3-lifetimes">Example 3: Lifetimes</h3>
<p><a id="markdown-example-3%3A-lifetimes" name="example-3%3A-lifetimes"></a></p>

<p>Rust enforces a set of rules that govern how references are used via <strong>lifetimes</strong>.</p>

<p>Lifetimes are named regions of code that a reference must be valid for.</p>
<ul>
  <li>For simple programs, lifetimes coincide with lexical scope.</li>
  <li>Those regions may be fairly complex, as they correspond to paths of execution in the
  program.</li>
  <li>There may even be holes in these paths of execution, as it‚Äôs possible to invalidate
  a reference as long as it‚Äôs reinitialized before it‚Äôs used again.</li>
  <li>Types which contain references (or pretend to) may also be tagged with lifetimes so
  that Rust can prevent them from being invalidated as well.</li>
</ul>

<p>Inside a function, Rust doesn‚Äôt let you explicitly name lifetimes. And each let
statement implicitly introduces a scope. However, once you cross the function
boundary, you need to start talking about lifetimes.</p>

<p>More info:</p>
<ul>
  <li><a href="https://doc.rust-lang.org/nomicon/lifetimes.html#the-area-covered-by-a-lifetime">https://doc.rust-lang.org/nomicon/lifetimes.html#the-area-covered-by-a-lifetime</a></li>
  <li><a href="https://doc.rust-lang.org/nomicon/lifetime-mismatch.html">https://doc.rust-lang.org/nomicon/lifetime-mismatch.html</a></li>
</ul>

<blockquote>
  <p>The code for this example is
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/lifetimes/src/ex_3_lifetimes.rs">here</a>.</p>
</blockquote>

<p>Add <code class="language-plaintext highlighter-rouge">mod ex_3_lifetimes;</code> to <code class="language-plaintext highlighter-rouge">lib.rs</code>. Then you can add the following code to the
<code class="language-plaintext highlighter-rouge">src/ex_3_lifetimes.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[rustfmt::skip]</span>
<span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">ex_3_lifetimes_1</span><span class="p">()</span> <span class="p">{</span>
    <span class="cd">/// 'fn is          &lt;  'input.</span>
    <span class="cd">/// 'fn needs to be &gt;= 'input.</span>
    <span class="cd">///</span>
    <span class="cd">/// - 'fn is the lifetime of the referent. It is short.</span>
    <span class="cd">/// - 'input is the lifetime of the reference. It is long.</span>
    <span class="k">fn</span> <span class="n">try_to_make_reference_outlive_referent</span><span class="o">&lt;</span><span class="nv">'input</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="n">param</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'input</span> <span class="nb">usize</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'input</span> <span class="nb">str</span> <span class="p">{</span>
        <span class="c1">// 'fn: {</span>
            <span class="k">let</span> <span class="n">referent</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">param</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">reference</span> <span class="o">=</span> <span class="o">&amp;</span><span class="cm">/*'fn*/</span><span class="n">referent</span><span class="p">;</span>
            <span class="c1">// return reference; /* üß® does not compile! */</span>
            <span class="nd">unreachable!</span><span class="p">()</span>
        <span class="c1">// }</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="n">fix_try_to_make_reference_outlive_referent</span><span class="o">&lt;</span><span class="nv">'input</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="n">param</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'input</span> <span class="nb">usize</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'input</span> <span class="nb">str</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">param</span> <span class="p">{</span>
            <span class="mi">0</span> <span class="k">=&gt;</span> <span class="cm">/* &amp;'static */</span> <span class="s">"zero"</span><span class="p">,</span>
            <span class="mi">1</span> <span class="k">=&gt;</span> <span class="cm">/* &amp;'static */</span> <span class="s">"one"</span><span class="p">,</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="cm">/* &amp;'static */</span> <span class="s">"many"</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">assert_eq!</span><span class="p">(</span>
        <span class="nf">fix_try_to_make_reference_outlive_referent</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">0</span><span class="p">),</span> <span class="s">"zero"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notes on the code above:</p>

<ul>
  <li>The string literals ‚Äúzero‚Äù, ‚Äúone‚Äù, and ‚Äúmany‚Äù are stored in a special section of memory
that is accessible throughout the entire program execution. This means that these string
literals are available for the entire duration of the program, hence they have the
<code class="language-plaintext highlighter-rouge">'static</code> lifetime.</li>
</ul>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">ex_3_lifetimes.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[rustfmt::skip]</span>
<span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">ex_3_lifetimes_2</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">try_to_modify_referent</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">data</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span> <span class="cm">/* referent */</span>
        <span class="c1">// 'first: {</span>
            <span class="cm">/* reference */</span>
            <span class="k">let</span> <span class="n">ref_to_first_item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="cm">/*'first*/</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="c1">//   'second: {</span>
            <span class="c1">//        /* üß® won't compile */</span>
            <span class="c1">//        Vec::push(&amp;/*'second*/mut data, 4);</span>
            <span class="c1">//    }</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"first_item: {}"</span><span class="p">,</span> <span class="n">ref_to_first_item</span><span class="p">);</span>
            <span class="cm">/* reference still in scope */</span>
        <span class="c1">// }</span>
        <span class="c1">// drop(ref_to_first_item);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notes on the code above:</p>

<ul>
  <li>
    <p>Rust doesn‚Äôt understand that <code class="language-plaintext highlighter-rouge">ref_to_first_item</code> is a reference to a subpath of
<code class="language-plaintext highlighter-rouge">data</code>. It doesn‚Äôt understand [<code class="language-plaintext highlighter-rouge">Vec</code>] at all. ü§Ø</p>
  </li>
  <li>Here‚Äôs what it sees:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">ref_to_first_item</code> which is <code class="language-plaintext highlighter-rouge">&amp;'first data</code> has to live for <code class="language-plaintext highlighter-rouge">'first</code> in order to
be printed.</li>
      <li>When we try to call push, it then sees us try to make an <code class="language-plaintext highlighter-rouge">&amp;'second mut data</code>.</li>
      <li>It knows that <code class="language-plaintext highlighter-rouge">'second</code> is contained within <code class="language-plaintext highlighter-rouge">'first</code>, and rejects our program
because the <code class="language-plaintext highlighter-rouge">&amp;'first data</code> must still be alive! And we can‚Äôt alias a <strong>mutable
reference</strong>.</li>
    </ul>
  </li>
  <li>The lifetime system is much more coarse than the reference semantics we‚Äôre
actually interested in preserving.</li>
</ul>

<h3 id="example-4-input-slices">Example 4: Input slices</h3>
<p><a id="markdown-example-4%3A-input-slices" name="example-4%3A-input-slices"></a></p>

<p>We can use lifetimes and slices to work with data without modifying it. This pattern shows
up a lot when working with parsers (eg: <code class="language-plaintext highlighter-rouge">nom</code>) and general string manipulation.</p>

<p>Real world examples:</p>
<ul>
  <li><a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/core/src/tui_core/graphemes">https://github.com/r3bl-org/r3bl-open-core/tree/main/core/src/tui_core/graphemes</a></li>
  <li><a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/core/src/tui_core/graphemes/access.rs#L173">https://github.com/r3bl-org/r3bl-open-core/blob/main/core/src/tui_core/graphemes/access.rs#L173</a></li>
</ul>

<blockquote>
  <p>The code for this example is
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/lifetimes/src/ex_4_input_slices.rs">here</a>.</p>
</blockquote>

<p>First add <code class="language-plaintext highlighter-rouge">mod ex_4_input_slices;</code> to <code class="language-plaintext highlighter-rouge">lib.rs</code>. Then you can add the following code to the
<code class="language-plaintext highlighter-rouge">src/ex_4_input_slices.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[rustfmt::skip]</span>
<span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">ex_4_input_slices</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 'fn {</span>
        <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"foo bar baz"</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">middle_word</span><span class="p">:</span> <span class="o">&amp;</span> <span class="cm">/*'fn*/</span> <span class="nb">str</span> <span class="o">=</span> <span class="nf">middle_word</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">middle_word</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">);</span>
    <span class="c1">// }</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">middle_word</span><span class="o">&lt;</span><span class="nv">'input</span><span class="o">&gt;</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'input</span> <span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'input</span> <span class="nb">str</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">input</span><span class="nf">.split_whitespace</span><span class="p">();</span>

    <span class="k">let</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">middle_word_index</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">iter_clone</span> <span class="o">=</span> <span class="n">iter</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">word_count</span> <span class="o">=</span> <span class="n">iter_clone</span><span class="nf">.count</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">middle_word_index</span> <span class="o">=</span> <span class="n">word_count</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="p">(</span><span class="n">word_count</span><span class="p">,</span> <span class="n">middle_word_index</span><span class="p">)</span>
    <span class="p">};</span>

    <span class="k">let</span> <span class="p">(</span><span class="n">middle_word_len</span><span class="p">,</span> <span class="n">len_until_middle_word</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">middle_word_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">len_until_middle_word</span> <span class="o">=</span> <span class="n">iter</span>
            <span class="nf">.enumerate</span><span class="p">()</span>
            <span class="c1">// Go as far as the middle word.</span>
            <span class="nf">.take_while</span><span class="p">(|(</span><span class="n">index</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="o">*</span><span class="n">index</span> <span class="o">&lt;=</span> <span class="n">middle_word_index</span><span class="p">)</span>
            <span class="nf">.map</span><span class="p">(|(</span><span class="n">index</span><span class="p">,</span> <span class="n">word</span><span class="p">)|</span> <span class="p">{</span>
                <span class="c1">// At middle word.</span>
                <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="n">middle_word_index</span> <span class="p">{</span>
                    <span class="n">middle_word_len</span> <span class="o">=</span> <span class="n">word</span><span class="nf">.len</span><span class="p">();</span>
                    <span class="mi">0</span>
                <span class="p">}</span>
                <span class="c1">// Before middle word.</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="n">word</span><span class="nf">.len</span><span class="p">()</span>
                <span class="p">}</span>
            <span class="p">})</span>
            <span class="py">.sum</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">();</span>

        <span class="p">(</span><span class="n">middle_word_len</span><span class="p">,</span> <span class="n">len_until_middle_word</span><span class="p">)</span>
    <span class="p">};</span>

    <span class="k">let</span> <span class="p">(</span><span class="n">start_index</span><span class="p">,</span> <span class="n">end_index</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">start_index</span> <span class="o">=</span> <span class="n">len_until_middle_word</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">end_index</span> <span class="o">=</span> <span class="n">len_until_middle_word</span> <span class="o">+</span> <span class="n">middle_word_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">(</span><span class="n">start_index</span><span class="p">,</span> <span class="n">end_index</span><span class="p">)</span>
    <span class="p">};</span>

    <span class="o">&amp;</span><span class="cm">/*'input*/</span><span class="n">input</span><span class="p">[</span><span class="n">start_index</span><span class="o">..</span><span class="n">end_index</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="example-5-splitting-borrows-on-structs">Example 5: Splitting borrows on structs</h3>
<p><a id="markdown-example-5%3A-splitting-borrows-on-structs" name="example-5%3A-splitting-borrows-on-structs"></a></p>

<p>The mutual exclusion property of mutable references can be very limiting when working with
a composite structure.</p>

<p>The borrow checker understand structs sufficiently to know that it‚Äôs possible to borrow
disjoint fields of a struct simultaneously.</p>

<p><code class="language-plaintext highlighter-rouge">ex_5_splitting_borrows_on_structs.rs</code> will demonstrate this.</p>

<blockquote>
  <p>The code for this example is
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/lifetimes/src/ex_5_splitting_borrows_on_structs.rs">here</a>.</p>
</blockquote>

<p>First add <code class="language-plaintext highlighter-rouge">mod ex_5_splitting_borrows_on_structs;</code> to <code class="language-plaintext highlighter-rouge">lib.rs</code>. Then you can add the
following code to the <code class="language-plaintext highlighter-rouge">src/ex_5_splitting_borrows_on_structs.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">ex_5_splitting_borrows_on_structs</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Data</span> <span class="p">{</span>
        <span class="n">a</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">b</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">change_field_by_ref</span><span class="p">(</span><span class="n">field</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">field</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">data</span> <span class="o">=</span> <span class="n">Data</span> <span class="p">{</span> <span class="n">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="mi">2</span> <span class="p">};</span>

    <span class="k">let</span> <span class="n">a_ref</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">data</span><span class="py">.a</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">b_ref</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">data</span><span class="py">.b</span><span class="p">;</span>

    <span class="nf">change_field_by_ref</span><span class="p">(</span><span class="n">a_ref</span><span class="p">);</span>
    <span class="nf">change_field_by_ref</span><span class="p">(</span><span class="n">b_ref</span><span class="p">);</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">data</span><span class="py">.a</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">data</span><span class="py">.b</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The next example shows a struct that only contains references. As long as the owned struct
and the references live for the same lifetime, it all works. Add the following code to the
same file:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">ex_5_splitting_borrows_on_structs_2</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Data</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">field_usize</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">field_str</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">impl</span> <span class="n">Data</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="n">new</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span>
            <span class="n">str_param</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span> <span class="n">usize_param</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="nb">usize</span>
        <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Data</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span>
        <span class="p">{</span>
            <span class="n">Data</span> <span class="p">{</span>
                <span class="n">field_usize</span><span class="p">:</span> <span class="n">usize_param</span><span class="p">,</span>
                <span class="n">field_str</span><span class="p">:</span> <span class="n">str_param</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">fn</span> <span class="nf">change_field_usize</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">*</span><span class="k">self</span><span class="py">.field_usize</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">fn</span> <span class="nf">change_field_str</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.field_str</span> <span class="o">=</span> <span class="s">"new value"</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">str_arg</span> <span class="o">=</span> <span class="s">"old value"</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">usize_arg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">data</span> <span class="o">=</span> <span class="nn">Data</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">str_arg</span><span class="p">,</span> <span class="n">usize_arg</span><span class="p">);</span>

    <span class="n">data</span><span class="nf">.change_field_usize</span><span class="p">();</span>
    <span class="n">data</span><span class="nf">.change_field_str</span><span class="p">();</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="py">.field_usize</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">data</span><span class="py">.field_str</span><span class="p">,</span> <span class="s">"new value"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="example-6-clone-on-write-cow">Example 6: Clone on write (Cow)</h3>
<p><a id="markdown-example-6%3A-clone-on-write-cow" name="example-6%3A-clone-on-write-cow"></a></p>

<p>The <a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code class="language-plaintext highlighter-rouge">Cow</code></a> type is a smart pointer
that can be used to work with both owned and borrowed data.</p>
<ul>
  <li>It is useful when you want to avoid unnecessary allocations and copying.</li>
  <li>You can also use it in functions where you might need to mutate the argument; in which
case the data will be <strong>lazily cloned</strong> when mutation or ownership is required.</li>
</ul>

<blockquote>
  <p>The code for this example is
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/lifetimes/src/ex_6_cow.rs">here</a>.</p>
</blockquote>

<p>First add <code class="language-plaintext highlighter-rouge">mod ex_6_cow;</code> to <code class="language-plaintext highlighter-rouge">lib.rs</code>. Then you can add the following code to the
<code class="language-plaintext highlighter-rouge">src/ex_6_cow.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">ex_6_cow</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">borrow</span><span class="p">::</span><span class="n">Cow</span><span class="p">;</span>

    <span class="k">fn</span> <span class="n">capitalize</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="n">Cow</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="nb">str</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Cow</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="nb">str</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">input</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">input</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">input</span><span class="nf">.chars</span><span class="p">()</span><span class="nf">.all</span><span class="p">(</span><span class="nn">char</span><span class="p">::</span><span class="n">is_uppercase</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">input</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">cloned</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">input</span><span class="nf">.len</span><span class="p">());</span>
        <span class="n">cloned</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input</span><span class="p">[</span><span class="o">..</span><span class="mi">1</span><span class="p">]</span><span class="nf">.to_uppercase</span><span class="p">());</span>
        <span class="n">cloned</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]);</span>
        <span class="nn">Cow</span><span class="p">::</span><span class="nf">Owned</span><span class="p">(</span><span class="n">cloned</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">borrowed_data</span> <span class="o">=</span> <span class="nn">Cow</span><span class="p">::</span><span class="nf">Borrowed</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">owned_data</span> <span class="o">=</span> <span class="nn">Cow</span><span class="p">::</span><span class="nf">Owned</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"world"</span><span class="p">));</span>

    <span class="k">let</span> <span class="n">capitalized_borrowed_data</span> <span class="o">=</span> <span class="nf">capitalize</span><span class="p">(</span><span class="n">borrowed_data</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">capitalized_owned_data</span> <span class="o">=</span> <span class="nf">capitalize</span><span class="p">(</span><span class="n">owned_data</span><span class="p">);</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">capitalized_borrowed_data</span><span class="p">,</span> <span class="s">"Hello"</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">capitalized_owned_data</span><span class="p">,</span> <span class="s">"World"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notes on the code:</p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">capitalize</code> function takes a <code class="language-plaintext highlighter-rouge">Cow</code> as an argument. It also returns a <code class="language-plaintext highlighter-rouge">Cow</code>.</li>
  <li>The <code class="language-plaintext highlighter-rouge">Cow</code> type is an enum that can hold either a borrowed reference or an owned value.</li>
  <li>The <code class="language-plaintext highlighter-rouge">capitalize</code> function will return the input unchanged if it is already capitalized.
Otherwise it allocates a new capitalized string, moves into into a <code class="language-plaintext highlighter-rouge">Cow</code> and returns it
as an owned value.</li>
</ul>

<p>Next, add the following code to the same file:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">ex_6_cow_2</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">borrow</span><span class="p">::</span><span class="n">Cow</span><span class="p">;</span>

    <span class="k">fn</span> <span class="n">capitalize_mut</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Cow</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="nb">str</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">input</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">input</span><span class="nf">.chars</span><span class="p">()</span><span class="nf">.all</span><span class="p">(</span><span class="nn">char</span><span class="p">::</span><span class="n">is_uppercase</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">cloned</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">input</span><span class="nf">.len</span><span class="p">());</span>
        <span class="n">cloned</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input</span><span class="p">[</span><span class="o">..</span><span class="mi">1</span><span class="p">]</span><span class="nf">.to_uppercase</span><span class="p">());</span>
        <span class="n">cloned</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]);</span>
        <span class="o">*</span><span class="n">input</span> <span class="o">=</span> <span class="nn">Cow</span><span class="p">::</span><span class="nf">Owned</span><span class="p">(</span><span class="n">cloned</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">borrowed_data</span> <span class="o">=</span> <span class="nn">Cow</span><span class="p">::</span><span class="nf">Borrowed</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">owned_data</span> <span class="o">=</span> <span class="nn">Cow</span><span class="p">::</span><span class="nf">Owned</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"world"</span><span class="p">));</span>

    <span class="nf">capitalize_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">borrowed_data</span><span class="p">);</span>
    <span class="nf">capitalize_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">owned_data</span><span class="p">);</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">borrowed_data</span><span class="p">,</span> <span class="s">"Hello"</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">owned_data</span><span class="p">,</span> <span class="s">"World"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notes on the code:</p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">capitalize_mut</code> function takes a mutable reference to a <code class="language-plaintext highlighter-rouge">Cow</code> as an argument.</li>
  <li>It will mutate the input in place if it is not already capitalized. This requires
cloning the input string.</li>
</ul>

<h3 id="example-7-subtyping-and-variance">Example 7: Subtyping and variance</h3>
<p><a id="markdown-example-7%3A-subtyping-and-variance" name="example-7%3A-subtyping-and-variance"></a></p>

<blockquote>
  <p>Please refer to the <a href="#what-is-subtyping-and-variance">Subtyping and variance</a> section for
more information, before following this example.</p>
</blockquote>

<p>Let‚Äôs define that <code class="language-plaintext highlighter-rouge">Sub</code> is a subtype of Super (ie <code class="language-plaintext highlighter-rouge">Sub : Super</code>).</p>
<ul>
  <li>What this is suggesting to us is that the set of requirements that <code class="language-plaintext highlighter-rouge">Super</code> defines
are completely satisfied by <code class="language-plaintext highlighter-rouge">Sub</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">Sub</code> may then have more requirements.</li>
  <li>That is, <code class="language-plaintext highlighter-rouge">Sub</code> &gt; <code class="language-plaintext highlighter-rouge">Super</code>.</li>
</ul>

<p>Replacing this with lifetimes, <code class="language-plaintext highlighter-rouge">'long : 'short</code> if and only if</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">'long</code> defines a region of code that completely contains <code class="language-plaintext highlighter-rouge">'short</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">'long</code> may define a region larger than <code class="language-plaintext highlighter-rouge">'short</code>, but that still fits our
definition.</li>
  <li>That is, <code class="language-plaintext highlighter-rouge">'long</code> &gt; <code class="language-plaintext highlighter-rouge">'short</code>.</li>
</ul>

<p>More info:</p>
<ul>
  <li><a href="https://doc.rust-lang.org/nomicon/subtyping.html">https://doc.rust-lang.org/nomicon/subtyping.html</a></li>
</ul>

<blockquote>
  <p>The code for this example is
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/lifetimes/src/ex_7_subtyping_and_variance.rs">here</a>.</p>
</blockquote>

<p>First add <code class="language-plaintext highlighter-rouge">mod ex_7_subtyping_and_variance;</code> to <code class="language-plaintext highlighter-rouge">lib.rs</code>. Then you can add the following code to the
<code class="language-plaintext highlighter-rouge">src/ex_7_subtyping_and_variance.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[rustfmt::skip]</span>
<span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">subtyping</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">debug</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"a: {}, b: {}"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">hello</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="nb">str</span> <span class="o">=</span> <span class="s">"hello"</span><span class="p">;</span>

    <span class="c1">// 'short {</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">world</span> <span class="o">=</span> <span class="s">"world"</span><span class="nf">.to_string</span><span class="p">();</span>
        <span class="nf">debug</span><span class="p">(</span>
            <span class="cm">/*&amp;'static*/</span> <span class="n">hello</span><span class="p">,</span>
            <span class="o">&amp;</span><span class="cm">/*'short*/</span>  <span class="n">world</span>
        <span class="p">);</span>
        <span class="c1">// Why does this work?</span>
        <span class="c1">// 1) `&amp;'static str` : `&amp;'short str`</span>
        <span class="c1">//       ‚Üë                ‚Üë</span>
        <span class="c1">//     Subtype          Super type</span>
        <span class="c1">// 2) `hello` silently downgrades from `&amp;'static str`</span>
        <span class="c1">//    into `&amp;'short str`</span>
    <span class="p">}</span>
    <span class="c1">// }</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notes on the code above:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">fn debug(a, b)</code>:
    <ul>
      <li>Since: <code class="language-plaintext highlighter-rouge">&amp;'a T</code> is covariant over <code class="language-plaintext highlighter-rouge">'a</code>, we are allowed to perform subtyping.</li>
      <li>And: <code class="language-plaintext highlighter-rouge">&amp;'static str</code> is a subtype of <code class="language-plaintext highlighter-rouge">&amp;'short str</code>.</li>
      <li>And since:
        <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'static : 'short
  ‚Üë       ‚Üë
 Sub     Super
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>Here‚Äôs a short table with the rules:</p>

    <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>|                 | `'a`     | `T` |
|-----------------|----------|-----|
| `&amp;'a T`         | C        | C   |
| `&amp;'a mut T`     | C        | I   |
</code></pre></div>    </div>
  </li>
</ul>

<p>Now, add the following code to the same file:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// More info:</span>
<span class="cd">/// - &lt;https://doc.rust-lang.org/nomicon/subtyping.html&gt;</span>
<span class="nd">#[rustfmt::skip]</span>
<span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">variance</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">assign</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">reference</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="n">T</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">reference</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">hello</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="nb">str</span> <span class="o">=</span> <span class="s">"hello"</span><span class="p">;</span>

    <span class="c1">// 'short {</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">world</span> <span class="o">=</span> <span class="s">"world"</span><span class="nf">.to_string</span><span class="p">();</span>
        <span class="cm">/* üß® does not compile! Due to invariance, the 2 args are
           different types!
        */</span>
        <span class="c1">// assign(</span>
        <span class="c1">//     &amp;mut/*&amp;'static*/ hello,</span>
        <span class="c1">//     &amp;/*'short*/      world</span>
        <span class="c1">// );</span>

        <span class="c1">// `&amp;mut T` is invariant over `T`, meaning, these are</span>
        <span class="c1">// incompatible:</span>
        <span class="c1">//</span>
        <span class="c1">// 1. 1st arg: `&amp;mut &amp;'static str`, which is `&amp;mut T`</span>
        <span class="c1">//    where `T = &amp;'static str`.</span>
        <span class="c1">// 2. 2nd arg: `&amp;'short str`, and it is expecting</span>
        <span class="c1">//    `T = &amp;'static str`. This `T` does not match!</span>
        <span class="c1">//</span>
        <span class="c1">// This means that:</span>
        <span class="c1">// - `&amp;mut &amp;'static str` cannot be a subtype of `&amp;'short str`</span>
        <span class="c1">// - even if `'static` **is** a subtype of `'short`</span>
    <span class="p">}</span>
    <span class="c1">// }</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notes on the code:</p>

<ol>
  <li>Take a mutable reference and a value and overwrite the <strong>referent</strong> with it.</li>
  <li>It clearly says in its signature the referent and the value must be the
 <strong>exact</strong> same type.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">&amp;mut T</code> is invariant over <code class="language-plaintext highlighter-rouge">T</code>, meaning,</li>
      <li><code class="language-plaintext highlighter-rouge">&amp;mut &amp;'long T</code> is <strong>NOT</strong> a subtype of <code class="language-plaintext highlighter-rouge">&amp;'short T</code>,</li>
      <li>Even when:
        <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'long : 'short
‚Üë       ‚Üë
Sub     Super
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>Here‚Äôs a short table with the rules:
    <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>|                 | `'a`     | `T` |
|-----------------|----------|-----|
| `&amp;'a T`         | C        | C   |
| `&amp;'a mut T`     | C        | I   |
</code></pre></div>    </div>
  </li>
</ol>

<h2 id="build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</h2>
<p><a id="markdown-build-with-naz-video-series-on-developerlife.com-youtube-channel" name="build-with-naz-video-series-on-developerlife.com-youtube-channel"></a></p>

<blockquote>
  <p>If you have comments and feedback on this content, or would like to request new content
(articles &amp; videos) on developerlife.com, please join our <a href="https://discord.gg/8M2ePAevaMi">discord
server</a>.</p>
</blockquote>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a></li>
  <li>Playlists
    <ul>
      <li><a href="https://www.youtube.com/watch?v=bolScvh4x7I&amp;list=PLofhE49PEwmw3MKOU1Kn3xbP4FRQR4Mb3">Build with Naz, Linux TTY, process, signals, commands in async Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmza94sS7UmJnN9gSCHTVTfz">Build with Naz, fundamental effective Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmwO69E7eiQ-ewnMME8ydgQ5">Build with Naz, effective async Rust and tokio</a></li>
      <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><summary type="html"><![CDATA[Rust lifetimes are key part of the type system which allows the Rust compiler to make its memory safety guarantees. We will explore subtyping, variance, references, memory aliasing, splitting borrows, and clone on write in this article, its video, and repo.]]></summary></entry><entry><title type="html">Build with Naz : Explore Linux TTY, process, signals w/ Rust</title><link href="http://developerlife.com/2024/08/20/tty-linux-async-rust/" rel="alternate" type="text/html" title="Build with Naz : Explore Linux TTY, process, signals w/ Rust" /><published>2024-08-20T10:00:00-05:00</published><updated>2024-08-20T10:00:00-05:00</updated><id>http://developerlife.com/2024/08/20/tty-linux-async-rust</id><content type="html" xml:base="http://developerlife.com/2024/08/20/tty-linux-async-rust/"><![CDATA[<p><img class="post-hero-image" src="/assets/linux-tty-proc-async-rust.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#prerequisite">Prerequisite</a></li>
  <li><a href="#github-repo-for-this-article">GitHub repo for this article</a></li>
  <li><a href="#related-youtube-videos-for-this-article">Related YouTube videos for this article</a>
    <ul>
      <li><a href="#part-1--3--background-info">Part 1 / 3 : background info</a></li>
      <li><a href="#part-2--3--examples-of-send--recieve-signals-proc-spawn-and-ipc">Part 2 / 3 : examples of send &amp; recieve signals, proc spawn, and IPC</a></li>
      <li><a href="#part-3--3--run-tokioprocesscommand-in-async-rust">Part 3 / 3 : run tokio::process::Command in async Rust</a></li>
    </ul>
  </li>
  <li><a href="#limitations-of-using-tty-in-linux-and-why-we-like-userland-terminal-emulators-pty">Limitations of using TTY in Linux, and why we like userland terminal emulators PTY</a>
    <ul>
      <li><a href="#kernel-tty-">Kernel TTY üëéüèΩ</a></li>
      <li><a href="#userland-pty-">Userland PTY üëçüèΩ</a></li>
    </ul>
  </li>
  <li><a href="#examples-of-using-pty-in-linux">Examples of using PTY in Linux</a>
    <ul>
      <li><a href="#using-redirection-to-write-to-another-pty-run-command-in-left-terminal-see-output-in-right-terminal">Using redirection to write to another PTY run command in left terminal, see output in right terminal</a></li>
      <li><a href="#using-redirection-to-read-from-another-pty-type-in-left-terminal-see-it-in-right-terminal">Using redirection to read from another PTY type in left terminal, see it in right terminal</a></li>
      <li><a href="#breaking-things-in-raw-mode">Breaking things in raw mode.</a></li>
    </ul>
  </li>
  <li><a href="#shells-processes-sessions-jobs-ptys-signals">Shells, processes, sessions, jobs, PTYs, signals</a>
    <ul>
      <li><a href="#background-information-knowledgebase">Background information knowledgebase</a>
        <ul>
          <li><a href="#file-descriptors-and-processes-ulimit-stdin-stdout-stderr-pipes">File descriptors and processes, ulimit, stdin, stdout, stderr, pipes</a></li>
          <li><a href="#unix-shells-that-run-in-terminals-to-execute-built-in-and-program-commands">Unix shells that run in terminals to execute built-in and program commands</a>
            <ul>
              <li><a href="#what-is-the-relationship-between-linux-shells-subshells-and-fork-exec-and-wait-patterns">What is the relationship between linux shells, subshells, and fork, exec, and wait patterns?</a></li>
              <li><a href="#does-exec-change-the-current-working-directory-or-affect-environment-variables-in-the-parent">Does exec change the current working directory or affect environment variables in the parent?</a></li>
              <li><a href="#then-how-does-the-cd-command-change-the-current-working-directory-of-a-shell">Then how does the cd command change the current working directory of a shell?</a></li>
              <li><a href="#how-do-subshells-work-in-the-case-where-i-dont-the-shells-environment-to-be-affected-at-all">How do subshells work, in the case where I don‚Äôt the shell‚Äôs environment to be affected at all?</a></li>
              <li><a href="#deep-dive-of-all-this-information-in-video-format">Deep dive of all this information in video format</a></li>
            </ul>
          </li>
          <li><a href="#processes-sessions-jobs-ptys-signals-using-c">Processes, sessions, jobs, PTYs, signals using C</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#what-is-devtty">What is /dev/tty?</a>
    <ul>
      <li><a href="#how-is-crossterm-built-on-top-of-stdio-pty-etc">How is crossterm built on top of stdio, PTY, etc?</a></li>
      <li><a href="#how-is-termion-built-on-top-of-stdio-pty-etc">How is termion built on top of stdio, PTY, etc?</a></li>
    </ul>
  </li>
  <li><a href="#list-of-signals">List of signals</a></li>
  <li><a href="#-sending-and-receiving-signals-in-rust">ü¶Ä Sending and receiving signals in Rust</a>
    <ul>
      <li><a href="#example-using-tokio-to-receive-signals">Example using tokio to receive signals</a></li>
      <li><a href="#example-using-signal-hook-and-signal-hook-tokio">Example using signal-hook and signal-hook-tokio</a></li>
    </ul>
  </li>
  <li><a href="#-process-spawning-in-rust">ü¶Ä Process spawning in Rust</a>
    <ul>
      <li><a href="#example-using-procspawn-to-spawn-processes">Example using procspawn to spawn processes</a></li>
      <li><a href="#example-using-procspawn-to-spawn-processes-w-ipc-channel">Example using procspawn to spawn processes w/ ipc-channel</a></li>
    </ul>
  </li>
  <li><a href="#-run-tokioprocesscommand-in-async-rust">ü¶Ä Run tokio:process::Command in async Rust</a>
    <ul>
      <li><a href="#example-running-echo-process-programmatically">Example running echo process programmatically</a></li>
      <li><a href="#example-piping-input-to-cat-process-programmatically">Example piping input to cat process programmatically</a></li>
      <li><a href="#example-programmatically-providing-input-into-stdin-and-getting-output-from-stdout-of-a-process">Example programmatically providing input into stdin and getting output from stdout of a process</a></li>
      <li><a href="#example-programmatically-piping-the-output-of-one-process-into-another">Example programmatically piping the output of one process into another</a></li>
      <li><a href="#example-using-r3bl_terminal_async-to-send-commands-to-a-long-running-bash-child-process">Example using r3bl_terminal_async to send commands to a long running bash child process</a></li>
    </ul>
  </li>
  <li><a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</a></li>
</ul>

<!-- /TOC -->

<h2 id="introduction">Introduction</h2>
<p><a id="markdown-introduction" name="introduction"></a></p>

<p>This article, along with related videos and the repository, explores Linux TTY, shells,
processes, sessions, jobs, PTYs, signals, and more using Rust. It explains <code class="language-plaintext highlighter-rouge">/dev/tty</code> and
describes how terminal libraries like <code class="language-plaintext highlighter-rouge">crossterm</code> and <code class="language-plaintext highlighter-rouge">termion</code> build on top of <code class="language-plaintext highlighter-rouge">stdio</code>
and <code class="language-plaintext highlighter-rouge">/dev/tty</code>. The article provides examples of using Rust to send and receive POSIX
signals, communicate with processes via IPC, and spawn processes. Additionally, it
includes examples of using PTY in Linux and controlling external commands (such as
binaries like <code class="language-plaintext highlighter-rouge">bash</code>) using asynchronous Rust.</p>

<h2 id="prerequisite">Prerequisite</h2>
<p><a id="markdown-prerequisite" name="prerequisite"></a></p>

<p>Read all about TTY history and implementation in Linux
<a href="https://www.linusakesson.net/programming/tty/">here</a> before reading this repo and doing
the exercises here. There is so much background history and information in this article
that is a prerequisite to understanding anything in this repo.</p>

<p>This is a great <a href="https://youtu.be/juGNPLdjLH4?si=0gg4ZPbPbnL2_rQx">YouTube video</a> that
explains the fundamentals of the Linux kernel and device drivers, and how <code class="language-plaintext highlighter-rouge">char</code> device
drivers work. TTYs are <code class="language-plaintext highlighter-rouge">char</code> devices.</p>

<h2 id="github-repo-for-this-article">GitHub repo for this article</h2>
<p><a id="markdown-github-repo-for-this-article" name="github-repo-for-this-article"></a></p>

<p>Here‚Äôs the <a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/README.md#list-of-signals"><code class="language-plaintext highlighter-rouge">tty</code>
repo</a>
containing the source code for this article and the videos.</p>

<h2 id="related-youtube-videos-for-this-article">Related YouTube videos for this article</h2>
<p><a id="markdown-related-youtube-videos-for-this-article" name="related-youtube-videos-for-this-article"></a></p>

<p>This article is a companion to the following YouTube videos. If you like to learn via
video, please watch the companion videos on the <a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube
channel</a>. Please
<a href="https://www.youtube.com/@developerlifecom?sub_confirmation=1">subscribe</a> to the channel.</p>

<blockquote>
  <p>‚èØÔ∏è Here‚Äôs the <a href="https://www.youtube.com/watch?v=bolScvh4x7I&amp;list=PLofhE49PEwmw3MKOU1Kn3xbP4FRQR4Mb3">TTY
playlist</a>
containing all these videos.</p>
</blockquote>

<h3 id="part-1--3--background-info">Part 1 / 3 : background info</h3>
<p><a id="markdown-part-1-%2F-3-%3A-background-info" name="part-1-%2F-3-%3A-background-info"></a></p>

<!-- video tty-1 -->
<iframe src="https://www.youtube.com/embed/bolScvh4x7I?si=9Cm95eajpdEym0zX" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<p><br /></p>

<h3 id="part-2--3--examples-of-send--recieve-signals-proc-spawn-and-ipc">Part 2 / 3 : examples of send &amp; recieve signals, proc spawn, and IPC</h3>
<p><a id="markdown-part-2-%2F-3-%3A-examples-of-send-%26-recieve-signals%2C-proc-spawn%2C-and-ipc" name="part-2-%2F-3-%3A-examples-of-send-%26-recieve-signals%2C-proc-spawn%2C-and-ipc"></a></p>

<!-- video tty-2 -->
<iframe src="https://www.youtube.com/embed/58_9yjLI4WA?si=-CZA8vZGnVTJ5ILD" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<p><br /></p>

<h3 id="part-3--3--run-tokioprocesscommand-in-async-rust">Part 3 / 3 : run tokio::process::Command in async Rust</h3>
<p><a id="markdown-part-3-%2F-3-%3A-run-tokio%3A%3Aprocess%3A%3Acommand-in-async-rust" name="part-3-%2F-3-%3A-run-tokio%3A%3Aprocess%3A%3Acommand-in-async-rust"></a></p>

<!-- video tty-3 -->
<iframe src="https://www.youtube.com/embed/8JeL1sGozO4?si=9i1-booV0MoQXRGg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<p><br /></p>

<h2 id="limitations-of-using-tty-in-linux-and-why-we-like-userland-terminal-emulators-pty">Limitations of using TTY in Linux, and why we like userland terminal emulators (PTY)</h2>
<p><a id="markdown-limitations-of-using-tty-in-linux%2C-and-why-we-like-userland-terminal-emulators-pty" name="limitations-of-using-tty-in-linux%2C-and-why-we-like-userland-terminal-emulators-pty"></a></p>

<h3 id="kernel-tty-">Kernel TTY üëéüèΩ</h3>
<p><a id="markdown-kernel-tty-%F0%9F%91%8E%F0%9F%8F%BD" name="kernel-tty-%F0%9F%91%8E%F0%9F%8F%BD"></a></p>

<p>To switch to TTYs in Linux, press:</p>

<ul>
  <li><kbd>Ctrl + Alt + F3</kbd> to <kbd>Ctrl + Alt + F4</kbd>. To access two TTYs, one on <kbd>F3</kbd>
and the other on <kbd>F4</kbd>.</li>
  <li>To switch back to the TTY in which the GUI is running, press <kbd>Ctrl + Alt + F2</kbd>.</li>
</ul>

<p>In the Linux kernel, the TTY driver and line discipline provide basic line editing (and the
implementation of <code class="language-plaintext highlighter-rouge">cooked</code> or <code class="language-plaintext highlighter-rouge">raw</code> mode), and there is no
<a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter"><code class="language-plaintext highlighter-rouge">UART</code></a> or physical
terminal involved. Instead, a video terminal (a complex state machine including a frame buffer of
characters and graphical character attributes) is emulated in software, and
<a href="https://www.youtube.com/watch?v=aAuw2EVCBBg">[video] rendered to a VGA display</a>.</p>

<blockquote>
  <p>So if you run <code class="language-plaintext highlighter-rouge">edi</code> in a TTY, you will see that the font rendering and colors are different than
in a GUI terminal emulator. However it still runs.</p>
</blockquote>

<h3 id="userland-pty-">Userland PTY üëçüèΩ</h3>
<p><a id="markdown-userland-pty-%F0%9F%91%8D%F0%9F%8F%BD" name="userland-pty-%F0%9F%91%8D%F0%9F%8F%BD"></a></p>

<p>The (kernel TTY) console subsystem is somewhat rigid. Things get more flexible (and abstract) if we
move the terminal emulation into userland. This is how <code class="language-plaintext highlighter-rouge">xterm</code> and its clones work. To facilitate
moving the terminal emulation into userland, while still keeping the TTY subsystem (session
management and line discipline) intact, the pseudo terminal or PTY was invented. And as you may have
guessed, things get even more complicated when you start running pseudo terminals inside pseudo
terminals, aka <code class="language-plaintext highlighter-rouge">screen</code> or <code class="language-plaintext highlighter-rouge">ssh</code>.</p>

<blockquote>
  <p>The primary use case for r3bl code is to run in this terminal emulator environment in userland and
not the TTY environment supplied by the Linux kernel itself.</p>
</blockquote>

<h2 id="examples-of-using-pty-in-linux">Examples of using PTY in Linux</h2>
<p><a id="markdown-examples-of-using-pty-in-linux" name="examples-of-using-pty-in-linux"></a></p>

<p>Each terminal in Linux is associated with a PTY (pseudo terminal). This is the device provided by
each terminal emulator program instance (aka process) that is currently running on the system. Use
the following command to get a list of all PTYs on the system.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ls</span> /dev/pts
</code></pre></div></div>

<p>Here‚Äôs sample output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>crw--w---- nazmul tty  0 B Wed Jul 17 11:36:35 2024 ÓòÅ 0
crw--w---- nazmul tty  0 B Wed Jul 17 11:38:32 2024 ÓòÅ 1
crw--w---- nazmul tty  0 B Wed Jul 17 11:38:06 2024 ÓòÅ 10
crw--w---- nazmul tty  0 B Wed Jul 17 11:23:20 2024 ÓòÅ 11
crw--w---- nazmul tty  0 B Sun Jul 14 16:19:36 2024 ÓòÅ 2
crw--w---- nazmul tty  0 B Mon Jul 15 13:22:48 2024 ÓòÅ 3
crw--w---- nazmul tty  0 B Tue Jul 16 09:58:08 2024 ÓòÅ 4
crw--w---- nazmul tty  0 B Wed Jul 17 10:34:48 2024 ÓòÅ 5
crw--w---- nazmul tty  0 B Wed Jul 17 11:30:32 2024 ÓòÅ 7
crw--w---- nazmul tty  0 B Wed Jul 17 11:36:36 2024 ÓòÅ 8
crw--w---- nazmul tty  0 B Wed Jul 17 11:30:48 2024 ÓòÅ 9
c--------- root   root 0 B Sat Jul 13 18:23:41 2024 ÓòÅ ptmx
</code></pre></div></div>

<p>So which PTY is associated with the currently open terminal? Run the following command to get the
TTY number of the currently open terminal.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">set </span>my_tty_id <span class="o">(</span><span class="nb">tty</span><span class="o">)</span>
<span class="nb">echo</span> <span class="nv">$my_tty_id</span>
</code></pre></div></div>

<p>It will output something like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/dev/pts/1
</code></pre></div></div>

<p>Each <code class="language-plaintext highlighter-rouge">/dev/pts/*</code> is a file. And you can read / write / redirect to these files just like any other
file.</p>

<p>For the following examples, let‚Äôs assume that you have 2 terminal emulator app windows open. One on
the left, and another one on the right.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                                ‚îÇ  ‚îÇ                                ‚îÇ
‚îÇ    LEFT TERMINAL               ‚îÇ  ‚îÇ    RIGHT TERMINAL              ‚îÇ
‚îÇ    /dev/pts/1                  ‚îÇ  ‚îÇ    /dev/pts/2                  ‚îÇ
‚îÇ                                ‚îÇ  ‚îÇ                                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre></div></div>

<h3 id="using-redirection-to-write-to-another-pty-run-command-in-left-terminal-see-output-in-right-terminal">Using redirection to write to another PTY (run command in left terminal, see output in right terminal)</h3>
<p><a id="markdown-using-redirection-to-write-to-another-pty-run-command-in-left-terminal%2C-see-output-in-right-terminal" name="using-redirection-to-write-to-another-pty-run-command-in-left-terminal%2C-see-output-in-right-terminal"></a></p>

<p>Let‚Äôs say you have 2 terminals open, and one has the PTY number <code class="language-plaintext highlighter-rouge">/dev/pts/1</code> (on the left) and the
other has the TTY number <code class="language-plaintext highlighter-rouge">/dev/pts/2</code> (on the right).</p>

<p>From the left PTY <code class="language-plaintext highlighter-rouge">/dev/pts/1</code>, you can write to the right PTY <code class="language-plaintext highlighter-rouge">/dev/pts/2</code> using the following
command, and you will see ‚ÄúHello, World!‚Äù in the right PTY.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Run this in left terminal /dev/pts/1</span>
<span class="nb">echo</span> <span class="s2">"Hello, World!"</span> <span class="o">&gt;</span> /dev/pts/2 <span class="c"># You will see this in the right terminal /dev/pts/2</span>
</code></pre></div></div>

<h3 id="using-redirection-to-read-from-another-pty-type-in-left-terminal-see-it-in-right-terminal">Using redirection to read from another PTY (type in left terminal, see it in right terminal)</h3>
<p><a id="markdown-using-redirection-to-read-from-another-pty-type-in-left-terminal%2C-see-it-in-right-terminal" name="using-redirection-to-read-from-another-pty-type-in-left-terminal%2C-see-it-in-right-terminal"></a></p>

<p>From the right PTY <code class="language-plaintext highlighter-rouge">/dev/pts/2</code> you can read input from the left PTY <code class="language-plaintext highlighter-rouge">/dev/pts/1</code> using the
following command.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Run this in right terminal /dev/pts/2</span>
<span class="nb">cat</span> /dev/pts/1
</code></pre></div></div>

<p>Type the following in the left PTY.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Run this in left terminal /dev/pts/1</span>
abcdefgh
</code></pre></div></div>

<p>You will see the following output in the right PTY: <code class="language-plaintext highlighter-rouge">abcdefgh</code>.</p>

<h3 id="breaking-things-in-raw-mode">Breaking things in raw mode.</h3>
<p><a id="markdown-breaking-things-in-raw-mode." name="breaking-things-in-raw-mode."></a></p>

<p>On the <strong>right</strong> terminal, run the following commands.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vi &amp;
<span class="nb">jobs</span>
</code></pre></div></div>

<p>Here you will see the job number of the <code class="language-plaintext highlighter-rouge">vi</code> process. And you will see that it is in the background.</p>

<p>If you run <code class="language-plaintext highlighter-rouge">ps l</code> you will see the states of all the processes that are running. If you run <code class="language-plaintext highlighter-rouge">ps -l</code>
you will this information on just the processes spawned in the right terminal. For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 S  1000  540327  540177  0  80   0 - 62854 futex_ pts/8    00:00:01 fish
0 T  1000  554675  540327  0  80   0 -  3023 do_sig pts/8    00:00:00 vi
4 R  1000  554850  540327  0  80   0 -  3478 -      pts/8    00:00:00 ps
</code></pre></div></div>

<p>Now if you bring <code class="language-plaintext highlighter-rouge">vi</code> to the foreground by running <code class="language-plaintext highlighter-rouge">fg</code>. The <code class="language-plaintext highlighter-rouge">vi</code> process is now in raw mode, and
the shell is no longer interpreting the input. It won‚Äôt know what to do with input that comes in
over <code class="language-plaintext highlighter-rouge">stdin</code>.</p>

<p>Run <code class="language-plaintext highlighter-rouge">echo "foo" &gt; /dev/pts/2</code> in the <strong>left</strong> terminal, you will see that the <code class="language-plaintext highlighter-rouge">vi</code> process gets
messed up, since it doesn‚Äôt really interpret that input (as it‚Äôs reading directly from keyboard and
mouse). However, the shell will send that output to <code class="language-plaintext highlighter-rouge">vi</code> and it‚Äôs UI will be messed up. The same
thing happens if you use <code class="language-plaintext highlighter-rouge">micro</code> or <code class="language-plaintext highlighter-rouge">nano</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    LEFT TERMINAL               ‚îÇ  ‚îÇ    RIGHT TERMINAL              ‚îÇ
‚îÇ    /dev/pts/1                  ‚îÇ  ‚îÇ    /dev/pts/2                  ‚îÇ
‚îÇ                                ‚îÇ  ‚îÇ                                ‚îÇ
‚îÇ                                ‚îÇ  ‚îÇ  &gt; vi &amp;                        ‚îÇ
‚îÇ                                ‚îÇ  ‚îÇ  &gt; jobs                        ‚îÇ
‚îÇ                                ‚îÇ  ‚îÇ  &gt; fg                          ‚îÇ
‚îÇ  &gt; echo "foo" &gt; /dev/pts/2     ‚îÇ  ‚îÇ  &gt; # vi is messed up           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre></div></div>

<p>To terminate the <code class="language-plaintext highlighter-rouge">vi</code> process (or many of them), run <code class="language-plaintext highlighter-rouge">killall -9 vi</code>. That sends the <code class="language-plaintext highlighter-rouge">SIGKILL</code>
signal to all the <code class="language-plaintext highlighter-rouge">vi</code> processes.</p>

<h2 id="shells-processes-sessions-jobs-ptys-signals">Shells, processes, sessions, jobs, PTYs, signals</h2>
<p><a id="markdown-shells%2C-processes%2C-sessions%2C-jobs%2C-ptys%2C-signals" name="shells%2C-processes%2C-sessions%2C-jobs%2C-ptys%2C-signals"></a></p>

<p>Let‚Äôs say in a new terminal emulator program <code class="language-plaintext highlighter-rouge">xterm</code>, and then you run the following commands in
<code class="language-plaintext highlighter-rouge">fish</code>:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> &amp;
<span class="nb">ls</span> | <span class="nb">sort</span>
</code></pre></div></div>

<p>What happens here? What sessions and jobs are created? What about the pipe?</p>

<p>There are 4 jobs:</p>

<ol>
  <li>The job that runs <code class="language-plaintext highlighter-rouge">xterm</code> itself.</li>
</ol>

<ul>
  <li>This does not have any <code class="language-plaintext highlighter-rouge">stdin</code>, <code class="language-plaintext highlighter-rouge">stdout</code>, <code class="language-plaintext highlighter-rouge">stderr</code> <code class="language-plaintext highlighter-rouge">fd</code>s associated with it.</li>
  <li>This does not have a PTY associated with it.</li>
</ul>

<ol>
  <li>The job that runs <code class="language-plaintext highlighter-rouge">bash</code> itself.</li>
</ol>

<ul>
  <li>This has <code class="language-plaintext highlighter-rouge">stdin</code>, <code class="language-plaintext highlighter-rouge">stdout</code>, <code class="language-plaintext highlighter-rouge">stderr</code> (from <code class="language-plaintext highlighter-rouge">xterm</code>), lets say, <code class="language-plaintext highlighter-rouge">/dev/pts/0</code>.</li>
  <li>This has a PTY associated with it, lets say, <code class="language-plaintext highlighter-rouge">/dev/pts/0</code>.</li>
</ul>

<ol>
  <li>The job that runs <code class="language-plaintext highlighter-rouge">cat</code> in the background.</li>
</ol>

<ul>
  <li>This has <code class="language-plaintext highlighter-rouge">stdin</code>, <code class="language-plaintext highlighter-rouge">stdout</code>, <code class="language-plaintext highlighter-rouge">stderr</code> (from <code class="language-plaintext highlighter-rouge">xterm</code>), <code class="language-plaintext highlighter-rouge">/dev/pts/0</code>.</li>
  <li>This has a PTY associated with it, <code class="language-plaintext highlighter-rouge">/dev/pts/0</code>.</li>
</ul>

<ol>
  <li>The job that runs <code class="language-plaintext highlighter-rouge">ls | sort</code> pipeline. This job has 2 processes inside of it which are spawned
in parallel due to the pipe: 4.1. The process that runs <code class="language-plaintext highlighter-rouge">ls</code>.
    <ul>
      <li>This has <code class="language-plaintext highlighter-rouge">stdin</code>, <code class="language-plaintext highlighter-rouge">stderr</code> (from <code class="language-plaintext highlighter-rouge">xterm</code>), <code class="language-plaintext highlighter-rouge">/dev/pts/0</code>.</li>
      <li>Due to the pipe <code class="language-plaintext highlighter-rouge">stdout</code> is set to <code class="language-plaintext highlighter-rouge">pipe0</code>.</li>
      <li>This has a PTY associated with it, <code class="language-plaintext highlighter-rouge">/dev/pts/0</code>. 4.2. The process that runs <code class="language-plaintext highlighter-rouge">sort</code>.</li>
      <li>This has <code class="language-plaintext highlighter-rouge">stdout</code>, <code class="language-plaintext highlighter-rouge">stderr</code> (from <code class="language-plaintext highlighter-rouge">xterm</code>), <code class="language-plaintext highlighter-rouge">/dev/pts/0</code>.</li>
      <li>Due to the pipe, this has <code class="language-plaintext highlighter-rouge">stdin</code> set to <code class="language-plaintext highlighter-rouge">pipe0</code>.</li>
      <li>This has a PTY associated with it, <code class="language-plaintext highlighter-rouge">/dev/pts/0</code>.</li>
    </ul>
  </li>
</ol>

<p>The basic idea is that every pipeline is a job, because every process in a pipeline should be
manipulated (stopped, resumed, killed) simultaneously. That‚Äôs why <code class="language-plaintext highlighter-rouge">kill</code> allows you to send signals
to entire process groups. By default, <code class="language-plaintext highlighter-rouge">fork</code> places a newly created child process in the same
process group as its parent, so that e.g. a <kbd>^C</kbd> from the keyboard will affect both parent
and child. But the shell, as part of its session leader duties, creates a new process group every
time it launches a pipeline.</p>

<p>The TTY driver keeps track of the foreground process group id, but only in a passive way. The
session leader has to update this information explicitly when necessary. Similarly, the TTY driver
keeps track of the size of the connected terminal, but this information has to be updated
explicitly, by the terminal emulator or even by the user.</p>

<p>Several processes have <code class="language-plaintext highlighter-rouge">/dev/pts/0</code> attached to their standard input. With these constrains:</p>

<ol>
  <li>Only the foreground job (the <code class="language-plaintext highlighter-rouge">ls | sort</code> pipeline) will receive input from the TTY.</li>
  <li>Likewise, only the foreground job will be allowed to write to the TTY device (in the default
configuration).</li>
  <li>If the <code class="language-plaintext highlighter-rouge">cat</code> process were to attempt to write to the TTY, the kernel would suspend it using a
signal.</li>
</ol>

<h3 id="background-information-knowledgebase">Background information (knowledgebase)</h3>
<p><a id="markdown-background-information-knowledgebase" name="background-information-knowledgebase"></a></p>

<p>The following sections are a deep live of the Linux kernel and how it works with processes, file
descriptors, shells, and PTYs.</p>

<h4 id="file-descriptors-and-processes-ulimit-stdin-stdout-stderr-pipes">File descriptors and processes, ulimit, stdin, stdout, stderr, pipes</h4>
<p><a id="markdown-file-descriptors-and-processes%2C-ulimit%2C-stdin%2C-stdout%2C-stderr%2C-pipes" name="file-descriptors-and-processes%2C-ulimit%2C-stdin%2C-stdout%2C-stderr%2C-pipes"></a></p>

<p>Here‚Äôs a
<a href="https://youtu.be/rW_NV6rf0rM?si=wcEkGPXnXzKeBn_G">[video] What‚Äôs behind a file descriptor in Linux? Also, i/o redirection with <code class="language-plaintext highlighter-rouge">dup2</code>.</a>
that goes into file descriptors, pipes, and process forking in Linux.</p>

<h4 id="unix-shells-that-run-in-terminals-to-execute-built-in-and-program-commands">Unix shells (that run in terminals to execute built-in and program commands)</h4>
<p><a id="markdown-unix-shells-that-run-in-terminals-to-execute-built-in-and-program-commands" name="unix-shells-that-run-in-terminals-to-execute-built-in-and-program-commands"></a></p>

<h5 id="what-is-the-relationship-between-linux-shells-subshells-and-fork-exec-and-wait-patterns">What is the relationship between linux shells, subshells, and fork, exec, and wait patterns?</h5>
<p><a id="markdown-what-is-the-relationship-between-linux-shells%2C-subshells%2C-and-fork%2C-exec%2C-and-wait-patterns%3F" name="what-is-the-relationship-between-linux-shells%2C-subshells%2C-and-fork%2C-exec%2C-and-wait-patterns%3F"></a></p>

<p>In Linux, shells, subshells, and the fork-exec-wait pattern are interconnected concepts that play a
crucial role in process management and execution. Here‚Äôs how they relate to each other:</p>

<ol>
  <li>
    <p><strong>Shells</strong>: A shell is a command-line interpreter that allows users to interact with the
operating system. Shells provide a way for users to run commands, launch programs, and manage
processes. Examples of popular shells in Linux include Bash, Zsh, and Fish.</p>
  </li>
  <li>
    <p><strong>Fork-Exec-Wait Pattern</strong>: This pattern is commonly used in shell scripting to spawn new
processes and manage their execution. By forking a new process, executing a different program in
the child process, and then waiting for the child process to finish, the shell can run multiple
commands concurrently and coordinate their execution. If the parent does not wait for the child
process to finish, the child is a zombie process.</p>

    <ul>
      <li><strong>Fork</strong>: When a process wants to execute a new program, it creates a copy of itself using the
<code class="language-plaintext highlighter-rouge">fork()</code> system call. This creates a new process (child process) that is an exact copy of the
original process (parent process) at the time of the <code class="language-plaintext highlighter-rouge">fork()</code> call. It needs to do this since
<code class="language-plaintext highlighter-rouge">exec()</code>, which is called next, will swap the program binaries of the process which calls it!
If it doesn‚Äôt spawn a child, then the parent will cease to exist in memory after <code class="language-plaintext highlighter-rouge">exec()</code> is
called.</li>
      <li><strong>Exec</strong>: After forking, the child process uses the <code class="language-plaintext highlighter-rouge">exec()</code> system call to replace its memory
space with a new program. This allows the child process to run a different program than the
parent process. The <code class="language-plaintext highlighter-rouge">exec()</code> system call loads the new program into the child process‚Äôs memory
and starts its execution.</li>
      <li><strong>Wait</strong>: After forking and executing a new program, the parent process may need to wait for
the child process to finish its execution. The parent process can use the <code class="language-plaintext highlighter-rouge">wait()</code> system call
to wait for the child process to terminate. This ensures that the parent process does not
continue its execution until the child process has completed its task.</li>
    </ul>
  </li>
  <li>
    <p><strong>Subshells</strong>: A subshell is a separate instance of the shell that is spawned to execute a
command or a group of commands. Subshells are created within the parent shell and can be used to
run commands in a separate environment without affecting the parent shell.</p>
  </li>
</ol>

<blockquote>
  <p>You can learn more about each of these system calls on your Linux machine simply by running
<code class="language-plaintext highlighter-rouge">bash -c "man fork"</code>, <code class="language-plaintext highlighter-rouge">bash -c "man exec"</code>, and <code class="language-plaintext highlighter-rouge">bash -c "man wait"</code>. The <code class="language-plaintext highlighter-rouge">bash -c</code> is needed only
if you‚Äôre running some other shell like <code class="language-plaintext highlighter-rouge">fish</code> and not <code class="language-plaintext highlighter-rouge">bash</code>.</p>
</blockquote>

<p>The relationship between these concepts is as follows:</p>

<ul>
  <li>A shell process (the parent) creates a clone of their ‚Äúself‚Äù process using <code class="language-plaintext highlighter-rouge">fork()</code>, called a
child process. And then they use <code class="language-plaintext highlighter-rouge">exec()</code> to replace the memory space of the child process with a
new program. Then the parent process waits for the child process to finish.</li>
  <li>The fork-exec-wait pattern is a common technique used in shells and subshells to spawn new
processes, execute programs, and coordinate their execution.</li>
  <li>Shells can create subshells to run commands in a separate environment. For example if you want to
run <code class="language-plaintext highlighter-rouge">cd</code> (which is a shell built-in command and not a external ‚Äúprogram‚Äù command) and you don‚Äôt
want this to affect the parent shell, you can run it in a subshell.</li>
</ul>

<p>Overall, these concepts work together to facilitate process management, execution, and command
interpretation in a Linux environment.</p>

<h5 id="does-exec-change-the-current-working-directory-or-affect-environment-variables-in-the-parent">Does exec() change the current working directory or affect environment variables in the parent?</h5>
<p><a id="markdown-does-exec-change-the-current-working-directory-or-affect-environment-variables-in-the-parent%3F" name="does-exec-change-the-current-working-directory-or-affect-environment-variables-in-the-parent%3F"></a></p>

<p>Running <code class="language-plaintext highlighter-rouge">exec()</code> on the child process does not change the current working directory of the parent
process.</p>

<p>When a process calls the <code class="language-plaintext highlighter-rouge">exec()</code> system call in Linux, it replaces its current image with a new
program. The <code class="language-plaintext highlighter-rouge">exec()</code> system call loads a new program into the process‚Äôs memory space and starts its
execution.</p>

<p>Here‚Äôs how <code class="language-plaintext highlighter-rouge">exec()</code> affects the current working directory and environment variables:</p>

<ol>
  <li>
    <p><strong>Current Working Directory</strong>: When a child process calls <code class="language-plaintext highlighter-rouge">exec()</code>, the current working directory
of the parent process remains unchanged. The new program loaded by <code class="language-plaintext highlighter-rouge">exec()</code> will start executing
with the same working directory as the original process. Therefore, the current working directory
of the parent process is not affected by the child‚Äôs <code class="language-plaintext highlighter-rouge">exec()</code> call.</p>
  </li>
  <li>
    <p><strong>Environment Variables</strong>: The environment of the new program loaded by <code class="language-plaintext highlighter-rouge">exec()</code> can be set
explicitly by the program itself or inherited from the parent process. If the new program does
not explicitly modify the environment variables, it will inherit the environment variables from
the parent process. Any changes made to environment variables in the child process after the
<code class="language-plaintext highlighter-rouge">exec()</code> call will not affect the environment variables of the parent process.</p>
  </li>
</ol>

<h5 id="then-how-does-the-cd-command-change-the-current-working-directory-of-a-shell">Then how does the cd command change the current working directory of a shell?</h5>
<p><a id="markdown-then-how-does-the-cd-command-change-the-current-working-directory-of-a-shell%3F" name="then-how-does-the-cd-command-change-the-current-working-directory-of-a-shell%3F"></a></p>

<p>The <code class="language-plaintext highlighter-rouge">cd</code> command is a special command called a ‚Äúshell built-in‚Äù command; there are about ~70 of
these. <code class="language-plaintext highlighter-rouge">echo</code>, <code class="language-plaintext highlighter-rouge">source</code> are examples of these ‚Äúbuilt-in‚Äù commands. These commands are built into the
shell itself. It is not a ‚Äúexternal executable program‚Äù command like <code class="language-plaintext highlighter-rouge">ls</code>. So a shell does not have
to <code class="language-plaintext highlighter-rouge">fork</code> and <code class="language-plaintext highlighter-rouge">exec</code> to run these commands. The shell runs them inside of it‚Äôs own ‚Äúparent‚Äù process,
which affects ‚Äúself‚Äù.</p>

<p>If you think about it, <code class="language-plaintext highlighter-rouge">cd</code> has to be a built-in command since we know that child processes can‚Äôt
affect the environment of the parent process, and the current working directory is part of a
process‚Äô environment.</p>

<blockquote>
  <p>Watch this <a href="https://youtu.be/GA2mIUQq48s?si=Sfbpre-MeNXlND_b&amp;t=820">video</a> to get an understanding
of <code class="language-plaintext highlighter-rouge">built-in</code> commands vs <code class="language-plaintext highlighter-rouge">external executable program</code> commands.</p>
</blockquote>

<p>Let‚Äôs say you want to <code class="language-plaintext highlighter-rouge">cd</code> into a folder but you don‚Äôt want this to affect the parent shell. How do
you do this? This is where subshells come into play. If you‚Äôre using <code class="language-plaintext highlighter-rouge">fish</code>, then a subshell is like
running <code class="language-plaintext highlighter-rouge">fish -c</code> with whatever is typed in between <code class="language-plaintext highlighter-rouge">""</code>.</p>

<h5 id="how-do-subshells-work-in-the-case-where-i-dont-the-shells-environment-to-be-affected-at-all">How do subshells work, in the case where I don‚Äôt the shell‚Äôs environment to be affected at all?</h5>
<p><a id="markdown-how-do-subshells-work%2C-in-the-case-where-i-don%E2%80%99t-the-shell%E2%80%99s-environment-to-be-affected-at-all%3F" name="how-do-subshells-work%2C-in-the-case-where-i-don%E2%80%99t-the-shell%E2%80%99s-environment-to-be-affected-at-all%3F"></a></p>

<p>In a Linux shell, a subshell is a separate instance of the shell that is spawned to execute a
command or a group of commands. When a user types a command to execute, the shell creates a subshell
to run that command.</p>

<p>Subshells are useful for various purposes, such as:</p>

<ol>
  <li>Running commands in a separate environment without affecting the parent shell.</li>
  <li>Running commands in parallel to improve performance.</li>
  <li>Running commands that need to be isolated from the parent shell.</li>
</ol>

<p>Subshells are typically created using parentheses <code class="language-plaintext highlighter-rouge">()</code> in <code class="language-plaintext highlighter-rouge">fish</code> or the <code class="language-plaintext highlighter-rouge">$(...)</code> syntax in <code class="language-plaintext highlighter-rouge">bash</code>.
For example, when you run a command within parentheses like this:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>command1<span class="p">;</span> command2<span class="o">)</span>
</code></pre></div></div>

<p>The commands <code class="language-plaintext highlighter-rouge">command1</code> and <code class="language-plaintext highlighter-rouge">command2</code> will be executed in a subshell. Once the commands finish
executing, the subshell exits, and the parent shell continues its operation. If you run the <code class="language-plaintext highlighter-rouge">cd ..</code>
command in a subshell, it won‚Äôt change the current working directory of the shell!</p>

<p>Subshells are used to manage sessions and jobs and pipelines. Things like foreground and background
jobs are managed using subshells. And signals are sent to processes using subshells in a pipeline.</p>

<blockquote>
  <p>Watch this <a href="https://youtu.be/N8kT2XRNEAg?si=iiv6i3mO6Lxi8qb1&amp;t=60">video</a> to get an understanding
of subshells, signals, jobs, pipelines, etc.</p>
</blockquote>

<h5 id="deep-dive-of-all-this-information-in-video-format">Deep dive of all this information in video format</h5>
<p><a id="markdown-deep-dive-of-all-this-information-in-video-format" name="deep-dive-of-all-this-information-in-video-format"></a></p>

<p>Here‚Äôs a
<a href="https://www.youtube.com/playlist?list=PLFAC320731F539902">[video playlist] Unix terminals and shells</a>
that goes into details about shells, subshells, forking, exec (command), and wait works.</p>

<h4 id="processes-sessions-jobs-ptys-signals-using-c">Processes, sessions, jobs, PTYs, signals using C</h4>
<p><a id="markdown-processes%2C-sessions%2C-jobs%2C-ptys%2C-signals-using-c" name="processes%2C-sessions%2C-jobs%2C-ptys%2C-signals-using-c"></a></p>

<p>Here are some videos on forking processes, zombies, and signals in C:</p>

<ul>
  <li><a href="https://www.youtube.com/watch?v=ss1-REMJ9GA">[video] Create new process in C w/ <code class="language-plaintext highlighter-rouge">fork()</code></a></li>
  <li><a href="https://www.youtube.com/watch?v=83M5-NPDeWs">[video] Send signals to processes in C w/ <code class="language-plaintext highlighter-rouge">kill()</code>, <code class="language-plaintext highlighter-rouge">signal()</code>, <code class="language-plaintext highlighter-rouge">sigaction()</code></a></li>
  <li><a href="https://www.youtube.com/watch?v=xJ8KenZw2ag">[video] Zombie processes in C</a></li>
  <li><a href="https://www.youtube.com/watch?v=_5SCtRNnf9U">[video] Stop process becoming zombie in C</a></li>
</ul>

<h2 id="what-is-devtty">What is /dev/tty?</h2>
<p><a id="markdown-what-is-%2Fdev%2Ftty%3F" name="what-is-%2Fdev%2Ftty%3F"></a></p>

<p><code class="language-plaintext highlighter-rouge">/dev/tty</code> is a special file in Unix-like operating systems that represents the controlling terminal
of the current process. It is a synonym for the controlling terminal device file associated with the
process.</p>

<p>The controlling terminal is the terminal that is currently active and connected to the process,
allowing input and output interactions. It provides a way for processes to interact with the user
through the terminal interface.</p>

<p>The <code class="language-plaintext highlighter-rouge">/dev/tty</code> file can be used to read from or write to the controlling terminal.</p>

<p>In each process, <code class="language-plaintext highlighter-rouge">/dev/tty</code> is a synonym for the controlling terminal associated with the process
group of that process, if any. It is useful for programs or shell procedures that wish to be sure of
writing messages to or reading data from the terminal no matter how output has been redirected. It
can also be used for applications that demand the name of a file for output, when typed output is
desired and it is tiresome to find out what terminal is currently in use.</p>

<ol>
  <li>Definition from
<a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap10.html">IEEE Open Group Base Specifications for POSIX</a>.</li>
  <li>You can see it used in <code class="language-plaintext highlighter-rouge">crossterm</code> crate
<a href="https://github.com/crossterm-rs/crossterm/blob/master/src/terminal/sys/file_descriptor.rs#L143">here</a>.</li>
  <li>Here‚Äôs more info about this on
<a href="https://www.baeldung.com/linux/monitor-keyboard-drivers#devtty">baeldung.com</a>.</li>
</ol>

<h3 id="how-is-crossterm-built-on-top-of-stdio-pty-etc">How is crossterm built on top of stdio, PTY, etc?</h3>
<p><a id="markdown-how-is-crossterm-built-on-top-of-stdio%2C-pty%2C-etc%3F" name="how-is-crossterm-built-on-top-of-stdio%2C-pty%2C-etc%3F"></a></p>

<p>The <a href="https://github.com/crossterm-rs/crossterm"><code class="language-plaintext highlighter-rouge">crossterm</code></a> crate is built on top of Tokio‚Äôs
<a href="https://docs.rs/mio/latest/mio/guide/index.html"><code class="language-plaintext highlighter-rouge">mio</code></a> crate, which uses Linux
<a href="https://man7.org/linux/man-pages/man7/epoll.7.html"><code class="language-plaintext highlighter-rouge">epoll</code></a> to work with file descriptors in an
async manner.</p>

<ul>
  <li>Here‚Äôs <a href="https://docs.rs/mio/latest/mio/struct.Poll.html"><code class="language-plaintext highlighter-rouge">mio</code>‚Äôs <code class="language-plaintext highlighter-rouge">Poll</code></a> using <code class="language-plaintext highlighter-rouge">epoll</code> under the
hood.</li>
  <li>Here‚Äôs an <a href="https://docs.rs/mio/latest/mio/guide/index.html">example</a> of <code class="language-plaintext highlighter-rouge">mio</code> using Linux <code class="language-plaintext highlighter-rouge">epoll</code>
in order to read from a file descriptor in an async manner.</li>
</ul>

<blockquote>
  <p>Linux <code class="language-plaintext highlighter-rouge">epoll</code> is able to work with <code class="language-plaintext highlighter-rouge">stdio</code> file descriptors (ie, <code class="language-plaintext highlighter-rouge">stdin</code>, <code class="language-plaintext highlighter-rouge">stdout</code>, <code class="language-plaintext highlighter-rouge">stderr</code>), as
well as other file descriptors (network and file system). However, for throughput and performance
(by reducing context switching and being efficient with buffers that hold IO data), Linux
<a href="https://en.wikipedia.org/wiki/Io_uring"><code class="language-plaintext highlighter-rouge">io_uring</code></a> might be more suitable.</p>
</blockquote>

<p>Here are some links to learn more about how <code class="language-plaintext highlighter-rouge">crossterm</code> works with <code class="language-plaintext highlighter-rouge">PTY</code>s and <code class="language-plaintext highlighter-rouge">stdio</code>:</p>

<ul>
  <li><a href="https://github.com/crossterm-rs/crossterm/blob/master/src/terminal/sys/file_descriptor.rs#L143">Get a file descriptor for the TTY <code class="language-plaintext highlighter-rouge">tty_fd()</code></a>.
It uses <a href="https://docs.rs/rustix/latest/rustix/stdio/fn.stdin.html"><code class="language-plaintext highlighter-rouge">rustix::stdio::stdin()</code></a> by
default and falls back on <code class="language-plaintext highlighter-rouge">/dev/tty/</code>.</li>
  <li>This <code class="language-plaintext highlighter-rouge">fd</code> is used by
<a href="https://github.com/crossterm-rs/crossterm/blob/master/src/event/source/unix/mio.rs#L35"><code class="language-plaintext highlighter-rouge">UnixInternalEventSource</code></a>
which creates a <code class="language-plaintext highlighter-rouge">mio::Poll</code> object for the <code class="language-plaintext highlighter-rouge">fd</code>. This <code class="language-plaintext highlighter-rouge">Poll</code> object uses <code class="language-plaintext highlighter-rouge">epoll</code> under the hood.
The
<a href="https://github.com/crossterm-rs/crossterm/blob/master/src/event/source/unix/mio.rs#L72"><code class="language-plaintext highlighter-rouge">EventSource</code> trait impl for <code class="language-plaintext highlighter-rouge">UnixInternalEventSource</code></a>
is used to actually
<a href="https://github.com/crossterm-rs/crossterm/blob/master/src/terminal/sys/file_descriptor.rs#L75">read</a>
the bytes from the <code class="language-plaintext highlighter-rouge">fd</code> (using
<a href="https://docs.rs/rustix/latest/rustix/io/fn.read.html"><code class="language-plaintext highlighter-rouge">rustix::io::read()</code></a>).</li>
  <li>Once a <code class="language-plaintext highlighter-rouge">Poll</code> has been created, a
<a href="https://docs.rs/mio/latest/mio/struct.Registry.html"><code class="language-plaintext highlighter-rouge">mio::Poll::registry()</code></a> must be used to
tell the OS to listen for events on the <code class="language-plaintext highlighter-rouge">fd</code>. A
<a href="https://docs.rs/mio/latest/mio/guide/index.html#2-registering-event-source">source and interest must be registered</a>
with the registry next:
    <ul>
      <li>The <code class="language-plaintext highlighter-rouge">fd</code> <a href="https://docs.rs/mio/latest/mio/unix/struct.SourceFd.html">implements</a> the
<a href="https://docs.rs/mio/latest/mio/event/trait.Source.html"><code class="language-plaintext highlighter-rouge">Source</code> trait</a> which
<a href="https://docs.rs/mio/latest/mio/event/trait.Source.html#implementing-eventsource">allows</a> <code class="language-plaintext highlighter-rouge">mio</code>
to listen for events on the <code class="language-plaintext highlighter-rouge">fd</code>.</li>
      <li>An <code class="language-plaintext highlighter-rouge">Interest::READABLE</code> must also be ‚Äúregistered‚Äù with the <code class="language-plaintext highlighter-rouge">registry</code>. For eg, for <code class="language-plaintext highlighter-rouge">stdin</code>, this
tells the OS to listen for input from the keyboard, and wake the <code class="language-plaintext highlighter-rouge">Poll</code> when this is ready.</li>
      <li>A <code class="language-plaintext highlighter-rouge">Token</code> is supplied that can be used when polling for events to see if they‚Äôre available on
the source. This happens in the
<a href="https://docs.rs/mio/latest/mio/guide/index.html#3-creating-the-event-loop"><code class="language-plaintext highlighter-rouge">loop</code></a> that calls
<code class="language-plaintext highlighter-rouge">poll()</code> to fill an <code class="language-plaintext highlighter-rouge">Event</code> buffer. If an event in this buffer matches the <code class="language-plaintext highlighter-rouge">Token</code>, then the
<code class="language-plaintext highlighter-rouge">fd</code> is ready for reading.</li>
    </ul>
  </li>
</ul>

<p>You can see all the steps (outlined above) in action, in the following crates:</p>

<ul>
  <li><a href="https://docs.rs/mio/latest/mio/guide/index.html">Guide in <code class="language-plaintext highlighter-rouge">mio</code> docs</a>.</li>
  <li><a href="https://github.com/crossterm-rs/crossterm/blob/master/src/event/source/unix/mio.rs"><code class="language-plaintext highlighter-rouge">mio.rs</code> file in <code class="language-plaintext highlighter-rouge">crossterm</code></a>.</li>
  <li>This <a href="https://github.com/nazmulidris/crossterm/pull/1">PR</a> in my fork of <code class="language-plaintext highlighter-rouge">crossterm</code> has
<code class="language-plaintext highlighter-rouge">println!</code> traces so you can see how <code class="language-plaintext highlighter-rouge">mio</code> is used under the hood by <code class="language-plaintext highlighter-rouge">crossterm</code> to read from
<code class="language-plaintext highlighter-rouge">stdin</code>.</li>
</ul>

<h3 id="how-is-termion-built-on-top-of-stdio-pty-etc">How is termion built on top of stdio, PTY, etc?</h3>
<p><a id="markdown-how-is-termion-built-on-top-of-stdio%2C-pty%2C-etc%3F" name="how-is-termion-built-on-top-of-stdio%2C-pty%2C-etc%3F"></a></p>

<p>Here‚Äôs a <a href="https://github.com/nazmulidris/termion/pull/1">PR</a> to explore the examples in <code class="language-plaintext highlighter-rouge">termion</code>
crate. This is a beautifully simple and elegant crate that is much simpler than <code class="language-plaintext highlighter-rouge">crossterm</code>. It
simply uses the standard library and a few other crates to get bytes from <code class="language-plaintext highlighter-rouge">stdin</code> and write bytes to
<code class="language-plaintext highlighter-rouge">stdout</code>. It does not use <code class="language-plaintext highlighter-rouge">mio</code>, and neither does it support <code class="language-plaintext highlighter-rouge">async</code> <code class="language-plaintext highlighter-rouge">EventStream</code>. There is an
‚Äúasync mode‚Äù, which simply spawns another thread and uses a channel to send events to the main
thread.</p>

<h2 id="list-of-signals">List of signals</h2>
<p><a id="markdown-list-of-signals" name="list-of-signals"></a></p>

<p>Here are the reference docs on signals:
<!-- cspell:disable-next-line --></p>
<ul>
  <li><a href="https://en.wikipedia.org/wiki/POSIX">POSIX</a>, pronounced ‚Äúpaw-siks‚Äù, <a href="https://en.wikipedia.org/wiki/Signal_(IPC)">signals</a></li>
  <li><a href="https://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html">gnu libc termination signals</a></li>
  <li><a href="https://www.gnu.org/software/libc/manual/html_node/Job-Control-Signals.html">gnu libc job control signals</a></li>
</ul>

<p>Here is a list of all the signals that a process might get:
<a href="https://www.linusakesson.net/programming/tty/#signal-madness:~:text=using%20a%20signal.-,Signal%20madness,-Now%20let%27s%20take">signals</a>.</p>

<p>You can also get a list of them using <code class="language-plaintext highlighter-rouge">kill -l</code>. It is different for <code class="language-plaintext highlighter-rouge">fish</code> and <code class="language-plaintext highlighter-rouge">bash</code>. However,
under the hood, the Linux kernel uses the same signal numbers for all shells.</p>

<!-- cSpell:disable -->

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>fish <span class="nt">-c</span> <span class="s2">"kill -l"</span>
HUP INT QUIT ILL TRAP ABRT BUS FPE KILL USR1 SEGV USR2 PIPE ALRM TERM STKFLT
CHLD CONT STOP TSTP TTIN TTOU URG XCPU XFSZ VTALRM PROF WINCH POLL PWR SYS

<span class="sb">```</span>shell
<span class="nv">$ </span>bash <span class="nt">-c</span> <span class="s2">"kill -l"</span>
 1<span class="o">)</span> SIGHUP	 2<span class="o">)</span> SIGINT	 3<span class="o">)</span> SIGQUIT	 4<span class="o">)</span> SIGILL	 5<span class="o">)</span> SIGTRAP
 6<span class="o">)</span> SIGABRT	 7<span class="o">)</span> SIGBUS	 8<span class="o">)</span> SIGFPE	 9<span class="o">)</span> SIGKILL	10<span class="o">)</span> SIGUSR1
11<span class="o">)</span> SIGSEGV	12<span class="o">)</span> SIGUSR2	13<span class="o">)</span> SIGPIPE	14<span class="o">)</span> SIGALRM	15<span class="o">)</span> SIGTERM
16<span class="o">)</span> SIGSTKFLT	17<span class="o">)</span> SIGCHLD	18<span class="o">)</span> SIGCONT	19<span class="o">)</span> SIGSTOP	20<span class="o">)</span> SIGTSTP
21<span class="o">)</span> SIGTTIN	22<span class="o">)</span> SIGTTOU	23<span class="o">)</span> SIGURG	24<span class="o">)</span> SIGXCPU	25<span class="o">)</span> SIGXFSZ
26<span class="o">)</span> SIGVTALRM	27<span class="o">)</span> SIGPROF	28<span class="o">)</span> SIGWINCH	29<span class="o">)</span> SIGIO	30<span class="o">)</span> SIGPWR
31<span class="o">)</span> SIGSYS	34<span class="o">)</span> SIGRTMIN	35<span class="o">)</span> SIGRTMIN+1	36<span class="o">)</span> SIGRTMIN+2	37<span class="o">)</span> SIGRTMIN+3
38<span class="o">)</span> SIGRTMIN+4	39<span class="o">)</span> SIGRTMIN+5	40<span class="o">)</span> SIGRTMIN+6	41<span class="o">)</span> SIGRTMIN+7	42<span class="o">)</span> SIGRTMIN+8
43<span class="o">)</span> SIGRTMIN+9	44<span class="o">)</span> SIGRTMIN+10	45<span class="o">)</span> SIGRTMIN+11	46<span class="o">)</span> SIGRTMIN+12	47<span class="o">)</span> SIGRTMIN+13
48<span class="o">)</span> SIGRTMIN+14	49<span class="o">)</span> SIGRTMIN+15	50<span class="o">)</span> SIGRTMAX-14	51<span class="o">)</span> SIGRTMAX-13	52<span class="o">)</span> SIGRTMAX-12
53<span class="o">)</span> SIGRTMAX-11	54<span class="o">)</span> SIGRTMAX-10	55<span class="o">)</span> SIGRTMAX-9	56<span class="o">)</span> SIGRTMAX-8	57<span class="o">)</span> SIGRTMAX-7
58<span class="o">)</span> SIGRTMAX-6	59<span class="o">)</span> SIGRTMAX-5	60<span class="o">)</span> SIGRTMAX-4	61<span class="o">)</span> SIGRTMAX-3	62<span class="o">)</span> SIGRTMAX-2
63<span class="o">)</span> SIGRTMAX-1	64<span class="o">)</span> SIGRTMAX
</code></pre></div></div>

<!-- cSpell:enable -->

<p>Here are some important ones.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SIGHUP</code></li>
</ol>

<ul>
  <li>Default action: Terminate</li>
  <li>Possible actions: Terminate, Ignore, Function call</li>
  <li><code class="language-plaintext highlighter-rouge">SIGHUP</code> is sent by the UART driver to the entire session when a hangup condition has been
detected. Normally, this will kill all the processes. Some programs, such as <code class="language-plaintext highlighter-rouge">nohup</code> and <code class="language-plaintext highlighter-rouge">screen</code>,
detach from their session (and TTY), so that their child processes won‚Äôt notice a hangup.</li>
</ul>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SIGINT</code></li>
</ol>

<ul>
  <li>Default action: Terminate</li>
  <li>Possible actions: Terminate, Ignore, Function call</li>
  <li><code class="language-plaintext highlighter-rouge">SIGINT</code> is sent by the TTY driver to the current foreground job when the interactive attention
character (typically <kbd>^C</kbd>, which has ASCII code 3) appears in the input stream, unless
this behavior has been turned off. Anybody with access permissions to the TTY device can change
the interactive attention character and toggle this feature; additionally, the session manager
keeps track of the TTY configuration of each job, and updates the TTY whenever there is a job
switch.</li>
</ul>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SIGQUIT</code></li>
</ol>

<ul>
  <li>Default action: Core dump</li>
  <li>Possible actions: Core dump, Ignore, Function call</li>
  <li><code class="language-plaintext highlighter-rouge">SIGQUIT</code> works just like SIGINT, but the quit character is typically <kbd>^\\</kbd> and the
default action is different.</li>
</ul>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SIGPIPE</code></li>
</ol>

<ul>
  <li>Default action: Terminate</li>
  <li>Possible actions: Terminate, Ignore, Function call</li>
  <li>The kernel sends <code class="language-plaintext highlighter-rouge">SIGPIPE</code> to any process which tries to write to a pipe with no readers. This is
useful, because otherwise jobs like <code class="language-plaintext highlighter-rouge">yes | head</code> would never terminate.</li>
</ul>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SIGCHLD</code></li>
</ol>

<ul>
  <li>Default action: Ignore</li>
  <li>Possible actions: Ignore, Function call</li>
  <li>When a process dies or changes state (stop/continue), the kernel sends a <code class="language-plaintext highlighter-rouge">SIGCHLD</code> to its parent
process. The <code class="language-plaintext highlighter-rouge">SIGCHLD</code> signal carries additional information, namely the process id, the user id,
the exit status (or termination signal) of the terminated process and some execution time
statistics. The session leader (shell) keeps track of its jobs using this signal.</li>
</ul>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SIGSTOP</code></li>
</ol>

<ul>
  <li>Default action: Suspend</li>
  <li>Possible actions: Suspend</li>
  <li>This signal will unconditionally suspend the recipient, i.e. its signal action can‚Äôt be
reconfigured. Please note, however, that <code class="language-plaintext highlighter-rouge">SIGSTOP</code> isn‚Äôt sent by the kernel during job control.
Instead, <kbd>^Z</kbd> typically triggers a <code class="language-plaintext highlighter-rouge">SIGTSTP</code>, which can be intercepted by the
application. The application may then e.g. move the cursor to the bottom of the screen or
otherwise put the terminal in a known state, and subsequently put itself to sleep using <code class="language-plaintext highlighter-rouge">SIGSTOP</code>.</li>
</ul>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SIGCONT</code></li>
</ol>

<ul>
  <li>Default action: Wake up</li>
  <li>Possible actions: Wake up, Wake up + Function call</li>
  <li><code class="language-plaintext highlighter-rouge">SIGCONT</code> will un-suspend a stopped process. It is sent explicitly by the shell when the user
invokes the <code class="language-plaintext highlighter-rouge">fg</code> command. Since <code class="language-plaintext highlighter-rouge">SIGSTOP</code> can‚Äôt be intercepted by an application, an unexpected
<code class="language-plaintext highlighter-rouge">SIGCONT</code> signal might indicate that the process was suspended some time ago, and then
un-suspended.</li>
</ul>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SIGTSTP</code></li>
</ol>

<ul>
  <li>Default action: Suspend</li>
  <li>Possible actions: Suspend, Ignore, Function call</li>
  <li><code class="language-plaintext highlighter-rouge">SIGTSTP</code> works just like <code class="language-plaintext highlighter-rouge">SIGINT</code> and <code class="language-plaintext highlighter-rouge">SIGQUIT</code>, but the magic character is typically
<kbd>^Z</kbd> and the default action is to suspend the process.</li>
</ul>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SIGTTIN</code></li>
</ol>

<ul>
  <li>Default action: Suspend</li>
  <li>Possible actions: Suspend, Ignore, Function call</li>
  <li>If a process within a background job tries to read from a TTY device, the TTY sends a <code class="language-plaintext highlighter-rouge">SIGTTIN</code>
signal to the entire job. This will normally suspend the job.</li>
</ul>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SIGTTOU</code></li>
</ol>

<ul>
  <li>Default action: Suspend</li>
  <li>Possible actions: Suspend, Ignore, Function call</li>
  <li>If a process within a background job tries to write to a TTY device, the TTY sends a <code class="language-plaintext highlighter-rouge">SIGTTOU</code>
signal to the entire job. This will normally suspend the job. It is possible to turn off this
feature on a per-TTY basis.</li>
</ul>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SIGWINCH</code></li>
</ol>

<ul>
  <li>Default action: Ignore</li>
  <li>Possible actions: Ignore, Function call</li>
  <li>As mentioned, the TTY device keeps track of the terminal size, but this information needs to be
updated manually. Whenever that happens, the TTY device sends <code class="language-plaintext highlighter-rouge">SIGWINCH</code> to the foreground job.
Well-behaving interactive applications, such as editors, react upon this, fetch the new terminal
size from the TTY device and redraw themselves accordingly.</li>
</ul>

<h2 id="-sending-and-receiving-signals-in-rust">ü¶Ä Sending and receiving signals in Rust</h2>
<p><a id="markdown-%F0%9F%A6%80-sending-and-receiving-signals-in-rust" name="%F0%9F%A6%80-sending-and-receiving-signals-in-rust"></a></p>

<table>
  <thead>
    <tr>
      <th>crate</th>
      <th>recv</th>
      <th>send</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="https://docs.rs/tokio/latest/tokio/signal">https://docs.rs/tokio/latest/tokio/signal</a></td>
      <td>üü¢</td>
      <td>üî¥</td>
    </tr>
    <tr>
      <td><a href="https://crates.io/crates/ctrlc">https://crates.io/crates/ctrlc</a></td>
      <td>üü¢</td>
      <td>üî¥</td>
    </tr>
    <tr>
      <td><a href="https://crates.io/crates/signal-hook">https://crates.io/crates/signal-hook</a></td>
      <td>üü¢</td>
      <td>üü¢ *</td>
    </tr>
    <tr>
      <td><a href="https://docs.rs/nix/latest/nix/">https://docs.rs/nix/latest/nix/</a></td>
      <td>üü¢</td>
      <td>üü¢</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>*: Via
<a href="https://docs.rs/signal-hook/latest/signal_hook/low_level/fn.raise.html"><code class="language-plaintext highlighter-rouge">signal_hook::low_level::raise</code></a>.</p>
</blockquote>

<h4 id="example-using-tokio-to-receive-signals">Example using tokio to receive signals</h4>
<p><a id="markdown-example-using-tokio-to-receive-signals" name="example-using-tokio-to-receive-signals"></a></p>

<p>Please watch the live coding <a href="#related-youtube-videos-for-this-article">videos</a> to get a
deep dive into what each line of code does.</p>

<p>Please clone this <a href="https://github.com/nazmulidris/rust-scratch">repo</a> to your computer to
play w/ the examples in the <a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/README.md"><code class="language-plaintext highlighter-rouge">rust-scratch/tty</code>
crate</a> shown below.</p>

<p><a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/src/receive_signal.rs"><code class="language-plaintext highlighter-rouge">receive_signal.rs</code></a>.
<code class="language-plaintext highlighter-rouge">tokio</code> has limited handling of signals. You can only receive certain signals, not send
them.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">miette</span><span class="p">::</span><span class="n">IntoDiagnostic</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">r3bl_rs_utils_core</span><span class="p">::</span><span class="n">ok</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">signal</span><span class="p">::</span><span class="n">unix</span><span class="p">;</span>

<span class="nd">#[tokio::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">signal</span> <span class="o">=</span> <span class="nn">unix</span><span class="p">::</span><span class="nn">SignalKind</span><span class="p">::</span><span class="nf">window_change</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">stream</span> <span class="o">=</span> <span class="nn">unix</span><span class="p">::</span><span class="nf">signal</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">tick_interval</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">interval</span><span class="p">(</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">500</span><span class="p">));</span>

    <span class="k">let</span> <span class="n">sleep_future</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nd">pin!</span><span class="p">(</span><span class="n">sleep_future</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">pid</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nf">id</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"PID: {}"</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>

    <span class="c1">// Copy child PID to clipboard.</span>
    <span class="c1">// Use `ClipboardProvider` trait.</span>
    <span class="k">use</span> <span class="nn">cli_clipboard</span><span class="p">::</span><span class="n">ClipboardProvider</span> <span class="k">as</span> <span class="n">_</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">ctx</span> <span class="o">=</span> <span class="nn">cli_clipboard</span><span class="p">::</span><span class="nn">ClipboardContext</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span>
        <span class="nf">.map_err</span><span class="p">(|</span><span class="n">e</span><span class="p">|</span> <span class="nn">miette</span><span class="p">::</span><span class="nd">miette!</span><span class="p">(</span>
            <span class="s">"couldn't create clip context: {}"</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
    <span class="n">ctx</span><span class="nf">.set_contents</span><span class="p">(</span><span class="n">pid</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.to_owned</span><span class="p">())</span>
        <span class="nf">.map_err</span><span class="p">(|</span><span class="n">e</span><span class="p">|</span> <span class="nn">miette</span><span class="p">::</span><span class="nd">miette!</span><span class="p">(</span>
            <span class="s">"couldn't set clip contents: {}"</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
    <span class="n">ctx</span><span class="nf">.get_contents</span><span class="p">()</span>
        <span class="nf">.map_err</span><span class="p">(|</span><span class="n">e</span><span class="p">|</span> <span class="nn">miette</span><span class="p">::</span><span class="nd">miette!</span><span class="p">(</span>
            <span class="s">"couldn't get clip contents: {}"</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span> <span class="p">{</span>
            <span class="c1">// Respond to window change signal.</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">stream</span><span class="nf">.recv</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">SIGWINCH received"</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// Sleep for 5 seconds &amp; terminate the program if running.</span>
            <span class="n">_</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">sleep_future</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Slept for 5 seconds"</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// Run at each tick interval.</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">tick_interval</span><span class="nf">.tick</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"Tick"</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="c1">// Respond to ctrl-c signal.</span>
            <span class="n">_</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">signal</span><span class="p">::</span><span class="nf">ctrl_c</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Ctrl-C received"</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">ok!</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here are some notes on the code:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">tokio::signal::ctrl_c</code> is a utility function that creates a future that completes
when <code class="language-plaintext highlighter-rouge">ctrl-c</code> is pressed. There is <strong>NO</strong> need to write a signal stream for this like
so:
    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">signal</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">signal</span><span class="p">::</span><span class="nn">unix</span><span class="p">::</span><span class="nn">SignalKind</span><span class="p">::</span><span class="nf">interrupt</span><span class="p">();</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">stream_sigterm</span> <span class="o">=</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nn">signal</span><span class="p">::</span><span class="nn">unix</span><span class="p">::</span><span class="nf">signal</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
<span class="k">loop</span> <span class="p">{</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span> <span class="p">{</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">stream_sigterm</span><span class="nf">.recv</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">SIGINT received"</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li><code class="language-plaintext highlighter-rouge">tokio::signal::unix::signal</code> is a lower level function that you can use to create a
stream of signals of a given type (e.g., <code class="language-plaintext highlighter-rouge">tokio::signal::unix::SignalKind</code>). Some
examples are:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">tokio::signal::unix::SignalKind::hangup</code></li>
      <li><code class="language-plaintext highlighter-rouge">tokio::signal::unix::SignalKind::interrupt</code></li>
      <li><code class="language-plaintext highlighter-rouge">tokio::signal::unix::SignalKind::pipe</code></li>
    </ul>
  </li>
  <li>There are limitations to what <code class="language-plaintext highlighter-rouge">tokio::signal::unix::SignalKind::from_raw</code> can do:
    <ul>
      <li>For example you can‚Äôt just pass in <code class="language-plaintext highlighter-rouge">SIGSTOP</code> ie <code class="language-plaintext highlighter-rouge">19</code> and expect it to work. This
is an <a href="https://docs.rs/signal-hook/latest/signal_hook/#limitations">OS
limitation</a> for both
<code class="language-plaintext highlighter-rouge">SIGKILL</code> or <code class="language-plaintext highlighter-rouge">SIGSTOP</code>.</li>
      <li>Here‚Äôs a list of POSIX signals that are
<a href="https://docs.rs/signal-hook/latest/signal_hook/low_level/fn.register.html#panics"><code class="language-plaintext highlighter-rouge">FORBIDDEN</code></a>
from the <code class="language-plaintext highlighter-rouge">signal_hook</code> crate.</li>
      <li>You can just pass the signal number directly to
<code class="language-plaintext highlighter-rouge">tokio::signal::unix::SignalKind::from_raw</code>.</li>
      <li>However, if you‚Äôre doing more sophisticated things you might need to use the
<a href="https://github.com/vorner/signal-hook">signal-hook</a> crate (which not only
supports sending and receiving signals, but also has async adapters for <code class="language-plaintext highlighter-rouge">tokio</code>).</li>
      <li>Here are relevant docs:
        <ul>
          <li><a href="https://docs.rs/tokio/latest/tokio/signal/index.html">tokio::signal</a></li>
          <li><a href="https://docs.rs/tokio/latest/tokio/signal/unix/fn.signal.html">tokio::signal::unix::signal</a></li>
          <li><a href="https://docs.rs/tokio/latest/tokio/signal/unix/struct.SignalKind.html">tokio::signal::unix::SignalKind</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>See it in action:</p>

<ul>
  <li>Run the binary: <code class="language-plaintext highlighter-rouge">cargo run --bin send_receive_signal</code></li>
  <li>Send signals to the process:
    <ul>
      <li>To get a list of all the signals that you can send to a process, you can run the
following command: <code class="language-plaintext highlighter-rouge">kill -L</code></li>
      <li>To send Ctrl+C, aka, <code class="language-plaintext highlighter-rouge">SIGINT</code>, aka <code class="language-plaintext highlighter-rouge">tokio::signal::unix::SignalKind::interrupt</code>, to
the process, you can run the following command: <code class="language-plaintext highlighter-rouge">kill -2 &lt;PID&gt;</code> or <code class="language-plaintext highlighter-rouge">kill -INT &lt;PID&gt;</code></li>
      <li>To send <code class="language-plaintext highlighter-rouge">SIGWINCH</code>, aka <code class="language-plaintext highlighter-rouge">tokio::signal::unix::SignalKind::window_change</code> to the
process, simply change the terminal window size of the terminal that the process is
running in. Or run the following command: <code class="language-plaintext highlighter-rouge">kill -28 &lt;PID&gt;</code> or <code class="language-plaintext highlighter-rouge">kill -WINCH &lt;PID&gt;</code></li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>Other crate choices to receive signals:</p>

  <ul>
    <li><a href="https://crates.io/crates/ctrlc"><code class="language-plaintext highlighter-rouge">ctrlc</code></a></li>
    <li><a href="https://crates.io/crates/signal-hook"><code class="language-plaintext highlighter-rouge">signal-hook</code></a></li>
  </ul>
</blockquote>

<h4 id="example-using-signal-hook-and-signal-hook-tokio">Example using signal-hook and signal-hook-tokio</h4>
<p><a id="markdown-example-using-signal-hook-and-signal-hook-tokio" name="example-using-signal-hook-and-signal-hook-tokio"></a></p>

<p>Please watch the live coding <a href="#related-youtube-videos-for-this-article">videos</a> to get a
deep dive into what each line of code does.</p>

<p>Please clone this <a href="https://github.com/nazmulidris/rust-scratch">repo</a> to your computer to
play w/ the examples in the <a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/README.md"><code class="language-plaintext highlighter-rouge">rust-scratch/tty</code>
crate</a> shown below.</p>

<p><a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/src/send_and_receive_signal.rs"><code class="language-plaintext highlighter-rouge">send_and_receive_signal.rs</code></a>
allows you to both send and receive signals in a process.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">futures</span><span class="p">::</span><span class="nn">stream</span><span class="p">::</span><span class="n">StreamExt</span> <span class="k">as</span> <span class="n">_</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">miette</span><span class="p">::</span><span class="n">IntoDiagnostic</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">r3bl_rs_utils_core</span><span class="p">::</span><span class="n">ok</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">signal_hook</span><span class="p">::</span><span class="nn">consts</span><span class="p">::</span><span class="nn">signal</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">signal_hook_tokio</span><span class="p">::</span><span class="n">Signals</span><span class="p">;</span>

<span class="nd">#[tokio::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">pid</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nf">id</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"PID: {}"</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>

    <span class="c1">// Broadcast channel to shutdown the process.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">sender_shutdown_channel</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">broadcast</span><span class="p">::</span><span class="nn">channel</span><span class="p">::</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="c1">// Register signal handlers.</span>
    <span class="k">let</span> <span class="n">signals_stream</span><span class="p">:</span> <span class="n">Signals</span> <span class="o">=</span>
        <span class="nn">Signals</span><span class="p">::</span><span class="nf">new</span><span class="p">([</span><span class="n">SIGHUP</span><span class="p">,</span> <span class="n">SIGTERM</span><span class="p">,</span> <span class="n">SIGINT</span><span class="p">,</span> <span class="n">SIGQUIT</span><span class="p">])</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">signals_handle</span> <span class="o">=</span> <span class="n">signals_stream</span><span class="nf">.handle</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">join_handle_monitor_signals_task</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span>
        <span class="nf">handle_signals_task</span><span class="p">(</span>
            <span class="n">signals_stream</span><span class="p">,</span>
            <span class="n">sender_shutdown_channel</span><span class="nf">.clone</span><span class="p">(),</span>
        <span class="p">));</span>

    <span class="nf">run_main_event_loop</span><span class="p">(</span><span class="n">sender_shutdown_channel</span><span class="nf">.clone</span><span class="p">())</span><span class="k">.await</span><span class="p">;</span>

    <span class="c1">// Cleanup tasks after shutdown.</span>
    <span class="n">signals_handle</span><span class="nf">.close</span><span class="p">();</span>
    <span class="n">join_handle_monitor_signals_task</span><span class="k">.await</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="nd">ok!</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">async</span> <span class="k">fn</span> <span class="nf">run_main_event_loop</span><span class="p">(</span>
    <span class="n">sender_shutdown_channel</span><span class="p">:</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">broadcast</span><span class="p">::</span><span class="n">Sender</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span>
    <span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">receiver_shutdown_channel</span> <span class="o">=</span>
        <span class="n">sender_shutdown_channel</span><span class="nf">.subscribe</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">tick_interval</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">interval</span><span class="p">(</span>
        <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">500</span><span class="p">));</span>

    <span class="c1">// Wait for 1 sec &amp; then send SIGTERM signal.</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span>
            <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="k">.await</span><span class="p">;</span>
        <span class="n">_</span> <span class="o">=</span> <span class="nn">signal_hook</span><span class="p">::</span><span class="nn">low_level</span><span class="p">::</span><span class="nf">raise</span><span class="p">(</span><span class="n">SIGTERM</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"üß® Sent SIGTERM signal"</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span> <span class="p">{</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">tick_interval</span><span class="nf">.tick</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"Tick"</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">receiver_shutdown_channel</span><span class="nf">.recv</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"Received shutdown signal"</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">async</span> <span class="k">fn</span> <span class="nf">handle_signals_task</span><span class="p">(</span>
    <span class="k">mut</span> <span class="n">signals_stream</span><span class="p">:</span> <span class="n">Signals</span><span class="p">,</span>
    <span class="n">sender_shutdown_channel</span><span class="p">:</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">broadcast</span><span class="p">::</span><span class="n">Sender</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span> <span class="o">=</span> <span class="n">signals_stream</span><span class="nf">.next</span><span class="p">()</span><span class="k">.await</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">signal</span> <span class="p">{</span>
            <span class="n">SIGHUP</span> <span class="p">|</span> <span class="n">SIGTERM</span> <span class="p">|</span> <span class="n">SIGINT</span> <span class="p">|</span> <span class="n">SIGQUIT</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"üì• Received signal: {:?}"</span><span class="p">,</span> <span class="n">signal</span><span class="p">);</span>
                <span class="n">_</span> <span class="o">=</span> <span class="n">sender_shutdown_channel</span><span class="nf">.send</span><span class="p">(());</span>
            <span class="p">}</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">unreachable!</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notes on the code:</p>

<ul>
  <li>Example of how to send and receive Linux (POSIX, Unix) signals in a process
It uses the following crates to make this happen:
    <ul>
      <li><a href="https://docs.rs/signal-hook/">signal-hook</a></li>
      <li><a href="https://docs.rs/signal-hook-tokio/latest/signal_hook_tokio/">signal-hook-tokio</a></li>
    </ul>
  </li>
  <li>Signal handler registration limitations (to receive signals)
POSIX allows signal handlers to be overridden in a process. This is a powerful feature
that can be used to implement a wide variety of functionality.
    <ul>
      <li>However, there are
<a href="https://docs.rs/signal-hook/latest/signal_hook/#limitations">limitations</a> around
overriding signal handlers in a process. For example, POSIX compliant operating
systems will not allow you to override the
<a href="https://docs.rs/signal-hook/latest/signal_hook/consts/signal/constant.SIGKILL.html"><code class="language-plaintext highlighter-rouge">SIGKILL</code></a>
or
<a href="https://docs.rs/signal-hook/latest/signal_hook/consts/signal/constant.SIGSTOP.html"><code class="language-plaintext highlighter-rouge">SIGSTOP</code></a>
signals.</li>
      <li>Here‚Äôs a full list of
<a href="https://docs.rs/signal-hook/latest/signal_hook/low_level/fn.register.html#panics"><code class="language-plaintext highlighter-rouge">FORBIDDEN</code></a>
signals that will <code class="language-plaintext highlighter-rouge">panic</code> the <code class="language-plaintext highlighter-rouge">register</code> function, if used.</li>
    </ul>
  </li>
  <li>The following dependencies need to be added to the <code class="language-plaintext highlighter-rouge">Cargo.toml</code> file for this to work:
    <div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="py">signal-hook</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.3.17"</span> <span class="p">}</span>
<span class="py">signal-hook-tokio</span> <span class="o">=</span> <span class="p">{</span>
    <span class="py">version</span> <span class="p">=</span> <span class="s">"0.3.1"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"futures-v0_3"</span><span class="p">]</span> <span class="p">}</span>
<span class="py">futures</span> <span class="p">=</span> <span class="s">"0.3.30"</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>See it in action:</p>

<ul>
  <li>Run the binary: <code class="language-plaintext highlighter-rouge">cargo run --bin send_and_receive_signal</code></li>
</ul>

<h2 id="-process-spawning-in-rust">ü¶Ä Process spawning in Rust</h2>
<p><a id="markdown-%F0%9F%A6%80-process-spawning-in-rust" name="%F0%9F%A6%80-process-spawning-in-rust"></a></p>

<p>Please watch the live coding <a href="#related-youtube-videos-for-this-article">videos</a> to get a
deep dive into what each line of code does.</p>

<p>Please clone this <a href="https://github.com/nazmulidris/rust-scratch">repo</a> to your computer to
play w/ the examples in the <a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/README.md"><code class="language-plaintext highlighter-rouge">rust-scratch/tty</code>
crate</a> shown below.</p>

<h4 id="example-using-procspawn-to-spawn-processes">Example using procspawn to spawn processes</h4>
<p><a id="markdown-example-using-procspawn-to-spawn-processes" name="example-using-procspawn-to-spawn-processes"></a></p>

<p><a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/src/procspawn.rs"><code class="language-plaintext highlighter-rouge">procspawn.rs</code></a>
can be used to spawn child processes in Rust with great flexibility and control.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">miette</span><span class="p">::</span><span class="n">IntoDiagnostic</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">r3bl_rs_utils_core</span><span class="p">::</span><span class="n">ok</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// A spawned process will execute every line of code up to here.</span>
    <span class="nn">procspawn</span><span class="p">::</span><span class="nf">init</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">pid_parent</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nf">id</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">args</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i64</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">sum</span><span class="p">,</span> <span class="n">pid_child</span><span class="p">,</span> <span class="n">pid_child_from_clip</span><span class="p">)</span> <span class="o">=</span> <span class="nf">configure_builder</span><span class="p">()</span>
        <span class="nf">.spawn</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">run_in_child_process</span><span class="p">)</span>
        <span class="nf">.join</span><span class="p">()</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"Parent PID: {}"</span><span class="p">,</span> <span class="n">pid_parent</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"Child PID: {}, sum: {}, pid from clip: {}"</span><span class="p">,</span>
        <span class="n">pid_child</span><span class="p">,</span> <span class="n">sum</span><span class="p">,</span> <span class="n">pid_child_from_clip</span>
    <span class="p">);</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">sum</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">pid_child</span><span class="p">,</span> <span class="n">pid_child_from_clip</span><span class="p">);</span>

    <span class="nd">ok!</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// Create a new builder with stderr &amp; stdout that's null.</span>
<span class="k">fn</span> <span class="nf">configure_builder</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">procspawn</span><span class="p">::</span><span class="n">Builder</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">it</span> <span class="o">=</span> <span class="nn">procspawn</span><span class="p">::</span><span class="nn">Builder</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="n">it</span><span class="nf">.stderr</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">null</span><span class="p">());</span> <span class="c1">// Suppress stderr.</span>
    <span class="n">it</span><span class="nf">.stdout</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">null</span><span class="p">());</span> <span class="c1">// Suppress stdout.</span>
    <span class="n">it</span>
<span class="p">}</span>

<span class="c1">// This function will be executed in a child process.</span>
<span class="k">fn</span> <span class="nf">run_in_child_process</span><span class="p">(</span>
    <span class="cm">/* serde */</span> <span class="n">param</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i64</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">result</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span>
    <span class="cm">/* serde - Ok variant */</span>
    <span class="p">(</span>
        <span class="cm">/* sum */</span> <span class="nb">i64</span><span class="p">,</span>
        <span class="cm">/* pid */</span> <span class="nb">String</span><span class="p">,</span>
        <span class="cm">/* pid from clip */</span> <span class="nb">String</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="cm">/* serde - Err variant */</span>
    <span class="n">ClipboardError</span><span class="p">,</span>
<span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">pid_child</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nf">id</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">param</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.sum</span><span class="p">();</span>

    <span class="c1">// Copy child pid to the clipboard.</span>
    <span class="c1">// Import `ClipboardProvider` trait.</span>
    <span class="k">use</span> <span class="nn">cli_clipboard</span><span class="p">::</span><span class="n">ClipboardProvider</span> <span class="k">as</span> <span class="n">_</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">ctx</span> <span class="o">=</span> <span class="nn">cli_clipboard</span><span class="p">::</span><span class="nn">ClipboardContext</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span>
        <span class="nf">.map_err</span><span class="p">(|</span><span class="n">_</span><span class="p">|</span> <span class="nn">ClipboardError</span><span class="p">::</span><span class="n">ContextUnavailable</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="n">ctx</span><span class="nf">.set_contents</span><span class="p">(</span><span class="n">pid_child</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.to_owned</span><span class="p">())</span>
        <span class="nf">.map_err</span><span class="p">(|</span><span class="n">_</span><span class="p">|</span> <span class="nn">ClipboardError</span><span class="p">::</span><span class="n">SetContents</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">pid_child_from_clip</span> <span class="o">=</span> <span class="n">ctx</span>
        <span class="nf">.get_contents</span><span class="p">()</span>
        <span class="nf">.map_err</span><span class="p">(|</span><span class="n">_</span><span class="p">|</span> <span class="nn">ClipboardError</span><span class="p">::</span><span class="n">GetContents</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">((</span><span class="n">sum</span><span class="p">,</span> <span class="n">pid_child</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="n">pid_child_from_clip</span><span class="p">))</span>
<span class="p">}</span>

<span class="nd">#[derive(</span>
    <span class="nd">Debug,</span> <span class="nd">serde::Deserialize,</span> <span class="nd">serde::Serialize,</span> <span class="nd">thiserror::Error</span>
<span class="nd">)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">ClipboardError</span> <span class="p">{</span>
    <span class="nd">#[error(</span><span class="s">"clipboard context unavailable"</span><span class="nd">)]</span>
    <span class="n">ContextUnavailable</span><span class="p">,</span>

    <span class="nd">#[error(</span><span class="s">"could not get clipboard contents"</span><span class="nd">)]</span>
    <span class="n">GetContents</span><span class="p">,</span>

    <span class="nd">#[error(</span><span class="s">"could not set clipboard contents"</span><span class="nd">)]</span>
    <span class="n">SetContents</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notes on the code:</p>

<ul>
  <li>The <a href="https://docs.rs/procspawn/latest/procspawn/"><code class="language-plaintext highlighter-rouge">procspawn</code></a> crate provides the
ability to spawn processes with a function similar to <code class="language-plaintext highlighter-rouge">thread::spawn</code>.</li>
  <li>Unlike <code class="language-plaintext highlighter-rouge">thread::spawn</code> data cannot be passed by the use of closures.</li>
  <li>Instead if must be explicitly passed as serializable object (specifically it must be
<code class="language-plaintext highlighter-rouge">serde</code> serializable). Internally, the data is serialized using
<a href="https://docs.rs/procspawn/latest/procspawn/#bincode-limitations"><code class="language-plaintext highlighter-rouge">bincode</code></a>.</li>
  <li>The return value from the spawned closure also must be serializable and can then be
retrieved from the returned join handle.</li>
  <li>If the spawned function causes a panic it will also be serialized across the process
boundaries.</li>
  <li>Great <a href="https://github.com/mitsuhiko/procspawn/tree/master/examples">examples</a> from the
official docs.</li>
</ul>

<p>See it in action:</p>

<ul>
  <li>Run the binary: <code class="language-plaintext highlighter-rouge">cargo run --bin procspawn</code></li>
</ul>

<h4 id="example-using-procspawn-to-spawn-processes-w-ipc-channel">Example using procspawn to spawn processes w/ ipc-channel</h4>
<p><a id="markdown-example-using-procspawn-to-spawn-processes-w%2F-ipc-channel" name="example-using-procspawn-to-spawn-processes-w%2F-ipc-channel"></a></p>

<p><a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/src/procspawn_ipc_channel.rs"><code class="language-plaintext highlighter-rouge">procspawn_ipc_channel.rs</code></a>
can be used to manage complex IPC communication between parent and child processes.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">miette</span><span class="p">::</span><span class="n">IntoDiagnostic</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">r3bl_rs_utils_core</span><span class="p">::</span><span class="n">ok</span><span class="p">;</span>

<span class="k">type</span> <span class="n">Message</span> <span class="o">=</span> <span class="nb">String</span><span class="p">;</span>

<span class="k">const</span> <span class="n">MSG_1</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="p">;</span>
<span class="k">const</span> <span class="n">MSG_2</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">"World"</span><span class="p">;</span>
<span class="k">const</span> <span class="n">END_MSG</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">"END"</span><span class="p">;</span>
<span class="k">const</span> <span class="n">SHUTDOWN_MSG</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">"SHUTDOWN"</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// A spawned process will execute every line of code up to here.</span>
    <span class="nn">procspawn</span><span class="p">::</span><span class="nf">init</span><span class="p">();</span>

    <span class="c1">// Create a channel to send messages across processes.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">receiver</span><span class="p">)</span> <span class="o">=</span> <span class="nn">ipc_channel</span><span class="p">::</span><span class="nn">ipc</span><span class="p">::</span><span class="nn">channel</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span><span class="p">()</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Spawn a child process that will receive messages from the</span>
    <span class="c1">// parent process.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">join_handle</span> <span class="o">=</span> <span class="nf">configure_builder</span><span class="p">()</span><span class="nf">.spawn</span><span class="p">(</span>
        <span class="cm">/* arg from parent process */</span> <span class="n">receiver</span><span class="p">,</span>
        <span class="cm">/* param to child process; closure runs in child process */</span>
        <span class="n">run_in_child_process</span><span class="p">,</span>
    <span class="p">);</span>

    <span class="nf">parent_send_messages</span><span class="p">(</span><span class="n">sender</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Read the stdout, until EOF, of the child process into `buf`.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">buf</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="c1">// Import `Read` trait for `read_to_string`.</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="n">Read</span> <span class="k">as</span> <span class="n">_</span><span class="p">;</span>
    <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">stdout</span><span class="p">)</span> <span class="o">=</span> <span class="n">join_handle</span><span class="nf">.stdout</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nn">miette</span><span class="p">::</span><span class="nd">bail!</span><span class="p">(</span><span class="s">"Failed to get stdout"</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="k">let</span> <span class="n">bytes_read</span> <span class="o">=</span> <span class="n">stdout</span><span class="nf">.read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">buf</span><span class="p">)</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"Output from child process: {:?}, bytes_read: {}"</span><span class="p">,</span>
        <span class="n">buf</span><span class="p">,</span> <span class="n">bytes_read</span>
    <span class="p">);</span>

    <span class="c1">// Make assertions.</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{MSG_1}</span><span class="se">\n</span><span class="s">{MSG_2}</span><span class="se">\n</span><span class="s">{END_MSG}</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>

    <span class="c1">// Wait for the child process to exit and get its return value.</span>
    <span class="n">join_handle</span><span class="nf">.join</span><span class="p">()</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="nd">ok!</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">parent_send_messages</span><span class="p">(</span>
    <span class="n">sender</span><span class="p">:</span> <span class="nn">ipc_channel</span><span class="p">::</span><span class="nn">ipc</span><span class="p">::</span><span class="n">IpcSender</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="n">sender</span><span class="nf">.send</span><span class="p">(</span><span class="n">MSG_1</span><span class="nf">.to_string</span><span class="p">())</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="n">sender</span><span class="nf">.send</span><span class="p">(</span><span class="n">MSG_2</span><span class="nf">.to_string</span><span class="p">())</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="n">sender</span><span class="nf">.send</span><span class="p">(</span><span class="n">SHUTDOWN_MSG</span><span class="nf">.to_string</span><span class="p">())</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="nd">ok!</span><span class="p">()</span>
<span class="p">}</span>

<span class="cd">/// This function will be executed in the child process. It gets</span>
<span class="cd">/// [Message]s from the parent process and processes them.</span>
<span class="k">fn</span> <span class="nf">run_in_child_process</span><span class="p">(</span>
    <span class="n">receiver</span><span class="p">:</span> <span class="nn">ipc_channel</span><span class="p">::</span><span class="nn">ipc</span><span class="p">::</span><span class="n">IpcReceiver</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="k">let</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">=</span> <span class="n">receiver</span><span class="nf">.recv</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">msg</span> <span class="o">==</span> <span class="n">SHUTDOWN_MSG</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// Print the message to stdout.</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Print `END_MSG` to stdout.</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{END_MSG}"</span><span class="p">);</span>
<span class="p">}</span>

<span class="cd">/// Create a new builder with stdout piped and stderr muted.</span>
<span class="k">fn</span> <span class="nf">configure_builder</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">procspawn</span><span class="p">::</span><span class="n">Builder</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">it</span> <span class="o">=</span> <span class="nn">procspawn</span><span class="p">::</span><span class="nn">Builder</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="n">it</span><span class="nf">.stdout</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">piped</span><span class="p">());</span>
    <span class="n">it</span><span class="nf">.stderr</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">null</span><span class="p">());</span>
    <span class="n">it</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notes on the code:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ipc_channel::ipc::channel</code> is used to send messages across processes via IPC. These
messages must be serializable.</li>
  <li>The parent process sends messages to the child process. This happens over an
ipc_channel sender.</li>
  <li>The child process receives messages from the parent process. This happens over an
ipc_channel receiver. The receiver is passed across process boundaries from
the parent to the child process.</li>
</ul>

<p>See it in action:</p>

<ul>
  <li>Run the binary: <code class="language-plaintext highlighter-rouge">cargo run --bin procspawn_ipc_channel</code></li>
</ul>

<blockquote>
  <p>Here‚Äôs the <a href="https://crates.io/crates/procspawn"><code class="language-plaintext highlighter-rouge">procspawn</code> crate</a> that we can use for this.</p>
</blockquote>

<h2 id="-run-tokioprocesscommand-in-async-rust">ü¶Ä Run tokio:process::Command in async Rust</h2>
<p><a id="markdown-%F0%9F%A6%80-run-tokio%3Aprocess%3A%3Acommand-in-async-rust" name="%F0%9F%A6%80-run-tokio%3Aprocess%3A%3Acommand-in-async-rust"></a></p>

<p>Please watch the live coding <a href="#related-youtube-videos-for-this-article">videos</a> to get a
deep dive into what each line of code does.</p>

<blockquote>
  <p>In <code class="language-plaintext highlighter-rouge">tokio</code> a good place to start is
<a href="https://docs.rs/tokio/latest/tokio/process/index.html"><code class="language-plaintext highlighter-rouge">tokio::process</code></a> which mimics
the <code class="language-plaintext highlighter-rouge">std::process</code> module.</p>
</blockquote>

<h3 id="example-running-echo-process-programmatically">Example running echo process programmatically</h3>
<p><a id="markdown-example-running-echo-process-programmatically" name="example-running-echo-process-programmatically"></a></p>

<p>Please clone this <a href="https://github.com/nazmulidris/rust-scratch">repo</a> to your computer to
play w/ the examples in the <a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/README.md"><code class="language-plaintext highlighter-rouge">rust-scratch/tty</code>
crate</a> shown below.</p>

<p><a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/src/async_command_exec_1.rs"><code class="language-plaintext highlighter-rouge">async_command_exec_1.rs</code></a></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">crossterm</span><span class="p">::</span><span class="nn">style</span><span class="p">::</span><span class="n">Stylize</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">miette</span><span class="p">::</span><span class="n">IntoDiagnostic</span><span class="p">;</span>

<span class="nd">#[tokio::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">run_command_no_capture</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">run_command_capture_output</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="c1">// - Run `echo hello world` and wait for it to complete.</span>
<span class="c1">// - Do not capture the output or provide the input.</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">run_command_no_capture</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"run_command_no_capture"</span><span class="nf">.blue</span><span class="p">());</span>

    <span class="c1">// Without redirection, the output of the command will be</span>
    <span class="c1">// inherited from the process that starts the command. So</span>
    <span class="c1">// if this is running in a terminal, the output will be</span>
    <span class="c1">// printed to the terminal.</span>
    <span class="c1">//</span>
    <span class="c1">// Even though `spawn()` is called this child / command</span>
    <span class="c1">// doesn't make any progress until you call `wait().await`.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">command</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">command</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Command</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"echo"</span><span class="p">);</span>
        <span class="n">command</span>
            <span class="nf">.args</span><span class="p">([</span><span class="s">"hello"</span><span class="p">,</span> <span class="s">"world"</span><span class="p">])</span>
            <span class="nf">.stdin</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">inherit</span><span class="p">())</span>
            <span class="nf">.stdout</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">inherit</span><span class="p">())</span>
            <span class="nf">.stderr</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">inherit</span><span class="p">());</span>
        <span class="n">command</span>
    <span class="p">};</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">child</span> <span class="o">=</span> <span class="n">command</span><span class="nf">.spawn</span><span class="p">()</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Wait for the command to complete. Don't capture the output,</span>
    <span class="c1">// it will go to `stdout` of the process running this program.</span>
    <span class="k">let</span> <span class="n">exit_status</span> <span class="o">=</span> <span class="n">child</span><span class="nf">.wait</span><span class="p">()</span><span class="k">.await</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="n">exit_status</span><span class="nf">.success</span><span class="p">());</span>

    <span class="c1">// Print the exit status of the command.</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"exit status: {}"</span><span class="p">,</span> <span class="n">exit_status</span><span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="c1">// - Run `echo hello world` and wait for it to complete.</span>
<span class="c1">// - Capture its output and do not provide the input.</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">run_command_capture_output</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"run_command_capture_output"</span><span class="nf">.blue</span><span class="p">());</span>

    <span class="c1">// Redirect the output of the command to a pipe `Stdio::piped()`.</span>
    <span class="c1">//</span>
    <span class="c1">// Even though `spawn()` is called this child / command doesn't</span>
    <span class="c1">// make any progress until you call `wait_with_out().await`.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">command</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">command</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Command</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"echo"</span><span class="p">);</span>
        <span class="n">command</span>
            <span class="nf">.args</span><span class="p">([</span><span class="s">"hello"</span><span class="p">,</span> <span class="s">"world"</span><span class="p">])</span>
            <span class="nf">.stdin</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">null</span><span class="p">())</span>
            <span class="nf">.stdout</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">piped</span><span class="p">())</span>
            <span class="nf">.stderr</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">null</span><span class="p">());</span>
        <span class="n">command</span>
    <span class="p">};</span>
    <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="n">command</span><span class="nf">.spawn</span><span class="p">()</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Wait for the command to complete and capture the output.</span>
    <span class="c1">// - Calling `wait()` consumes the child process, so we can't</span>
    <span class="c1">//   call `output.stdout` on it after this.</span>
    <span class="c1">// - That's why we use `wait_with_output()`, which actually</span>
    <span class="c1">//   returns a different type than `wait()`; this is also a</span>
    <span class="c1">//   great use of type state pattern.</span>
    <span class="k">let</span> <span class="n">output</span> <span class="o">=</span> <span class="n">child</span><span class="nf">.wait_with_output</span><span class="p">()</span><span class="k">.await</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="nd">assert!</span><span class="p">(</span><span class="n">output</span><span class="py">.status</span><span class="nf">.success</span><span class="p">());</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">output</span><span class="py">.stdout</span><span class="p">,</span> <span class="s">b"hello world</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notes on the code:</p>

<ul>
  <li>Run a command and wait for it to complete. Do not capture the output or provide the
input.</li>
  <li>Run a command and capture the output. Do not provide the input. This example uses the
<a href="https://docs.rs/tokio/latest/tokio/process/index.html"><code class="language-plaintext highlighter-rouge">tokio::process::Command</code></a>
struct to execute a command asynchronously.</li>
  <li>In both cases, the pattern is the same:
    <ol>
      <li>Create a <code class="language-plaintext highlighter-rouge">tokio::process::Command</code>.</li>
      <li>Configure it with the desired <code class="language-plaintext highlighter-rouge">stdin</code> and <code class="language-plaintext highlighter-rouge">stdout</code>.</li>
      <li>Spawn the command. Note this doesn‚Äôt make any progress until you call
<code class="language-plaintext highlighter-rouge">wait().await</code> or <code class="language-plaintext highlighter-rouge">wait_with_output().await</code>.</li>
      <li>Wait for the command to complete with or without output capture.</li>
    </ol>
  </li>
</ul>

<p>See it in action:</p>

<ul>
  <li>Run the binary: <code class="language-plaintext highlighter-rouge">cargo run --bin async_command_exec_1</code></li>
  <li>You should see something like the following in your terminal
    <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hello world
exit status: exit status: 0
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="example-piping-input-to-cat-process-programmatically">Example piping input to cat process programmatically</h3>
<p><a id="markdown-example-piping-input-to-cat-process-programmatically" name="example-piping-input-to-cat-process-programmatically"></a></p>

<p>Please clone this <a href="https://github.com/nazmulidris/rust-scratch">repo</a> to your computer to
play w/ the examples in the <a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/README.md"><code class="language-plaintext highlighter-rouge">rust-scratch/tty</code>
crate</a> shown below.</p>

<p><a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/src/async_command_exec_2.rs"><code class="language-plaintext highlighter-rouge">async_command_exec_2.rs</code></a></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">crossterm</span><span class="p">::</span><span class="nn">style</span><span class="p">::</span><span class="n">Stylize</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">miette</span><span class="p">::</span><span class="n">IntoDiagnostic</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">r3bl_rs_utils_core</span><span class="p">::</span><span class="n">ok</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="n">Stdio</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">io</span><span class="p">::{</span><span class="n">AsyncBufReadExt</span><span class="p">,</span> <span class="n">BufReader</span><span class="p">};</span>

<span class="cd">/// This variant requires the use of `tokio::spawn` to wait for the</span>
<span class="cd">/// child process to complete.</span>
<span class="nd">#[tokio::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Create a child process that runs `cat`.</span>
    <span class="c1">// - Send the output of `cat` back to this child process.</span>
    <span class="c1">// - This child / command does not make progress until</span>
    <span class="c1">//   `wait().await` is called.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">child</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Command</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"cat"</span><span class="p">)</span>
        <span class="nf">.stdin</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">inherit</span><span class="p">())</span>
        <span class="nf">.stdout</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">piped</span><span class="p">())</span>
        <span class="nf">.stderr</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">inherit</span><span class="p">())</span>
        <span class="nf">.spawn</span><span class="p">()</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Get the stdout of the child process. Do this before the next</span>
    <span class="c1">// step, because the `child` struct is moved into the closure.</span>
    <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">child_stdout</span><span class="p">)</span> <span class="o">=</span> <span class="n">child</span><span class="py">.stdout</span><span class="nf">.take</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nn">miette</span><span class="p">::</span><span class="nd">bail!</span><span class="p">(</span><span class="s">"Failed to capture stdout of child process"</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="c1">// üöÄ Ensure the child process is spawned in the runtime, so it</span>
    <span class="c1">// can make progress on its own while we await any output.</span>
    <span class="k">let</span> <span class="n">child_task_join_handle</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">result_exit_status</span> <span class="o">=</span> <span class="n">child</span><span class="nf">.wait</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>
        <span class="nd">println!</span><span class="p">(</span>
            <span class="s">"{}"</span><span class="p">,</span>
            <span class="nd">format!</span><span class="p">(</span>
                <span class="s">"Child process exited with status: {:?}"</span><span class="p">,</span>
                <span class="n">result_exit_status</span>
            <span class="p">)</span><span class="nf">.green</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">});</span>

    <span class="c1">// As long as there is a line to be read from the child process,</span>
    <span class="c1">// print it to the terminal.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">child_stdout_reader</span> <span class="o">=</span> <span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">child_stdout</span><span class="p">)</span><span class="nf">.lines</span><span class="p">();</span>
    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">=</span> <span class="n">child_stdout_reader</span>
        <span class="nf">.next_line</span><span class="p">()</span><span class="k">.await</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span>
    <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"‚ùØ {}"</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span><span class="nf">.cyan</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="c1">// Wait for the child task to complete.</span>
    <span class="n">child_task_join_handle</span><span class="k">.await</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="nd">ok!</span><span class="p">()</span>
<span class="p">}</span>

<span class="cd">/// This is a simpler version of the `main` function above. It</span>
<span class="cd">/// doesn't need to use `tokio::spawn` to wait for the child</span>
<span class="cd">/// process to complete.</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main_simpler</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Create a child process that runs `cat`.</span>
    <span class="c1">// - Send the output of `cat` back to this child process.</span>
    <span class="c1">// - This child / command does not make progress until</span>
    <span class="c1">//   `wait().await` is called.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">child</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Command</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"cat"</span><span class="p">)</span>
        <span class="nf">.stdin</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">inherit</span><span class="p">())</span>
        <span class="nf">.stdout</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">piped</span><span class="p">())</span>
        <span class="nf">.stderr</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">inherit</span><span class="p">())</span>
        <span class="nf">.spawn</span><span class="p">()</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Get the stdout of the child process. Do this before the next</span>
    <span class="c1">// step, because the `child` struct is moved into the closure.</span>
    <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">child_stdout</span><span class="p">)</span> <span class="o">=</span> <span class="n">child</span><span class="py">.stdout</span><span class="nf">.take</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nn">miette</span><span class="p">::</span><span class="nd">bail!</span><span class="p">(</span><span class="s">"Failed to capture stdout of child process"</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="c1">// As long as there is a line to be read from the child process,</span>
    <span class="c1">// print it to the terminal.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">child_stdout_reader</span> <span class="o">=</span> <span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">child_stdout</span><span class="p">)</span><span class="nf">.lines</span><span class="p">();</span>
    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">=</span> <span class="n">child_stdout_reader</span>
        <span class="nf">.next_line</span><span class="p">()</span><span class="k">.await</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span>
    <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"‚ùØ {}"</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span><span class="nf">.cyan</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="c1">// Simultaneously waits for the child to exit and collect all</span>
    <span class="c1">// remaining output on the stdout/stderr handles, returning an</span>
    <span class="c1">// Output instance.</span>
    <span class="k">let</span> <span class="n">output</span> <span class="o">=</span> <span class="n">child</span><span class="nf">.wait_with_output</span><span class="p">()</span><span class="k">.await</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"{}"</span><span class="p">,</span>
        <span class="nd">format!</span><span class="p">(</span>
            <span class="s">"Child process exited with status: {:?}"</span><span class="p">,</span> <span class="n">output</span><span class="py">.status</span>
        <span class="p">)</span><span class="nf">.green</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="nd">ok!</span><span class="p">()</span>
<span class="p">}</span>

<span class="cd">/// The nature of this function is different to the 2 above. For eg,</span>
<span class="cd">/// if you run this function in a terminal, you have to terminate</span>
<span class="cd">/// the input using `Ctrl-D` (EOF) if you want to see anything</span>
<span class="cd">/// displayed in the terminal output. In the two variants above,</span>
<span class="cd">/// output is captured in an "interactive" manner, as it comes</span>
<span class="cd">///  in from the stdin.</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main_non_interactive</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Create a child process that runs `cat`.</span>
    <span class="c1">// - Send the output of `cat` back to this child process.</span>
    <span class="c1">// - This child / command does not make progress until</span>
    <span class="c1">// `wait().await` is called.</span>
    <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Command</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"cat"</span><span class="p">)</span>
        <span class="nf">.stdin</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">inherit</span><span class="p">())</span>
        <span class="nf">.stdout</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">piped</span><span class="p">())</span>
        <span class="nf">.stderr</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">inherit</span><span class="p">())</span>
        <span class="nf">.spawn</span><span class="p">()</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Simultaneously waits for the child to exit and collect</span>
    <span class="c1">// all remaining output on the stdout/stderr handles,</span>
    <span class="c1">// returning an Output instance.</span>
    <span class="k">let</span> <span class="n">output</span> <span class="o">=</span> <span class="n">child</span><span class="nf">.wait_with_output</span><span class="p">()</span><span class="k">.await</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"{}"</span><span class="p">,</span>
        <span class="nd">format!</span><span class="p">(</span>
            <span class="s">"Child process exited with status: {:?}"</span><span class="p">,</span> <span class="n">output</span><span class="py">.status</span>
        <span class="p">)</span><span class="nf">.green</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="c1">// Print the output.stdout to terminal.</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_lossy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">output</span><span class="py">.stdout</span><span class="p">));</span>

    <span class="nd">ok!</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notes on the code:</p>

<ul>
  <li>This example uses the
<a href="https://docs.rs/tokio/latest/tokio/process/index.html"><code class="language-plaintext highlighter-rouge">tokio::process::Command</code></a>
struct to execute a command asynchronously, and then pipes the output of this command,
back to itself. Then prints the output one line at a time.</li>
  <li>To run this program, pipe some input (from the shell) into this program.
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"hello world</span><span class="se">\n</span><span class="s2">foo</span><span class="se">\n</span><span class="s2">bar</span><span class="se">\n</span><span class="s2">"</span> <span class="se">\</span>
  | cargo run <span class="nt">--bin</span> async_command_exec_2
</code></pre></div>    </div>
  </li>
  <li>This process will then run <code class="language-plaintext highlighter-rouge">cat</code> and capture the output from <code class="language-plaintext highlighter-rouge">cat</code>.</li>
  <li>It will then print the output from <code class="language-plaintext highlighter-rouge">cat</code> one line at time to the terminal.</li>
  <li>Flow diagram of the program:
    <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Terminal emulator running fish/bash shell
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ&gt; echo -e "foo\nbar\nbaz" | cargo run --bin async_command_exec_2‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ≤‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ≤‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îÇ                     ‚îÇ        Pipeline above runs
        ‚îÇ                     ‚îÇ        in parallel
   external                 external
   process                  process
   command (fork &amp; exec)    command (fork &amp; exec)
                              ‚îÇ
                              ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ create async Command for `cat`
                              ‚îÇ      with stdout = `Stdio::piped()`
                              ‚îÇ      to capture the output of `cmd`
                              ‚îÇ      back into this program
                              ‚îÇ
                              ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ the stdin for this Command is
                              ‚îÇ      inherited from the current
                              ‚îÇ      process which is provided by
                              ‚îÇ      process the terminal &amp; `pipe`
                              ‚îÇ
                              ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ `cmd.spawn()` then sets up the
                              ‚îÇ      `cat` process to run with the
                              ‚îÇ      given stdin &amp; stdout and
                              ‚îÇ      returns a `Child` struct
                              ‚îÇ
                              ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ üöÄ instead of waiting
                              ‚îÇ      "normally", we must use
                              ‚îÇ      `tokio::spawn` to call
                              ‚îÇ      `child.wait().await` on the
                              ‚îÇ      child so it can make progress
                              ‚îÇ      while we wait for its output
                              ‚îÇ      below (in the current task)
                              ‚îÇ
                              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ in our current task, we can
                                     now access `stdout` WHILE the
                                     child task is making progress
                                     above
</code></pre></div>    </div>
  </li>
  <li>How to kill child process:
    <ul>
      <li>Note that similar to the behavior to the standard library, and unlike the futures
paradigm of dropping-implies-cancellation, a spawned process will, by default,
continue to execute even after the <code class="language-plaintext highlighter-rouge">tokio::process::Child</code> handle has been dropped.
More info in the
<a href="https://docs.rs/tokio/latest/tokio/process/index.html#caveats">docs</a>. To change this
behavior you can use <code class="language-plaintext highlighter-rouge">tokio::process::Command::kill_on_drop</code> which isn‚Äôt really
recommended.</li>
      <li>Instead, to kill a child process, you can do the following:
        <ul>
          <li><code class="language-plaintext highlighter-rouge">tokio::process::Child::kill</code> - This forces the child process to exit.</li>
          <li><code class="language-plaintext highlighter-rouge">tokio::process::Child::wait</code> - This waits for the child process to cleanly exit.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>See it in action:</p>

<ul>
  <li>Run the binary: <code class="language-plaintext highlighter-rouge">echo -e "foo\nbar\nbaz" | cargo run --bin async_command_exec_2</code></li>
  <li>Or run the binary: <code class="language-plaintext highlighter-rouge">cargo run --bin async_command_exec_2</code> and then type some input
into the terminal and then press <code class="language-plaintext highlighter-rouge">Ctrl-D</code> to terminate the input.</li>
</ul>

<h3 id="example-programmatically-providing-input-into-stdin-and-getting-output-from-stdout-of-a-process">Example programmatically providing input into stdin and getting output from stdout of a process</h3>
<p><a id="markdown-example-programmatically-providing-input-into-stdin-and-getting-output-from-stdout-of-a-process" name="example-programmatically-providing-input-into-stdin-and-getting-output-from-stdout-of-a-process"></a></p>

<p>Please clone this <a href="https://github.com/nazmulidris/rust-scratch">repo</a> to your computer to
play w/ the examples in the <a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/README.md"><code class="language-plaintext highlighter-rouge">rust-scratch/tty</code>
crate</a> shown below.</p>

<p><a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/src/async_command_exec_3.rs"><code class="language-plaintext highlighter-rouge">async_command_exec_3.rs</code></a></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">crossterm</span><span class="p">::</span><span class="nn">style</span><span class="p">::</span><span class="n">Stylize</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">miette</span><span class="p">::</span><span class="n">IntoDiagnostic</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">r3bl_rs_utils_core</span><span class="p">::</span><span class="n">ok</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="n">Stdio</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">tokio</span><span class="p">::{</span>
    <span class="nn">io</span><span class="p">::{</span><span class="n">AsyncBufReadExt</span><span class="p">,</span> <span class="n">AsyncWriteExt</span><span class="p">,</span> <span class="n">BufReader</span><span class="p">},</span>
    <span class="nn">process</span><span class="p">::{</span><span class="n">Child</span><span class="p">,</span> <span class="n">ChildStdin</span><span class="p">,</span> <span class="n">ChildStdout</span><span class="p">},</span>
    <span class="nn">task</span><span class="p">::</span><span class="n">JoinHandle</span><span class="p">,</span>
<span class="p">};</span>

<span class="nd">#[tokio::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Create a child process that runs `cat`.</span>
    <span class="c1">// 1. Send the output of `cat` back to this child process.</span>
    <span class="c1">// 2. Send the input to `cat` from this child process.</span>
    <span class="c1">// 3. This child / command does not make progress until</span>
    <span class="c1">//    `wait().await` is called.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">child</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Command</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"cat"</span><span class="p">)</span>
        <span class="nf">.stdin</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">piped</span><span class="p">())</span>
        <span class="nf">.stdout</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">piped</span><span class="p">())</span>
        <span class="nf">.stderr</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">null</span><span class="p">())</span>
        <span class="nf">.spawn</span><span class="p">()</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// These are the bytes that will be sent to the `stdin` of the</span>
    <span class="c1">// child process.</span>
    <span class="k">let</span> <span class="n">input</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"hello"</span><span class="p">,</span> <span class="s">"nadia!"</span><span class="p">];</span>

    <span class="c1">// Get the stdout &amp; stdin of the child process. Do this before</span>
    <span class="c1">// the next step, because the `child` struct is moved into</span>
    <span class="c1">// the closure.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="n">stdin</span><span class="p">):</span> <span class="p">(</span><span class="n">ChildStdout</span><span class="p">,</span> <span class="n">ChildStdin</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">stdout</span><span class="p">)</span> <span class="o">=</span> <span class="n">child</span><span class="py">.stdout</span><span class="nf">.take</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nn">miette</span><span class="p">::</span><span class="nd">bail!</span><span class="p">(</span><span class="s">"Child process did not have a stdout"</span><span class="p">);</span>
        <span class="p">};</span>
        <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">stdin</span><span class="p">)</span> <span class="o">=</span> <span class="n">child</span><span class="py">.stdin</span><span class="nf">.take</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nn">miette</span><span class="p">::</span><span class="nd">bail!</span><span class="p">(</span><span class="s">"Child process did not have a stdin"</span><span class="p">);</span>
        <span class="p">};</span>
        <span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="n">stdin</span><span class="p">)</span>
    <span class="p">};</span>

    <span class="c1">// Spawn tasks to:</span>
    <span class="k">let</span> <span class="n">join_handle_child_task</span> <span class="o">=</span> <span class="nf">spawn_child_process</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">join_handle_provide_input_task</span> <span class="o">=</span>
        <span class="nf">spawn_provide_input</span><span class="p">(</span><span class="n">stdin</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>

    <span class="c1">// Read the output of the child process, on the current thread.</span>
    <span class="n">_</span> <span class="o">=</span> <span class="nf">read_stdout</span><span class="p">(</span><span class="n">stdout</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>

    <span class="c1">// Wait for the child process to complete.</span>
    <span class="n">_</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nd">join!</span><span class="p">(</span>
        <span class="n">join_handle_child_task</span><span class="p">,</span> <span class="n">join_handle_provide_input_task</span><span class="p">);</span>

    <span class="c1">// Make assertions.</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">input</span><span class="nf">.join</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span> <span class="s">"hello</span><span class="se">\n</span><span class="s">nadia!"</span><span class="p">);</span>

    <span class="nd">ok!</span><span class="p">()</span>
<span class="p">}</span>

<span class="cd">/// As long as there is a line to be read from the child process,</span>
<span class="cd">/// print it to the terminal.</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">read_stdout</span><span class="p">(</span><span class="n">stdout</span><span class="p">:</span> <span class="n">ChildStdout</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">output</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">stdout_reader</span> <span class="o">=</span> <span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">stdout</span><span class="p">)</span><span class="nf">.lines</span><span class="p">();</span>
    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">=</span> <span class="n">stdout_reader</span>
        <span class="nf">.next_line</span><span class="p">()</span><span class="k">.await</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span>
    <span class="p">{</span>
        <span class="n">output</span><span class="nf">.push</span><span class="p">(</span><span class="n">line</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="nd">println!</span><span class="p">(</span>
            <span class="s">"üßµ read_stdout -&gt; {}"</span><span class="p">,</span>
            <span class="nd">format!</span><span class="p">(</span><span class="s">"ü´≤  {}"</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span><span class="nf">.cyan</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="nd">ok!</span><span class="p">()</span>
<span class="p">}</span>

<span class="cd">/// üöÄ Ensure the child process is spawned in the runtime, so it</span>
<span class="cd">/// can make progress on its own while we await any output.</span>
<span class="k">fn</span> <span class="nf">spawn_child_process</span><span class="p">(</span><span class="k">mut</span> <span class="n">child</span><span class="p">:</span> <span class="n">Child</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">JoinHandle</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">result_exit_status</span> <span class="o">=</span> <span class="n">child</span><span class="nf">.wait</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>
        <span class="nd">println!</span><span class="p">(</span>
            <span class="s">"{}"</span><span class="p">,</span>
            <span class="nd">format!</span><span class="p">(</span>
                <span class="s">"üöÄ spawn_child_process -&gt; exit w/ status: {:?}"</span><span class="p">,</span>
                <span class="n">result_exit_status</span>
            <span class="p">)</span>
            <span class="nf">.green</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="cd">/// üöÄ Provide input to the child process.</span>
<span class="k">fn</span> <span class="nf">spawn_provide_input</span><span class="p">(</span>
    <span class="k">mut</span> <span class="n">stdin</span><span class="p">:</span> <span class="n">ChildStdin</span><span class="p">,</span> <span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="o">&amp;</span><span class="nb">str</span><span class="p">]</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="n">JoinHandle</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">input</span> <span class="o">=</span> <span class="n">input</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">s</span><span class="p">|</span> <span class="n">s</span><span class="nf">.to_string</span><span class="p">())</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;&gt;</span><span class="p">()</span>
        <span class="nf">.join</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="c1">// Write the input to the `stdin` of the child process.</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">stdin</span><span class="nf">.write_all</span><span class="p">(</span><span class="n">input</span><span class="nf">.as_bytes</span><span class="p">())</span><span class="k">.await</span><span class="p">;</span>

        <span class="c1">// Drop the handle to signal EOF to the child process.</span>
        <span class="nf">drop</span><span class="p">(</span><span class="n">stdin</span><span class="p">);</span>

        <span class="nd">println!</span><span class="p">(</span>
            <span class="s">"{}: {}"</span><span class="p">,</span>
            <span class="s">"üöÄ spawn_provide_input -&gt; EOF to child ü´±  stdin"</span>
                <span class="nf">.green</span><span class="p">(),</span>
            <span class="nd">format!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">input</span><span class="p">)</span><span class="nf">.blue</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">})</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notes on the code:</p>

<ul>
  <li>This example is similar to <code class="language-plaintext highlighter-rouge">async_command_exec_2.rs</code>, except that there is no need to
pipe input from the shell into this program. It does the following:
    <ol>
      <li>Programmatically provides data to the <code class="language-plaintext highlighter-rouge">cat</code> command via <code class="language-plaintext highlighter-rouge">stdin</code>.</li>
      <li>Programmatically captures the output of <code class="language-plaintext highlighter-rouge">cat</code> via <code class="language-plaintext highlighter-rouge">stdout</code>.</li>
    </ol>
  </li>
  <li>Flow diagram of the program:
    <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Terminal emulator running fish/bash shell
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ &gt; cargo run --bin async_command_exec_3 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚ñ≤‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ create async Command for `cat`
    ‚îÇ      with stdout = `Stdio::piped()` to
    ‚îÇ      capture the output of `cmd`
    ‚îÇ      back into this program
    ‚îÇ
    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ set stdin = `Stdio::piped()` to provide
    ‚îÇ      input to the `cat` command asynchronously
    ‚îÇ
    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ `cmd.spawn()` then sets up the `cat` process
    ‚îÇ      to run with the given stdin &amp; stdout and
    ‚îÇ      returns a `Child` struct
    ‚îÇ
    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ üöÄ instead of waiting "normally", we must use
    ‚îÇ      `tokio::spawn` to call `child.wait().await`
    ‚îÇ      on the child so it can make progress while
    ‚îÇ      we wait for its output below (in the current task)
    ‚îÇ
    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ üöÄ also use `tokio::spawn` to call
    ‚îÇ      `child.stdin.write_all()` to provide input
    ‚îÇ      to the `cat` command
    ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ in our current task, we can now access `stdout`
           WHILE the child task is making progress above
</code></pre></div>    </div>
  </li>
  <li>How to kill child process:
    <ul>
      <li>Note that similar to the behavior to the standard library, and unlike the futures
paradigm of dropping-implies-cancellation, a spawned process will, by default,
continue to execute even after the <code class="language-plaintext highlighter-rouge">tokio::process::Child</code> handle has been dropped.
More info in the
<a href="https://docs.rs/tokio/latest/tokio/process/index.html#caveats">docs</a>. To change this
behavior you can use <code class="language-plaintext highlighter-rouge">tokio::process::Command::kill_on_drop</code> which isn‚Äôt really
recommended.</li>
      <li>Instead, to kill a child process, you can do the following:
        <ul>
          <li><code class="language-plaintext highlighter-rouge">tokio::process::Child::kill</code> - This forces the child process to exit.</li>
          <li><code class="language-plaintext highlighter-rouge">tokio::process::Child::wait</code> - This waits for the child process to cleanly exit.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>See it in action:</p>

<ul>
  <li>Run the binary: <code class="language-plaintext highlighter-rouge">cargo run --bin async_command_exec_3</code></li>
  <li>It should produce output that looks something like the following:
    <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>üöÄ spawn_provide_input -&gt; Finished providing input + EOF to child process ü´±  stdin: "hello\nnadia!"
üßµ read_stdout -&gt; ü´≤  hello
üßµ read_stdout -&gt; ü´≤  nadia!
üöÄ spawn_child_process -&gt; Child process exited with status: Ok(ExitStatus(unix_wait_status(0)))
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="example-programmatically-piping-the-output-of-one-process-into-another">Example programmatically piping the output of one process into another</h3>
<p><a id="markdown-example-programmatically-piping-the-output-of-one-process-into-another" name="example-programmatically-piping-the-output-of-one-process-into-another"></a></p>

<p>Please clone this <a href="https://github.com/nazmulidris/rust-scratch">repo</a> to your computer to
play w/ the examples in the <a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/README.md"><code class="language-plaintext highlighter-rouge">rust-scratch/tty</code>
crate</a> shown below.</p>

<p><a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/src/async_command_exec_4.rs"><code class="language-plaintext highlighter-rouge">async_command_exec_4.rs</code></a></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">crossterm</span><span class="p">::</span><span class="nn">style</span><span class="p">::</span><span class="n">Stylize</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">miette</span><span class="p">::</span><span class="n">IntoDiagnostic</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">r3bl_rs_utils_core</span><span class="p">::</span><span class="n">ok</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="n">Stdio</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">tokio</span><span class="p">::{</span><span class="nn">io</span><span class="p">::</span><span class="n">AsyncReadExt</span><span class="p">,</span> <span class="nn">process</span><span class="p">::</span><span class="n">Command</span><span class="p">};</span>

<span class="k">type</span> <span class="n">EchoResult</span> <span class="o">=</span> <span class="p">(</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="n">ChildStdout</span><span class="p">,</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">task</span><span class="p">::</span><span class="n">JoinHandle</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">type</span> <span class="n">TrResult</span> <span class="o">=</span> <span class="p">(</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="n">ChildStdout</span><span class="p">,</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">task</span><span class="p">::</span><span class="n">JoinHandle</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">);</span>

<span class="k">const</span> <span class="n">INPUT</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">"hello world"</span><span class="p">;</span>

<span class="nd">#[tokio::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Spawn the `echo` command &amp; get its `stdout`.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">child_stdout_echo</span><span class="p">,</span> <span class="n">join_handle_echo</span><span class="p">):</span> <span class="n">EchoResult</span> <span class="o">=</span>
        <span class="nf">spawn_child_echo_and_get_stdout</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Spawn the `tr` command &amp; provide the `stdout` of `echo` to</span>
    <span class="c1">// its `stdin`.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">child_stdout_tr</span><span class="p">,</span> <span class="n">join_handle_tr</span><span class="p">):</span> <span class="n">TrResult</span> <span class="o">=</span>
        <span class="nf">spawn_child_tr_and_provide_stdin</span><span class="p">(</span><span class="n">child_stdout_echo</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Wait for both child processes to complete.</span>
    <span class="n">_</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nd">try_join!</span><span class="p">(</span><span class="n">join_handle_echo</span><span class="p">,</span> <span class="n">join_handle_tr</span><span class="p">);</span>

    <span class="c1">// Read the output of the `tr` command from `child_stdout_tr`.</span>
    <span class="k">let</span> <span class="n">output</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">buf</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">child_stdout_tr</span><span class="p">)</span>
            <span class="nf">.read_to_end</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">buf</span><span class="p">)</span>
            <span class="k">.await</span>
            <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
        <span class="n">buf</span>
    <span class="p">};</span>

    <span class="c1">// Make assertions.</span>
    <span class="k">let</span> <span class="n">expected_output</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{INPUT}</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span><span class="nf">.to_uppercase</span><span class="p">();</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">expected_output</span><span class="p">,</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_lossy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">output</span><span class="p">));</span>

    <span class="c1">// Print the output of the `tr` command.</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"{}: {}"</span><span class="p">,</span>
        <span class="s">"output"</span><span class="nf">.blue</span><span class="p">(),</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_lossy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">output</span><span class="p">))</span><span class="nf">.green</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="nd">ok!</span><span class="p">()</span>
<span class="p">}</span>

<span class="cd">/// üöÄ Spawn `echo` command &amp; get its `stdout`. We will pipe this</span>
<span class="cd">/// into the `stdin` of `tr`.</span>
<span class="cd">///</span>
<span class="cd">/// Return a tuple of:</span>
<span class="cd">/// 1. `stdout` of `echo`: [tokio::process::ChildStdout].</span>
<span class="cd">/// 2. [tokio::task::JoinHandle] of `echo` [tokio::process::Child]</span>
<span class="cd">///    process, spawned by the [tokio::process::Command] that</span>
<span class="cd">///    starts `echo`.</span>
<span class="k">fn</span> <span class="nf">spawn_child_echo_and_get_stdout</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">EchoResult</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Spawn the child process for `echo`.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">child_echo</span> <span class="o">=</span> <span class="nn">Command</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"echo"</span><span class="p">)</span>
        <span class="nf">.arg</span><span class="p">(</span><span class="n">INPUT</span><span class="p">)</span>
        <span class="nf">.stdout</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">piped</span><span class="p">())</span>
        <span class="nf">.stdin</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">null</span><span class="p">())</span>
        <span class="nf">.stderr</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">null</span><span class="p">())</span>
        <span class="nf">.spawn</span><span class="p">()</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Take the `stdout` of the child process.</span>
    <span class="k">let</span> <span class="n">child_stdout</span> <span class="o">=</span> <span class="n">child_echo</span><span class="py">.stdout</span><span class="nf">.take</span><span class="p">()</span>
        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">miette</span><span class="p">::</span><span class="nd">miette!</span><span class="p">(</span>
            <span class="s">"Failed to capture stdout of `echo` child process"</span>
        <span class="p">))</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Ensure the child process is spawned in the runtime, so it can</span>
    <span class="c1">// make progress on its own while we await any output.</span>
    <span class="k">let</span> <span class="n">join_handle</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">child_echo</span><span class="nf">.wait</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>
    <span class="p">});</span>

    <span class="c1">// Return the `stdout` of `echo` and the `JoinHandle` of the</span>
    <span class="c1">// `echo` child process.</span>
    <span class="nf">Ok</span><span class="p">((</span><span class="n">child_stdout</span><span class="p">,</span> <span class="n">join_handle</span><span class="p">))</span>
<span class="p">}</span>

<span class="cd">/// üöÄ Spawn `tr` command &amp; pass the given</span>
<span class="cd">/// [tokio::process::ChildStdout] to its `stdin`.</span>
<span class="cd">///</span>
<span class="cd">/// Return a tuple of:</span>
<span class="cd">/// 1. `stdout` of `tr`: [tokio::process::ChildStdout].</span>
<span class="cd">/// 2. [tokio::task::JoinHandle] of `tr` [tokio::process::Child]</span>
<span class="cd">///    process, spawned by the [tokio::process::Command] that</span>
<span class="cd">///    starts `tr`.</span>
<span class="k">fn</span> <span class="nf">spawn_child_tr_and_provide_stdin</span><span class="p">(</span>
    <span class="n">stdout_from_other_child</span><span class="p">:</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="n">ChildStdout</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">TrResult</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Convert `stdout_from_other_child`: tokio::process::ChildStdout</span>
    <span class="c1">// into tokio::process::ChildStdin, so it can be provided to the</span>
    <span class="c1">// `stdin` of the `tr` command.</span>
    <span class="k">let</span> <span class="n">stdout_from_other_child</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="n">Stdio</span> <span class="o">=</span>
        <span class="n">stdout_from_other_child</span><span class="nf">.try_into</span><span class="p">()</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Spawn child process.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">child_tr</span> <span class="o">=</span> <span class="nn">Command</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"tr"</span><span class="p">)</span>
        <span class="nf">.arg</span><span class="p">(</span><span class="s">"a-z"</span><span class="p">)</span>
        <span class="nf">.arg</span><span class="p">(</span><span class="s">"A-Z"</span><span class="p">)</span>
        <span class="nf">.stdin</span><span class="p">(</span><span class="n">stdout_from_other_child</span><span class="p">)</span>
        <span class="nf">.stdout</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">piped</span><span class="p">())</span>
        <span class="nf">.stderr</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">null</span><span class="p">())</span>
        <span class="nf">.spawn</span><span class="p">()</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Take the `stdout` of the child process.</span>
    <span class="k">let</span> <span class="n">child_stdout</span> <span class="o">=</span> <span class="n">child_tr</span><span class="py">.stdout</span><span class="nf">.take</span><span class="p">()</span><span class="nf">.ok_or</span><span class="p">(</span><span class="nn">miette</span><span class="p">::</span><span class="nd">miette!</span><span class="p">(</span>
        <span class="s">"Failed to capture stdout of `tr` child process"</span>
    <span class="p">))</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Ensure the child process is spawned in the runtime, so it can</span>
    <span class="c1">// make progress on its own while we await any output.</span>
    <span class="k">let</span> <span class="n">join_handle</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">child_tr</span><span class="nf">.wait</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>
    <span class="p">});</span>

    <span class="nf">Ok</span><span class="p">((</span><span class="n">child_stdout</span><span class="p">,</span> <span class="n">join_handle</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notes on the code:</p>

<ul>
  <li>In this example, we will will orchestrate two processes and make a pipe between them
programmatically (we are used to doing this using <code class="language-plaintext highlighter-rouge">|</code> in shells). We will replicate
the following functionality in this program: <code class="language-plaintext highlighter-rouge">echo hello world | tr a-z A-Z</code>.
    <ol>
      <li>Spawn the <code class="language-plaintext highlighter-rouge">echo</code> command, with arg <code class="language-plaintext highlighter-rouge">hello world</code> and get its <code class="language-plaintext highlighter-rouge">stdout</code>.</li>
      <li>Then we will provide this <code class="language-plaintext highlighter-rouge">stdout</code> to the <code class="language-plaintext highlighter-rouge">stdin</code> of the <code class="language-plaintext highlighter-rouge">tr</code> command, with arg
<code class="language-plaintext highlighter-rouge">a-z A-Z</code> and spawn it.</li>
      <li>Finally we join the <code class="language-plaintext highlighter-rouge">echo</code> and <code class="language-plaintext highlighter-rouge">tr</code> child processes and wait for them both to
complete.</li>
    </ol>
  </li>
</ul>

<p>See it in action:</p>

<ul>
  <li>Run the binary: <code class="language-plaintext highlighter-rouge">cargo run --bin async_command_exec_4</code></li>
  <li>You should see output that looks something like the following:
    <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>output: HELLO WORLD
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="example-using-r3bl_terminal_async-to-send-commands-to-a-long-running-bash-child-process">Example using r3bl_terminal_async to send commands to a long running bash child process</h3>
<p><a id="markdown-example-using-r3bl_terminal_async-to-send-commands-to-a-long-running-bash-child-process" name="example-using-r3bl_terminal_async-to-send-commands-to-a-long-running-bash-child-process"></a></p>

<p>The following example is in the <a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/terminal_async"><code class="language-plaintext highlighter-rouge">r3bl_terminal_async</code>
repo</a>. Please clone that repo to your computer to
play w/ the following example:</p>

<p><a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/terminal_async/examples/shell_async.rs"><code class="language-plaintext highlighter-rouge">shell_async.rs</code></a></p>

<p>You can clone the <a href="https://github.com/r3bl-org/r3bl-open-core"><code class="language-plaintext highlighter-rouge">r3bl-open-core</code></a> repo to your computer
and then run the following command to run the example:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/r3bl-org/r3bl-open-core
<span class="nb">cd </span>r3bl-open-core/terminal_async
cargo run <span class="nt">--example</span> shell_async
</code></pre></div></div>

<p>Type the following commands to have a go at this.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">msg</span><span class="o">=</span><span class="s2">"hello nadia!"</span>
<span class="nb">echo</span> <span class="nv">$msg</span>
</code></pre></div></div>

<p>You should see something like the following.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[1606192] &gt; msg="hello nadia!"
[1606192] &gt; echo $msg
hello nadia!
[1606192] &gt;
</code></pre></div></div>

<p>Clean up any left over processes:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>killall <span class="nt">-9</span> bash shell_async
</code></pre></div></div>

<h2 id="build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</h2>
<p><a id="markdown-build-with-naz-video-series-on-developerlife.com-youtube-channel" name="build-with-naz-video-series-on-developerlife.com-youtube-channel"></a></p>

<blockquote>
  <p>If you have comments and feedback on this content, or would like to request new content
(articles &amp; videos) on developerlife.com, please join our <a href="https://discord.gg/8M2ePAevaMi">discord
server</a>.</p>
</blockquote>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a></li>
  <li>Playlists
    <ul>
      <li><a href="https://www.youtube.com/watch?v=bolScvh4x7I&amp;list=PLofhE49PEwmw3MKOU1Kn3xbP4FRQR4Mb3">Build with Naz, Linux TTY, process, signals, commands in async Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmza94sS7UmJnN9gSCHTVTfz">Build with Naz, fundamental effective Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmwO69E7eiQ-ewnMME8ydgQ5">Build with Naz, effective async Rust and tokio</a></li>
      <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><category term="TUI" /><summary type="html"><![CDATA[This article, along with related videos and the repository, explores Linux TTY, shells, processes, sessions, jobs, PTYs, signals, and more using Rust. It explains /dev/tty and describes how terminal libraries like crossterm and termion build on top of stdio and /dev/tty. The article provides examples of using Rust to send and receive POSIX signals, communicate with processes via IPC, and spawn processes. Additionally, it includes examples of using PTY in Linux and controlling external commands (such as binaries like bash) using asynchronous Rust.]]></summary></entry><entry><title type="html">Build with Naz : Box and Pin exploration in Rust</title><link href="http://developerlife.com/2024/07/16/pin-box-dynamic-duo/" rel="alternate" type="text/html" title="Build with Naz : Box and Pin exploration in Rust" /><published>2024-07-16T10:00:00-05:00</published><updated>2024-07-16T10:00:00-05:00</updated><id>http://developerlife.com/2024/07/16/pin-box-dynamic-duo</id><content type="html" xml:base="http://developerlife.com/2024/07/16/pin-box-dynamic-duo/"><![CDATA[<p><img class="post-hero-image" src="/assets/box-and-pin.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#why-do-we-need-both-box-and-pin">Why do we need both Box and Pin?</a></li>
  <li><a href="#formatting-pointers">Formatting pointers</a></li>
  <li><a href="#what-is-a-smart-pointer">What is a smart pointer?</a></li>
  <li><a href="#youtube-video-for-this-article">YouTube video for this article</a></li>
  <li><a href="#examples-rust-box-smart-pointer-and-pin">Examples Rust Box smart pointer, and Pin</a>
    <ul>
      <li><a href="#example-1-getting-the-address-of-variables-on-the-stack-and-heap">Example 1: Getting the address of variables on the stack and heap</a></li>
      <li><a href="#example-2-what-does-box-move-do">Example 2: What does Box move do?</a></li>
      <li><a href="#example-3-how-do-we-swap-the-contents-of-two-boxes">Example 3: How do we swap the contents of two boxes?</a></li>
      <li><a href="#example-4-what-does-pining-a-box-do">Example 4: What does pining a box do?</a></li>
    </ul>
  </li>
  <li><a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</a></li>
</ul>

<!-- /TOC -->

<h2 id="introduction">Introduction</h2>
<p><a id="markdown-introduction" name="introduction"></a></p>

<p>This tutorial, video, and repo are a deep dive into Rust <code class="language-plaintext highlighter-rouge">Pin</code> and <code class="language-plaintext highlighter-rouge">Box</code> types, along with
concepts of ownership and borrowing. We will also cover a lot of background information on
the concepts of operating system process, memory allocation and access, stack, and heap.
The examples we create are designed to demonstrate  the different semantics around the use
of boxes and pinned boxes in Rust.</p>

<h2 id="why-do-we-need-both-box-and-pin">Why do we need both Box and Pin?</h2>
<p><a id="markdown-why-do-we-need-both-box-and-pin%3F" name="why-do-we-need-both-box-and-pin%3F"></a></p>

<p>It is common to use <code class="language-plaintext highlighter-rouge">Pin</code> for <code class="language-plaintext highlighter-rouge">tokio::select!</code> macro branches in <a href="https://developerlife.com/2024/05/19/effective-async-rust/">Rust async
code</a>. And <code class="language-plaintext highlighter-rouge">Box</code> is used
commonly for <a href="https://developerlife.com/2024/04/28/rust-polymorphism-dyn-impl-trait-objects-for-testing-and-extensibiity/">trait
pointers</a>.</p>

<p>This article, video, and repo illustrate the concepts (moving a box, swapping box
contents, and pinning a box) by example. Lots of pretty formatted output is generated so
that you can run tests and see what‚Äôs happening (and make sense of it).</p>

<h2 id="formatting-pointers">Formatting pointers</h2>
<p><a id="markdown-formatting-pointers" name="formatting-pointers"></a></p>

<p>To format pointers in Rust, we can use the formatting trait
<a href="https://doc.rust-lang.org/std/fmt/#formatting-traits"><code class="language-plaintext highlighter-rouge">{:p}</code></a>. You can format a
pointer by using two approaches:</p>
<ol>
  <li>Get the address of the pointer using [<code class="language-plaintext highlighter-rouge">std::ptr::addr_of!</code>] and then format it
using <code class="language-plaintext highlighter-rouge">{:p}</code>. Eg: <code class="language-plaintext highlighter-rouge">let x = 1; println!("{:p}", std::ptr::addr_of!(x));</code></li>
  <li>Get a reference to the pointer using <code class="language-plaintext highlighter-rouge">&amp;</code> and then format it using <code class="language-plaintext highlighter-rouge">{:p}</code>. Eg: <code class="language-plaintext highlighter-rouge">let
x = 1; println!("{:p}", &amp;x);</code></li>
</ol>

<h2 id="what-is-a-smart-pointer">What is a smart pointer?</h2>
<p><a id="markdown-what-is-a-smart-pointer%3F" name="what-is-a-smart-pointer%3F"></a></p>

<p>Smart pointers in Rust are data structures that act like pointers but also have additional
metadata and capabilities. They provide a level of abstraction over raw pointers, offering
features like ownership management, reference counting, and more. Smart pointers often
manage ownership of the data they point to, ensuring proper deallocation when no longer
needed.</p>

<blockquote>
  <p>For a great visualization of memory allocation, stack and heap please read this
<a href="https://courses.grainger.illinois.edu/cs225/fa2022/resources/stack-heap/">article</a>.</p>
</blockquote>

<h2 id="youtube-video-for-this-article">YouTube video for this article</h2>
<p><a id="markdown-youtube-video-for-this-article" name="youtube-video-for-this-article"></a></p>

<p>This blog post has examples from this live coding video. If you like
to learn via video, please watch the companion video on the <a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube
channel</a>.</p>

<!-- video on tokio-async-cancel-safety -->
<iframe src="https://www.youtube.com/embed/SZtZkM2Ujhs?si=6wtfI_Q8ORpKUU_G" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<p><br /></p>

<h2 id="examples-rust-box-smart-pointer-and-pin">Examples Rust Box smart pointer, and Pin</h2>
<p><a id="markdown-examples-rust-box-smart-pointer%2C-and-pin" name="examples-rust-box-smart-pointer%2C-and-pin"></a></p>

<p>Let‚Äôs create some examples to illustrate how <code class="language-plaintext highlighter-rouge">Box</code> and <code class="language-plaintext highlighter-rouge">Pin</code> and pointers to stack
allocations and heap allocations work in Rust. You can run <code class="language-plaintext highlighter-rouge">cargo new --lib box-and-pin</code>
to create a new library crate.</p>

<blockquote>
  <p>üí° You can get the code from the
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/box-and-pin/"><code class="language-plaintext highlighter-rouge">rust-scratch</code></a> repo.</p>
</blockquote>

<p>Then add the following to the <code class="language-plaintext highlighter-rouge">Cargo.toml</code> file that‚Äôs generated. These pull in all the
dependencies that we need for these examples.</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[package]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"box-and-pin"</span>
<span class="py">version</span> <span class="p">=</span> <span class="s">"0.1.0"</span>
<span class="py">edition</span> <span class="p">=</span> <span class="s">"2021"</span>

<span class="nn">[dependencies]</span>
<span class="py">crossterm</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.27.0"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"event-stream"</span><span class="p">]</span> <span class="p">}</span>
<span class="py">serial_test</span> <span class="p">=</span> <span class="s">"3.1.1"</span>
</code></pre></div></div>

<p>Here are the dependencies we are using:</p>
<ol>
  <li>The <code class="language-plaintext highlighter-rouge">serial_test</code> dep allows us to run Rust tests serially, so that we can examine the
output of each test, without it being clobbered by other test output running in
parallel.</li>
  <li>The <code class="language-plaintext highlighter-rouge">crossterm</code> dep allows us to generate colorful <code class="language-plaintext highlighter-rouge">println!</code> output in the terminal
which will help us visualize what is going on with the pointers and memory allocations.</li>
</ol>

<p>We are going to add all the examples below as tests to the <code class="language-plaintext highlighter-rouge">lib.rs</code> file in this crate.</p>

<h3 id="example-1-getting-the-address-of-variables-on-the-stack-and-heap">Example 1: Getting the address of variables on the stack and heap</h3>
<p><a id="markdown-example-1%3A-getting-the-address-of-variables-on-the-stack-and-heap" name="example-1%3A-getting-the-address-of-variables-on-the-stack-and-heap"></a></p>

<p>Let‚Äôs add the following imports and macros to the top of the <code class="language-plaintext highlighter-rouge">lib.rs</code> file. These will
help us print output from the tests, so that we can track where a pointer is located in
memory and what the size of the thing it points to is. There are two macros, one for a
reference or pointer, and another one for pinned pointers. And we have an assertion
function that can return true if all 3 arguments are equal.</p>

<div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">crossterm</span><span class="p">::</span><span class="nn">style</span><span class="p">::</span><span class="n">Stylize</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">serial_test</span><span class="p">::</span><span class="n">serial</span><span class="p">;</span>

<span class="cd">/// Given a pointer `$p`, it prints:</span>
<span class="cd">/// 1. it's address,</span>
<span class="cd">/// 2. and size of the thing it points to (in bytes).</span>
<span class="nd">macro_rules!</span> <span class="n">print_ptr_addr_size</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$p</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"{:p}‚îÜ{}b"</span><span class="p">,</span> <span class="nv">$p</span><span class="p">,</span> <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">size_of_val</span><span class="p">(</span><span class="nv">$p</span><span class="p">))</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="cd">/// Given a pinned pointer `$p`, it prints:</span>
<span class="cd">/// 1. it's address,</span>
<span class="cd">/// 2. and size of the thing it points to (in bytes).</span>
<span class="nd">macro_rules!</span> <span class="n">print_pin_addr_size</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$p</span><span class="p">:</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"{:p}‚îÜ{}b"</span><span class="p">,</span> <span class="nv">$p</span><span class="p">,</span> <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">size_of_val</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="nv">$p</span><span class="p">)))</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">assert_three_equal</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">PartialEq</span> <span class="o">+</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="s">"a and b are not equal"</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="s">"a and c are not equal"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So, before we start with the examples, let‚Äôs add a test that demonstrates how to get the
address of a variable on the stack and heap. Add the following code to your <code class="language-plaintext highlighter-rouge">lib.rs</code> file.</p>

<div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[test]</span>
<span class="nd">#[serial]</span>
<span class="k">fn</span> <span class="nf">print_ptr_addr_size</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Using `std::ptr::addr_of!` to get the memory address of a variable.</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">100u8</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">x_addr</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ptr</span><span class="p">::</span><span class="nd">addr_of!</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"x: {}, x_addr  : {}"</span><span class="p">,</span>
        <span class="n">x</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">(),</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">x_addr</span><span class="p">)</span><span class="nf">.red</span><span class="p">()</span><span class="nf">.italic</span><span class="p">(),</span>
    <span class="p">);</span>

    <span class="c1">// Using `format!` to get the memory address of a variable.</span>
    <span class="k">let</span> <span class="n">x_addr_2</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{:p}"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"x: {}, x_addr_2: {}"</span><span class="p">,</span>
        <span class="n">x</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">(),</span>
        <span class="n">x_addr_2</span><span class="nf">.red</span><span class="p">()</span><span class="nf">.italic</span><span class="p">()</span><span class="nf">.on_black</span><span class="p">(),</span>
    <span class="p">);</span>

    <span class="c1">// Get size of `x` in bytes.</span>
    <span class="k">let</span> <span class="n">x_size</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">size_of_val</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"x: {}, x_size  : {}b"</span><span class="p">,</span>
        <span class="n">x</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">(),</span>
        <span class="n">x_size</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.magenta</span><span class="p">()</span><span class="nf">.italic</span><span class="p">()</span><span class="nf">.on_black</span><span class="p">(),</span>
    <span class="p">);</span>

    <span class="c1">// Using `print_ptr_addr_size!` to get the memory address of a variable.</span>
    <span class="k">let</span> <span class="n">x_addr_3</span> <span class="o">=</span> <span class="nd">print_ptr_addr_size!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"x: {}, x_addr_3: {}"</span><span class="p">,</span>
        <span class="n">x</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">(),</span>
        <span class="n">x_addr_3</span><span class="nf">.red</span><span class="p">()</span><span class="nf">.italic</span><span class="p">()</span><span class="nf">.on_black</span><span class="p">(),</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here‚Äôs the output of the test above, after you run <code class="language-plaintext highlighter-rouge">cargo watch -x "test --lib -- --show-output print"</code>.</p>

<pre class="pre-manual-highlight">
---- print_ptr_addr_size stdout ----
x: <span style="color:#81A1C1"><u style="text-decoration-style:solid">100</u></span>, x_addr  : <span style="color:#BF616A"><i>0x7e17cd9feb97</i></span>
x: <span style="color:#81A1C1"><u style="text-decoration-style:solid">100</u></span>, x_addr_2: <span style="background-color:#3B4252"><span style="color:#BF616A"><i>0x7e17cd9feb97</i></span></span>
x: <span style="color:#81A1C1"><u style="text-decoration-style:solid">100</u></span>, x_size  : <span style="background-color:#3B4252"><span style="color:#B48EAD"><i>1</i></span></span>b
x: <span style="color:#81A1C1"><u style="text-decoration-style:solid">100</u></span>, x_addr_3: <span style="background-color:#3B4252"><span style="color:#BF616A"><i>0x7e17cd9feb97‚îÜ1b</i></span></span>
</pre>

<p>Let‚Äôs walk through the output above:</p>
<ol>
  <li>We have a variable <code class="language-plaintext highlighter-rouge">x</code> that is a <code class="language-plaintext highlighter-rouge">u8</code> with a value of <code class="language-plaintext highlighter-rouge">100</code>. This is a stack
allocation. It occupies 1 byte of memory (its size).</li>
  <li>We get the address of <code class="language-plaintext highlighter-rouge">x</code> using <code class="language-plaintext highlighter-rouge">std::ptr::addr_of!(x)</code> and <code class="language-plaintext highlighter-rouge">format!("{:p}", &amp;x)</code>.</li>
  <li>We get the size of <code class="language-plaintext highlighter-rouge">x</code> in bytes using <code class="language-plaintext highlighter-rouge">std::mem::size_of_val(&amp;x)</code>. The size is 1 byte.</li>
  <li>We get the address of <code class="language-plaintext highlighter-rouge">x</code> and the size of <code class="language-plaintext highlighter-rouge">x</code> using the <code class="language-plaintext highlighter-rouge">print_ptr_addr_size!</code> macro.</li>
</ol>

<h3 id="example-2-what-does-box-move-do">Example 2: What does Box move do?</h3>
<p><a id="markdown-example-2%3A-what-does-box-move-do%3F" name="example-2%3A-what-does-box-move-do%3F"></a></p>

<p>Add the following snippet to the <code class="language-plaintext highlighter-rouge">lib.rs</code> file next. This
<a href="https://courses.grainger.illinois.edu/cs225/fa2022/resources/stack-heap/">link</a> provids
lots of great diagrams on how stack and heap memory works in an operating system.</p>

<div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// &lt;https://courses.grainger.illinois.edu/cs225/fa2022/resources/stack-heap/&gt;</span>
<span class="nd">#[test]</span>
<span class="nd">#[serial]</span>
<span class="k">fn</span> <span class="nf">move_a_box</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">b_1</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">255u8</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">b_1_addr</span> <span class="o">=</span> <span class="nd">print_ptr_addr_size!</span><span class="p">(</span><span class="n">b_1</span><span class="nf">.as_ref</span><span class="p">());</span> <span class="c1">// Pointee (heap)</span>
    <span class="k">let</span> <span class="n">b_1_ptr_addr</span> <span class="o">=</span> <span class="nd">print_ptr_addr_size!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b_1</span><span class="p">);</span> <span class="c1">// Pointer (stack)</span>

    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"1. {}: {}, {} (pointee, heap): {}, {} (ptr, stack): {}"</span><span class="p">,</span>
        <span class="s">"b_1"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="n">b_1</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">(),</span>
        <span class="s">"b_1_addr"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="n">b_1_addr</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.magenta</span><span class="p">()</span><span class="nf">.italic</span><span class="p">()</span><span class="nf">.on_black</span><span class="p">(),</span>
        <span class="s">"b_1_ptr_addr"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="n">b_1_ptr_addr</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.magenta</span><span class="p">()</span><span class="nf">.italic</span><span class="p">()</span><span class="nf">.on_black</span><span class="p">(),</span>
    <span class="p">);</span>

    <span class="k">let</span> <span class="n">b_2</span> <span class="o">=</span> <span class="n">b_1</span><span class="p">;</span>
    <span class="c1">// println!("{b_1:p}"); // ‚õî error: use of moved value: `b_1`</span>
    <span class="k">let</span> <span class="n">b_2_addr</span> <span class="o">=</span> <span class="nd">print_ptr_addr_size!</span><span class="p">(</span><span class="n">b_2</span><span class="nf">.as_ref</span><span class="p">());</span> <span class="c1">// Pointee (heap)</span>
    <span class="k">let</span> <span class="n">b_2_ptr_addr</span> <span class="o">=</span> <span class="nd">print_ptr_addr_size!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b_2</span><span class="p">);</span> <span class="c1">// Pointer (stack)</span>

    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"2. {}: {}, {} (pointee, heap): {}, {} (ptr, stack): {}"</span><span class="p">,</span>
        <span class="s">"b_2"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="n">b_2</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">(),</span>
        <span class="s">"b_2_addr"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="n">b_2_addr</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.magenta</span><span class="p">()</span><span class="nf">.italic</span><span class="p">()</span><span class="nf">.on_black</span><span class="p">(),</span>
        <span class="s">"b_2_ptr_addr"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="n">b_2_ptr_addr</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.magenta</span><span class="p">()</span><span class="nf">.italic</span><span class="p">()</span><span class="nf">.on_black</span><span class="p">(),</span>
    <span class="p">);</span>

    <span class="c1">// The heap memory allocation does not change (does not move). Pointee does not move.</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">b_1_addr</span><span class="p">,</span> <span class="n">b_2_addr</span><span class="p">);</span>

    <span class="c1">// The stack memory allocation does change (does move). Boxes aka pointers have move.</span>
    <span class="nd">assert_ne!</span><span class="p">(</span><span class="n">b_1_ptr_addr</span><span class="p">,</span> <span class="n">b_2_ptr_addr</span><span class="p">);</span>

    <span class="c1">// When b_2 is dropped, the heap allocation is deallocated. This is why Box is a smart pointer.</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Let‚Äôs walk through the output above:</p>
<ol>
  <li>We have a <code class="language-plaintext highlighter-rouge">Box</code> <code class="language-plaintext highlighter-rouge">b_1</code> that points to a heap allocation of a <code class="language-plaintext highlighter-rouge">u8</code> with a value of <code class="language-plaintext highlighter-rouge">255</code>.
<code class="language-plaintext highlighter-rouge">b_1</code> is a variable on the stack that points to a heap allocation. We get the address
of the pointee and the pointer using the <code class="language-plaintext highlighter-rouge">print_ptr_addr_size!</code> macro with
<code class="language-plaintext highlighter-rouge">b_1.as_ref()</code>. And we get the address of the pointer by passing <code class="language-plaintext highlighter-rouge">&amp;b_1</code> to
<code class="language-plaintext highlighter-rouge">print_ptr_addr_size!</code>.</li>
  <li>We move <code class="language-plaintext highlighter-rouge">b_1</code> into <code class="language-plaintext highlighter-rouge">b_2</code>. The heap memory allocation does not change (does not move).
The pointee does not move. But the stack memory allocation does change (does move).
Boxes aka pointers have moved. The <code class="language-plaintext highlighter-rouge">b_1</code> variable gets dropped. We can get the address
of the pointee using <code class="language-plaintext highlighter-rouge">print_ptr_addr_size!</code> macro with <code class="language-plaintext highlighter-rouge">b_2.as_ref()</code>. We can get the
address of the pointer using <code class="language-plaintext highlighter-rouge">print_ptr_addr_size!</code> macro with <code class="language-plaintext highlighter-rouge">&amp;b_2</code>.</li>
  <li>In the assertions, we check that the heap memory allocation does <strong>not</strong> change (does
not move). And we check that the stack memory allocation <strong>does</strong> change (does move).</li>
</ol>

<h3 id="example-3-how-do-we-swap-the-contents-of-two-boxes">Example 3: How do we swap the contents of two boxes?</h3>
<p><a id="markdown-example-3%3A-how-do-we-swap-the-contents-of-two-boxes%3F" name="example-3%3A-how-do-we-swap-the-contents-of-two-boxes%3F"></a></p>

<p>Add the following snippet to the <code class="language-plaintext highlighter-rouge">lib.rs</code> file next.</p>

<div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[test]</span>
<span class="nd">#[serial]</span>
<span class="k">fn</span> <span class="nf">swap_box_contents</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">b_1</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">100u8</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">b_2</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">200u8</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">og_b_1_addr</span> <span class="o">=</span> <span class="nd">print_ptr_addr_size!</span><span class="p">(</span><span class="n">b_1</span><span class="nf">.as_ref</span><span class="p">());</span>
    <span class="k">let</span> <span class="n">og_b_2_addr</span> <span class="o">=</span> <span class="nd">print_ptr_addr_size!</span><span class="p">(</span><span class="n">b_2</span><span class="nf">.as_ref</span><span class="p">());</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="o">*</span><span class="n">b_1</span><span class="p">,</span> <span class="mi">100u8</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="o">*</span><span class="n">b_2</span><span class="p">,</span> <span class="mi">200u8</span><span class="p">);</span>

    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"1. {}: {}, {} (pointee, heap): {}, {} (ptr, stack): {}"</span><span class="p">,</span>
        <span class="s">"b_1"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="n">b_1</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">(),</span>
        <span class="s">"b_1_addr"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="n">og_b_1_addr</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.red</span><span class="p">()</span><span class="nf">.italic</span><span class="p">()</span><span class="nf">.on_black</span><span class="p">(),</span>
        <span class="s">"b_1_ptr_addr"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="nd">print_ptr_addr_size!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b_1</span><span class="p">)</span>
            <span class="nf">.clone</span><span class="p">()</span>
            <span class="nf">.magenta</span><span class="p">()</span>
            <span class="nf">.italic</span><span class="p">()</span>
            <span class="nf">.on_black</span><span class="p">(),</span>
    <span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"2. {}: {}, {} (pointee, heap): {}, {} (ptr, stack): {}"</span><span class="p">,</span>
        <span class="s">"b_2"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="n">b_2</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">(),</span>
        <span class="s">"b_2_addr"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="n">og_b_2_addr</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.magenta</span><span class="p">()</span><span class="nf">.italic</span><span class="p">()</span><span class="nf">.on_black</span><span class="p">(),</span>
        <span class="s">"b_2_ptr_addr"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="nd">print_ptr_addr_size!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b_2</span><span class="p">)</span>
            <span class="nf">.clone</span><span class="p">()</span>
            <span class="nf">.cyan</span><span class="p">()</span>
            <span class="nf">.italic</span><span class="p">()</span>
            <span class="nf">.on_black</span><span class="p">(),</span>
    <span class="p">);</span>

    <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">b_1</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">b_2</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"Swapped b_1 and b_2"</span><span class="nf">.cyan</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">());</span>

    <span class="k">let</span> <span class="n">new_b_1_addr</span> <span class="o">=</span> <span class="nd">print_ptr_addr_size!</span><span class="p">(</span><span class="n">b_1</span><span class="nf">.as_ref</span><span class="p">());</span>
    <span class="k">let</span> <span class="n">new_b_2_addr</span> <span class="o">=</span> <span class="nd">print_ptr_addr_size!</span><span class="p">(</span><span class="n">b_2</span><span class="nf">.as_ref</span><span class="p">());</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="o">*</span><span class="n">b_1</span><span class="p">,</span> <span class="mi">200u8</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="o">*</span><span class="n">b_2</span><span class="p">,</span> <span class="mi">100u8</span><span class="p">);</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">og_b_1_addr</span><span class="p">,</span> <span class="n">new_b_2_addr</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">og_b_2_addr</span><span class="p">,</span> <span class="n">new_b_1_addr</span><span class="p">);</span>

    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"3. {}: {}, {} (pointee, heap): {}, {} (ptr, stack): {}"</span><span class="p">,</span>
        <span class="s">"b_1"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="n">b_1</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">(),</span>
        <span class="s">"b_1_addr"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="n">new_b_1_addr</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.magenta</span><span class="p">()</span><span class="nf">.italic</span><span class="p">()</span><span class="nf">.on_black</span><span class="p">(),</span>
        <span class="s">"b_1_ptr_addr"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="nd">print_ptr_addr_size!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b_1</span><span class="p">)</span>
            <span class="nf">.clone</span><span class="p">()</span>
            <span class="nf">.magenta</span><span class="p">()</span>
            <span class="nf">.italic</span><span class="p">()</span>
            <span class="nf">.on_black</span><span class="p">(),</span>
    <span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"4. {}: {}, {} (pointee, heap): {}, {} (ptr, stack): {}"</span><span class="p">,</span>
        <span class="s">"b_2"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="n">b_2</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">(),</span>
        <span class="s">"b_2_addr"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="n">new_b_2_addr</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.red</span><span class="p">()</span><span class="nf">.italic</span><span class="p">()</span><span class="nf">.on_black</span><span class="p">(),</span>
        <span class="s">"b_2_ptr_addr"</span><span class="nf">.green</span><span class="p">(),</span>
        <span class="nd">print_ptr_addr_size!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b_2</span><span class="p">)</span>
            <span class="nf">.clone</span><span class="p">()</span>
            <span class="nf">.cyan</span><span class="p">()</span>
            <span class="nf">.italic</span><span class="p">()</span>
            <span class="nf">.on_black</span><span class="p">(),</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here‚Äôs the output of the test above, after you run <code class="language-plaintext highlighter-rouge">cargo watch -x "test --lib -- --show-output swap"</code>.</p>

<pre class="pre-manual-highlight">
---- swap_box_contents stdout ----
1. <span style="color:#A3BE8C">b_1</span>: <span style="color:#81A1C1"><u style="text-decoration-style:solid">100</u></span>, <span style="color:#A3BE8C">b_1_addr</span> (pointee, heap): <span style="background-color:#3B4252"><span style="color:#BF616A"><i>0x722b38000d10‚îÜ1b</i></span></span>, <span style="color:#A3BE8C">b_1_ptr_addr</span> (ptr, stack): <span style="background-color:#3B4252"><span style="color:#B48EAD"><i>0x722b3cbfdad0‚îÜ8b</i></span></span>
2. <span style="color:#A3BE8C">b_2</span>: <span style="color:#81A1C1"><u style="text-decoration-style:solid">200</u></span>, <span style="color:#A3BE8C">b_2_addr</span> (pointee, heap): <span style="background-color:#3B4252"><span style="color:#B48EAD"><i>0x722b38001f30‚îÜ1b</i></span></span>, <span style="color:#A3BE8C">b_2_ptr_addr</span> (ptr, stack): <span style="background-color:#3B4252"><span style="color:#8FBCBB"><i>0x722b3cbfdad8‚îÜ8b</i></span></span>
<span style="color:#8FBCBB"><u style="text-decoration-style:solid">Swapped b_1 and b_2</u></span>
3. <span style="color:#A3BE8C">b_1</span>: <span style="color:#81A1C1"><u style="text-decoration-style:solid">200</u></span>, <span style="color:#A3BE8C">b_1_addr</span> (pointee, heap): <span style="background-color:#3B4252"><span style="color:#B48EAD"><i>0x722b38001f30‚îÜ1b</i></span></span>, <span style="color:#A3BE8C">b_1_ptr_addr</span> (ptr, stack): <span style="background-color:#3B4252"><span style="color:#B48EAD"><i>0x722b3cbfdad0‚îÜ8b</i></span></span>
4. <span style="color:#A3BE8C">b_2</span>: <span style="color:#81A1C1"><u style="text-decoration-style:solid">100</u></span>, <span style="color:#A3BE8C">b_2_addr</span> (pointee, heap): <span style="background-color:#3B4252"><span style="color:#BF616A"><i>0x722b38000d10‚îÜ1b</i></span></span>, <span style="color:#A3BE8C">b_2_ptr_addr</span> (ptr, stack): <span style="background-color:#3B4252"><span style="color:#8FBCBB"><i>0x722b3cbfdad8‚îÜ8b</i></span></span>
</pre>

<p>Let‚Äôs walk through the output above:</p>
<ol>
  <li>We have two <code class="language-plaintext highlighter-rouge">Box</code>es <code class="language-plaintext highlighter-rouge">b_1</code> and <code class="language-plaintext highlighter-rouge">b_2</code> that point to heap allocations of <code class="language-plaintext highlighter-rouge">u8</code> with values
<code class="language-plaintext highlighter-rouge">100</code> and <code class="language-plaintext highlighter-rouge">200</code> respectively. We get the address of the pointees using
the <code class="language-plaintext highlighter-rouge">print_ptr_addr_size!</code> macro with <code class="language-plaintext highlighter-rouge">b_1.as_ref()</code> and <code class="language-plaintext highlighter-rouge">b_2.as_ref()</code>. We get the
address of the pointers using the <code class="language-plaintext highlighter-rouge">print_ptr_addr_size!</code> macro with <code class="language-plaintext highlighter-rouge">&amp;b_1</code> and <code class="language-plaintext highlighter-rouge">&amp;b_2</code>.</li>
  <li>We swap the contents of <code class="language-plaintext highlighter-rouge">b_1</code> and <code class="language-plaintext highlighter-rouge">b_2</code> using <code class="language-plaintext highlighter-rouge">std::mem::swap(&amp;mut b_1, &amp;mut b_2)</code>.
The values of <code class="language-plaintext highlighter-rouge">b_1</code> and <code class="language-plaintext highlighter-rouge">b_2</code> are now <code class="language-plaintext highlighter-rouge">200</code> and <code class="language-plaintext highlighter-rouge">100</code> respectively.</li>
  <li>We get the new addresses of the pointees using the <code class="language-plaintext highlighter-rouge">print_ptr_addr_size!</code> macro with
<code class="language-plaintext highlighter-rouge">b_1.as_ref()</code> and <code class="language-plaintext highlighter-rouge">b_2.as_ref()</code>. We get the new addresses of the pointers using the
<code class="language-plaintext highlighter-rouge">print_ptr_addr_size!</code> macro with <code class="language-plaintext highlighter-rouge">&amp;b_1</code> and <code class="language-plaintext highlighter-rouge">&amp;b_2</code>.</li>
  <li>In the assertions, we check that the values of <code class="language-plaintext highlighter-rouge">b_1</code> and <code class="language-plaintext highlighter-rouge">b_2</code> are <code class="language-plaintext highlighter-rouge">200</code> and <code class="language-plaintext highlighter-rouge">100</code>
respectively. We check that the addresses of the pointees <strong>have</strong> swapped. And we check
that the addresses of the pointers have <strong>not</strong> swapped.</li>
</ol>

<h3 id="example-4-what-does-pining-a-box-do">Example 4: What does pining a box do?</h3>
<p><a id="markdown-example-4%3A-what-does-pining-a-box-do%3F" name="example-4%3A-what-does-pining-a-box-do%3F"></a></p>

<p>Add the following code to your <code class="language-plaintext highlighter-rouge">lib.rs</code> file.</p>

<div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">box_and_pin_dynamic_duo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">b_1</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">100u8</span><span class="p">);</span>
    <span class="c1">// Pointee.</span>
    <span class="k">let</span> <span class="n">b_1_addr</span> <span class="o">=</span> <span class="nd">print_ptr_addr_size!</span><span class="p">(</span><span class="n">b_1</span><span class="nf">.as_ref</span><span class="p">());</span>

    <span class="k">let</span> <span class="n">p_b_1</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">boxed</span><span class="p">::</span><span class="nn">Box</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">into_pin</span><span class="p">(</span><span class="n">b_1</span><span class="p">);</span>
    <span class="c1">// Pinned.</span>
    <span class="k">let</span> <span class="n">p_b_1_addr</span> <span class="o">=</span> <span class="nd">print_pin_addr_size!</span><span class="p">(</span><span class="n">p_b_1</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">b_2</span> <span class="o">=</span> <span class="n">p_b_1</span><span class="p">;</span>
    <span class="c1">// println!("{}", p_b_1); // ‚õî error: use of moved value: `p_b_1`</span>

    <span class="c1">// Pin does not move.</span>
    <span class="k">let</span> <span class="n">b_2_addr</span> <span class="o">=</span> <span class="nd">print_pin_addr_size!</span><span class="p">(</span><span class="n">b_2</span><span class="p">);</span>

    <span class="c1">// Pointee has not moved!</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">b_1_addr</span><span class="p">,</span> <span class="n">b_2_addr</span><span class="p">);</span>

    <span class="c1">// Pointer has not moved!</span>
    <span class="nf">assert_three_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b_1_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p_b_1_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b_2_addr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When you run the command <code class="language-plaintext highlighter-rouge">cargo watch -x "test --lib -- --show-output dynamic"</code> it doesn‚Äôt
really produce any output.</p>

<p>Let‚Äôs walk through the code above:</p>
<ol>
  <li>We have a <code class="language-plaintext highlighter-rouge">Box</code> <code class="language-plaintext highlighter-rouge">b_1</code> that points to a heap allocation of a <code class="language-plaintext highlighter-rouge">u8</code> with a value of <code class="language-plaintext highlighter-rouge">100</code>.
We get the address of the pointee using the <code class="language-plaintext highlighter-rouge">print_ptr_addr_size!</code> macro with
<code class="language-plaintext highlighter-rouge">b_1.as_ref()</code>.</li>
  <li>We pin <code class="language-plaintext highlighter-rouge">b_1</code> into <code class="language-plaintext highlighter-rouge">p_b_1</code> using <code class="language-plaintext highlighter-rouge">std::boxed::Box::&lt;u8&gt;::into_pin(b_1)</code>. The pointee
does not move. We get the address of the pinned pointer using the
<code class="language-plaintext highlighter-rouge">print_pin_addr_size!</code> macro with <code class="language-plaintext highlighter-rouge">p_b_1</code>.</li>
  <li>We move <code class="language-plaintext highlighter-rouge">p_b_1</code> into <code class="language-plaintext highlighter-rouge">b_2</code>. The pin does not move. We get the address of the pinned
pointer using the <code class="language-plaintext highlighter-rouge">print_pin_addr_size!</code> macro with <code class="language-plaintext highlighter-rouge">b_2</code>.</li>
  <li>In the assertions, we check that the pointee has <strong>not</strong> moved. And we check that the
pointer has <strong>not</strong> moved.</li>
</ol>

<h2 id="build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</h2>
<p><a id="markdown-build-with-naz-video-series-on-developerlife.com-youtube-channel" name="build-with-naz-video-series-on-developerlife.com-youtube-channel"></a></p>

<blockquote>
  <p>If you have comments and feedback on this content, or would like to request new content
(articles &amp; videos) on developerlife.com, please join our <a href="https://discord.gg/8M2ePAevaMi">discord
server</a>.</p>
</blockquote>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a></li>
  <li>Playlists
    <ul>
      <li><a href="https://www.youtube.com/watch?v=bolScvh4x7I&amp;list=PLofhE49PEwmw3MKOU1Kn3xbP4FRQR4Mb3">Build with Naz, Linux TTY, process, signals, commands in async Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmza94sS7UmJnN9gSCHTVTfz">Build with Naz, fundamental effective Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmwO69E7eiQ-ewnMME8ydgQ5">Build with Naz, effective async Rust and tokio</a></li>
      <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><category term="TUI" /><summary type="html"><![CDATA[This tutorial, video, and repo are a deep dive into Rust `Pin` and `Box` types, along with concepts of ownership and borrowing. We will also cover a lot of background information on the concepts of operating system process, memory allocation and access, stack, and heap. The examples we create are designed to demonstrate the different semantics around the use of boxes and pinned boxes in Rust.]]></summary></entry><entry><title type="html">Build with Naz : Rust async in practice tokio::select!, actor pattern &amp;amp; cancel safety</title><link href="http://developerlife.com/2024/07/10/rust-async-cancellation-safety-tokio/" rel="alternate" type="text/html" title="Build with Naz : Rust async in practice tokio::select!, actor pattern &amp;amp; cancel safety" /><published>2024-07-10T10:00:00-05:00</published><updated>2024-07-10T10:00:00-05:00</updated><id>http://developerlife.com/2024/07/10/rust-async-cancellation-safety-tokio</id><content type="html" xml:base="http://developerlife.com/2024/07/10/rust-async-cancellation-safety-tokio/"><![CDATA[<p><img class="post-hero-image" src="/assets/tokio-async-cancel-safety.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#what-can-go-wrong-when-racing-futures">What can go wrong when racing futures?</a></li>
  <li><a href="#youtube-video-for-this-article">YouTube video for this article</a></li>
  <li><a href="#examples-of-cancellation-safety-in-async-rust-using-tokioselect">Examples of cancellation safety in async Rust using tokio::select!</a>
    <ul>
      <li><a href="#example-1-right-and-wrong-way-to-sleep-and-interval">Example 1: Right and wrong way to sleep, and interval</a>
        <ul>
          <li><a href="#difference-between-interval-and-sleep">Difference between interval and sleep</a></li>
        </ul>
      </li>
      <li><a href="#example-2-safe-cancel-of-a-future-using-interval-and-mpsc-channel">Example 2: Safe cancel of a future using interval and mpsc channel</a></li>
      <li><a href="#example-3-inducing-cancellation-safety-issues">Example 3: Inducing cancellation safety issues</a></li>
    </ul>
  </li>
  <li><a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</a></li>
</ul>

<!-- /TOC -->

<h2 id="introduction">Introduction</h2>
<p><a id="markdown-introduction" name="introduction"></a></p>

<p>This tutorial, video, and repo are a deep dive into the concept of cancellation safety in
async code using Tokio and Rust. It affects the <code class="language-plaintext highlighter-rouge">tokio::select!</code> macro, and what happens
to the racing <code class="language-plaintext highlighter-rouge">Future</code>s that don‚Äôt win. The examples provided here, along with the video,
will go over both code that is is cancellation safe and code that is not. These examples
reflect real-world patterns, and are a generalized form of them.</p>

<p><code class="language-plaintext highlighter-rouge">tokio::select!</code> might as well have been called <code class="language-plaintext highlighter-rouge">tokio::race!</code> (there‚Äôs a <a href="https://en.wikipedia.org/wiki/The_Fast_and_the_Furious:_Tokyo_Drift">The Fast and
Furious : Tokyo
Drift</a> joke in there
somewhere).</p>

<p>It races the given futures in the branches of the macro, and the first one to resolve wins
(it is <code class="language-plaintext highlighter-rouge">Ready</code> when <code class="language-plaintext highlighter-rouge">poll()</code>ed). The other futures are dropped. These futures are run
concurrently, not in parallel, on the same worker thread, since we are not using
<code class="language-plaintext highlighter-rouge">tokio::spawn!</code> or its variants.</p>

<p>Here‚Äôs the basic setup:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">loop</span> <span class="p">{</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span><span class="p">{</span>
        <span class="n">branch_1_result</span> <span class="o">=</span> <span class="n">future_1</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="c1">// handle branch_1_result</span>
        <span class="p">},</span>
        <span class="n">branch_2_result</span> <span class="o">=</span> <span class="n">future_2</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="c1">// handle branch_2_result</span>
        <span class="p">},</span>
        <span class="c1">// and so on</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A classic example is that you‚Äôre reading something from an <em>async</em> network or file stream.
And you want to have a timeout that breaks out of the <code class="language-plaintext highlighter-rouge">loop</code> if it takes too long. In this
case you might have two branches:</p>
<ol>
  <li>A <code class="language-plaintext highlighter-rouge">tokio::time::sleep()</code> <code class="language-plaintext highlighter-rouge">Future</code> in the timeout branch.</li>
  <li>Some code to get the data asynchronously from the stream in the other branch.</li>
</ol>

<blockquote>
  <p>Another example is that you might be waiting for the user to type something from the
keyboard or mouse (such as a TUI app) and also listen for signals to shut down the app,
or other signals to perform re-rendering of the TUI. You can see this <a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/terminal_window/main_event_loop.rs#L94">in <code class="language-plaintext highlighter-rouge">r3bl_tui</code>
here</a>
and <a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/terminal_async/src/readline_impl/readline.rs#L468">in <code class="language-plaintext highlighter-rouge">r3bl_terminal_async</code>
here</a>.</p>
</blockquote>

<p>Note that all branches must have a <code class="language-plaintext highlighter-rouge">Future</code> to call <code class="language-plaintext highlighter-rouge">.await</code> on. The macro does not
require you to call <code class="language-plaintext highlighter-rouge">.await</code>. The code it generates take care of this.</p>

<blockquote>
  <p>It might be worth your time (if you haven‚Äôt already) to read the <a href="https://docs.rs/tokio/latest/tokio/macro.select.html#cancellation-safety">official Tokio
docs</a> on
<code class="language-plaintext highlighter-rouge">tokio::select!</code> macro and the concept of cancellation safety before diving into the
examples below.</p>
</blockquote>

<h2 id="what-can-go-wrong-when-racing-futures">What can go wrong when racing futures?</h2>
<p><a id="markdown-what-can-go-wrong-when-racing-futures%3F" name="what-can-go-wrong-when-racing-futures%3F"></a></p>

<p>If you recall, in Rust, a <code class="language-plaintext highlighter-rouge">Future</code> is just a data structure that doesn‚Äôt really do
anything until you <code class="language-plaintext highlighter-rouge">.await</code> it.</p>
<ul>
  <li>The Tokio runtime actually does work on the <code class="language-plaintext highlighter-rouge">Future</code>s by polling them to see whether
they are <code class="language-plaintext highlighter-rouge">Ready</code> or <code class="language-plaintext highlighter-rouge">Pending</code>.</li>
  <li>If they‚Äôre not <code class="language-plaintext highlighter-rouge">Ready</code> they go back to waiting until their <code class="language-plaintext highlighter-rouge">Waker</code> is called, and then
Tokio will <code class="language-plaintext highlighter-rouge">poll()</code> them again.</li>
  <li>They are cheap to create, they are stateful, and they can be nested (easily composed).</li>
</ul>

<blockquote>
  <p>Please read our article on <a href="https://developerlife.com/2024/05/19/effective-async-rust/">effective async
Rust</a> to get a better
understanding of how async Rust, and <code class="language-plaintext highlighter-rouge">Future</code>s works and how runtimes are implemented.</p>
</blockquote>

<p>These are some of the great things about Rust <code class="language-plaintext highlighter-rouge">Future</code>s. However, the nature of a Rust
<code class="language-plaintext highlighter-rouge">Future</code> is what may cause a problem with ‚Äúcancellation safety‚Äù in the <code class="language-plaintext highlighter-rouge">tokio::select!</code>
macro.</p>

<p>So what happens to <code class="language-plaintext highlighter-rouge">future_2</code> (the branch reading or writing from an async stream) if the
timeout branch (for <code class="language-plaintext highlighter-rouge">future_1</code>) wins the race?</p>
<ul>
  <li>Is the <code class="language-plaintext highlighter-rouge">future_2</code> in the middle of doing something when this happens?</li>
  <li>And if so, what happens to the work it was doing when it hits the <code class="language-plaintext highlighter-rouge">.await</code> point in its
code, and then stops?</li>
</ul>

<p>This is the crux of the issue with cancellation safety in async Rust code. Lots of <code class="language-plaintext highlighter-rouge">tokio</code>
code is built to be cancellation safe, so if you‚Äôre using <code class="language-plaintext highlighter-rouge">mpsc</code> or <code class="language-plaintext highlighter-rouge">broadcast</code> channels,
async streams, etc. you will be fine. However if you‚Äôre maintaining state inside the
<code class="language-plaintext highlighter-rouge">future_2</code> and then it is dropped, then this article will help you understand what
happens.</p>

<h2 id="youtube-video-for-this-article">YouTube video for this article</h2>
<p><a id="markdown-youtube-video-for-this-article" name="youtube-video-for-this-article"></a></p>

<p>This blog post has examples from this live coding video. If you like
to learn via video, please watch the companion video on the <a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube
channel</a>.</p>

<!-- video on tokio-async-cancel-safety -->
<iframe src="https://www.youtube.com/embed/cQq5i8J1ELg?si=UDgJdFFQn0-yNXsS" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<p><br /></p>

<h2 id="examples-of-cancellation-safety-in-async-rust-using-tokioselect">Examples of cancellation safety in async Rust using tokio::select!</h2>
<p><a id="markdown-examples-of-cancellation-safety-in-async-rust-using-tokio%3A%3Aselect!" name="examples-of-cancellation-safety-in-async-rust-using-tokio%3A%3Aselect!"></a></p>

<p>Let‚Äôs create some examples to illustrate how to use the typestate pattern in Rust. You can run
<code class="language-plaintext highlighter-rouge">cargo new --lib async_cancel_safe</code> to create a new library crate.</p>

<blockquote>
  <p>üí° You can get the code from the
<a href="https://github.com/nazmulidris/rust-scratch/tree/main/async_cancel_safe"><code class="language-plaintext highlighter-rouge">rust-scratch</code></a> repo.</p>
</blockquote>

<p>Then add the following to the <code class="language-plaintext highlighter-rouge">Cargo.toml</code> file that‚Äôs generated. These pull in all the
dependencies that we need for these examples.</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[package]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"async_cancel_safe"</span>
<span class="py">version</span> <span class="p">=</span> <span class="s">"0.1.0"</span>
<span class="py">edition</span> <span class="p">=</span> <span class="s">"2021"</span>

<span class="nn">[dependencies]</span>
<span class="py">tokio</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"1.38.0"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"full"</span><span class="p">]</span> <span class="p">}</span>

<span class="c"># Async stream testing.</span>
<span class="py">r3bl_test_fixtures</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.0.2"</span> <span class="p">}</span>
<span class="py">futures-util</span> <span class="p">=</span> <span class="s">"0.3.30"</span>
</code></pre></div></div>

<p>We are going to add all the examples below as tests to the <code class="language-plaintext highlighter-rouge">lib.rs</code> file in this crate.</p>

<h3 id="example-1-right-and-wrong-way-to-sleep-and-interval">Example 1: Right and wrong way to sleep, and interval</h3>
<p><a id="markdown-example-1%3A-right-and-wrong-way-to-sleep%2C-and-interval" name="example-1%3A-right-and-wrong-way-to-sleep%2C-and-interval"></a></p>

<p>Add the following code to your <code class="language-plaintext highlighter-rouge">lib.rs</code> file. Both these examples show similar ways of using
<code class="language-plaintext highlighter-rouge">tokio::time::sleep(..)</code> incorrectly in a <code class="language-plaintext highlighter-rouge">tokio::select!</code> block.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Equivalent to [test_sleep_right_and_wrong_ways_v2]. This test uses</span>
<span class="cd">/// [`tokio::pin`] and [`tokio::time::sleep`].</span>
<span class="cd">/// Run the test using:</span>
<span class="cd">/// `cargo test -- --nocapture test_sleep_right_and_wrong_ways_v1`</span>
<span class="nd">#[tokio::test]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">test_sleep_right_and_wrong_ways_v1</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">sleep_time</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">duration</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="n">sleep_time</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">sleep</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="n">duration</span><span class="p">);</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nd">pin!</span><span class="p">(</span><span class="n">sleep</span><span class="p">);</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span> <span class="p">{</span>
            <span class="c1">// Branch 1 (right way)</span>
            <span class="c1">// This branch executes a deterministic number of times. The same</span>
            <span class="c1">// sleep future is re-used on each iteration.</span>
            <span class="n">_</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">sleep</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"branch 1 - tick : {count}"</span><span class="p">);</span>
                <span class="n">count</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="c1">// Branch 2 (wrong way)</span>
            <span class="c1">// This branch is executed a non deterministic number of times.</span>
            <span class="c1">// This is because the sleep future is not pinned. It is dropped</span>
            <span class="c1">// when the other branch is executed. Then on the next iteration,</span>
            <span class="c1">// a new sleep future is created.</span>
            <span class="n">_</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"branch 2 - sleep"</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cd">/// Equivalent to [test_sleep_right_and_wrong_ways_v1]. This test uses</span>
<span class="cd">/// [`tokio::time::interval()`]</span>
<span class="cd">/// Run the test using:</span>
<span class="cd">/// `cargo test -- --nocapture test_sleep_right_and_wrong_ways_v2`</span>
<span class="nd">#[tokio::test]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">test_sleep_right_and_wrong_ways_v2</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">sleep_time</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">duration</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="n">sleep_time</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">interval</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">interval</span><span class="p">(</span><span class="n">duration</span><span class="p">);</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span> <span class="p">{</span>
            <span class="c1">// Branch 1 (right way)</span>
            <span class="c1">// This branch executes a deterministic number of times. The same</span>
            <span class="c1">// sleep future is re-used on each iteration.</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">interval</span><span class="nf">.tick</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"branch 1 - tick : {count}"</span><span class="p">);</span>
                <span class="n">count</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="c1">// Branch 2 (wrong way)</span>
            <span class="c1">// This branch is executed a non deterministic number of times.</span>
            <span class="c1">// This is because the sleep future is not pinned. It is dropped</span>
            <span class="c1">// when the other branch is executed. Then on the next iteration,</span>
            <span class="c1">// a new sleep future is created.</span>
            <span class="n">_</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"branch 2 - sleep"</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>You can run these tests to see what they do by running the following in your terminal:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">cargo test -- --nocapture test_sleep_right_and_wrong_ways_v1</code></li>
  <li><code class="language-plaintext highlighter-rouge">cargo test -- --nocapture test_sleep_right_and_wrong_ways_v2</code></li>
</ul>

<p>They are flaky and its not possible to really make accurate assertions at the end of
each of these tests.</p>

<p>Let‚Äôs break down <code class="language-plaintext highlighter-rouge">v1</code> first to see what is happening.</p>

<ul>
  <li>Branch 1 (right way): This branch executes a deterministic number of times. The same
sleep future is re-used on each iteration. This is achieved using the <code class="language-plaintext highlighter-rouge">tokio::pin!</code>
macro. Since futures are stateful, ensuring that the same one is re-used between
iterations of the <code class="language-plaintext highlighter-rouge">loop</code> ensures that state isn‚Äôt lost when the other branch is
executed, or when this branch finishes and its future is dropped.</li>
  <li>Branch 2 (wrong way): This branch is executed a non deterministic number of times. This
is because the sleep future is not pinned. It is dropped when the other branch is
executed. Then on the next iteration, a <strong>new</strong> sleep future is created. This means that
the state of the future is lost, and its behavior with providing a reliable delay is
non deterministic.</li>
</ul>

<p>Let‚Äôs break down <code class="language-plaintext highlighter-rouge">v2</code> next.</p>

<ul>
  <li>Branch 1 (right way): This branch executes a deterministic number of times. However, we
are using <code class="language-plaintext highlighter-rouge">tokio::time::interval()</code> this time around. It is re-used between many
iterations of the <code class="language-plaintext highlighter-rouge">loop</code>. This function returns a <code class="language-plaintext highlighter-rouge">Interval</code> struct that has a <code class="language-plaintext highlighter-rouge">tick()</code>
method that returns a <code class="language-plaintext highlighter-rouge">Future</code> that resolves when the interval has elapsed.</li>
  <li>Branch 2 (wrong way): Same as before.</li>
</ul>

<h4 id="difference-between-interval-and-sleep">Difference between interval and sleep</h4>
<p><a id="markdown-difference-between-interval-and-sleep" name="difference-between-interval-and-sleep"></a></p>

<p>This is the mental model that I‚Äôve developed for using these.</p>

<ol>
  <li>If your intention is to have a single timeout then, <code class="language-plaintext highlighter-rouge">sleep</code> might be the way to go. You
create and <code class="language-plaintext highlighter-rouge">tokio::pin!</code> the <code class="language-plaintext highlighter-rouge">sleep</code> future, and then re-use it in the <code class="language-plaintext highlighter-rouge">loop</code>. Once
this timeout expires, then you can handle your timeout condition in that branch.</li>
  <li>If your intention is to have a re-usable timer that ticks on a regular interval, then
<code class="language-plaintext highlighter-rouge">interval</code> is the way to go. You create the <code class="language-plaintext highlighter-rouge">interval</code> outside the <code class="language-plaintext highlighter-rouge">loop</code>, and then
call <code class="language-plaintext highlighter-rouge">tick()</code> on it in the <code class="language-plaintext highlighter-rouge">loop</code>. This will give you a <code class="language-plaintext highlighter-rouge">Future</code> that resolves when the
interval has elapsed. And you can safely use this same <code class="language-plaintext highlighter-rouge">Interval</code> repeatedly in the
loop. And even accumulate how many times it runs to decide when to break.</li>
</ol>

<h3 id="example-2-safe-cancel-of-a-future-using-interval-and-mpsc-channel">Example 2: Safe cancel of a future using interval and mpsc channel</h3>
<p><a id="markdown-example-2%3A-safe-cancel-of-a-future-using-interval-and-mpsc-channel" name="example-2%3A-safe-cancel-of-a-future-using-interval-and-mpsc-channel"></a></p>

<p>Add the following snippet to your <code class="language-plaintext highlighter-rouge">lib.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Run the test using:</span>
<span class="cd">/// `cargo test -- --nocapture test_safe_cancel_example`</span>
<span class="nd">#[tokio::test]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">test_safe_cancel_example</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">sleep_time</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">duration</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="n">sleep_time</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">interval</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">interval</span><span class="p">(</span><span class="n">duration</span><span class="p">);</span>

    <span class="c1">// Shutdown channel.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="k">mut</span> <span class="n">rx</span><span class="p">)</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">mpsc</span><span class="p">::</span><span class="nf">channel</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">vec</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span> <span class="p">{</span>
            <span class="c1">// Branch 1.</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">interval</span><span class="nf">.tick</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"branch 1 - tick : count {}"</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

                <span class="n">vec</span><span class="nf">.push</span><span class="p">(</span><span class="n">count</span><span class="p">);</span>
                <span class="n">count</span> <span class="o">=</span> <span class="n">count</span><span class="nf">.saturating_sub</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

                <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="n">_</span> <span class="o">=</span> <span class="n">tx</span><span class="nf">.try_send</span><span class="p">(());</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="c1">// Branch 2.</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">rx</span><span class="nf">.recv</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"branch 2 =&gt; shut down"</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When you run this test using <code class="language-plaintext highlighter-rouge">cargo test -- --nocapture test_safe_cancel_example</code>, you should
get this output in your terminal:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>running 1 test
branch 1 - tick : count 5
branch 1 - tick : count 4
branch 1 - tick : count 3
branch 1 - tick : count 2
branch 1 - tick : count 1
branch 2 =&gt; shut down
</code></pre></div></div>

<p>Let‚Äôs break down what‚Äôs happening in this test.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Branch 1</code> - The <code class="language-plaintext highlighter-rouge">interval</code> is created outside the <code class="language-plaintext highlighter-rouge">loop</code> and is used to create a
<code class="language-plaintext highlighter-rouge">Future</code> that resolves when the interval has elapsed. This happens in <code class="language-plaintext highlighter-rouge">Branch 1</code> and we
let this branch run <code class="language-plaintext highlighter-rouge">5</code> times before sending a message on the <code class="language-plaintext highlighter-rouge">tx</code> channel.</li>
  <li><code class="language-plaintext highlighter-rouge">Branch 2</code> - The <code class="language-plaintext highlighter-rouge">tx</code> channel is used to send a message to the <code class="language-plaintext highlighter-rouge">rx</code> channel. This is
done in <code class="language-plaintext highlighter-rouge">Branch 1</code> when <code class="language-plaintext highlighter-rouge">count</code> reaches <code class="language-plaintext highlighter-rouge">0</code>. The <code class="language-plaintext highlighter-rouge">rx</code> channel is used to receive a
message. This is done in <code class="language-plaintext highlighter-rouge">Branch 2</code> and when a message is received, we break out of the
<code class="language-plaintext highlighter-rouge">loop</code>.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">Branch 1</code> runs 5 times, and <code class="language-plaintext highlighter-rouge">Branch 1</code> runs 1 time and breaks out of the loop. If you
look at the <code class="language-plaintext highlighter-rouge">vec</code> that we accumulate outside of the <code class="language-plaintext highlighter-rouge">loop</code> this contains what we expect.</p>

<h3 id="example-3-inducing-cancellation-safety-issues">Example 3: Inducing cancellation safety issues</h3>
<p><a id="markdown-example-3%3A-inducing-cancellation-safety-issues" name="example-3%3A-inducing-cancellation-safety-issues"></a></p>

<p>This is the example we have all been waiting for. Let‚Äôs start with copying the
following snippet in your <code class="language-plaintext highlighter-rouge">lib.rs</code> file. We will create a new module here.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="k">pub</span> <span class="k">mod</span> <span class="n">test_unsafe_cancel_example</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">r3bl_test_fixtures</span><span class="p">::{</span><span class="n">gen_input_stream_with_delay</span><span class="p">,</span> <span class="n">PinnedInputStream</span><span class="p">};</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_input_vec</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_stream_delay</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="n">Duration</span> <span class="p">{</span>
        <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">get_input_stream</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">PinnedInputStream</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">gen_input_stream_with_delay</span><span class="p">(</span><span class="nf">get_input_vec</span><span class="p">(),</span> <span class="nf">get_stream_delay</span><span class="p">())</span>
    <span class="p">}</span>

    <span class="cd">/// This is just to see how to use the async stream [gen_input_stream()].</span>
    <span class="nd">#[tokio::test]</span>
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">test_generate_event_stream_pinned</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">use</span> <span class="nn">futures_util</span><span class="p">::</span><span class="n">StreamExt</span><span class="p">;</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">stream</span> <span class="o">=</span> <span class="nf">get_stream</span><span class="p">();</span>

        <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">=</span> <span class="n">stream</span><span class="nf">.next</span><span class="p">()</span><span class="k">.await</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">lhs</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">rhs</span> <span class="o">=</span> <span class="nf">get_input_vec</span><span class="p">()[</span><span class="n">count</span><span class="p">];</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// &lt;more stuff to add later&gt;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Let‚Äôs break down what‚Äôs happening here.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">get_input_vec()</code> - This function returns a <code class="language-plaintext highlighter-rouge">Vec&lt;usize&gt;</code> that we will use to generate
events in the <code class="language-plaintext highlighter-rouge">gen_input_stream()</code> function. This is meant to simulate the stream of
<code class="language-plaintext highlighter-rouge">usize</code> values that may be generated from reading a file or a network source. Or even
write to a file or network source. We could have just made these <code class="language-plaintext highlighter-rouge">u8</code>, but this is a
made up test, so we are using <code class="language-plaintext highlighter-rouge">usize</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">gen_input_stream()</code> - This is where things get interesting. This function creates an
async stream that yields the values from the <code class="language-plaintext highlighter-rouge">Vec&lt;usize&gt;</code> returned by <code class="language-plaintext highlighter-rouge">get_input_vec()</code>.
It waits for <code class="language-plaintext highlighter-rouge">100ms</code> between each value that it yields. This is to simulate the delay
that might be present when reading from a file or network source. Note the trait magic
and imports that are used to make this work; to get the details on this, check our
article on <a href="https://developerlife.com/2024/04/28/rust-polymorphism-dyn-impl-trait-objects-for-testing-and-extensibiity/">trait pointers and
testing</a>.</li>
  <li>These two functions are our test fixture to simulate a slow async stream. Now, let‚Äôs
test the test fixtures in <code class="language-plaintext highlighter-rouge">test_generate_event_stream_pinned()</code>. This test simply reads
from the async stream and compares the values that it reads with the values that are
expected from the <code class="language-plaintext highlighter-rouge">Vec&lt;usize&gt;</code> returned by <code class="language-plaintext highlighter-rouge">get_input_vec()</code>.</li>
</ul>

<blockquote>
  <p>You can get the <code class="language-plaintext highlighter-rouge">r3bl_test_fixtures</code> <a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/test_fixtures">source
here</a>. You can get
the crate from <a href="https://crates.io/crates/r3bl_test_fixtures">crates.io</a>.</p>
</blockquote>

<p>In <code class="language-plaintext highlighter-rouge">lib.rs</code> replace the <code class="language-plaintext highlighter-rouge">// &lt;more stuff to add later&gt;</code> with the following code:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// There is no need to [futures_util::FutureExt::fuse()] the items in each</span>
<span class="cd">/// [tokio::select!] branch. This is because Tokio's event loop is designed to handle</span>
<span class="cd">/// this efficiently by remembering the state of each future across iterations.</span>
<span class="cd">///</span>
<span class="cd">/// More info: &lt;https://gemini.google.com/app/e55fd62339b674fb&gt;</span>
<span class="nd">#[rustfmt::skip]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">read_3_items_not_cancel_safe</span><span class="p">(</span><span class="n">stream</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">PinnedInputStream</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">use</span> <span class="nn">futures_util</span><span class="p">::</span><span class="n">StreamExt</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">vec</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"branch 2 =&gt; entering read_3_items_not_cancel_safe"</span><span class="p">);</span>

    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">3</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">item</span> <span class="o">=</span> <span class="n">stream</span><span class="nf">.next</span><span class="p">()</span> <span class="cm">/* .fuse() */</span> <span class="k">.await</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"branch 2 =&gt; read_3_items_not_cancel_safe got item: {item}"</span><span class="p">);</span>
        <span class="n">vec</span><span class="nf">.push</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"branch 2 =&gt; vec so far contains: {vec:?}"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">vec</span>
<span class="p">}</span>

<span class="cd">/// There is no need to [futures_util::FutureExt::fuse()] the items in each</span>
<span class="cd">/// [tokio::select!] branch. This is because Tokio's event loop is designed to handle</span>
<span class="cd">/// this efficiently by remembering the state of each future across iterations.</span>
<span class="cd">///</span>
<span class="cd">/// More info: &lt;https://gemini.google.com/app/e55fd62339b674fb&gt;</span>
<span class="nd">#[tokio::test]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">test_unsafe_cancel_stream</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">futures_util</span><span class="p">::</span><span class="n">StreamExt</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">stream</span> <span class="o">=</span> <span class="nf">get_input_stream</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">sleep_time</span> <span class="o">=</span> <span class="mi">300</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">duration</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="n">sleep_time</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">sleep</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="n">duration</span><span class="p">);</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nd">pin!</span><span class="p">(</span><span class="n">sleep</span><span class="p">);</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span> <span class="p">{</span>
            <span class="c1">// Branch 1 - Timeout.</span>
            <span class="n">_</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">sleep</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"branch 1 - time is up - end"</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// Branch 2 - Read from stream.</span>
            <span class="n">it</span> <span class="o">=</span> <span class="nf">read_3_items_not_cancel_safe</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">stream</span><span class="p">)</span> <span class="cm">/* .fuse() */</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"branch 2 - got 3 items: {it:?}"</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"loop exited"</span><span class="p">);</span>

    <span class="c1">// Only [1, 2] is consumed by Branch 2 before the timeout happens</span>
    <span class="c1">// in Branch 1.</span>
    <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="n">stream</span><span class="nf">.next</span><span class="p">()</span><span class="k">.await</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When you run this test using <code class="language-plaintext highlighter-rouge">cargo test -- --nocapture test_unsafe_cancel_stream</code>, you
can expect the following output in your terminal.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>branch 2 =&gt; entering read_3_items_not_cancel_safe
yielding item: 1
branch 2 =&gt; read_3_items_not_cancel_safe got item: 1
branch 2 =&gt; vec so far contains: [1]
yielding item: 2
branch 2 =&gt; read_3_items_not_cancel_safe got item: 2
branch 2 =&gt; vec so far contains: [1, 2]
branch 1 - time is up - end
loop exited
yielding item: 3
</code></pre></div></div>

<p>So let‚Äôs break down what‚Äôs happening in this test.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Branch 1</code> - This branch is a timeout branch. It waits for <code class="language-plaintext highlighter-rouge">300ms</code> before breaking out
of the loop. This is to simulate a timeout that might happen when reading from a file or
network source. With this delay, we ensure that <code class="language-plaintext highlighter-rouge">Branch 2</code> doesn‚Äôt get to read all the
values from the async stream. And thus we induce a cancellation safety issue, due the
way <code class="language-plaintext highlighter-rouge">read_3_items_not_cancel_safe()</code> is implemented.</li>
  <li><code class="language-plaintext highlighter-rouge">Branch 2</code> - This branch needs to reads <code class="language-plaintext highlighter-rouge">3</code> items from the async stream before
resolving. This is done in a loop that reads <code class="language-plaintext highlighter-rouge">3</code> items in
<code class="language-plaintext highlighter-rouge">read_3_items_not_cancel_safe()</code>. This is not safe because if the timeout branch wins
the race, then the stream is dropped and the <code class="language-plaintext highlighter-rouge">read_3_items_not_cancel_safe()</code> future is
dropped, along with the contained <code class="language-plaintext highlighter-rouge">vec</code>! This means that the stream is dropped before
all the items are read from it. This is the cancellation safety issue that we are
inducing in this test.</li>
</ul>

<p>There are many ways to resolve this. The key is not to hold state inside of a <code class="language-plaintext highlighter-rouge">Future</code>
that you don‚Äôt want to lose if the <code class="language-plaintext highlighter-rouge">Future</code> is dropped. You can use <code class="language-plaintext highlighter-rouge">mpsc</code> channels or a
pinned <code class="language-plaintext highlighter-rouge">Vec</code> to get around this issue.</p>

<blockquote>
  <p>Note that in the case of a graceful shutdown, where you might not care about what data
in some buffer is dropped, then this is not a problem.</p>
</blockquote>

<h2 id="build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</h2>
<p><a id="markdown-build-with-naz-video-series-on-developerlife.com-youtube-channel" name="build-with-naz-video-series-on-developerlife.com-youtube-channel"></a></p>

<blockquote>
  <p>If you have comments and feedback on this content, or would like to request new content
(articles &amp; videos) on developerlife.com, please join our <a href="https://discord.gg/8M2ePAevaMi">discord
server</a>.</p>
</blockquote>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a></li>
  <li>Playlists
    <ul>
      <li><a href="https://www.youtube.com/watch?v=bolScvh4x7I&amp;list=PLofhE49PEwmw3MKOU1Kn3xbP4FRQR4Mb3">Build with Naz, Linux TTY, process, signals, commands in async Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmza94sS7UmJnN9gSCHTVTfz">Build with Naz, fundamental effective Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmwO69E7eiQ-ewnMME8ydgQ5">Build with Naz, effective async Rust and tokio</a></li>
      <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><category term="TUI" /><summary type="html"><![CDATA[This tutorial, video, and repo are a deep dive into the concept of cancellation safety in async code using Tokio and Rust. It affects the `tokio::select!` macro, and what happens to the racing `Future`s that don't win. The examples provided here, along with the video, will go over both code that is is cancellation safe and code that is not. These examples reflect real-world patterns, and are a generalized form of them.]]></summary></entry><entry><title type="html">Build with Naz : Ubuntu 24.04 setup and config for dev productivity</title><link href="http://developerlife.com/2024/07/08/ubuntu24/" rel="alternate" type="text/html" title="Build with Naz : Ubuntu 24.04 setup and config for dev productivity" /><published>2024-07-08T10:00:00-05:00</published><updated>2024-07-08T10:00:00-05:00</updated><id>http://developerlife.com/2024/07/08/ubuntu24</id><content type="html" xml:base="http://developerlife.com/2024/07/08/ubuntu24/"><![CDATA[<p><img class="post-hero-image" src="/assets/ubuntu24.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#related-videos">Related videos</a></li>
  <li><a href="#what-comes-with-the-scripts">What comes with the scripts</a></li>
  <li><a href="#running-the-scripts">Running the scripts</a></li>
  <li><a href="#gnome-extensions">Gnome Extensions</a></li>
  <li><a href="#keyboard-remapping">Keyboard remapping</a>
    <ul>
      <li><a href="#tilix-and-quake-mode">Tilix and quake mode</a></li>
      <li><a href="#remap-superq">Remap Super+Q</a></li>
      <li><a href="#remap-caps-lock-to-ctrl">Remap Caps Lock to Ctrl</a></li>
    </ul>
  </li>
  <li><a href="#chrome-issues-w-wayland">Chrome issues w/ Wayland</a></li>
  <li><a href="#libfuse2-and-appimage-issues">libfuse2 and AppImage issues</a>
    <ul>
      <li><a href="#approach-1---simple">Approach 1 - simple</a></li>
      <li><a href="#approach-2---complex">Approach 2 - complex</a></li>
    </ul>
  </li>
  <li><a href="#settings---key-mappings">Settings -&gt; Key mappings</a></li>
  <li><a href="#obs-studio-issues">OBS Studio issues</a></li>
  <li><a href="#fontconfig">Fontconfig</a></li>
  <li><a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</a></li>
</ul>

<!-- /TOC -->

<h2 id="introduction">Introduction</h2>
<p><a id="markdown-introduction" name="introduction"></a></p>

<p>I‚Äôve provided scripts for setting up a new Ubuntu 24.04 desktop machine. They have been
tested on a fresh install of Ubuntu 24.04 LTS. They contain all the software that is
needed for Rust development, OBS Studio use, and general developer productivity. They are
highly opinionated for my use case, but you can modify them to suit your needs. I‚Äôve also
recently migrated from Pop_OS! 22.04.</p>

<h2 id="related-videos">Related videos</h2>
<p><a id="markdown-related-videos" name="related-videos"></a></p>

<p>This video shows what the scripts do after you run them, and how they make your Ubuntu
24.04 desktop environment look and feel. This article is really a companion to the video.</p>

<!-- linux keyboard productivity guide -->
<iframe src="https://www.youtube.com/embed/iNSnvfguChU?si=kxcIa6lI9ZX2WfHz" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<p><br />
This video is all about keyboard customization and productivity on Linux. It‚Äôs a great
companion to the scripts that I‚Äôve provided in this article. It is highly reliant on the
use of the <a href="https://ultimatehackingkeyboard.com/">UHK v2 keyboard</a>.</p>

<!-- video on ubuntu24 -->
<iframe src="https://www.youtube.com/embed/zGljNewTc0I?si=D5-5P0afPVBw-3IB" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<p><br /></p>

<h2 id="what-comes-with-the-scripts">What comes with the scripts</h2>
<p><a id="markdown-what-comes-with-the-scripts" name="what-comes-with-the-scripts"></a></p>

<blockquote>
  <p>üí° You can get the scripts from the
<a href="https://github.com/nazmulidris/rust-scratch/tree/main/ubuntu24"><code class="language-plaintext highlighter-rouge">rust-scratch</code></a> repo.</p>
</blockquote>

<p>Here is a non exhaustive list of software that will be installed:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">fish</code> as the default login shell. All the configuration scripts are written in <code class="language-plaintext highlighter-rouge">fish</code>.
 <code class="language-plaintext highlighter-rouge">bass</code> is also installed to allow for running <code class="language-plaintext highlighter-rouge">bash</code> scripts in <code class="language-plaintext highlighter-rouge">fish</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">rustup</code>, <code class="language-plaintext highlighter-rouge">brew</code>, and <code class="language-plaintext highlighter-rouge">flatpak</code> with <code class="language-plaintext highlighter-rouge">flathub</code> as package managers.</li>
  <li><code class="language-plaintext highlighter-rouge">docker</code> and <code class="language-plaintext highlighter-rouge">docker-compose</code> for containerization.</li>
  <li><code class="language-plaintext highlighter-rouge">obs-studio</code> for screen recording and streaming.</li>
  <li><code class="language-plaintext highlighter-rouge">vlc</code>, <code class="language-plaintext highlighter-rouge">mpv</code> for media playback.</li>
  <li><code class="language-plaintext highlighter-rouge">chrome</code> for web browsing.</li>
  <li><code class="language-plaintext highlighter-rouge">vscode</code> for code editing.</li>
  <li>Lots of Gnome extensions for desktop customization.</li>
  <li><code class="language-plaintext highlighter-rouge">nerd-fonts</code> for terminal font customization. Along with <code class="language-plaintext highlighter-rouge">guake</code> and <code class="language-plaintext highlighter-rouge">tilix</code> for
 terminal emulators. Along with <code class="language-plaintext highlighter-rouge">tmux</code> for terminal multiplexing.</li>
</ol>

<blockquote>
  <p>To download Ubuntu 24.04, visit the <a href="https://ubuntu.com/download/desktop">Ubuntu
website</a> and prepare a USB drive with the ISO file
for installation. You can use <a href="https://flathub.org/apps/com.system76.Popsicle">Popsicle</a>
to create a bootable USB drive.</p>
</blockquote>

<h2 id="running-the-scripts">Running the scripts</h2>
<p><a id="markdown-running-the-scripts" name="running-the-scripts"></a></p>

<p>Lots of customized font configurations are included in the scripts. You can clone the repo
and run the scripts, or just copy the links below and run them in your terminal.</p>

<p>You can run the following commands to get this on your machine. The first script
<code class="language-plaintext highlighter-rouge">0-bootstrap.bash</code> has to be installed first. It installs <code class="language-plaintext highlighter-rouge">fish</code> shell and makes it the
default and installs <code class="language-plaintext highlighter-rouge">flatpak</code> and <code class="language-plaintext highlighter-rouge">flatpak flathub</code>. It also installs <code class="language-plaintext highlighter-rouge">bass</code> to allow
running bash scripts in fish. The remainder of the scripts can be run in any order.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install</span> <span class="nt">-y</span> curl git
<span class="nb">cd</span> ~/Downloads/
git clone https://github.com/nazmulidris/rust-scratch/
<span class="nb">cd </span>rust-scratch/ubuntu24/
./0-bootstrap.bash
<span class="c"># You will need to reboot after running the 0-bootstrap.bash script</span>
</code></pre></div></div>

<p>Once you reboot, you can run the following scripts.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> ~/Downloads/rust-scratch/ubuntu24/
./1-install.fish
./2-install-docker.bash
./3-install-fonts.fish
</code></pre></div></div>

<p>You can see the contents of the scripts by clicking on the links below:</p>

<ol>
  <li><a href="https://raw.githubusercontent.com/nazmulidris/rust-scratch/main/ubuntu24/0-bootstrap.bash">https://raw.githubusercontent.com/nazmulidris/rust-scratch/main/ubuntu24/0-bootstrap.bash</a></li>
  <li><a href="https://raw.githubusercontent.com/nazmulidris/rust-scratch/main/ubuntu24/1-install.fish">https://raw.githubusercontent.com/nazmulidris/rust-scratch/main/ubuntu24/1-install.fish</a></li>
  <li><a href="https://raw.githubusercontent.com/nazmulidris/rust-scratch/main/ubuntu24/2-install-docker.bash">https://raw.githubusercontent.com/nazmulidris/rust-scratch/main/ubuntu24/2-install-docker.bash</a></li>
  <li><a href="https://raw.githubusercontent.com/nazmulidris/rust-scratch/main/ubuntu24/3-install-fonts.fish">https://raw.githubusercontent.com/nazmulidris/rust-scratch/main/ubuntu24/3-install-fonts.fish</a></li>
</ol>

<p>Optional scripts:</p>
<ol>
  <li><a href="https://github.com/nazmulidris/rust-scratch/blob/main/ubuntu24/install-agent-into-bin.fish">https://github.com/nazmulidris/rust-scratch/blob/main/ubuntu24/install-agent-into-bin.fish</a></li>
  <li><a href="https://github.com/nazmulidris/rust-scratch/blob/main/ubuntu24/fix-gnome-session-path-env-var-linuxbrew.fish">https://github.com/nazmulidris/rust-scratch/blob/main/ubuntu24/fix-gnome-session-path-env-var-linuxbrew.fish</a></li>
  <li><a href="https://github.com/nazmulidris/rust-scratch/blob/main/ubuntu24/fix-usr-local-bin-symlinks.fish">https://github.com/nazmulidris/rust-scratch/blob/main/ubuntu24/fix-usr-local-bin-symlinks.fish</a></li>
</ol>

<h2 id="gnome-extensions">Gnome Extensions</h2>
<p><a id="markdown-gnome-extensions" name="gnome-extensions"></a></p>

<ul>
  <li><a href="https://extensions.gnome.org/extension/4548/tactile/">Tactile tiling support</a></li>
  <li><a href="https://extensions.gnome.org/extension/7065/tiling-shell/">Tiling shell tiling support</a></li>
  <li><a href="https://extensions.gnome.org/extension/5660/weather-or-not/">Weather in top bar</a></li>
  <li><a href="https://extensions.gnome.org/extension/1460/vitals/">Vitals in top bar</a></li>
  <li><a href="https://extensions.gnome.org/extension/6242/emoji-copy/">Emoji chooser in top bar</a></li>
  <li><a href="https://extensions.gnome.org/extension/4839/clipboard-history/">Clipboard history</a></li>
  <li><a href="https://extensions.gnome.org/extension/4679/burn-my-windows/">Burn my windows animation for window open and close</a></li>
  <li><a href="https://extensions.gnome.org/extension/3843/just-perfection/">Just Perfection ultra GNOME customization</a></li>
</ul>

<h2 id="keyboard-remapping">Keyboard remapping</h2>
<p><a id="markdown-keyboard-remapping" name="keyboard-remapping"></a></p>

<h3 id="tilix-and-quake-mode">Tilix and quake mode</h3>
<p><a id="markdown-tilix-and-quake-mode" name="tilix-and-quake-mode"></a></p>

<p><code class="language-plaintext highlighter-rouge">tilix</code> and its <code class="language-plaintext highlighter-rouge">quake mode</code> is disabled in Wayland. So I installed <code class="language-plaintext highlighter-rouge">guake</code>. You can use
<a href="https://lukaszwrobel.pl/blog/tmux-tutorial-split-terminal-windows-easily/"><code class="language-plaintext highlighter-rouge">tmux</code></a> to
manage the panes in this <code class="language-plaintext highlighter-rouge">guake</code> terminal with ease.</p>

<h3 id="remap-superq">Remap Super+Q</h3>
<p><a id="markdown-remap-super%2Bq" name="remap-super%2Bq"></a></p>

<p>The following links show you how to remove the default binding for the <kbd>Super+Q</kbd>
key to close the current window. This is useful if you want to use that binding to launch
the <code class="language-plaintext highlighter-rouge">guake</code> terminal. I used to use <code class="language-plaintext highlighter-rouge">tilix</code> in <code class="language-plaintext highlighter-rouge">quake mode</code>, but that doesn‚Äôt work in
Wayland, so I am using <code class="language-plaintext highlighter-rouge">guake</code> for that now. But I‚Äôm still using <code class="language-plaintext highlighter-rouge">tilix</code>.</p>

<ul>
  <li><a href="https://askubuntu.com/questions/977876/changing-command-super-q">https://askubuntu.com/questions/977876/changing-command-super-q</a></li>
  <li><a href="https://flameshot.org/docs/guide/wayland-help/">https://flameshot.org/docs/guide/wayland-help/</a></li>
  <li><a href="https://github.com/Ulauncher/Ulauncher/wiki/Hotkey-In-Wayland">https://github.com/Ulauncher/Ulauncher/wiki/Hotkey-In-Wayland</a></li>
  <li><a href="https://askubuntu.com/questions/26056/where-are-gnome-keyboard-shortcuts-stored">https://askubuntu.com/questions/26056/where-are-gnome-keyboard-shortcuts-stored</a></li>
</ul>

<h3 id="remap-caps-lock-to-ctrl">Remap Caps Lock to Ctrl</h3>
<p><a id="markdown-remap-caps-lock-to-ctrl" name="remap-caps-lock-to-ctrl"></a></p>

<p>Here‚Äôs a snippet to allow you map your <kbd>Caps Lock</kbd> key to the <kbd>Ctrl</kbd>
key:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function </span>remapCapsLockKey
    <span class="nb">echo</span> <span class="s2">"Remapping caps lock key"</span>
    <span class="c"># https://opensource.com/article/21/5/remap-caps-lock-key-linux</span>
    dconf write /org/gnome/desktop/input-sources/xkb-options <span class="s2">"['caps:ctrl_modifier']"</span>
    <span class="c"># dconf write /org/gnome/desktop/input-sources/xkb-options "['caps:ctrl']"</span>
end
</code></pre></div></div>

<h2 id="chrome-issues-w-wayland">Chrome issues w/ Wayland</h2>
<p><a id="markdown-chrome-issues-w%2F-wayland" name="chrome-issues-w%2F-wayland"></a></p>

<p>If you find Chrome to be blurry (or AppImages or Electron apps), then you may need to
do the following to fix this in Wayland:</p>

<ul>
  <li>Navigate to <code class="language-plaintext highlighter-rouge">chrome://flags</code></li>
  <li>Change <code class="language-plaintext highlighter-rouge">Preferred Ozone Platform</code> from <code class="language-plaintext highlighter-rouge">default</code> to <code class="language-plaintext highlighter-rouge">wayland</code></li>
  <li><a href="https://askubuntu.com/a/1502896/872482">More info</a></li>
</ul>

<h2 id="libfuse2-and-appimage-issues">libfuse2 and AppImage issues</h2>
<p><a id="markdown-libfuse2-and-appimage-issues" name="libfuse2-and-appimage-issues"></a></p>

<p>On Ubuntu 24.04 I ran into some issues w/ <code class="language-plaintext highlighter-rouge">libfuse2</code> and running <code class="language-plaintext highlighter-rouge">AppImage</code>s.</p>

<ul>
  <li>Ubuntu 24 does not come w/ <code class="language-plaintext highlighter-rouge">libfuse2</code> out of the box (for good reasons), and instead it
has <code class="language-plaintext highlighter-rouge">libfuse3</code>.</li>
  <li>And <code class="language-plaintext highlighter-rouge">AppImage</code> currently only supports <code class="language-plaintext highlighter-rouge">libfuse2</code>.</li>
</ul>

<h3 id="approach-1---simple">Approach 1 - simple</h3>
<p><a id="markdown-approach-1---simple" name="approach-1---simple"></a></p>

<p>Instead of installing <code class="language-plaintext highlighter-rouge">libfuse2</code>, however, if you don‚Äôt want to do that you can simply run
the your <code class="language-plaintext highlighter-rouge">XYZ.AppImage</code> using the following command (once it‚Äôs been marked as executable):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>chmod +x XYZ.AppImage
./XYZ.AppImage \
  --no-sandbox --enable-features=UseOzonePlatform,WaylandWindowDecorations \
  --ozone-platform-hint=auto
</code></pre></div></div>

<p>Explanation of the flags:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">--no-sandbox</code> - removes the need for libfuse2</li>
  <li><code class="language-plaintext highlighter-rouge">--enable-features=UseOzonePlatform,WaylandWindowDecorations</code> - tells chromium in
electron to do things for Wayland.</li>
  <li><code class="language-plaintext highlighter-rouge">--ozone-platform-hint=auto</code> - tells chromium to use Wayland if it is available. This
setting is set to <code class="language-plaintext highlighter-rouge">X11</code> by default. If you see blurry windows in Chrome, you may need to set
this in your Chrome too (using <code class="language-plaintext highlighter-rouge">chrome://flags/</code>).</li>
</ul>

<p>Here‚Äôs an example of my <code class="language-plaintext highlighter-rouge">~/.local/share/applications/uhk-agent.desktop</code> file, which I use
to run the <a href="https://forum.ultimatehackingkeyboard.com/t/run-agent-appimage-in-wayland-eg-on-ubuntu-24/1364"><code class="language-plaintext highlighter-rouge">uhk-agent</code>
AppImage</a>
w/ the above flags:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Desktop Entry]
Type=Application
Name=UHK Agent
Comment=Launch UHK Agent
Categories=Utilities;
Icon=/home/nazmul/bin/uhk-agent.png
Exec=/home/nazmul/bin/UHK.Agent.AppImage --no-sandbox --enable-features=UseOzonePlatform,WaylandWindowDecorations --ozone-platform-hint=auto
Terminal=false
</code></pre></div></div>

<h3 id="approach-2---complex">Approach 2 - complex</h3>
<p><a id="markdown-approach-2---complex" name="approach-2---complex"></a></p>

<p>Here‚Äôs another approach to run <code class="language-plaintext highlighter-rouge">AppImage</code>s, which is more complex:</p>

<ul>
  <li><a href="https://github.com/AppImage/AppImageKit/wiki/FUSE"><code class="language-plaintext highlighter-rouge">libfuse2</code></a> is not included with
Ubuntu 24.04. <code class="language-plaintext highlighter-rouge">AppImage</code>s are difficult to run (since they need <code class="language-plaintext highlighter-rouge">libfuse2</code> installed).</li>
  <li>To run them, have to pass an extra flag in the terminal or <code class="language-plaintext highlighter-rouge">.desktop</code> file(eg for
<code class="language-plaintext highlighter-rouge">uhk-agent</code>). here‚Äôs a workaround (to keep from installing <code class="language-plaintext highlighter-rouge">libfuse2</code>).</li>
</ul>

<p>Here‚Äôs an example of the command to run the <a href="https://ultimatehackingkeyboard.com/agent"><code class="language-plaintext highlighter-rouge">uhk-agent</code>
AppImage</a>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/UHK.Agent-4.2.0-linux-x86_64.AppImage <span class="nt">--appimage-extract</span>
<span class="nb">cd </span>squashfs-root
./uhk-agent <span class="nt">--no-sandox</span>
</code></pre></div></div>

<p>Here‚Äôs a
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/ubuntu24/install-agent-into-bin.fish">script</a>
that uses this complex approach to unpack an <code class="language-plaintext highlighter-rouge">AppImage</code> into the <code class="language-plaintext highlighter-rouge">~/bin</code> folder so you can
run it.</p>

<h2 id="settings---key-mappings">Settings -&gt; Key mappings</h2>
<p><a id="markdown-settings--%3E-key-mappings" name="settings--%3E-key-mappings"></a></p>

<ul>
  <li>To create keyboard shortcuts that launch a shell command, wrap it in <code class="language-plaintext highlighter-rouge">sh -c $CMD</code>. This
is what must be done for <code class="language-plaintext highlighter-rouge">flameshot</code>, and <code class="language-plaintext highlighter-rouge">ulauncher</code>.</li>
  <li>Bind <code class="language-plaintext highlighter-rouge">ulauncher-toggle</code> to the settings -&gt; keyboard shortcuts in gnome.</li>
</ul>

<h2 id="obs-studio-issues">OBS Studio issues</h2>
<p><a id="markdown-obs-studio-issues" name="obs-studio-issues"></a></p>

<p><code class="language-plaintext highlighter-rouge">obs-studio</code> has some UI issues, and dialog boxes are quite glitchy and don‚Äôt display
properly. keyboard shortcuts can‚Äôt be reliably used when the <code class="language-plaintext highlighter-rouge">obs-studio</code> window is not in
focus. can‚Äôt really bind to settings -&gt; keyboard shortcuts either, since there‚Äôs no
command to stop recording; start recording will spawn a new process.</p>

<h2 id="fontconfig">Fontconfig</h2>
<p><a id="markdown-fontconfig" name="fontconfig"></a></p>

<p>Custom font install using script. optional - <code class="language-plaintext highlighter-rouge">~/.config/fontconfig/fonts.conf</code> change
for system fonts that affect all apps. also <code class="language-plaintext highlighter-rouge">gnome-tweaks</code> to change fonts, and other
settings.</p>

<ul>
  <li><a href="https://jichu4n.com/posts/how-to-set-default-fonts-and-font-aliases-on-linux/">https://jichu4n.com/posts/how-to-set-default-fonts-and-font-aliases-on-linux/</a></li>
  <li><a href="https://www.freedesktop.org/software/fontconfig/fontconfig-user.html">https://www.freedesktop.org/software/fontconfig/fontconfig-user.html</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Fontconfig">https://en.wikipedia.org/wiki/Fontconfig</a></li>
</ul>

<h2 id="build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</h2>
<p><a id="markdown-build-with-naz-video-series-on-developerlife.com-youtube-channel" name="build-with-naz-video-series-on-developerlife.com-youtube-channel"></a></p>

<blockquote>
  <p>If you have comments and feedback on this content, or would like to request new content
(articles &amp; videos) on developerlife.com, please join our <a href="https://discord.gg/8M2ePAevaMi">discord
server</a>.</p>
</blockquote>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a></li>
  <li>Playlists
    <ul>
      <li><a href="https://www.youtube.com/watch?v=bolScvh4x7I&amp;list=PLofhE49PEwmw3MKOU1Kn3xbP4FRQR4Mb3">Build with Naz, Linux TTY, process, signals, commands in async Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmza94sS7UmJnN9gSCHTVTfz">Build with Naz, fundamental effective Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmwO69E7eiQ-ewnMME8ydgQ5">Build with Naz, effective async Rust and tokio</a></li>
      <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="Linux" /><category term="Misc" /><category term="Productivity" /><summary type="html"><![CDATA[I've provided scripts for setting up a new Ubuntu 24.04 desktop machine. They have been tested on a fresh install of Ubuntu 24.04 LTS. They contain all the software that is needed for Rust development, OBS Studio use, and general developer productivity. They are highly opinionated for my use case, but you can modify them to suit your needs.]]></summary></entry><entry><title type="html">Build with Naz : Markdown parser in Rust and nom from r3bl_tui</title><link href="http://developerlife.com/2024/06/28/md-parser-rust-from-r3bl-tui/" rel="alternate" type="text/html" title="Build with Naz : Markdown parser in Rust and nom from r3bl_tui" /><published>2024-06-28T10:00:00-05:00</published><updated>2024-06-28T10:00:00-05:00</updated><id>http://developerlife.com/2024/06/28/md-parser-rust-from-r3bl-tui</id><content type="html" xml:base="http://developerlife.com/2024/06/28/md-parser-rust-from-r3bl-tui/"><![CDATA[<p><img class="post-hero-image" src="/assets/rust-tui-md-parser.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#nom-crate-review">nom crate review</a></li>
  <li><a href="#a-real-production-grade-markdown-parser-example">A real production grade Markdown parser example</a></li>
  <li><a href="#related-video">Related video</a></li>
  <li><a href="#architecture-and-parsing-order">Architecture and parsing order</a></li>
  <li><a href="#references">References</a></li>
</ul>

<!-- /TOC -->

<h2 id="introduction">Introduction</h2>
<p><a id="markdown-introduction" name="introduction"></a></p>

<p>This tutorial, and video are a deep dive in a real Markdown parser written using nom in
Rust. This MD Parser is part of the <a href="https://crates.io/crates/r3bl_tui"><code class="language-plaintext highlighter-rouge">r3bl_tui</code></a> crate,
which is part of the <code class="language-plaintext highlighter-rouge">r3bl-open-core</code> repo. It goes over the architecture of thinking
about building complex parsers and the nitty gritty details the runtime nature and
behavior when combining nom parsers.</p>

<p>The <a href="https://crates.io/crates/r3bl_tui"><code class="language-plaintext highlighter-rouge">r3bl_tui</code></a> crate is a Text User Interface (TUI)
crate that is used in the <a href="https://r3bl.com">R3BL</a> suite of products. It is a very
powerful and flexible TUI crate that is used to build a variety of different applications.
It comes with a full featured Markdown editor component, and the parser that‚Äôs the focus
on this tutorial is used by that editor component to parse an input string slice into a
Markdown document model (AST representation in memory).</p>

<h2 id="nom-crate-review">nom crate review</h2>
<p><a id="markdown-nom-crate-review" name="nom-crate-review"></a></p>

<p><a href="https://crates.io/crates/nom"><code class="language-plaintext highlighter-rouge">nom</code></a> is a parser combinator library for Rust. You can write small
functions that parse a specific part of your input, and then combine them to build a parser that
parses the whole input. <code class="language-plaintext highlighter-rouge">nom</code> is very efficient and fast, it does not allocate memory when parsing if
it doesn‚Äôt have to, and it makes it very easy for you to do the same. <code class="language-plaintext highlighter-rouge">nom</code> uses streaming mode or
complete mode, and in this tutorial &amp; code examples provided we will be using complete mode.</p>

<p>Roughly the way it works is that you tell <code class="language-plaintext highlighter-rouge">nom</code> how to parse a bunch of bytes in a way that matches
some pattern that is valid for your data. It will try to parse as much as it can from the input, and
the rest of the input will be returned to you.</p>

<p>You express the pattern that you‚Äôre looking for by combining parsers. <code class="language-plaintext highlighter-rouge">nom</code> has a whole bunch of these
that come out of the box. And a huge part of learning <code class="language-plaintext highlighter-rouge">nom</code> is figuring out what these built in
parsers are and how to combine them to build a parser that does what you want.</p>

<p>Errors are a key part of it being able to apply a variety of different parsers to the same input. If
a parser fails, <code class="language-plaintext highlighter-rouge">nom</code> will return an error, and the rest of the input will be returned to you. This
allows you to combine parsers in a way that you can try to parse a bunch of different things, and if
one of them fails, you can try the next one. This is very useful when you are trying to parse a
bunch of different things, and you don‚Äôt know which one you are going to get.</p>

<blockquote>
  <p>We have a video and article on developerlife where you can learn more about <code class="language-plaintext highlighter-rouge">nom</code> and how to use it.</p>
  <ul>
    <li><a href="https://youtu.be/v3tMwr_ysPg">Video on nom fundamentals</a>.</li>
    <li><a href="https://developerlife.com/2023/02/20/guide-to-nom-parsing/">Article on nom fundamentals</a>.</li>
  </ul>
</blockquote>

<h2 id="a-real-production-grade-markdown-parser-example">A real production grade Markdown parser example</h2>
<p><a id="markdown-a-real-production-grade-markdown-parser-example" name="a-real-production-grade-markdown-parser-example"></a></p>

<p>The production
<a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/tui/src/tui/md_parser"><code class="language-plaintext highlighter-rouge">md_parser</code></a>
module in the <code class="language-plaintext highlighter-rouge">r3bl-open-core</code> repo contains a fully functional Markdown parser (that you
can use in your projects that need a Markdown parser). This parser supports standard
Markdown syntax as well as some extensions that are
added to make it work w/ <a href="https://r3bl.com">R3BL</a> products. It makes a great starting
point to study how a relatively complex parser is written. There are lots of tests that
you can follow along to understand what the code is doing.</p>

<blockquote>
  <p>üí° You can get the source code for the production Markdown parser used in <code class="language-plaintext highlighter-rouge">r3bl_tui</code> from the
<a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/tui/src/tui/md_parser"><code class="language-plaintext highlighter-rouge">r3bl-open-core</code></a>
repo.</p>

  <p>üåü Please star this repo on github if you like it üôè.</p>
</blockquote>

<p>The main entry point (function) for this Markdown parsing module is
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/parse_markdown.rs"><code class="language-plaintext highlighter-rouge">parse_markdown()</code></a>.</p>
<ul>
  <li>It takes a string slice.</li>
  <li>And returns a vector of <a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/types.rs"><code class="language-plaintext highlighter-rouge">MdBlock</code>s</a>.</li>
</ul>

<p>Here are some entry points into the codebase.</p>

<ol>
  <li>The main function
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/parse_markdown.rs"><code class="language-plaintext highlighter-rouge">parse_markdown()</code></a>
that does the parsing of a string slice into a
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/types.rs"><code class="language-plaintext highlighter-rouge">MdDocument</code></a>.
The tests are provided alongside the code itself. And you can follow along to see how
other smaller parsers are used to build up this big one that parses the whole of the
Markdown document.</li>
  <li>The
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/types.rs"><code class="language-plaintext highlighter-rouge">types</code></a> module
contain all the types that are used to represent the Markdown document model, such as <code class="language-plaintext highlighter-rouge">MdDocument</code>, <code class="language-plaintext highlighter-rouge">MdBlock</code>,
<code class="language-plaintext highlighter-rouge">MdLineFragment</code> and all the other intermediate types &amp; enums required for parsing.</li>
  <li>All the parsers related to parsing metadata specific for <a href="https://r3bl.com">R3BL</a>
applications which are not standard Markdown can be found in
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/extended/parse_metadata_kv.rs#L1"><code class="language-plaintext highlighter-rouge">parse_metadata_kv</code></a>
and
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/extended/parse_metadata_kcsv.rs#L1"><code class="language-plaintext highlighter-rouge">parse_metadata_kcsv</code></a>.</li>
  <li>All the parsers that are related to parsing the main ‚Äúblocks‚Äù of Markdown, such as
order lists, unordered lists, code blocks, text blocks, heading blocks, can be
found <a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/block/mod.rs#L3"><code class="language-plaintext highlighter-rouge">block</code></a>.</li>
  <li>All the parsers that are related to parsing a single line of Markdown text, such as
links, bold, italic, etc. can be found
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/fragment/mod.rs#L1"><code class="language-plaintext highlighter-rouge">fragment</code></a>.</li>
</ol>

<h2 id="related-video">Related video</h2>
<p><a id="markdown-related-video" name="related-video"></a></p>

<p>If you like to consume content via video, then you can watch this video that covers the same content
as this article, but in a live coding format.</p>

<!-- video on nom -->
<iframe src="https://www.youtube.com/embed/SbwvSHZRb1E?si=8UFyEKyF8sHnam-K" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<blockquote>
  <p>üí° You can get the source code for the production Markdown parser used in <code class="language-plaintext highlighter-rouge">r3bl_tui</code> from the
<a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/tui/src/tui/md_parser"><code class="language-plaintext highlighter-rouge">r3bl-open-core</code></a>
repo.</p>
</blockquote>

<h2 id="architecture-and-parsing-order">Architecture and parsing order</h2>
<p><a id="markdown-architecture-and-parsing-order" name="architecture-and-parsing-order"></a></p>

<p>This diagram showcases the order in which the parsers are called and how they are
composed together to parse a Markdown document.</p>

<!--
diagram:
https://asciiflow.com/#/share/eJzdlL9qwzAQxl%2Fl0JRChhLo0Gz9M3Rop2YUCNUWsYgsGfkcxxhD6dyhQwh9ltKnyZNUtus0hAYrJaXQQyAZf%2F6d7rN0JdE8FmSsM6WGRPFCWDImJSULSsbnZ6MhJYVbjZoVigW6B0oSK42VWMB6%2BbxePv7T8UKpBojkNAJwlT5Bwm0qWMztLDS5HpxACTsR8wTQAEYCAmOtCHBX0aIacgvdTDHXxengG3331U8LWb0B3IWXygQzmHMrucZ9e4DPGlGiEmzOVSZcmb0xqeV99W3YfJoyJVP0ITu2k%2Fd617F5hpGx3viLVu7HDjkeYAlcO7n3vh%2Fqn8MiwUOpp8wkyIRR%2B9PctMJD2Kk7tujjy30tvHU6f3ZgQj9PrpywPYfe7O62sbr5sFxixIxtZpMh0yJ3Nek6%2B8S9%2F8q0h%2B114vpii71679jVMcgde6u%2FLv%2B6C%2F7eeG1cVCY%2FjnVdUFKR6gNnN4sV)
-->

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>priority ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  high   ‚îÇ parse_markdown() {           map to the correct                    ‚îÇ
    ‚îÇ    ‚îÇ   many0(                     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫  MdBlock variant ‚îÇ
    ‚îÇ    ‚îÇ     parse_title_value()                              Title         ‚îÇ
    ‚îÇ    ‚îÇ     parse_tags_list()                                Tags          ‚îÇ
    ‚îÇ    ‚îÇ     parse_authors_list()                             Authors       ‚îÇ
    ‚îÇ    ‚îÇ     parse_date_value()                               Date          ‚îÇ
    ‚îÇ    ‚îÇ     parse_block_heading_opt_eol()                    Heading       ‚îÇ
    ‚îÇ    ‚îÇ     parse_block_smart_list()                         SmartList     ‚îÇ
    ‚îÇ    ‚îÇ     parse_block_code()                               CodeBlock     ‚îÇ
    ‚îÇ    ‚îÇ     parse_block_m..n_text_with_or_without_new_line() Text          ‚îÇ
    ‚îÇ    ‚îÇ   )                                                                ‚îÇ
    ‚ñº    ‚îÇ }                                                                  ‚îÇ
priority ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
  low
</code></pre></div></div>

<p>The parsing strategy in most cases is to parse the most specific thing first and then
parse the more general thing later. We often use the existence of <code class="language-plaintext highlighter-rouge">\n</code> (or <code class="language-plaintext highlighter-rouge">eol</code>) to
decide how far forwards we need to go into the input. And sometimes <code class="language-plaintext highlighter-rouge">\n</code> doesn‚Äôt exist
and we simply use the entire input (or end of input or <code class="language-plaintext highlighter-rouge">eoi</code>). You might see functions
that have these suffixes in their names. Another term you might see is
<code class="language-plaintext highlighter-rouge">with_or_without_new_line</code> which makes the parsing strategy explicit in the name.</p>

<p>The nature of <code class="language-plaintext highlighter-rouge">nom</code> parsers is to simply error out when they don‚Äôt match. And leave
the <code class="language-plaintext highlighter-rouge">input</code> untouched, so that another parser have a go at it again. The nature of
these parsing functions is kind of recursive in nature. So it‚Äôs important identify
edge and exit cases up front before diving into the parsing logic. You will see this
used in parsers which look for something more specific, if its not found, they error
out, and allow less specific parsers to have a go at it, and so on.</p>

<h2 id="the-priority-of-parsers">The priority of parsers</h2>

<p>As we drill down into the implementation further, we see that the parsers are
prioritized in the order of their specificity. The most specific parsers are called
first and the least specific parsers are called last. This is done to ensure that the
most specific parsers get a chance to parse the input first. And if they fail, then
the less specific parsers get a chance to parse the input.</p>

<!--
diagram:
https://asciiflow.com/#/share/eJytlFFuwjAMhq8S5QkkHtD2MjhLJCsNBqK6CUpTUYaQpp2h4iB7RDtNT7I0sK1ABYNhVapdJ1%2F%2F2G7X3MgM%2BdgURANOcoWOj%2Fla8FLw8ejleSD4KnhPo2HwPJY%2BBIIvpMsRErIqhUy6dGKXBposLLWfg3XxbgsPBpdA2mCvz9bs3IQwjGXSrIa9juxtFlmM7bVp07wVpk7OMjQ%2Bh8J4TYCWGnVodRB0nRWsWVZX7%2F9VtvmNHkBrRXVV1dVbvd0xSf7OIh4TI3X7cSjkdwUh99KFOsYGF2aCLlfWIaBzYE27zx20cOILtMbv4LS05QtUWpJ%2BxclVWiJV6nUYzC5ipMXNLmdN3X6u7e4Kl3DqQWdy9pAzR1rY3CnzZpqao0oTW4ax9zZkXHu6u7r7%2BSfaMTaxlnr9SFPSq3kYODop4Sl1QVIffgzGnvf2ROO%2BL4cnFz%2FPiyb4hm%2B%2BAFpUbMk%3D)
-->

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>parse_block_markdown_text_with_or_without_new_line() {
  many0(
    parse_inline_fragments_until_eol_or_eoi()
       )   ‚îÇ
}          ‚îÇ                                           ‚îÄ‚îÄmap to the correct‚îÄ‚îÄ‚ñ∫
           ‚îî‚îÄ‚ñ∫ alt(                                     MdLineFragment variant

             ‚ñ≤ p..e_f..t_s..s_with_underscore_err_on_new_line()  Italic
             ‚îÇ p..e_f..t_s..s_with_star_err_on_new_line()        Bold
specialized  ‚îÇ p..e_f..t_s..s_with_backtick_err_on_new_line()    InlineCode
parsers ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ p..e_f..t_s..s_with_left_image_err_on_new_line()  Image
             ‚îÇ p..e_f..t_s..s_with_left_link_err_on_new_line()   Link
             ‚îÇ p..e_f..t_s..s_with_checkbox_into_str()           Plain
             ‚ñº p..e_f..t_s..s_with_checkbox_checkbox_into_bool() Checkbox
catch all‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ p..e_f..t_plain_text_no_new_line()                Plain
parser
               )
</code></pre></div></div>

<p>The last one on the list in the diagram above is
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/block/parse_block_markdown_text_until_eol_or_eoi.rs"><code class="language-plaintext highlighter-rouge">parse_block_markdown_text_with_or_without_new_line()</code></a>.
Let‚Äôs zoom into this function and see how it is composed.</p>

<h2 id="the-catch-all-parser-which-is-the-most-complicated-and-the-lowest-priority">The ‚Äúcatch all‚Äù parser, which is the most complicated, and the lowest priority</h2>

<p>The most complicated parser is the ‚Äúcatch all‚Äù parser or the ‚Äúplain text‚Äù parser. This
parser is the last one in the chain and it simply consumes the rest of the input and
turns it into a <code class="language-plaintext highlighter-rouge">MdBlock::Text</code>. This parser is the most complicated because it has to
deal with all the edge cases and exit cases that other parsers have not dealt with.
Such as special characters like <code class="language-plaintext highlighter-rouge">`</code>, <code class="language-plaintext highlighter-rouge">*</code>, <code class="language-plaintext highlighter-rouge">_</code>, etc. They are all listed here:</p>

<ul>
  <li>If the input does not start with a special char in this
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/fragment/plain_parser_catch_all.rs"><code class="language-plaintext highlighter-rouge">get_sp_char_set_2()</code></a>,
then this is the ‚ÄúNormal case‚Äù. In this case the input is split at the first occurrence
of a special char in
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/fragment/plain_parser_catch_all.rs"><code class="language-plaintext highlighter-rouge">get_sp_char_set_3()</code></a>.
The ‚Äúbefore‚Äù part is <code class="language-plaintext highlighter-rouge">MdLineFragment::Plain</code> and the ‚Äúafter‚Äù part is parsed again by a
more specific parser.</li>
  <li>If the input starts with a special char in this <a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/fragment/plain_parser_catch_all.rs"><code class="language-plaintext highlighter-rouge">get_sp_char_set_2()</code></a> and it is not
in the <code class="language-plaintext highlighter-rouge">get_sp_char_set_1()</code> with only 1 occurrence, then the behavior is different
‚ÄúEdge case -&gt; Normal case‚Äù. Otherwise the behavior is ‚ÄúEdge case -&gt; Special case‚Äù.
    <ul>
      <li>‚ÄúEdge case -&gt; Normal case‚Äù takes all the characters until <code class="language-plaintext highlighter-rouge">\n</code> or end of input and
turns it into a <code class="language-plaintext highlighter-rouge">MdLineFragment::Plain</code>.</li>
      <li>‚ÄúEdge case -&gt; Special case‚Äù splits the <code class="language-plaintext highlighter-rouge">input</code> before and after the special char.
The ‚Äúbefore‚Äù part is turned into a <code class="language-plaintext highlighter-rouge">MdLineFragment::Plain</code> and the ‚Äúafter‚Äù part is
parsed again by a more specific parser.</li>
    </ul>
  </li>
</ul>

<p>The reason this parser gets called repeatedly is because it is the last one in the chain.
Its the lowest priority parser called by
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/fragment/parse_fragments_in_a_line.rs"><code class="language-plaintext highlighter-rouge">parse_inline_fragments_until_eol_or_eoi()</code></a>,
which itself is called:</p>
<ol>
  <li>Repeatedly in a loop by
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/block/parse_block_markdown_text_until_eol_or_eoi.rs"><code class="language-plaintext highlighter-rouge">parse_block_markdown_text_with_or_without_new_line()</code></a>.</li>
  <li>And by
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/block/parse_block_markdown_text_until_eol_or_eoi.rs#L80"><code class="language-plaintext highlighter-rouge">parse_block_markdown_text_with_checkbox_policy_with_or_without_new_line()</code></a>.</li>
</ol>

<h2 id="visualize-the-parsers-running-on-real-input">Visualize the parsers running on real input</h2>

<p>Let‚Äôs run some tests from the <code class="language-plaintext highlighter-rouge">md_parser</code> module with the
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/mod.rs#L34"><code class="language-plaintext highlighter-rouge">DEBUG_MD_PARSER_STDOUT</code></a>
flag set to <code class="language-plaintext highlighter-rouge">true</code>.</p>

<p>This will allow us to see the output of the parsers as they run on
real input. This is a great way to understand how the parsers are working and what they
are doing. This helps build an intuition around what happens at runtime which might not
match what you think is happening when you read the code.</p>

<ol>
  <li>The test we will run are in this file:
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/block/parse_block_markdown_text_until_eol_or_eoi.rs#L81"><code class="language-plaintext highlighter-rouge">tui/src/tui/md_parser/block/parse_block_markdown_text_until_eol_or_eoi.rs</code></a>.</li>
  <li>The test suite itself is called
<code class="language-plaintext highlighter-rouge">tests_parse_block_markdown_text_with_or_without_new_line</code>.</li>
  <li>And the function under test is
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/block/parse_block_markdown_text_until_eol_or_eoi.rs#L24"><code class="language-plaintext highlighter-rouge">parse_block_markdown_text_with_or_without_new_line()</code></a>.</li>
</ol>

<p>For convenience, here‚Äôs a copy of the test that we will run (in this
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/md_parser/block/parse_block_markdown_text_until_eol_or_eoi.rs#L101">file</a>):</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">test_parse_hyperlink_markdown_text_1</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">input</span> <span class="o">=</span> <span class="s">"This is a _hyperlink: [foo](http://google.com)."</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="nf">parse_block_markdown_text_with_or_without_new_line</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
    <span class="nd">assert_eq2!</span><span class="p">(</span>
        <span class="n">it</span><span class="p">,</span>
        <span class="nf">Ok</span><span class="p">((</span>
            <span class="s">""</span><span class="p">,</span>
            <span class="nd">list!</span><span class="p">[</span>
                <span class="nn">MdLineFragment</span><span class="p">::</span><span class="nf">Plain</span><span class="p">(</span><span class="s">"This is a "</span><span class="p">,),</span>
                <span class="nn">MdLineFragment</span><span class="p">::</span><span class="nf">Plain</span><span class="p">(</span><span class="s">"_"</span><span class="p">,),</span>
                <span class="nn">MdLineFragment</span><span class="p">::</span><span class="nf">Plain</span><span class="p">(</span><span class="s">"hyperlink: "</span><span class="p">,),</span>
                <span class="nn">MdLineFragment</span><span class="p">::</span><span class="nf">Link</span><span class="p">(</span><span class="n">HyperlinkData</span> <span class="p">{</span>
                    <span class="n">text</span><span class="p">:</span> <span class="s">"foo"</span><span class="p">,</span>
                    <span class="n">url</span><span class="p">:</span> <span class="s">"http://google.com"</span><span class="p">,</span>
                <span class="p">},),</span>
                <span class="nn">MdLineFragment</span><span class="p">::</span><span class="nf">Plain</span><span class="p">(</span><span class="s">"."</span><span class="p">,),</span>
            <span class="p">],</span>
        <span class="p">))</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>You can see from the <code class="language-plaintext highlighter-rouge">assert_eq2!()</code> statements that the input <code class="language-plaintext highlighter-rouge">"This is a _hyperlink:
[foo](http://google.com)."</code> is turned into a abstract syntax tree (AST) which looks like
this:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span>
    <span class="nn">MdLineFragment</span><span class="p">::</span><span class="nf">Plain</span><span class="p">(</span><span class="s">"This is a "</span><span class="p">,),</span>
    <span class="nn">MdLineFragment</span><span class="p">::</span><span class="nf">Plain</span><span class="p">(</span><span class="s">"_"</span><span class="p">,),</span>
    <span class="nn">MdLineFragment</span><span class="p">::</span><span class="nf">Plain</span><span class="p">(</span><span class="s">"hyperlink: "</span><span class="p">,),</span>
    <span class="nn">MdLineFragment</span><span class="p">::</span><span class="nf">Link</span><span class="p">(</span><span class="n">HyperlinkData</span> <span class="p">{</span>
        <span class="n">text</span><span class="p">:</span> <span class="s">"foo"</span><span class="p">,</span>
        <span class="n">url</span><span class="p">:</span> <span class="s">"http://google.com"</span><span class="p">,</span>
    <span class="p">},),</span>
    <span class="nn">MdLineFragment</span><span class="p">::</span><span class="nf">Plain</span><span class="p">(</span><span class="s">"."</span><span class="p">,),</span>
<span class="p">]</span>
</code></pre></div></div>

<p>Note the ‚Äústrange‚Äù way in which <code class="language-plaintext highlighter-rouge">"_"</code> is handled. Instead of what we might expect <code class="language-plaintext highlighter-rouge">Plain("This is a _ hyperlink: ")</code>.
But we get 3 fragments instead of one. This is because of the lowest priority parser handles special characters
so that more specific parsers (higher priority) can have a go at it. So it doesn‚Äôt prematurely mark them as <code class="language-plaintext highlighter-rouge">Plain</code>.</p>

<p>Here are the commands to run one of the tests (make sure to run this in the <code class="language-plaintext highlighter-rouge">tui</code> subfolder):</p>

<pre class="pre-manual-highlight">
<span style="color:#F8F8F2">cargo</span> <span style="color:#FF79C6">test</span> <span style="color:#FF79C6">--</span> <span style="color:#FF79C6">--nocapture</span> <span style="color:#FF79C6">test_parse_hyperlink_markdown_text_1</span>
</pre>

<p>Here‚Äôs the output, which you can walk through to see the parsing algorithms in action:</p>

<pre class="pre-manual-highlight">
<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser _:
input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;, delim: &quot;_&quot;
count: 1, starts_w: false, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser *:
input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;, delim: &quot;*&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser `:
input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;, delim: &quot;`&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser take text between delims err on new line:
input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;, start_delim: &quot;![&quot;, end_delim: &quot;]&quot;
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;

<span style="color:#BF616A">‚¨¢‚¨¢</span> specialized parser error out with image:
input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;, delim: &quot;![&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser take text between delims err on new line:
input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;, start_delim: &quot;[&quot;, end_delim: &quot;]&quot;
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;

<span style="color:#BF616A">‚¨¢‚¨¢</span> specialized parser error out with link:
input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;, delim: &quot;[&quot;
<span style="color:#BF616A">‚¨¢‚¨¢</span> specialized parser for checkbox: Err(Error(Error { input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;, code: Tag }))

<span style="color:#B48EAD">‚ñà‚ñà</span> plain parser, input: &quot;This is a _hyperlink: [foo](http://google.com).&quot;
<span style="color:#81A1C1">‚ñ≤‚ñ≤</span> normal case :: Ok((&quot;_hyperlink: [foo](http://google.com).&quot;, &quot;This is a &quot;))

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser _:
input: &quot;_hyperlink: [foo](http://google.com).&quot;, delim: &quot;_&quot;
count: 1, starts_w: true, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;_hyperlink: [foo](http://google.com).&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser *:
input: &quot;_hyperlink: [foo](http://google.com).&quot;, delim: &quot;*&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;_hyperlink: [foo](http://google.com).&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser `:
input: &quot;_hyperlink: [foo](http://google.com).&quot;, delim: &quot;`&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;_hyperlink: [foo](http://google.com).&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser take text between delims err on new line:
input: &quot;_hyperlink: [foo](http://google.com).&quot;, start_delim: &quot;![&quot;, end_delim: &quot;]&quot;
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;_hyperlink: [foo](http://google.com).&quot;

<span style="color:#BF616A">‚¨¢‚¨¢</span> specialized parser error out with image:
input: &quot;_hyperlink: [foo](http://google.com).&quot;, delim: &quot;![&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser take text between delims err on new line:
input: &quot;_hyperlink: [foo](http://google.com).&quot;, start_delim: &quot;[&quot;, end_delim: &quot;]&quot;
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;_hyperlink: [foo](http://google.com).&quot;

<span style="color:#BF616A">‚¨¢‚¨¢</span> specialized parser error out with link:
input: &quot;_hyperlink: [foo](http://google.com).&quot;, delim: &quot;[&quot;
<span style="color:#BF616A">‚¨¢‚¨¢</span> specialized parser for checkbox: Err(Error(Error { input: &quot;_hyperlink: [foo](http://google.com).&quot;, code: Tag }))

<span style="color:#B48EAD">‚ñà‚ñà</span> plain parser, input: &quot;_hyperlink: [foo](http://google.com).&quot;
<span style="color:#81A1C1">‚ñ≤‚ñ≤</span> edge case -&gt; special case :: rem: &quot;hyperlink: [foo](http://google.com).&quot;, output: &quot;_&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser _:
input: &quot;hyperlink: [foo](http://google.com).&quot;, delim: &quot;_&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;hyperlink: [foo](http://google.com).&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser *:
input: &quot;hyperlink: [foo](http://google.com).&quot;, delim: &quot;*&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;hyperlink: [foo](http://google.com).&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser `:
input: &quot;hyperlink: [foo](http://google.com).&quot;, delim: &quot;`&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;hyperlink: [foo](http://google.com).&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser take text between delims err on new line:
input: &quot;hyperlink: [foo](http://google.com).&quot;, start_delim: &quot;![&quot;, end_delim: &quot;]&quot;
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;hyperlink: [foo](http://google.com).&quot;

<span style="color:#BF616A">‚¨¢‚¨¢</span> specialized parser error out with image:
input: &quot;hyperlink: [foo](http://google.com).&quot;, delim: &quot;![&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser take text between delims err on new line:
input: &quot;hyperlink: [foo](http://google.com).&quot;, start_delim: &quot;[&quot;, end_delim: &quot;]&quot;
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;hyperlink: [foo](http://google.com).&quot;

<span style="color:#BF616A">‚¨¢‚¨¢</span> specialized parser error out with link:
input: &quot;hyperlink: [foo](http://google.com).&quot;, delim: &quot;[&quot;
<span style="color:#BF616A">‚¨¢‚¨¢</span> specialized parser for checkbox: Err(Error(Error { input: &quot;hyperlink: [foo](http://google.com).&quot;, code: Tag }))

<span style="color:#B48EAD">‚ñà‚ñà</span> plain parser, input: &quot;hyperlink: [foo](http://google.com).&quot;
<span style="color:#81A1C1">‚ñ≤‚ñ≤</span> normal case :: Ok((&quot;[foo](http://google.com).&quot;, &quot;hyperlink: &quot;))

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser _:
input: &quot;[foo](http://google.com).&quot;, delim: &quot;_&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;[foo](http://google.com).&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser *:
input: &quot;[foo](http://google.com).&quot;, delim: &quot;*&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;[foo](http://google.com).&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser `:
input: &quot;[foo](http://google.com).&quot;, delim: &quot;`&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;[foo](http://google.com).&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser take text between delims err on new line:
input: &quot;[foo](http://google.com).&quot;, start_delim: &quot;![&quot;, end_delim: &quot;]&quot;
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;[foo](http://google.com).&quot;

<span style="color:#BF616A">‚¨¢‚¨¢</span> specialized parser error out with image:
input: &quot;[foo](http://google.com).&quot;, delim: &quot;![&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser take text between delims err on new line:
input: &quot;[foo](http://google.com).&quot;, start_delim: &quot;[&quot;, end_delim: &quot;]&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser take text between delims err on new line:
input: &quot;(http://google.com).&quot;, start_delim: &quot;(&quot;, end_delim: &quot;)&quot;
<span style="color:#81A1C1">‚ñ≤‚ñ≤</span> specialized parser for link: Ok((&quot;.&quot;, HyperlinkData { text: &quot;foo&quot;, url: &quot;http://google.com&quot; }))

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser _:
input: &quot;.&quot;, delim: &quot;_&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;.&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser *:
input: &quot;.&quot;, delim: &quot;*&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;.&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser `:
input: &quot;.&quot;, delim: &quot;`&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;.&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser take text between delims err on new line:
input: &quot;.&quot;, start_delim: &quot;![&quot;, end_delim: &quot;]&quot;
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;.&quot;

<span style="color:#BF616A">‚¨¢‚¨¢</span> specialized parser error out with image:
input: &quot;.&quot;, delim: &quot;![&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser take text between delims err on new line:
input: &quot;.&quot;, start_delim: &quot;[&quot;, end_delim: &quot;]&quot;
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;.&quot;

<span style="color:#BF616A">‚¨¢‚¨¢</span> specialized parser error out with link:
input: &quot;.&quot;, delim: &quot;[&quot;
<span style="color:#BF616A">‚¨¢‚¨¢</span> specialized parser for checkbox: Err(Error(Error { input: &quot;.&quot;, code: Tag }))

<span style="color:#B48EAD">‚ñà‚ñà</span> plain parser, input: &quot;.&quot;
<span style="color:#81A1C1">‚ñ≤‚ñ≤</span> normal case :: Ok((&quot;&quot;, &quot;.&quot;))

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser _:
input: &quot;&quot;, delim: &quot;_&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser *:
input: &quot;&quot;, delim: &quot;*&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser `:
input: &quot;&quot;, delim: &quot;`&quot;
count: 0, starts_w: false, input=delim: false
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser take text between delims err on new line:
input: &quot;&quot;, start_delim: &quot;![&quot;, end_delim: &quot;]&quot;
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;&quot;

<span style="color:#BF616A">‚¨¢‚¨¢</span> specialized parser error out with image:
input: &quot;&quot;, delim: &quot;![&quot;

<span style="color:#A3BE8C">‚ñ†‚ñ†</span> specialized parser take text between delims err on new line:
input: &quot;&quot;, start_delim: &quot;[&quot;, end_delim: &quot;]&quot;
<span style="color:#BF616A">‚¨¢‚¨¢</span> parser error out for input: &quot;&quot;

<span style="color:#BF616A">‚¨¢‚¨¢</span> specialized parser error out with link:
input: &quot;&quot;, delim: &quot;[&quot;
<span style="color:#BF616A">‚¨¢‚¨¢</span> specialized parser for checkbox: Err(Error(Error { input: &quot;&quot;, code: Tag }))

<span style="color:#B48EAD">‚ñà‚ñà</span> plain parser, input: &quot;&quot;
<span style="color:#BF616A">‚¨¢‚¨¢</span> normal case :: Err(Error(Error { input: &quot;&quot;, code: Eof }))
</pre>

<h2 id="see-this-in-action-in-r3bl-cmdr">See this in action in r3bl-cmdr</h2>

<p>If you want to use a TUI app that uses this Markdown Parser, run the following commands:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo <span class="nb">install </span>r3bl-cmdr
edi <span class="nt">--help</span>
</code></pre></div></div>

<p>This will install the <code class="language-plaintext highlighter-rouge">r3bl-cmdr</code> binary and run <code class="language-plaintext highlighter-rouge">edi</code>, which is a TUI Markdown editor
that you can use on any OS (Mac, Windows, Linux).</p>

<h2 id="references">References</h2>
<p><a id="markdown-references" name="references"></a></p>

<p><code class="language-plaintext highlighter-rouge">nom</code> is a huge topic. This tutorial takes a hands on approach to learning <code class="language-plaintext highlighter-rouge">nom</code>. However, the resources
listed below are very useful for learning <code class="language-plaintext highlighter-rouge">nom</code>. Think of them as a reference guide and deep dive into
how the <code class="language-plaintext highlighter-rouge">nom</code> library works.</p>

<ul>
  <li>Useful:
    <ul>
      <li>Source code examples (fantastic way to learn <code class="language-plaintext highlighter-rouge">nom</code>):
        <ul>
          <li><a href="https://github.com/dimfeld/export-logseq-notes/tree/master/src">export-logseq-notes repo</a></li>
        </ul>
      </li>
      <li>Videos:
        <ul>
          <li><a href="https://youtu.be/EXEMm5173SM">Intro from the author 7yrs old</a></li>
          <li><code class="language-plaintext highlighter-rouge">nom</code> 7 deep dive videos:
            <ul>
              <li><a href="https://youtu.be/Igajh2Vliog">Parsing name, age, and preference from natural language input</a></li>
              <li><a href="https://youtu.be/Xm4jrjohDN8">Parsing number ranges</a></li>
              <li><a href="https://youtu.be/6b2ymQWldoE">Parsing lines of text</a></li>
            </ul>
          </li>
          <li><code class="language-plaintext highlighter-rouge">nom</code> 6 videos (deep dive into how nom combinators themselves are constructed):
            <ul>
              <li><a href="https://youtu.be/zHF6j1LvngA">Deep dive, Part 1</a></li>
              <li><a href="https://youtu.be/9GLFJcSO08Y">Deep dive, Part 2</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Tutorials:
        <ul>
          <li><a href="https://codeandbitters.com/lets-build-a-parser/">Build a JSON parser using <code class="language-plaintext highlighter-rouge">nom</code> 7</a></li>
          <li><a href="https://github.com/benkay86/nom-tutorial">Excellent beginner to advanced</a></li>
          <li><a href="https://github.com/rust-bakery/nom/blob/main/doc/making_a_new_parser_from_scratch.md">Write a parser from scratch</a></li>
        </ul>
      </li>
      <li>Reference docs:
        <ul>
          <li><a href="https://tfpk.github.io/nominomicon/introduction.html">nominomicon</a></li>
          <li><a href="https://github.com/rust-bakery/nom/blob/main/doc/choosing_a_combinator.md">What combinator or parser to use?</a></li>
          <li><a href="https://docs.rs/nom/7.1.3/nom/">docs.rs</a></li>
          <li><a href="https://github.com/rust-bakery/nom/blob/main/doc/upgrading_to_nom_5.md">Upgrading to <code class="language-plaintext highlighter-rouge">nom</code> 5.0</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Less useful:
    <ul>
      <li><a href="https://github.com/rust-bakery/nom">README</a></li>
      <li><a href="https://crates.io/crates/nom"><code class="language-plaintext highlighter-rouge">nom</code> crate</a></li>
    </ul>
  </li>
</ul>

<h2 id="build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</h2>
<p><a id="markdown-build-with-naz-video-series-on-developerlife.com-youtube-channel" name="build-with-naz-video-series-on-developerlife.com-youtube-channel"></a></p>

<blockquote>
  <p>If you have comments and feedback on this content, or would like to request new content
(articles &amp; videos) on developerlife.com, please join our <a href="https://discord.gg/8M2ePAevaMi">discord
server</a>.</p>
</blockquote>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a></li>
  <li>Playlists
    <ul>
      <li><a href="https://www.youtube.com/watch?v=bolScvh4x7I&amp;list=PLofhE49PEwmw3MKOU1Kn3xbP4FRQR4Mb3">Build with Naz, Linux TTY, process, signals, commands in async Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmza94sS7UmJnN9gSCHTVTfz">Build with Naz, fundamental effective Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmwO69E7eiQ-ewnMME8ydgQ5">Build with Naz, effective async Rust and tokio</a></li>
      <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><category term="TUI" /><summary type="html"><![CDATA[This tutorial and video are a deep dive in a real Markdown parser written using nom in Rust. This MD Parser is part of the r3bl_tui crate, which is part of the r3bl-open-core repo. It goes over the architecture of thinking about building complex parsers and the nitty gritty details the runtime nature and behavior when combining nom parsers.]]></summary></entry><entry><title type="html">Build with Naz : Rust error handling with miette</title><link href="http://developerlife.com/2024/06/10/rust-miette-error-handling/" rel="alternate" type="text/html" title="Build with Naz : Rust error handling with miette" /><published>2024-06-10T10:00:00-05:00</published><updated>2024-06-10T10:00:00-05:00</updated><id>http://developerlife.com/2024/06/10/rust-miette-error-handling</id><content type="html" xml:base="http://developerlife.com/2024/06/10/rust-miette-error-handling/"><![CDATA[<p><img class="post-hero-image" src="/assets/rust-miette.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#rust-error-handling-primer">Rust error handling primer</a></li>
  <li><a href="#more-resources-on-rust-error-handling">More resources on Rust error handling</a></li>
  <li><a href="#youtube-video-for-this-article">YouTube video for this article</a></li>
  <li><a href="#examples-of-rust-error-handling-with-miette">Examples of Rust error handling with miette</a>
    <ul>
      <li><a href="#example-1-simple-miette-usage">Example 1: Simple miette usage</a></li>
      <li><a href="#example-2-complex-miette-usage">Example 2: Complex miette usage</a></li>
      <li><a href="#parting-thoughts">Parting thoughts</a></li>
    </ul>
  </li>
  <li><a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</a></li>
</ul>

<!-- /TOC -->

<h2 id="introduction">Introduction</h2>
<p><a id="markdown-introduction" name="introduction"></a></p>

<p>miette is an excellent crate that can make error handling in Rust powerful, flexible,
and easy to use. It provides a way to create custom error types, add context to errors,
and display errors in a user-friendly way. In this article, video, and repo, we‚Äôll
explore how to use miette to improve error handling in your Rust applications.</p>

<h2 id="rust-error-handling-primer">Rust error handling primer</h2>
<p><a id="markdown-rust-error-handling-primer" name="rust-error-handling-primer"></a></p>

<p>Rust has a powerful error handling system that is based on the
<a href="https://doc.rust-lang.org/std/result/"><code class="language-plaintext highlighter-rouge">Result</code></a> and <code class="language-plaintext highlighter-rouge">Option</code> types. For this tutorial we
will focus on the <code class="language-plaintext highlighter-rouge">Result</code> type, which is an enum that has two variants: <code class="language-plaintext highlighter-rouge">Ok</code> and <code class="language-plaintext highlighter-rouge">Err</code>.
The <code class="language-plaintext highlighter-rouge">Ok</code> variant is used to represent a successful result, while the <code class="language-plaintext highlighter-rouge">Err</code> variant is used
to represent an error.</p>

<p>The <a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code class="language-plaintext highlighter-rouge">Error</code></a> trait in Rust has to
be implemented for types that can be used as errors. The <code class="language-plaintext highlighter-rouge">Error</code> trait has a method called
<code class="language-plaintext highlighter-rouge">source</code> that returns a reference to the underlying cause of the error. This trait has two
supertraits: <code class="language-plaintext highlighter-rouge">Debug</code> and <code class="language-plaintext highlighter-rouge">Display</code>. The <code class="language-plaintext highlighter-rouge">Debug</code> trait is used to format the error for
debugging purposes (for the operator), while the <code class="language-plaintext highlighter-rouge">Display</code> trait is used to format the
error for displaying to the user.</p>

<p>The <code class="language-plaintext highlighter-rouge">?</code> operator can be used in order to propagate errors up the call stack. This operator
is used to unwrap the <code class="language-plaintext highlighter-rouge">Result</code> type and provide the inner value of the <code class="language-plaintext highlighter-rouge">Ok</code> variant.
Otherwise it returns from the function with the error, if it is the <code class="language-plaintext highlighter-rouge">Err</code> variant. This
operator can only be used in functions that return a <code class="language-plaintext highlighter-rouge">Result</code> type. Here‚Äôs an example:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Fails and produces output:</span>
<span class="cd">/// ```text</span>
<span class="cd">/// Error: ParseIntError { kind: InvalidDigit }</span>
<span class="cd">/// ```</span>
<span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">test</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">return_error_result</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">u32</span><span class="p">,</span> <span class="nn">std</span><span class="p">::</span><span class="nn">num</span><span class="p">::</span><span class="n">ParseIntError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="s">"1.2"</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">run</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="c1">// It is as if the `?` is turned into the following code.</span>
        <span class="c1">// let result = match result {</span>
        <span class="c1">//     Ok(value) =&gt; value,</span>
        <span class="c1">//     Err(err) =&gt; return Err(Box::new(err)),</span>
        <span class="c1">// }</span>
        <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">return_error_result</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

        <span class="c1">// The following lines will never be executed, since the previous</span>
        <span class="c1">// line will return from the function with an error.</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Result: {}"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>

    <span class="nf">run</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In the rest of the tutorial (and accompanying video), we will build upon this knowledge
and introduce <code class="language-plaintext highlighter-rouge">miette</code>, a crate that can make error handling in Rust powerful, flexible,
and easy to use. We will also learn more about the <code class="language-plaintext highlighter-rouge">thiserror</code> crate, which can be used to
easily create custom error types in Rust.</p>

<h2 id="more-resources-on-rust-error-handling">More resources on Rust error handling</h2>
<p><a id="markdown-more-resources-on-rust-error-handling" name="more-resources-on-rust-error-handling"></a></p>

<ul>
  <li><a href="https://docs.rs/thiserror/latest/thiserror/"><code class="language-plaintext highlighter-rouge">thiserror</code> crate</a>.</li>
  <li><a href="https://docs.rs/miette/latest/miette/"><code class="language-plaintext highlighter-rouge">miette</code> crate</a>.</li>
  <li><a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code class="language-plaintext highlighter-rouge">Error</code> trait</a>.</li>
  <li><a href="https://doc.rust-lang.org/std/result/"><code class="language-plaintext highlighter-rouge">Result</code> enum</a>.</li>
</ul>

<h2 id="youtube-video-for-this-article">YouTube video for this article</h2>
<p><a id="markdown-youtube-video-for-this-article" name="youtube-video-for-this-article"></a></p>

<p>This blog post has short examples on how to use <code class="language-plaintext highlighter-rouge">miette</code> to enhance Rust error handling. If
you like to learn via video, please watch the companion video on the <a href="https://www.youtube.com/@developerlifecom">developerlife.com
YouTube channel</a>.</p>

<!-- rust error handling with miette -->
<iframe src="https://www.youtube.com/embed/TmLF7vI8lKk?si=Xh5belp5zD-w-J3P" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<p><br /></p>

<h2 id="examples-of-rust-error-handling-with-miette">Examples of Rust error handling with miette</h2>
<p><a id="markdown-examples-of-rust-error-handling-with-miette" name="examples-of-rust-error-handling-with-miette"></a></p>

<p>Let‚Äôs create some examples to illustrate how to use <code class="language-plaintext highlighter-rouge">miette</code> to enhance Rust error
handling. You can run <code class="language-plaintext highlighter-rouge">cargo new --lib error-miette</code> to create a new library crate.</p>

<blockquote>
  <p>The code in the video and this tutorial are all in <a href="https://github.com/nazmulidris/rust-scratch/blob/main/error-miette/src/lib.rs">this GitHub
repo</a>.</p>
</blockquote>

<p>Then add the following to the <code class="language-plaintext highlighter-rouge">Cargo.toml</code> file that‚Äôs generated. These pull in all the
dependencies that we need for these examples.</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[package]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"error-miette"</span>
<span class="py">version</span> <span class="p">=</span> <span class="s">"0.1.0"</span>
<span class="py">edition</span> <span class="p">=</span> <span class="s">"2021"</span>

<span class="nn">[dependencies]</span>

<span class="c"># Pretty terminal output.</span>
<span class="py">crossterm</span> <span class="p">=</span> <span class="s">"0.27.0"</span>

<span class="c"># Error handling.</span>
<span class="py">thiserror</span> <span class="p">=</span> <span class="s">"1.0.61"</span>
<span class="py">miette</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"7.2.0"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"fancy"</span><span class="p">]</span> <span class="p">}</span>
<span class="py">pretty_assertions</span> <span class="p">=</span> <span class="s">"1.4.0"</span>
</code></pre></div></div>

<h3 id="example-1-simple-miette-usage">Example 1: Simple miette usage</h3>
<p><a id="markdown-example-1%3A-simple-miette-usage" name="example-1%3A-simple-miette-usage"></a></p>

<p>Then you can add the following code to the <code class="language-plaintext highlighter-rouge">src/lib.rs</code> file. You can note the following things
in the code:</p>
<ul>
  <li>We define a custom error type called <code class="language-plaintext highlighter-rouge">UnderlyingDatabaseError</code> using the <code class="language-plaintext highlighter-rouge">thiserror</code> crate.</li>
  <li>We define a function called <code class="language-plaintext highlighter-rouge">return_error_result</code> that returns a <code class="language-plaintext highlighter-rouge">Result&lt;u32, std::num::ParseIntError&gt;</code>.</li>
  <li>We write a test called <code class="language-plaintext highlighter-rouge">test_into_diagnostic</code> that demonstrates how to use <code class="language-plaintext highlighter-rouge">miette</code> to
add context to errors and display them in a user-friendly way. The test also
demonstrates how to use the <code class="language-plaintext highlighter-rouge">wrap_err</code> and <code class="language-plaintext highlighter-rouge">context</code> methods to add context to errors.
And how they are displayed in the error report (in the inverse order in which they were
added).</li>
  <li>We also demonstrate how to use the <code class="language-plaintext highlighter-rouge">into_diagnostic</code> method to convert a <code class="language-plaintext highlighter-rouge">Result</code> into a
<code class="language-plaintext highlighter-rouge">miette::Result</code>.</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="k">pub</span> <span class="k">mod</span> <span class="n">simple_miette_usage</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">crossterm</span><span class="p">::</span><span class="nn">style</span><span class="p">::</span><span class="n">Stylize</span><span class="p">;</span>
    <span class="k">use</span> <span class="nn">miette</span><span class="p">::{</span><span class="n">Context</span><span class="p">,</span> <span class="n">IntoDiagnostic</span><span class="p">};</span>

    <span class="nd">#[derive(Debug,</span> <span class="nd">thiserror::Error)]</span>
    <span class="k">pub</span> <span class="k">enum</span> <span class="n">UnderlyingDatabaseError</span> <span class="p">{</span>
        <span class="nd">#[error(</span><span class="s">"database corrupted"</span><span class="nd">)]</span>
        <span class="n">DatabaseCorrupted</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">return_error_result</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">u32</span><span class="p">,</span> <span class="nn">std</span><span class="p">::</span><span class="nn">num</span><span class="p">::</span><span class="n">ParseIntError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="s">"1.2"</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">test_into_diagnostic</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">error_result</span><span class="p">:</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">u32</span><span class="p">,</span> <span class="nn">std</span><span class="p">::</span><span class="nn">num</span><span class="p">::</span><span class="n">ParseIntError</span><span class="o">&gt;</span> <span class="o">=</span>
            <span class="nf">return_error_result</span><span class="p">();</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">error_result</span><span class="nf">.is_err</span><span class="p">());</span>

        <span class="c1">// The following line will return from this test.</span>
        <span class="c1">// let it: u32 = error_result.into_diagnostic()?;</span>

        <span class="k">let</span> <span class="n">new_miette_result</span><span class="p">:</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">error_result</span>
            <span class="nf">.into_diagnostic</span><span class="p">()</span>
            <span class="nf">.context</span><span class="p">(</span><span class="s">"üçç foo bar baz"</span><span class="p">)</span>
            <span class="nf">.wrap_err</span><span class="p">(</span><span class="nn">miette</span><span class="p">::</span><span class="nd">miette!</span><span class="p">(</span><span class="s">"custom string error"</span><span class="p">))</span>
            <span class="nf">.wrap_err</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="nn">ErrorKind</span><span class="p">::</span><span class="n">NotFound</span><span class="p">)</span>
            <span class="nf">.wrap_err</span><span class="p">(</span><span class="nn">UnderlyingDatabaseError</span><span class="p">::</span><span class="n">DatabaseCorrupted</span><span class="p">)</span>
            <span class="nf">.wrap_err</span><span class="p">(</span><span class="s">"üéÉ this is additional context about the failure"</span><span class="p">);</span>

        <span class="nd">assert!</span><span class="p">(</span><span class="n">new_miette_result</span><span class="nf">.is_err</span><span class="p">());</span>

        <span class="nd">println!</span><span class="p">(</span>
            <span class="s">"{}:</span><span class="se">\n</span><span class="s">{:?}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="s">"debug output"</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.bold</span><span class="p">(),</span>
            <span class="n">new_miette_result</span>
        <span class="p">);</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Err</span><span class="p">(</span><span class="k">ref</span> <span class="n">miette_report</span><span class="p">)</span> <span class="o">=</span> <span class="n">new_miette_result</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span>
                <span class="s">"{}:</span><span class="se">\n</span><span class="s">{:?}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                <span class="s">"miette report"</span><span class="nf">.red</span><span class="p">()</span><span class="nf">.bold</span><span class="p">(),</span>
                <span class="n">miette_report</span><span class="nf">.to_string</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">miette_report</span><span class="nf">.chain</span><span class="p">();</span>

            <span class="c1">// First.</span>
            <span class="nn">pretty_assertions</span><span class="p">::</span><span class="nd">assert_eq!</span><span class="p">(</span>
                <span class="n">iter</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="s">"üéÉ this is additional context about the failure"</span>
                    <span class="nf">.to_string</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="c1">// Second.</span>
            <span class="nn">pretty_assertions</span><span class="p">::</span><span class="nd">assert_eq!</span><span class="p">(</span>
                <span class="n">iter</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="s">"database corrupted"</span><span class="nf">.to_string</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="c1">// Third.</span>
            <span class="nn">pretty_assertions</span><span class="p">::</span><span class="nd">assert_eq!</span><span class="p">(</span>
                <span class="n">iter</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="s">"entity not found"</span><span class="nf">.to_string</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="c1">// Fourth.</span>
            <span class="nn">pretty_assertions</span><span class="p">::</span><span class="nd">assert_eq!</span><span class="p">(</span>
                <span class="n">iter</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="s">"custom string error"</span><span class="nf">.to_string</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="c1">// Fifth.</span>
            <span class="nn">pretty_assertions</span><span class="p">::</span><span class="nd">assert_eq!</span><span class="p">(</span>
                <span class="n">iter</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="s">"üçç foo bar baz"</span><span class="nf">.to_string</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="c1">// Final.</span>
            <span class="nn">pretty_assertions</span><span class="p">::</span><span class="nd">assert_eq!</span><span class="p">(</span>
                <span class="n">iter</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="s">"invalid digit found in string"</span><span class="nf">.to_string</span><span class="p">()</span>
            <span class="p">);</span>
        <span class="p">}</span>

        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">test_convert_report_into_error</span><span class="p">()</span> <span class="k">-&gt;</span>
        <span class="nn">std</span><span class="p">::</span><span class="nn">result</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">miette_result</span><span class="p">:</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span> <span class="o">=</span>
            <span class="nf">return_error_result</span><span class="p">()</span>
                <span class="nf">.into_diagnostic</span><span class="p">()</span>
                <span class="nf">.wrap_err</span><span class="p">(</span><span class="nn">miette</span><span class="p">::</span><span class="nn">Report</span><span class="p">::</span><span class="nf">msg</span><span class="p">(</span>
                    <span class="s">"wrapper for the source parse int error"</span><span class="p">,</span>
                <span class="p">));</span>

        <span class="c1">// let converted_result: Result&lt;u32, Box&lt;dyn Error&gt;&gt; =</span>
        <span class="c1">//     miette_result.map_err(|report| report.into());</span>

        <span class="k">let</span> <span class="n">converted_result</span><span class="p">:</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">result</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;&gt;</span> <span class="o">=</span>
            <span class="k">match</span> <span class="n">miette_result</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(()),</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">miette_report</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">boxed_error</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span> <span class="o">=</span>
                        <span class="n">miette_report</span><span class="nf">.into</span><span class="p">();</span>
                    <span class="nf">Err</span><span class="p">(</span><span class="n">boxed_error</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">};</span>

        <span class="nd">println!</span><span class="p">(</span>
            <span class="s">"{}:</span><span class="se">\n</span><span class="s">{:?}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="s">"debug output"</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.bold</span><span class="p">(),</span>
            <span class="n">converted_result</span>
        <span class="p">);</span>

        <span class="nd">assert!</span><span class="p">(</span><span class="n">converted_result</span><span class="nf">.is_err</span><span class="p">());</span>

        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="example-2-complex-miette-usage">Example 2: Complex miette usage</h3>
<p><a id="markdown-example-2%3A-complex-miette-usage" name="example-2%3A-complex-miette-usage"></a></p>

<p>Next, we will add the following code to the <code class="language-plaintext highlighter-rouge">src/lib.rs</code> file. You can note the following
things in the code:</p>

<ul>
  <li>We define a custom error type called <code class="language-plaintext highlighter-rouge">KvStoreError</code> using the <code class="language-plaintext highlighter-rouge">thiserror</code> crate.</li>
  <li>We define two variants for the <code class="language-plaintext highlighter-rouge">KvStoreError</code> enum: <code class="language-plaintext highlighter-rouge">CouldNotCreateDbFolder</code> and
<code class="language-plaintext highlighter-rouge">CouldNotGetOrCreateEnvOrOpenStore</code>. The latter variant has a field called <code class="language-plaintext highlighter-rouge">source</code> that
is of type <code class="language-plaintext highlighter-rouge">UnderlyingDatabaseError</code>, which is defined in the previous example.</li>
  <li>We define two functions called <code class="language-plaintext highlighter-rouge">return_flat_err</code> and <code class="language-plaintext highlighter-rouge">return_nested_err</code> that return
<code class="language-plaintext highlighter-rouge">miette::Result&lt;(), KvStoreError&gt;</code>.</li>
  <li>We write two tests called <code class="language-plaintext highlighter-rouge">fails_with_flat_err</code> and <code class="language-plaintext highlighter-rouge">fails_with_nested_err</code> that
demonstrate how to use <code class="language-plaintext highlighter-rouge">miette</code> to add context to errors and display them in a
user-friendly way. The tests also demonstrate how to use the <code class="language-plaintext highlighter-rouge">from</code> attribute to convert
an error of one type into an error of another type.</li>
  <li>We also demonstrate how to use the <code class="language-plaintext highlighter-rouge">#[diagnostic]</code> attribute to add a code and help URL
to the error type.</li>
  <li>We also demonstrate how to use the <code class="language-plaintext highlighter-rouge">#[from]</code> attribute to convert an error of one type
into an error of another type.</li>
  <li>We also demonstrate how to use the <code class="language-plaintext highlighter-rouge">#[error]</code> attribute to add a custom error message to
the error type.</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="k">pub</span> <span class="k">mod</span> <span class="n">complex_miette_usage</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span><span class="p">;</span>

    <span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="nn">simple_miette_usage</span><span class="p">::</span><span class="n">UnderlyingDatabaseError</span><span class="p">;</span>
    <span class="k">use</span> <span class="nn">pretty_assertions</span><span class="p">::</span><span class="n">assert_eq</span><span class="p">;</span>

    <span class="nd">#[derive(thiserror::Error,</span> <span class="nd">Debug,</span> <span class="nd">miette::Diagnostic)]</span>
    <span class="k">pub</span> <span class="k">enum</span> <span class="n">KvStoreError</span> <span class="p">{</span>
        <span class="nd">#[diagnostic(</span>
            <span class="nd">code(MyErrorCode::FileSystemError),</span>
            <span class="nd">help(</span><span class="s">"https://docs.rs/rkv/latest/rkv/enum.StoreError.html"</span><span class="nd">),</span>
            <span class="c1">// url(docsrs) /* Works if this code was on crates.io / docs.rs */</span>
        <span class="nd">)]</span>
        <span class="nd">#[error(</span><span class="s">"üìÇ Could not create db folder: '{db_folder_path}' on disk"</span><span class="nd">)]</span>
        <span class="n">CouldNotCreateDbFolder</span> <span class="p">{</span> <span class="n">db_folder_path</span><span class="p">:</span> <span class="nb">String</span> <span class="p">},</span>

        <span class="nd">#[diagnostic(</span>
            <span class="nd">code(MyErrorCode::StoreCreateOrAccessError),</span>
            <span class="nd">help(</span><span class="s">"https://docs.rs/rkv/latest/rkv/enum.StoreError.html"</span><span class="nd">),</span>
            <span class="c1">// url(docsrs) /* Works if this code was on crates.io / docs.rs */</span>
        <span class="nd">)]</span>
        <span class="nd">#[error(</span><span class="s">"üíæ Could not get or create environment, or open store"</span><span class="nd">)]</span>
        <span class="n">CouldNotGetOrCreateEnvOrOpenStore</span> <span class="p">{</span>
            <span class="nd">#[from]</span>
            <span class="n">source</span><span class="p">:</span> <span class="n">UnderlyingDatabaseError</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">return_flat_err</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">KvStoreError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nn">Result</span><span class="p">::</span><span class="nf">Err</span><span class="p">(</span><span class="nn">KvStoreError</span><span class="p">::</span><span class="n">CouldNotCreateDbFolder</span> <span class="p">{</span>
            <span class="n">db_folder_path</span><span class="p">:</span> <span class="s">"some/path/to/db"</span><span class="nf">.to_string</span><span class="p">(),</span>
        <span class="p">})</span>
    <span class="p">}</span>

    <span class="cd">/// This test will not run! It will fail and demonstrate the default</span>
    <span class="cd">/// [report handler](miette::ReportHandler) of the `miette` crate.</span>
    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">fails_with_flat_err</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">return_flat_err</span><span class="p">();</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Err</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">result</span> <span class="p">{</span>
            <span class="nd">assert_eq!</span><span class="p">(</span>
                <span class="nd">format!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">error</span><span class="p">),</span>
                <span class="s">"CouldNotCreateDbFolder { db_folder_path: </span><span class="se">\"</span><span class="s">some/path/to/db</span><span class="se">\"</span><span class="s"> }"</span>
            <span class="p">);</span>
        <span class="p">}</span>

        <span class="n">result</span><span class="o">?</span><span class="p">;</span>

        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">return_nested_err</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">KvStoreError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// Variant 1 - Very verbose.</span>
        <span class="k">let</span> <span class="n">store_error</span> <span class="o">=</span> <span class="nn">UnderlyingDatabaseError</span><span class="p">::</span><span class="n">DatabaseCorrupted</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">rkv_error</span> <span class="o">=</span> <span class="nn">KvStoreError</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">store_error</span><span class="p">);</span>
        <span class="nn">Result</span><span class="p">::</span><span class="nf">Err</span><span class="p">(</span><span class="n">rkv_error</span><span class="p">)</span>

        <span class="c1">// Variant 2.</span>
        <span class="c1">// Result::Err(KvStoreError::CouldNotGetOrCreateEnvOrOpenStore {</span>
        <span class="c1">//     source: UnderlyingDatabaseError::DatabaseCorrupted,</span>
        <span class="c1">// })</span>
    <span class="p">}</span>

    <span class="cd">/// This test will not run! It will fail and demonstrate the default</span>
    <span class="cd">/// [report handler](miette::ReportHandler) of the `miette` crate.</span>
    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">fails_with_nested_err</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">return_nested_err</span><span class="p">();</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Err</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">result</span> <span class="p">{</span>
            <span class="nd">assert_eq!</span><span class="p">(</span>
                <span class="nd">format!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">error</span><span class="p">),</span>
                <span class="s">"CouldNotGetOrCreateEnvOrOpenStore { source: DatabaseCorrupted }"</span>
            <span class="p">);</span>
        <span class="p">}</span>

        <span class="n">result</span><span class="o">?</span><span class="p">;</span>

        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="parting-thoughts">Parting thoughts</h3>
<p><a id="markdown-parting-thoughts" name="parting-thoughts"></a></p>

<p>For more sophisticated error handling examples, please check out the following links:</p>

<ul>
  <li><a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/terminal_async/src/public_api/terminal_async.rs#L57"><code class="language-plaintext highlighter-rouge">terminal_async.rs</code> in <code class="language-plaintext highlighter-rouge">r3bl_terminal_async</code>
crate</a>.</li>
  <li><a href="https://github.com/nazmulidris/rust-scratch/blob/main/tcp-api-server/src/standalone/kv.rs#L137"><code class="language-plaintext highlighter-rouge">kv.rs</code> in <code class="language-plaintext highlighter-rouge">tcp-api-server</code>
crate</a>.</li>
  <li><a href="https://github.com/nazmulidris/rust-scratch/blob/main/tcp-api-server/src/standalone/miette_setup_global_report_handler.rs">Custom global report handler for <code class="language-plaintext highlighter-rouge">miette</code> in <code class="language-plaintext highlighter-rouge">tcp-api-server</code>
crate</a>.</li>
</ul>

<h2 id="build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</h2>
<p><a id="markdown-build-with-naz-video-series-on-developerlife.com-youtube-channel" name="build-with-naz-video-series-on-developerlife.com-youtube-channel"></a></p>

<blockquote>
  <p>If you have comments and feedback on this content, or would like to request new content
(articles &amp; videos) on developerlife.com, please join our <a href="https://discord.gg/8M2ePAevaMi">discord
server</a>.</p>
</blockquote>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a></li>
  <li>Playlists
    <ul>
      <li><a href="https://www.youtube.com/watch?v=bolScvh4x7I&amp;list=PLofhE49PEwmw3MKOU1Kn3xbP4FRQR4Mb3">Build with Naz, Linux TTY, process, signals, commands in async Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmza94sS7UmJnN9gSCHTVTfz">Build with Naz, fundamental effective Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmwO69E7eiQ-ewnMME8ydgQ5">Build with Naz, effective async Rust and tokio</a></li>
      <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><summary type="html"><![CDATA[miette is an excellent crate that can make error handling in Rust powerful, flexible, and easy to use. It provides a way to create custom error types, add context to errors, and display errors in a user-friendly way. In this article, video, and repo, we'll explore how to use miette to improve error handling in your Rust applications.]]></summary></entry><entry><title type="html">Build with Naz : Rust typestate pattern</title><link href="http://developerlife.com/2024/05/28/typestate-pattern-rust/" rel="alternate" type="text/html" title="Build with Naz : Rust typestate pattern" /><published>2024-05-28T10:00:00-05:00</published><updated>2024-05-28T10:00:00-05:00</updated><id>http://developerlife.com/2024/05/28/typestate-pattern-rust</id><content type="html" xml:base="http://developerlife.com/2024/05/28/typestate-pattern-rust/"><![CDATA[<p><img class="post-hero-image" src="/assets/rust-typestate-pattern.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#what-is-the-typestate-pattern">What is the typestate pattern?</a></li>
  <li><a href="#more-resources-on-typestate-pattern-and-others-in-rust">More resources on typestate pattern and others in Rust</a></li>
  <li><a href="#youtube-video-for-this-article">YouTube video for this article</a></li>
  <li><a href="#examples-of-typestate-pattern-in-rust">Examples of typestate pattern in Rust</a>
    <ul>
      <li><a href="#example-1-simple-version-of-this-is-using-enums-to-encapsulate-states-as-variants">Example 1: Simple version of this is using enums to encapsulate states as variants</a></li>
      <li><a href="#example-2-slightly-more-complex-versions-are-where-one-type--data--another-type">Example 2: Slightly more complex versions are where one type + data = another type</a></li>
      <li><a href="#example-3-best-of-both-worlds-using-generics-and-struct--enum-with-a-marker-trait">Example 3: Best of both worlds, using generics and struct / enum with a marker trait</a></li>
      <li><a href="#example-31-using-enum-and-phantomdata-instead-of-struct">Example 3.1: Using enum and PhantomData instead of struct</a></li>
      <li><a href="#parting-thoughts">Parting thoughts</a></li>
    </ul>
  </li>
  <li><a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</a></li>
</ul>

<!-- /TOC -->

<h2 id="what-is-the-typestate-pattern">What is the typestate pattern?</h2>
<p><a id="markdown-what-is-the-typestate-pattern%3F" name="what-is-the-typestate-pattern%3F"></a></p>

<p>The Typestate Pattern in Rust is a way to manage objects that go through different states
in their lifecycle. It leverages Rust‚Äôs powerful type system to enforce these states and
transitions between them, making your code safer and more predictable. Learn all about it
in this article, its video, and repo.</p>

<p>Here are the key ideas behind the Typestate Pattern:</p>

<ul>
  <li><em>States as structs</em>: Each possible state of the object is represented by a separate
struct. This lets you associate specific methods and data with each state.</li>
  <li><em>Transitions with ownership</em>: Methods that transition the object to a new state consume
the old state and return a value representing the new state. Rust‚Äôs ownership system
ensures you can‚Äôt accidentally use the object in an invalid state.</li>
  <li><em>Encapsulated functionality</em>: Methods are only available on the structs representing the
valid states. This prevents you from trying to perform actions that aren‚Äôt allowed in
the current state.</li>
</ul>

<p>Benefits of using the Typestate Pattern:</p>

<ul>
  <li><em>Safer code</em>: By statically checking types at compile time, the compiler prevents you from
accidentally using the object in an invalid state. This leads to fewer runtime errors
and more robust code.</li>
  <li><em>Improved readability</em>: The code becomes more self-documenting because the valid state
transitions are encoded in the types themselves.</li>
  <li><em>Clearer APIs</em>: By separating functionality based on state, APIs become more intuitive and
easier to understand.</li>
</ul>

<h2 id="more-resources-on-typestate-pattern-and-others-in-rust">More resources on typestate pattern and others in Rust</h2>
<p><a id="markdown-more-resources-on-typestate-pattern-and-others-in-rust" name="more-resources-on-typestate-pattern-and-others-in-rust"></a></p>

<ul>
  <li><a href="https://arxiv.org/pdf/2307.07069">Functional typed design patterns</a>.</li>
  <li><a href="https://gemini.google.com/app/5bd7fed51858cb4d">Enums and typestate (and limitations)</a>.</li>
  <li><a href="https://willcrichton.net/rust-api-type-patterns/typestate.html">Type-Driven API Design in Rust</a>.</li>
  <li><a href="https://ruk.si/notes/rust/typestate/">Rust typestate notes</a>.</li>
  <li><a href="https://rustype.github.io/notes/notes/rust-typestate-series/rust-typestate-part-1">Rusty Typestates - Starting Out</a>.</li>
  <li><a href="https://docs.rust-embedded.org/book/static-guarantees/typestate-programming.html">The Embedded Rust Book - Typestate programming</a>.</li>
  <li><a href="https://yoric.github.io/post/rust-typestate/">Typestates in Rust</a>.</li>
</ul>

<h2 id="youtube-video-for-this-article">YouTube video for this article</h2>
<p><a id="markdown-youtube-video-for-this-article" name="youtube-video-for-this-article"></a></p>

<p>This blog post has short examples on how to use the typestate pattern in Rust. If you like
to learn via video, please watch the companion video on the <a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube
channel</a>.</p>

<!-- rust typestate pattern -->
<iframe src="https://www.youtube.com/embed/FTSb0dyDOCA?si=ZdUYIxxGTsaAC1B3" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<p><br /></p>

<h2 id="examples-of-typestate-pattern-in-rust">Examples of typestate pattern in Rust</h2>
<p><a id="markdown-examples-of-typestate-pattern-in-rust" name="examples-of-typestate-pattern-in-rust"></a></p>

<p>Let‚Äôs create some examples to illustrate how to use the typestate pattern in Rust. You can run
<code class="language-plaintext highlighter-rouge">cargo new --bin typestate-pattern</code> to create a new binary crate.</p>

<blockquote>
  <p>The code in the video and this tutorial are all in <a href="https://github.com/nazmulidris/rust-scratch/blob/main/typestate-pattern/">this GitHub
repo</a>.</p>
</blockquote>

<p>Then add the following to the <code class="language-plaintext highlighter-rouge">Cargo.toml</code> file that‚Äôs generated. These pull in all the
dependencies that we need for these examples.</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[package]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"typestate-pattern"</span>
<span class="py">version</span> <span class="p">=</span> <span class="s">"0.1.0"</span>
<span class="py">edition</span> <span class="p">=</span> <span class="s">"2021"</span>

<span class="nn">[[bin]]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"ex1"</span>
<span class="py">path</span> <span class="p">=</span> <span class="s">"src/ex1.rs"</span>

<span class="nn">[[bin]]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"ex2"</span>
<span class="py">path</span> <span class="p">=</span> <span class="s">"src/ex2.rs"</span>

<span class="nn">[[bin]]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"ex3"</span>
<span class="py">path</span> <span class="p">=</span> <span class="s">"src/ex3.rs"</span>

<span class="nn">[[bin]]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"ex3_1"</span>
<span class="py">path</span> <span class="p">=</span> <span class="s">"src/ex3_1.rs"</span>

<span class="c"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span>

<span class="nn">[dependencies]</span>
<span class="py">crossterm</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.27.0"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"event-stream"</span><span class="p">]</span> <span class="p">}</span>
</code></pre></div></div>

<h3 id="example-1-simple-version-of-this-is-using-enums-to-encapsulate-states-as-variants">Example 1: Simple version of this is using enums to encapsulate states as variants</h3>
<p><a id="markdown-example-1%3A-simple-version-of-this-is-using-enums-to-encapsulate-states-as-variants" name="example-1%3A-simple-version-of-this-is-using-enums-to-encapsulate-states-as-variants"></a></p>

<p>Then you can add the following code to the <code class="language-plaintext highlighter-rouge">src/ex1.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">InputEvent</span> <span class="p">{</span>
    <span class="nf">Keyboard</span><span class="p">((</span><span class="n">KeyPress</span><span class="p">,</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Modifier</span><span class="o">&gt;&gt;</span><span class="p">)),</span>
    <span class="nf">Resize</span><span class="p">(</span><span class="n">Size</span><span class="p">),</span>
    <span class="nf">Mouse</span><span class="p">(</span><span class="n">MouseEvent</span><span class="p">),</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">Modifier</span> <span class="p">{</span>
    <span class="n">Shift</span><span class="p">,</span>
    <span class="n">Control</span><span class="p">,</span>
    <span class="n">Alt</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">KeyPress</span> <span class="p">{</span>
    <span class="nf">Char</span><span class="p">(</span><span class="nb">char</span><span class="p">),</span>
    <span class="n">Enter</span><span class="p">,</span>
    <span class="n">Backspace</span><span class="p">,</span>
    <span class="n">Delete</span><span class="p">,</span>
    <span class="n">Left</span><span class="p">,</span>
    <span class="n">Right</span><span class="p">,</span>
    <span class="n">Up</span><span class="p">,</span>
    <span class="n">Down</span><span class="p">,</span>
    <span class="n">Home</span><span class="p">,</span>
    <span class="n">End</span><span class="p">,</span>
    <span class="n">PageUp</span><span class="p">,</span>
    <span class="n">PageDown</span><span class="p">,</span>
    <span class="n">Tab</span><span class="p">,</span>
    <span class="nf">F</span><span class="p">(</span><span class="nb">u8</span><span class="p">),</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">Size</span> <span class="p">{</span>
    <span class="nf">Height</span><span class="p">(</span><span class="nb">u16</span><span class="p">),</span>
    <span class="nf">Width</span><span class="p">(</span><span class="nb">u16</span><span class="p">),</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">MouseEvent</span> <span class="p">{</span>
    <span class="nf">Press</span><span class="p">(</span><span class="n">MouseButton</span><span class="p">,</span> <span class="nb">u16</span><span class="p">,</span> <span class="nb">u16</span><span class="p">),</span>
    <span class="nf">Release</span><span class="p">(</span><span class="nb">u16</span><span class="p">,</span> <span class="nb">u16</span><span class="p">),</span>
    <span class="nf">Hold</span><span class="p">(</span><span class="nb">u16</span><span class="p">,</span> <span class="nb">u16</span><span class="p">),</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">MouseButton</span> <span class="p">{</span>
    <span class="n">Left</span><span class="p">,</span>
    <span class="n">Right</span><span class="p">,</span>
    <span class="n">Middle</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">InputEvent</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">pretty_print</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
            <span class="nn">InputEvent</span><span class="p">::</span><span class="nf">Keyboard</span><span class="p">((</span><span class="n">keypress</span><span class="p">,</span> <span class="n">modifiers</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">result</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">keypress</span><span class="p">);</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">modifiers</span><span class="p">)</span> <span class="o">=</span> <span class="n">modifiers</span> <span class="p">{</span>
                    <span class="n">result</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">modifiers</span><span class="p">));</span>
                <span class="p">}</span>
                <span class="n">result</span>
            <span class="p">}</span>
            <span class="nn">InputEvent</span><span class="p">::</span><span class="nf">Resize</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">size</span><span class="p">),</span>
            <span class="nn">InputEvent</span><span class="p">::</span><span class="nf">Mouse</span><span class="p">(</span><span class="n">mouse_event</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">mouse_event</span><span class="p">),</span>
        <span class="p">};</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">it</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">a_pressed</span> <span class="o">=</span> <span class="nn">InputEvent</span><span class="p">::</span><span class="nf">Keyboard</span><span class="p">((</span><span class="nn">KeyPress</span><span class="p">::</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'a'</span><span class="p">),</span> <span class="nb">None</span><span class="p">));</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">a_pressed</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">ctrl_c_pressed</span> <span class="o">=</span> <span class="nn">InputEvent</span><span class="p">::</span><span class="nf">Keyboard</span><span class="p">(</span>
        <span class="p">(</span><span class="nn">KeyPress</span><span class="p">::</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'c'</span><span class="p">),</span> <span class="nf">Some</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="nn">Modifier</span><span class="p">::</span><span class="n">Control</span><span class="p">]))</span>
    <span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">ctrl_c_pressed</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">enter_pressed</span> <span class="o">=</span> <span class="nn">InputEvent</span><span class="p">::</span><span class="nf">Keyboard</span><span class="p">((</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Enter</span><span class="p">,</span> <span class="nb">None</span><span class="p">));</span>
    <span class="n">enter_pressed</span><span class="nf">.pretty_print</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">mouse_pressed</span> <span class="o">=</span> <span class="nn">InputEvent</span><span class="p">::</span><span class="nf">Mouse</span><span class="p">(</span>
        <span class="nn">MouseEvent</span><span class="p">::</span><span class="nf">Press</span><span class="p">(</span><span class="nn">MouseButton</span><span class="p">::</span><span class="n">Left</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
    <span class="p">);</span>
    <span class="n">mouse_pressed</span><span class="nf">.pretty_print</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>The code for this example is
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/typestate-pattern/src/ex1.rs">here</a>.
Here‚Äôs the code for the real
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/terminal_lib_backends/input_event.rs"><code class="language-plaintext highlighter-rouge">InputEvent</code></a>.</p>
</blockquote>

<p>The main things to note about this code.</p>

<ul>
  <li>We have a bunch of enums that represent different types of input events.</li>
  <li>We have a method on the <code class="language-plaintext highlighter-rouge">InputEvent</code> enum that pretty prints the event for all variants.
We don‚Äôt have a way to restrict methods on a specific variant using this approach.</li>
</ul>

<p>When you run this code (using <code class="language-plaintext highlighter-rouge">cargo run --bin ex1</code>), it should produce the following
output:</p>

<pre class="pre-manual-highlight">$ cargo run --bin ex1
Keyboard((Char('a'), None))
Keyboard((Char('c'), Some([Control])))
Enter
Press(Left, 10, 20)
</pre>

<h3 id="example-2-slightly-more-complex-versions-are-where-one-type--data--another-type">Example 2: Slightly more complex versions are where one type + data = another type</h3>
<p><a id="markdown-example-2%3A-slightly-more-complex-versions-are-where-one-type-%2B-data-%3D-another-type" name="example-2%3A-slightly-more-complex-versions-are-where-one-type-%2B-data-%3D-another-type"></a></p>

<p>For this example, let‚Äôs add the following code to the <code class="language-plaintext highlighter-rouge">src/ex2.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">mod</span> <span class="n">ex1</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">ex1</span><span class="p">::</span><span class="n">InputEvent</span><span class="p">;</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">EditorEvent</span> <span class="p">{</span>
    <span class="nf">InsertChar</span><span class="p">(</span><span class="nb">char</span><span class="p">),</span>
    <span class="n">InsertNewLine</span><span class="p">,</span>
    <span class="n">Delete</span><span class="p">,</span>
    <span class="n">Backspace</span><span class="p">,</span>
    <span class="n">MoveCursorLeft</span><span class="p">,</span>
    <span class="n">MoveCursorRight</span><span class="p">,</span>
    <span class="n">MoveCursorUp</span><span class="p">,</span>
    <span class="n">MoveCursorDown</span><span class="p">,</span>
    <span class="nb">Copy</span><span class="p">,</span>
    <span class="n">Paste</span><span class="p">,</span>
    <span class="n">Cut</span><span class="p">,</span>
    <span class="n">Undo</span><span class="p">,</span>
    <span class="n">Redo</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">TryFrom</span><span class="o">&lt;</span><span class="n">InputEvent</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">EditorEvent</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Error</span> <span class="o">=</span> <span class="nb">String</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">try_from</span><span class="p">(</span><span class="n">input_event</span><span class="p">:</span> <span class="n">InputEvent</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">,</span> <span class="k">Self</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">input_event</span> <span class="p">{</span>
            <span class="nn">InputEvent</span><span class="p">::</span><span class="nf">Keyboard</span><span class="p">((</span><span class="n">keypress</span><span class="p">,</span> <span class="n">modifiers</span><span class="p">))</span> <span class="k">=&gt;</span>
                <span class="k">match</span> <span class="p">(</span><span class="n">keypress</span><span class="p">,</span> <span class="n">modifiers</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="nf">Char</span><span class="p">(</span><span class="n">ch</span><span class="p">),</span> <span class="nb">None</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span><span class="p">::</span><span class="nf">InsertChar</span><span class="p">(</span><span class="n">ch</span><span class="p">)),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="nf">Char</span><span class="p">(</span><span class="n">_</span><span class="p">),</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Enter</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="k">Self</span><span class="p">::</span><span class="n">InsertNewLine</span><span class="p">),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Enter</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Backspace</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Backspace</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Delete</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Delete</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Left</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Left</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Right</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Right</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Up</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Up</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Down</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Down</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Home</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Home</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">End</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">End</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">PageUp</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">PageUp</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">PageDown</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">PageDown</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Tab</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Tab</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="nf">F</span><span class="p">(</span><span class="n">_</span><span class="p">),</span> <span class="nb">None</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
                <span class="p">(</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="nf">F</span><span class="p">(</span><span class="n">_</span><span class="p">),</span> <span class="nf">Some</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
            <span class="p">},</span>
            <span class="nn">InputEvent</span><span class="p">::</span><span class="nf">Resize</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
            <span class="nn">InputEvent</span><span class="p">::</span><span class="nf">Mouse</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">todo!</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">a_pressed</span> <span class="o">=</span> <span class="nn">InputEvent</span><span class="p">::</span><span class="nf">Keyboard</span><span class="p">((</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="nf">Char</span><span class="p">(</span><span class="sc">'a'</span><span class="p">),</span> <span class="nb">None</span><span class="p">));</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="nn">EditorEvent</span><span class="p">::</span><span class="nf">try_from</span><span class="p">(</span><span class="n">a_pressed</span><span class="p">));</span>

    <span class="k">let</span> <span class="n">enter_pressed</span> <span class="o">=</span> <span class="nn">InputEvent</span><span class="p">::</span><span class="nf">Keyboard</span><span class="p">((</span><span class="nn">ex1</span><span class="p">::</span><span class="nn">KeyPress</span><span class="p">::</span><span class="n">Enter</span><span class="p">,</span> <span class="nb">None</span><span class="p">));</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="nn">EditorEvent</span><span class="p">::</span><span class="nf">try_from</span><span class="p">(</span><span class="n">enter_pressed</span><span class="p">));</span>
<span class="p">}</span>

</code></pre></div></div>

<blockquote>
  <p>You can get the source code for this example
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/typestate-pattern/src/ex2.rs">here</a>.
Here‚Äôs the code for the real
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/editor/editor_component/editor_event.rs#L74"><code class="language-plaintext highlighter-rouge">EditorEvent</code></a>.</p>
</blockquote>

<p>Here are some notes on this code:</p>

<ul>
  <li>We have a new enum called <code class="language-plaintext highlighter-rouge">EditorEvent</code> that represents different types of events that
can happen in an editor.</li>
  <li>We have a <code class="language-plaintext highlighter-rouge">TryFrom</code> implementation for <code class="language-plaintext highlighter-rouge">InputEvent</code> that converts an <code class="language-plaintext highlighter-rouge">InputEvent</code> into
an <code class="language-plaintext highlighter-rouge">EditorEvent</code>. This is a way to restrict methods to specific variants of an enum by
converting it into a totally different type.</li>
  <li>We still don‚Äôt have a way to restrict methods to specific variants of the enum.</li>
</ul>

<p>When you run this code (using <code class="language-plaintext highlighter-rouge">cargo run --bin ex2</code>), it should produce the following:</p>

<pre class="pre-manual-highlight">$ cargo run --bin ex2
Ok(InsertChar('a'))
Ok(InsertNewLine)
</pre>

<h3 id="example-3-best-of-both-worlds-using-generics-and-struct--enum-with-a-marker-trait">Example 3: Best of both worlds, using generics and struct / enum with a marker trait</h3>
<p><a id="markdown-example-3%3A-best-of-both-worlds%2C-using-generics-and-struct-%2F-enum-with-a-marker-trait" name="example-3%3A-best-of-both-worlds%2C-using-generics-and-struct-%2F-enum-with-a-marker-trait"></a></p>

<p>Finally we have arrived at the typestate pattern in Rust. With this example:</p>
<ul>
  <li>You can now group all the states under a marker.</li>
  <li>You can have methods that are specific to a variant.</li>
  <li>You can specify methods that are common to all.</li>
  <li>It‚Äôs like a very sophisticated builder pattern if you‚Äôre already familiar with that.</li>
</ul>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">src/ex3.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="k">self</span><span class="p">::</span><span class="nn">type_state_builder</span><span class="p">::</span><span class="n">HttpResponse</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">crossterm</span><span class="p">::</span><span class="nn">style</span><span class="p">::</span><span class="n">Stylize</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="nb">String</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">response</span> <span class="o">=</span> <span class="nn">HttpResponse</span><span class="p">::</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"Start state"</span><span class="nf">.red</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">());</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"response: {:#?}"</span><span class="p">,</span> <span class="n">response</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"response size: {}"</span><span class="p">,</span>
        <span class="n">response</span><span class="nf">.get_size</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="c1">// Transition to HeaderAndBody state by calling `set_status_line`.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">response</span> <span class="o">=</span> <span class="n">response</span><span class="nf">.set_status_line</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="s">"OK"</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"response: {:#?}"</span><span class="p">,</span> <span class="n">response</span><span class="p">);</span>

    <span class="c1">// Status line is required.</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"HeaderAndBody state"</span><span class="nf">.red</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">());</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"response_code: {}"</span><span class="p">,</span> <span class="n">response</span><span class="nf">.get_response_code</span><span class="p">());</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"response body: {:#?}"</span><span class="p">,</span> <span class="n">response</span><span class="nf">.get_body</span><span class="p">());</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"response: {:#?}"</span><span class="p">,</span> <span class="n">response</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"response size: {}"</span><span class="p">,</span>
        <span class="n">response</span><span class="nf">.get_size</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="c1">// Body and headers are optional.</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"HeaderAndBody state # 2"</span><span class="nf">.red</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">());</span>
    <span class="n">response</span><span class="nf">.add_header</span><span class="p">(</span><span class="s">"Content-Type"</span><span class="p">,</span> <span class="s">"text/html"</span><span class="p">);</span>
    <span class="n">response</span><span class="nf">.set_body</span><span class="p">(</span><span class="s">"&lt;html&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt;"</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"response: {:#?}"</span><span class="p">,</span> <span class="n">response</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"response size: {}"</span><span class="p">,</span>
        <span class="n">response</span><span class="nf">.get_size</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="c1">// Final state.</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"Final state"</span><span class="nf">.red</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">());</span>
    <span class="k">let</span> <span class="n">response</span> <span class="o">=</span> <span class="n">response</span><span class="nf">.finish</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"response_code: {}"</span><span class="p">,</span> <span class="n">response</span><span class="nf">.get_response_code</span><span class="p">());</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"status_line: {}"</span><span class="p">,</span> <span class="n">response</span><span class="nf">.get_status_line</span><span class="p">());</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"headers: {:#?}"</span><span class="p">,</span> <span class="n">response</span><span class="nf">.get_headers</span><span class="p">());</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"body: {}"</span><span class="p">,</span> <span class="n">response</span><span class="nf">.get_body</span><span class="p">());</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"response: {:#?}"</span><span class="p">,</span> <span class="n">response</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"response size: {}"</span><span class="p">,</span>
        <span class="n">response</span><span class="nf">.get_size</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note the API that we have built here:</p>
<ul>
  <li>You can‚Äôt call <code class="language-plaintext highlighter-rouge">get_response_code</code> or <code class="language-plaintext highlighter-rouge">get_body</code> until you‚Äôve called <code class="language-plaintext highlighter-rouge">set_status_line</code>.</li>
  <li>You can‚Äôt call <code class="language-plaintext highlighter-rouge">add_header</code> or <code class="language-plaintext highlighter-rouge">set_body</code> until you‚Äôve called <code class="language-plaintext highlighter-rouge">set_status_line</code>.</li>
  <li>You can‚Äôt call <code class="language-plaintext highlighter-rouge">finish</code> until you‚Äôve called <code class="language-plaintext highlighter-rouge">set_status_line</code>.</li>
  <li>We have 3 states: <code class="language-plaintext highlighter-rouge">Start</code>, <code class="language-plaintext highlighter-rouge">HeaderAndBody</code>, and <code class="language-plaintext highlighter-rouge">Final</code>. These are meant to be used as
markers to restrict methods to specific states. Each is a struct with a marker trait.
And it may or may not contain data / fields.</li>
  <li>We have a <code class="language-plaintext highlighter-rouge">HttpResponse</code> struct that uses a generic type <code class="language-plaintext highlighter-rouge">T: Marker</code> to represent the
state. This is a way to restrict methods to specific states.</li>
  <li>We can transition between states by calling methods that consume the current state and
return a new state. These methods are specific to the state they transition from. And
they can be implemented via <code class="language-plaintext highlighter-rouge">impl HttpResponse&lt;T: Marker&gt; { ... }</code> blocks, where <code class="language-plaintext highlighter-rouge">T</code> is
the <code class="language-plaintext highlighter-rouge">Start</code>, <code class="language-plaintext highlighter-rouge">HeaderAndBody</code>, or <code class="language-plaintext highlighter-rouge">Final</code> state.</li>
  <li>We can even implement methods that are valid for a non-existent state using <code class="language-plaintext highlighter-rouge">impl
HttpResponse&lt;()&gt; { ... }</code>. This is the constructor.</li>
  <li>In the <code class="language-plaintext highlighter-rouge">Final</code> state, the data becomes immutable.</li>
</ul>

<p>Add the following code to desribe the different state structs.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">mod</span> <span class="n">state</span> <span class="p">{</span>
    <span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Default)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">Start</span> <span class="p">{}</span>

    <span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Default)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">HeaderAndBody</span> <span class="p">{</span>
        <span class="k">pub</span> <span class="n">response_code</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
        <span class="k">pub</span> <span class="n">status_line</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
        <span class="k">pub</span> <span class="n">headers</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span> <span class="nb">String</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">,</span>
        <span class="k">pub</span> <span class="n">body</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Default)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">Final</span> <span class="p">{</span>
        <span class="k">pub</span> <span class="n">response_code</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
        <span class="k">pub</span> <span class="n">status_line</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
        <span class="k">pub</span> <span class="n">headers</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span> <span class="nb">String</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="k">pub</span> <span class="n">body</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1">// The following marker trait is used to restrict the operations</span>
    <span class="c1">// that are available in each state. This isn't strictly necessary,</span>
    <span class="c1">// but it's a nice thing to use in a where clause to restrict types.</span>
    <span class="k">pub</span> <span class="k">trait</span> <span class="n">Marker</span> <span class="p">{}</span>
    <span class="k">impl</span> <span class="n">Marker</span> <span class="k">for</span> <span class="p">()</span> <span class="p">{}</span>
    <span class="k">impl</span> <span class="n">Marker</span> <span class="k">for</span> <span class="n">Start</span> <span class="p">{}</span>
    <span class="k">impl</span> <span class="n">Marker</span> <span class="k">for</span> <span class="n">HeaderAndBody</span> <span class="p">{}</span>
    <span class="k">impl</span> <span class="n">Marker</span> <span class="k">for</span> <span class="n">Final</span> <span class="p">{}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here is the code for the <code class="language-plaintext highlighter-rouge">HttpResponse</code> struct.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">mod</span> <span class="n">type_state_builder</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="nn">state</span><span class="p">::{</span><span class="n">Final</span><span class="p">,</span> <span class="n">HeaderAndBody</span><span class="p">,</span> <span class="n">Marker</span><span class="p">,</span> <span class="n">Start</span><span class="p">};</span>

    <span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Default)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="n">S</span><span class="p">:</span> <span class="n">Marker</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">pub</span> <span class="n">state</span><span class="p">:</span> <span class="n">S</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1">// Operations that are available in all states.</span>
    <span class="k">impl</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">S</span><span class="p">:</span> <span class="n">Marker</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_size</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">size_of_val</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>
            <span class="nd">format!</span><span class="p">(</span><span class="s">"{} bytes"</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Operations that are only valid in `()`.</span>
    <span class="k">impl</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="n">Start</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="n">HttpResponse</span> <span class="p">{</span> <span class="n">state</span><span class="p">:</span> <span class="n">Start</span> <span class="p">{}</span> <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Operations that are only valid in `Start`.</span>
    <span class="k">impl</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="n">Start</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">set_status_line</span><span class="p">(</span>
            <span class="k">self</span><span class="p">,</span>
            <span class="n">response_code</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
            <span class="n">message</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
        <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="n">HeaderAndBody</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="n">HttpResponse</span> <span class="p">{</span>
                <span class="n">state</span><span class="p">:</span> <span class="n">HeaderAndBody</span> <span class="p">{</span>
                    <span class="n">response_code</span><span class="p">,</span>
                    <span class="n">status_line</span><span class="p">:</span> <span class="nd">format!</span><span class="p">(</span>
                        <span class="s">"HTTP/1.1 {} {}"</span><span class="p">,</span> <span class="n">response_code</span><span class="p">,</span> <span class="n">message</span>
                    <span class="p">),</span>
                    <span class="o">..</span><span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">()</span>
                <span class="p">},</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Operations that are only valid in `HeaderAndBodyState`.</span>
    <span class="k">impl</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="n">HeaderAndBody</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// setter.</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">add_header</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">self</span><span class="py">.state.headers</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.state.headers</span><span class="nf">.replace</span><span class="p">(</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">());</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.state.headers</span><span class="nf">.as_mut</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">v</span><span class="nf">.push</span><span class="p">((</span><span class="n">key</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="n">value</span><span class="nf">.to_string</span><span class="p">()))</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// getter.</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_response_code</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u8</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.state.response_code</span>
        <span class="p">}</span>

        <span class="c1">// setter.</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">set_body</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">body</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.state.body</span><span class="nf">.replace</span><span class="p">(</span><span class="n">body</span><span class="nf">.to_string</span><span class="p">());</span>
        <span class="p">}</span>

        <span class="c1">// getter.</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_body</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.state.body</span><span class="nf">.as_deref</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="c1">// transition to Final state.</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">finish</span><span class="p">(</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="n">Final</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="n">HttpResponse</span> <span class="p">{</span>
                <span class="n">state</span><span class="p">:</span> <span class="n">Final</span> <span class="p">{</span>
                    <span class="n">response_code</span><span class="p">:</span> <span class="k">self</span><span class="py">.state.response_code</span><span class="p">,</span>
                    <span class="n">status_line</span><span class="p">:</span> <span class="k">self</span><span class="py">.state.status_line</span><span class="nf">.clone</span><span class="p">(),</span>
                    <span class="n">headers</span><span class="p">:</span> <span class="k">self</span><span class="py">.state.headers</span><span class="nf">.take</span><span class="p">()</span><span class="nf">.unwrap_or_default</span><span class="p">(),</span>
                    <span class="n">body</span><span class="p">:</span> <span class="k">self</span><span class="py">.state.body</span><span class="nf">.take</span><span class="p">()</span><span class="nf">.unwrap_or_default</span><span class="p">(),</span>
                <span class="p">},</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Operations that are only valid in `Final`.</span>
    <span class="k">impl</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="n">Final</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// getter.</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_headers</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span> <span class="nb">String</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="o">&amp;</span><span class="k">self</span><span class="py">.state.headers</span>
        <span class="p">}</span>

        <span class="c1">// getter.</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_body</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="p">{</span>
            <span class="o">&amp;</span><span class="k">self</span><span class="py">.state.body</span>
        <span class="p">}</span>

        <span class="c1">// getter.</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_response_code</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u8</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.state.response_code</span>
        <span class="p">}</span>

        <span class="c1">// getter.</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_status_line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="p">{</span>
            <span class="o">&amp;</span><span class="k">self</span><span class="py">.state.status_line</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When you run the code using <code class="language-plaintext highlighter-rouge">cargo run --bin ex3</code>, it should produce the following output.</p>

<pre class="pre-manual-highlight">$ cargo run --bin ex3
<span style="color:#BF616A"><u style="text-decoration-style:single"><b>Start state</b></u></span>
response: HttpResponse {
    state: Start,
}
response size: <span style="color:#81A1C1"><b>0 bytes</b></span>
response: HttpResponse {
    state: HeaderAndBody {
        response_code: 200,
        status_line: &quot;HTTP/1.1 200 OK&quot;,
        headers: None,
        body: None,
    },
}
<span style="color:#BF616A"><u style="text-decoration-style:single"><b>HeaderAndBody state</b></u></span>
response_code: 200
response body: None
response: HttpResponse {
    state: HeaderAndBody {
        response_code: 200,
        status_line: &quot;HTTP/1.1 200 OK&quot;,
        headers: None,
        body: None,
    },
}
response size: <span style="color:#81A1C1"><b>80 bytes</b></span>
<span style="color:#BF616A"><u style="text-decoration-style:single"><b>HeaderAndBody state # 2</b></u></span>
response: HttpResponse {
    state: HeaderAndBody {
        response_code: 200,
        status_line: &quot;HTTP/1.1 200 OK&quot;,
        headers: Some(
            [
                (
                    &quot;Content-Type&quot;,
                    &quot;text/html&quot;,
                ),
            ],
        ),
        body: Some(
            &quot;&lt;html&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt;&quot;,
        ),
    },
}
response size: <span style="color:#81A1C1"><b>80 bytes</b></span>
<span style="color:#BF616A"><u style="text-decoration-style:single"><b>Final state</b></u></span>
response_code: 200
status_line: HTTP/1.1 200 OK
headers: [
    (
        &quot;Content-Type&quot;,
        &quot;text/html&quot;,
    ),
]
body: &lt;html&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt;
response: HttpResponse {
    state: Final {
        response_code: 200,
        status_line: &quot;HTTP/1.1 200 OK&quot;,
        headers: [
            (
                &quot;Content-Type&quot;,
                &quot;text/html&quot;,
            ),
        ],
        body: &quot;&lt;html&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt;&quot;,
    },
}
response size: <span style="color:#81A1C1"><b>80 bytes</b></span>
</pre>

<h3 id="example-31-using-enum-and-phantomdata-instead-of-struct">Example 3.1: Using enum and PhantomData instead of struct</h3>
<p><a id="markdown-example-3.1%3A-using-enum-and-phantomdata-instead-of-struct" name="example-3.1%3A-using-enum-and-phantomdata-instead-of-struct"></a></p>

<ul>
  <li>You can use enums instead of structs if you have shared data (inner) that you move with
state transitions.</li>
  <li>And you have to use <code class="language-plaintext highlighter-rouge">PhantomData</code> here.</li>
</ul>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">src/ex3_1.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="k">self</span><span class="p">::</span><span class="nn">type_state_builder</span><span class="p">::</span><span class="n">HttpResponse</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">crossterm</span><span class="p">::</span><span class="nn">style</span><span class="p">::</span><span class="n">Stylize</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="nb">String</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">response</span> <span class="o">=</span> <span class="nn">HttpResponse</span><span class="p">::</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"Start state"</span><span class="nf">.red</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">());</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"response: {:#?}"</span><span class="p">,</span> <span class="n">response</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"response size: {}"</span><span class="p">,</span>
        <span class="n">response</span><span class="nf">.get_size</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="c1">// Status line is required.</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"HeaderAndBody state"</span><span class="nf">.red</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">());</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">response</span> <span class="o">=</span> <span class="n">response</span><span class="nf">.set_status_line</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="s">"OK"</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"response_code: {}"</span><span class="p">,</span> <span class="n">response</span><span class="nf">.get_response_code</span><span class="p">());</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"response body: {:#?}"</span><span class="p">,</span> <span class="n">response</span><span class="nf">.get_body</span><span class="p">());</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"response: {:#?}"</span><span class="p">,</span> <span class="n">response</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"response size: {}"</span><span class="p">,</span>
        <span class="n">response</span><span class="nf">.get_size</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="c1">// Body and headers are optional.</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"HeaderAndBody state # 2"</span><span class="nf">.red</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">());</span>
    <span class="n">response</span><span class="nf">.add_header</span><span class="p">(</span><span class="s">"Content-Type"</span><span class="p">,</span> <span class="s">"text/html"</span><span class="p">);</span>
    <span class="n">response</span><span class="nf">.set_body</span><span class="p">(</span><span class="s">"&lt;html&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt;"</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"response: {:#?}"</span><span class="p">,</span> <span class="n">response</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"response size: {}"</span><span class="p">,</span>
        <span class="n">response</span><span class="nf">.get_size</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="c1">// Final state.</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"Final state"</span><span class="nf">.red</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">());</span>
    <span class="k">let</span> <span class="n">response</span> <span class="o">=</span> <span class="n">response</span><span class="nf">.finish</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"response_code: {}"</span><span class="p">,</span> <span class="n">response</span><span class="nf">.get_response_code</span><span class="p">());</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"status_line: {}"</span><span class="p">,</span> <span class="n">response</span><span class="nf">.get_status_line</span><span class="p">());</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"headers: {:#?}"</span><span class="p">,</span> <span class="n">response</span><span class="nf">.get_headers</span><span class="p">());</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"body: {:#?}"</span><span class="p">,</span> <span class="n">response</span><span class="nf">.get_body</span><span class="p">());</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"response: {:#?}"</span><span class="p">,</span> <span class="n">response</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"response size: {}"</span><span class="p">,</span>
        <span class="n">response</span><span class="nf">.get_size</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.blue</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note that this <code class="language-plaintext highlighter-rouge">main</code> function is the same as the one in the previous example.</p>

<p>The following code will be different. We are adding a new <code class="language-plaintext highlighter-rouge">data</code> module.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">mod</span> <span class="n">data</span> <span class="p">{</span>
    <span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Default)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">HttpResponseData</span> <span class="p">{</span>
        <span class="k">pub</span> <span class="n">response_code</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
        <span class="k">pub</span> <span class="n">status_line</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
        <span class="k">pub</span> <span class="n">headers</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span> <span class="nb">String</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">,</span>
        <span class="k">pub</span> <span class="n">body</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here‚Äôs the new <code class="language-plaintext highlighter-rouge">state</code> module. Note the use of enums and <code class="language-plaintext highlighter-rouge">PhantomData</code> instead of structs.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">mod</span> <span class="n">state</span> <span class="p">{</span>
    <span class="nd">#[derive(Debug,</span> <span class="nd">Clone)]</span>
    <span class="k">pub</span> <span class="k">enum</span> <span class="n">Start</span> <span class="p">{}</span>

    <span class="nd">#[derive(Debug,</span> <span class="nd">Clone)]</span>
    <span class="k">pub</span> <span class="k">enum</span> <span class="n">HeaderAndBody</span> <span class="p">{}</span>

    <span class="nd">#[derive(Debug,</span> <span class="nd">Clone)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">Final</span> <span class="p">{}</span>

    <span class="c1">// The following marker trait is used to restrict the operations</span>
    <span class="c1">// that are available in each state. This isn't strictly necessary,</span>
    <span class="c1">// but it's a nice thing to use in a where clause to restrict types.</span>
    <span class="k">pub</span> <span class="k">trait</span> <span class="n">Marker</span> <span class="p">{}</span>
    <span class="k">impl</span> <span class="n">Marker</span> <span class="k">for</span> <span class="p">()</span> <span class="p">{}</span>
    <span class="k">impl</span> <span class="n">Marker</span> <span class="k">for</span> <span class="n">Start</span> <span class="p">{}</span>
    <span class="k">impl</span> <span class="n">Marker</span> <span class="k">for</span> <span class="n">HeaderAndBody</span> <span class="p">{}</span>
    <span class="k">impl</span> <span class="n">Marker</span> <span class="k">for</span> <span class="n">Final</span> <span class="p">{}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here is the changed code for the <code class="language-plaintext highlighter-rouge">HttpResponse</code> struct.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">mod</span> <span class="n">type_state_builder</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::{</span>
        <span class="nn">data</span><span class="p">::</span><span class="n">HttpResponseData</span><span class="p">,</span>
        <span class="nn">state</span><span class="p">::{</span><span class="n">Final</span><span class="p">,</span> <span class="n">HeaderAndBody</span><span class="p">,</span> <span class="n">Marker</span><span class="p">,</span> <span class="n">Start</span><span class="p">},</span>
    <span class="p">};</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">marker</span><span class="p">::</span><span class="n">PhantomData</span><span class="p">;</span>

    <span class="nd">#[derive(Debug,</span> <span class="nd">Clone)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="n">S</span><span class="p">:</span> <span class="n">Marker</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">pub</span> <span class="n">data</span><span class="p">:</span> <span class="n">HttpResponseData</span><span class="p">,</span>
        <span class="k">pub</span> <span class="n">state</span><span class="p">:</span> <span class="n">PhantomData</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1">// Operations that are only valid in ().</span>
    <span class="k">impl</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="n">Start</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="n">HttpResponse</span> <span class="p">{</span>
                <span class="n">data</span><span class="p">:</span> <span class="nn">HttpResponseData</span><span class="p">::</span><span class="nf">default</span><span class="p">(),</span>
                <span class="n">state</span><span class="p">:</span> <span class="nn">PhantomData</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Start</span><span class="o">&gt;</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Operations that are only valid in Start.</span>
    <span class="k">impl</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="n">Start</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// setter.</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">set_status_line</span><span class="p">(</span>
            <span class="k">self</span><span class="p">,</span>
            <span class="n">response_code</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
            <span class="n">message</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
        <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="n">HeaderAndBody</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="n">HttpResponse</span> <span class="p">{</span>
                <span class="n">data</span><span class="p">:</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="k">mut</span> <span class="n">data</span> <span class="o">=</span> <span class="k">self</span><span class="py">.data</span><span class="p">;</span>
                    <span class="n">data</span><span class="py">.response_code</span> <span class="o">=</span> <span class="n">response_code</span><span class="p">;</span>
                    <span class="n">data</span><span class="py">.status_line</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span>
                        <span class="s">"HTTP/1.1 {} {}"</span><span class="p">,</span> <span class="n">response_code</span><span class="p">,</span> <span class="n">message</span>
                    <span class="p">);</span>
                    <span class="n">data</span>
                <span class="p">},</span>
                <span class="n">state</span><span class="p">:</span> <span class="nn">PhantomData</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HeaderAndBody</span><span class="o">&gt;</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Operations that are only valid in HeaderAndBodyState.</span>
    <span class="k">impl</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="n">HeaderAndBody</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// setter.</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">add_header</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">mut_data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.data</span><span class="p">;</span>
            <span class="k">if</span> <span class="n">mut_data</span><span class="py">.headers</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">mut_data</span><span class="py">.headers</span><span class="nf">.replace</span><span class="p">(</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">());</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">headers</span><span class="p">)</span> <span class="o">=</span> <span class="n">mut_data</span><span class="py">.headers</span><span class="nf">.as_mut</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">headers</span><span class="nf">.push</span><span class="p">((</span><span class="n">key</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="n">value</span><span class="nf">.to_string</span><span class="p">()))</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// getter.</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_response_code</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u8</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.data.response_code</span>
        <span class="p">}</span>

        <span class="c1">// setter.</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">set_body</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">body</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.data.body</span><span class="nf">.replace</span><span class="p">(</span><span class="n">body</span><span class="nf">.to_string</span><span class="p">());</span>
        <span class="p">}</span>

        <span class="c1">// getter.</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_body</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.data.body</span><span class="nf">.as_deref</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="c1">// transition to Final state.</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">finish</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="n">Final</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">data</span> <span class="o">=</span> <span class="k">self</span><span class="py">.data</span><span class="p">;</span>
            <span class="n">HttpResponse</span> <span class="p">{</span>
                <span class="n">data</span><span class="p">:</span> <span class="n">HttpResponseData</span> <span class="p">{</span>
                    <span class="n">response_code</span><span class="p">:</span> <span class="n">data</span><span class="py">.response_code</span><span class="p">,</span>
                    <span class="n">status_line</span><span class="p">:</span> <span class="n">data</span><span class="py">.status_line</span><span class="nf">.clone</span><span class="p">(),</span>
                    <span class="n">headers</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="n">data</span><span class="py">.headers</span><span class="nf">.take</span><span class="p">()</span><span class="nf">.unwrap_or_default</span><span class="p">()),</span>
                    <span class="n">body</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="n">data</span><span class="py">.body</span><span class="nf">.take</span><span class="p">()</span><span class="nf">.unwrap_or_default</span><span class="p">()),</span>
                <span class="p">},</span>
                <span class="n">state</span><span class="p">:</span> <span class="nn">PhantomData</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Final</span><span class="o">&gt;</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Operations that are only valid in FinalState.</span>
    <span class="k">impl</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="n">Final</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_headers</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span> <span class="nb">String</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
            <span class="o">&amp;</span><span class="k">self</span><span class="py">.data.headers</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_body</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="o">&amp;</span><span class="k">self</span><span class="py">.data.body</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_response_code</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u8</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.data.response_code</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_status_line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="p">{</span>
            <span class="o">&amp;</span><span class="k">self</span><span class="py">.data.status_line</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Operations that are available in all states.</span>
    <span class="k">impl</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="n">HttpResponse</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">S</span><span class="p">:</span> <span class="n">Marker</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_size</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">size_of_val</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>
            <span class="nd">format!</span><span class="p">(</span><span class="s">"{} bytes"</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here‚Äôs the output when you run the code using <code class="language-plaintext highlighter-rouge">cargo run --bin ex3_1</code>.</p>

<pre class="pre-manual-highlight">$ cargo run --bin ex3_1
<span style="color:#BF616A"><u style="text-decoration-style:single"><b>Start state</b></u></span>
response: HttpResponse {
    data: HttpResponseData {
        response_code: 0,
        status_line: &quot;&quot;,
        headers: None,
        body: None,
    },
    state: PhantomData&lt;ex3_1::state::Start&gt;,
}
response size: <span style="color:#81A1C1"><b>80 bytes</b></span>
<span style="color:#BF616A"><u style="text-decoration-style:single"><b>HeaderAndBody state</b></u></span>
response_code: 200
response body: None
response: HttpResponse {
    data: HttpResponseData {
        response_code: 200,
        status_line: &quot;HTTP/1.1 200 OK&quot;,
        headers: None,
        body: None,
    },
    state: PhantomData&lt;ex3_1::state::HeaderAndBody&gt;,
}
response size: <span style="color:#81A1C1"><b>80 bytes</b></span>
<span style="color:#BF616A"><u style="text-decoration-style:single"><b>HeaderAndBody state # 2</b></u></span>
response: HttpResponse {
    data: HttpResponseData {
        response_code: 200,
        status_line: &quot;HTTP/1.1 200 OK&quot;,
        headers: Some(
            [
                (
                    &quot;Content-Type&quot;,
                    &quot;text/html&quot;,
                ),
            ],
        ),
        body: Some(
            &quot;&lt;html&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt;&quot;,
        ),
    },
    state: PhantomData&lt;ex3_1::state::HeaderAndBody&gt;,
}
response size: <span style="color:#81A1C1"><b>80 bytes</b></span>
<span style="color:#BF616A"><u style="text-decoration-style:single"><b>Final state</b></u></span>
response_code: 200
status_line: HTTP/1.1 200 OK
headers: Some(
    [
        (
            &quot;Content-Type&quot;,
            &quot;text/html&quot;,
        ),
    ],
)
body: Some(
    &quot;&lt;html&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt;&quot;,
)
response: HttpResponse {
    data: HttpResponseData {
        response_code: 200,
        status_line: &quot;HTTP/1.1 200 OK&quot;,
        headers: Some(
            [
                (
                    &quot;Content-Type&quot;,
                    &quot;text/html&quot;,
                ),
            ],
        ),
        body: Some(
            &quot;&lt;html&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt;&quot;,
        ),
    },
    state: PhantomData&lt;ex3_1::state::Final&gt;,
}
response size: <span style="color:#81A1C1"><b>80 bytes</b></span>
</pre>

<h3 id="parting-thoughts">Parting thoughts</h3>
<p><a id="markdown-parting-thoughts" name="parting-thoughts"></a></p>

<p>To get an experiential understanding of the typestate pattern, you should try to build
something using it. It‚Äôs a powerful pattern that can help you write more robust and
predictable code. And it‚Äôs a great way to leverage Rust‚Äôs type system to enforce state
transitions in your code. I encourage you to clone the repo and run the code to see how it
works. And make changes to it to see if you can make it behave differently and use it in
your own projects.</p>

<h2 id="build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</h2>
<p><a id="markdown-build-with-naz-video-series-on-developerlife.com-youtube-channel" name="build-with-naz-video-series-on-developerlife.com-youtube-channel"></a></p>

<blockquote>
  <p>If you have comments and feedback on this content, or would like to request new content
(articles &amp; videos) on developerlife.com, please join our <a href="https://discord.gg/8M2ePAevaMi">discord
server</a>.</p>
</blockquote>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a></li>
  <li>Playlists
    <ul>
      <li><a href="https://www.youtube.com/watch?v=bolScvh4x7I&amp;list=PLofhE49PEwmw3MKOU1Kn3xbP4FRQR4Mb3">Build with Naz, Linux TTY, process, signals, commands in async Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmza94sS7UmJnN9gSCHTVTfz">Build with Naz, fundamental effective Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmwO69E7eiQ-ewnMME8ydgQ5">Build with Naz, effective async Rust and tokio</a></li>
      <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><summary type="html"><![CDATA[The Typestate Pattern in Rust is a way to manage objects that go through different states in their lifecycle. It leverages Rust's powerful type system to enforce these states and transitions between them, making your code safer and more predictable. Learn all about it in this article, its video, and repo.]]></summary></entry><entry><title type="html">Build with Naz : Linux io_uring and tokio-uring exploration with Rust</title><link href="http://developerlife.com/2024/05/25/tokio-uring-exploration-rust/" rel="alternate" type="text/html" title="Build with Naz : Linux io_uring and tokio-uring exploration with Rust" /><published>2024-05-25T10:00:00-05:00</published><updated>2024-05-25T10:00:00-05:00</updated><id>http://developerlife.com/2024/05/25/tokio-uring-exploration-rust</id><content type="html" xml:base="http://developerlife.com/2024/05/25/tokio-uring-exploration-rust/"><![CDATA[<p><img class="post-hero-image" src="/assets/rust_tokio_uring.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#what-is-linux-io_uring">What is Linux io_uring?</a></li>
  <li><a href="#youtube-video-for-this-article">YouTube video for this article</a></li>
  <li><a href="#examples-of-using-tokio-uring-in-rust">Examples of using tokio-uring in Rust</a>
    <ul>
      <li><a href="#example-1-read-a-file-using-tokio-uring-and-async-non-blocking-io">Example 1: Read a file using tokio-uring and async, non-blocking IO</a></li>
      <li><a href="#example-2-building-a-tcp-echo-server-using-tokio-uring-that-also-uses-tokio">Example 2: Building a TCP echo server using tokio-uring that also uses tokio</a></li>
      <li><a href="#parting-thoughts">Parting thoughts</a></li>
    </ul>
  </li>
  <li><a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</a></li>
</ul>

<!-- /TOC -->

<h2 id="what-is-linux-io_uring">What is Linux io_uring?</h2>
<p><a id="markdown-what-is-linux-io_uring%3F" name="what-is-linux-io_uring%3F"></a></p>

<p>When using async Rust and <code class="language-plaintext highlighter-rouge">tokio</code>, you don‚Äôt get async file IO at the OS level. Here are
links from the official docs that discourage using <code class="language-plaintext highlighter-rouge">tokio</code> for file IO:</p>
<ul>
  <li><a href="https://tokio.rs/tokio/tutorial">Tokio tutorial, when not to use Tokio</a>.</li>
  <li><a href="https://users.rust-lang.org/t/tokio-copy-slower-than-std-io-copy/111242">Tokio::io::copy slower than std
io::copy</a>.</li>
</ul>

<p>This is because <code class="language-plaintext highlighter-rouge">tokio</code> uses the <code class="language-plaintext highlighter-rouge">mio</code> crate, which uses <code class="language-plaintext highlighter-rouge">epoll</code> on Linux. These are not
the most efficient ways to do async IO on Linux. The most efficient way to do async IO on
Linux is to use the <code class="language-plaintext highlighter-rouge">io_uring</code> syscall. This is a new syscall that was added to the Linux
kernel in version 5.1. It is a more efficient way to do async IO on Linux, and is used by
the <code class="language-plaintext highlighter-rouge">tokio-uring</code> crate. Here are some great links to learn more about <code class="language-plaintext highlighter-rouge">io_uring</code>:</p>
<ul>
  <li><a href="https://unixism.net/loti/what_is_io_uring.html#the-io-uring-interface">io_uring mental
model</a>.</li>
  <li><a href="https://www.scylladb.com/2020/05/05/how-io_uring-and-ebpf-will-revolutionize-programming-in-linux/0/">How io_uring and eBPF Will Revolutionize Programming in
Linux</a>.</li>
  <li><a href="https://lore.kernel.org/io-uring/4af91b50-4a9c-8a16-9470-a51430bd7733@kernel.dk/T/#u">io_uring and Intel Optane
stats</a>.</li>
  <li><a href="https://tokio.rs/blog/2021-07-tokio-uring">Announcing io_uring support for Tokio -
tokio-uring</a>.</li>
</ul>

<p>In this article, we will explore how to use <code class="language-plaintext highlighter-rouge">tokio-uring</code> to do async file IO at the OS
level, and how to use it to build a simple echo TCP server, for use with <code class="language-plaintext highlighter-rouge">netcat</code>.</p>

<h2 id="youtube-video-for-this-article">YouTube video for this article</h2>
<p><a id="markdown-youtube-video-for-this-article" name="youtube-video-for-this-article"></a></p>

<p>This blog post has short examples on how to use the <code class="language-plaintext highlighter-rouge">tokio-uring</code> crate. If you like to
learn via video, please watch the companion video on the <a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube
channel</a>.</p>

<!-- rust tokio-uring exploration-->
<iframe src="https://www.youtube.com/embed/VKL52XmY6Os?si=RgUKu-CZSXvKpJ7M" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<p><br /></p>

<h2 id="examples-of-using-tokio-uring-in-rust">Examples of using tokio-uring in Rust</h2>
<p><a id="markdown-examples-of-using-tokio-uring-in-rust" name="examples-of-using-tokio-uring-in-rust"></a></p>

<p>Let‚Äôs create some examples to illustrate how to use <code class="language-plaintext highlighter-rouge">tokio-uring</code>. You can run
<code class="language-plaintext highlighter-rouge">cargo new --bin tokio-uring</code> to create a new binary crate.</p>

<blockquote>
  <p>The code in the video and this tutorial are all in <a href="https://github.com/nazmulidris/rust-scratch/tree/main/tokio-uring">this GitHub
repo</a>.</p>
</blockquote>

<p>Then add the following to the <code class="language-plaintext highlighter-rouge">Cargo.toml</code> file that‚Äôs generated. These pull in all the
dependencies that we need for these examples.</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[package]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"tokio-uring"</span>
<span class="py">version</span> <span class="p">=</span> <span class="s">"0.1.0"</span>
<span class="py">edition</span> <span class="p">=</span> <span class="s">"2021"</span>

<span class="nn">[[bin]]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"readfile"</span>
<span class="py">path</span> <span class="p">=</span> <span class="s">"src/readfile.rs"</span>

<span class="nn">[[bin]]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"socketserver"</span>
<span class="py">path</span> <span class="p">=</span> <span class="s">"src/socketserver.rs"</span>

<span class="nn">[dependencies]</span>
<span class="py">tokio-uring</span> <span class="p">=</span> <span class="s">"0.4.0"</span>
<span class="py">tokio</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"1.37.0"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"full"</span><span class="p">,</span> <span class="s">"tracing"</span><span class="p">]</span> <span class="p">}</span>
<span class="py">tokio-util</span> <span class="p">=</span> <span class="s">"0.7.11"</span>
<span class="py">tracing</span> <span class="p">=</span> <span class="s">"0.1.40"</span>
<span class="py">tracing-subscriber</span> <span class="p">=</span> <span class="s">"0.3.18"</span>

<span class="py">ctrlc</span> <span class="p">=</span> <span class="s">"3.4.4"</span>
<span class="py">miette</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"7.2.0"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"fancy"</span><span class="p">]</span> <span class="p">}</span>

<span class="py">crossterm</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.27.0"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"event-stream"</span><span class="p">]</span> <span class="p">}</span>

<span class="py">r3bl_terminal_async</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.5.3"</span> <span class="p">}</span>
</code></pre></div></div>

<h3 id="example-1-read-a-file-using-tokio-uring-and-async-non-blocking-io">Example 1: Read a file using tokio-uring and async, non-blocking IO</h3>
<p><a id="markdown-example-1%3A-read-a-file-using-tokio-uring-and-async%2C-non-blocking-io" name="example-1%3A-read-a-file-using-tokio-uring-and-async%2C-non-blocking-io"></a></p>

<p>Then you can add the following code to the <code class="language-plaintext highlighter-rouge">src/readfile.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">crossterm</span><span class="p">::</span><span class="nn">style</span><span class="p">::</span><span class="n">Stylize</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">miette</span><span class="p">::</span><span class="n">IntoDiagnostic</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">path</span><span class="p">::</span><span class="n">Path</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nn">tokio_uring</span><span class="p">::</span><span class="nf">start</span><span class="p">(</span><span class="nf">read_file</span><span class="p">(</span><span class="s">"Cargo.toml"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">async</span> <span class="k">fn</span> <span class="nf">read_file</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="k">impl</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">file</span> <span class="o">=</span> <span class="nn">tokio_uring</span><span class="p">::</span><span class="nn">fs</span><span class="p">::</span><span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="k">.await</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">buf_move</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">4096</span><span class="p">];</span>

    <span class="c1">// Read some data, the buffer is passed by ownership and submitted</span>
    <span class="c1">// to the kernel. When the operation completes, we get the buffer</span>
    <span class="c1">// back.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">buf_from_kernel</span><span class="p">)</span> <span class="o">=</span> <span class="n">file</span><span class="nf">.read_at</span><span class="p">(</span><span class="n">buf_move</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">bytes_read</span> <span class="o">=</span> <span class="n">result</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"{}"</span><span class="p">,</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"Read {} bytes"</span><span class="p">,</span> <span class="n">bytes_read</span><span class="p">)</span>
            <span class="nf">.yellow</span><span class="p">()</span>
            <span class="nf">.underlined</span><span class="p">()</span>
            <span class="nf">.bold</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"{}</span><span class="se">\n</span><span class="s">{}"</span><span class="p">,</span>
        <span class="s">"Data (bytes):"</span><span class="nf">.yellow</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">(),</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf_from_kernel</span><span class="p">[</span><span class="o">..</span><span class="n">bytes_read</span><span class="p">])</span>
            <span class="nf">.blue</span><span class="p">()</span>
            <span class="nf">.bold</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"{}</span><span class="se">\n</span><span class="s">{}"</span><span class="p">,</span>
        <span class="s">"Data (string):"</span><span class="nf">.yellow</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">(),</span>
        <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_lossy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf_from_kernel</span><span class="p">[</span><span class="o">..</span><span class="n">bytes_read</span><span class="p">])</span>
            <span class="nf">.cyan</span><span class="p">()</span>
            <span class="nf">.bold</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>The code for this example is
<a href="https://github.com/nazmulidris/rust-scratch/tree/main/tokio-uring/src/readfile.rs">here</a>.</p>
</blockquote>

<p>The main things to note about this code.</p>

<ul>
  <li>We use the <code class="language-plaintext highlighter-rouge">tokio_uring::fs::File</code> struct to open a file.</li>
  <li>We use the <code class="language-plaintext highlighter-rouge">read_at</code> method to read from the file at a specific offset. The buffer is
passed by ownership to the kernel, and when the operation completes, we get the buffer
back. This is different than how it works with <code class="language-plaintext highlighter-rouge">tokio</code> and <code class="language-plaintext highlighter-rouge">std</code>.</li>
  <li>We print out the bytes that were read from the file, and the string representation of
those bytes.</li>
</ul>

<p>When you run this code (using <code class="language-plaintext highlighter-rouge">cargo run --bin readfile</code>), it should produce the following
output:</p>

<pre class="pre-manual-highlight">
<span style="color:#81A1C1"><u style="text-decoration-style:single">read file using tokio_uring: </u></span><span style="color:#BF616A"><u style="text-decoration-style:single"><b>Cargo.toml</b></u></span>
<span style="color:#81A1C1"><u style="text-decoration-style:single">read </u></span><span style="color:#EBCB8B"><u style="text-decoration-style:single"><b>604</b></u></span> bytes from file
<span style="color:#A3BE8C">file contents: [package]</span>
<span style="color:#A3BE8C">name = &quot;tokio-uring&quot;</span>
<span style="color:#A3BE8C">version = &quot;0.1.0&quot;</span>
<span style="color:#A3BE8C">edition = &quot;2021&quot;</span>

<span style="color:#A3BE8C">[[bin]]</span>
<span style="color:#A3BE8C">name = &quot;readfile&quot;</span>
<span style="color:#A3BE8C">path = &quot;src/readfile.rs&quot;</span>

<span style="color:#A3BE8C">[[bin]]</span>
<span style="color:#A3BE8C">name = &quot;socketserver&quot;</span>
<span style="color:#A3BE8C">path = &quot;src/socketserver.rs&quot;</span>

<span style="color:#A3BE8C">[dependencies]</span>
<span style="color:#A3BE8C">tokio-uring = &quot;0.4.0&quot;</span>
<span style="color:#A3BE8C">tokio = { version = &quot;1.37.0&quot;, features = [&quot;full&quot;, &quot;tracing&quot;] }</span>
<span style="color:#A3BE8C">tokio-util = &quot;0.7.11&quot;</span>
<span style="color:#A3BE8C">tracing = &quot;0.1.40&quot;</span>
<span style="color:#A3BE8C">tracing-subscriber = &quot;0.3.18&quot;</span>

<span style="color:#A3BE8C">ctrlc = &quot;3.4.4&quot;</span>

<span style="color:#A3BE8C">miette = { version = &quot;7.2.0&quot;, features = [&quot;fancy&quot;] }</span>

<span style="color:#A3BE8C">crossterm = { version = &quot;0.27.0&quot;, features = [&quot;event-stream&quot;] }</span>

<span style="color:#A3BE8C">r3bl_terminal_async = { version = &quot;0.5.3&quot; }</span>
<span style="color:#A3BE8C"># r3bl_terminal_async = { path = &quot;../../r3bl-open-core/terminal_async&quot; }</span>
</pre>

<h3 id="example-2-building-a-tcp-echo-server-using-tokio-uring-that-also-uses-tokio">Example 2: Building a TCP echo server using tokio-uring that also uses tokio</h3>
<p><a id="markdown-example-2%3A-building-a-tcp-echo-server-using-tokio-uring-that-also-uses-tokio" name="example-2%3A-building-a-tcp-echo-server-using-tokio-uring-that-also-uses-tokio"></a></p>

<p>For this example, let‚Äôs add the following code to the <code class="language-plaintext highlighter-rouge">src/socketserver.rs</code> file.</p>
<ul>
  <li>This will simply add the required imports to <code class="language-plaintext highlighter-rouge">tokio_uring</code> for <code class="language-plaintext highlighter-rouge">TcpListener</code> and
<code class="language-plaintext highlighter-rouge">TcpStream</code>.</li>
  <li>And we will also configure the <code class="language-plaintext highlighter-rouge">tracing_subscriber</code> to use the formatted subscriber, so
that we get pretty printed log output to stdout and we have information about what thread
generated that log event.</li>
  <li>We use the <code class="language-plaintext highlighter-rouge">tokio_uring::start</code> function to spawn the runtime. This runtime isn‚Äôt the
same as the one that we get from using <code class="language-plaintext highlighter-rouge">#[tokio::main]</code> and later in this example, we
will see how we can handle both.</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">crossterm</span><span class="p">::</span><span class="nn">style</span><span class="p">::</span><span class="n">Stylize</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">miette</span><span class="p">::</span><span class="n">IntoDiagnostic</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">r3bl_terminal_async</span><span class="p">::</span><span class="n">port_availability</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">net</span><span class="p">::</span><span class="n">SocketAddr</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">task</span><span class="p">::</span><span class="n">AbortHandle</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">tokio_uring</span><span class="p">::{</span>
    <span class="nn">buf</span><span class="p">::</span><span class="n">IoBuf</span><span class="p">,</span>
    <span class="nn">net</span><span class="p">::{</span><span class="n">TcpListener</span><span class="p">,</span> <span class="n">TcpStream</span><span class="p">},</span>
<span class="p">};</span>
<span class="k">use</span> <span class="nn">tokio_util</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="n">CancellationToken</span><span class="p">;</span>

<span class="cd">/// Run `netcat localhost:8080` to test this server (once you run this main function).</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Register tracing subscriber.</span>
    <span class="nn">tracing_subscriber</span><span class="p">::</span><span class="nf">fmt</span><span class="p">()</span>
        <span class="nf">.without_time</span><span class="p">()</span>
        <span class="nf">.compact</span><span class="p">()</span>
        <span class="nf">.with_target</span><span class="p">(</span><span class="k">false</span><span class="p">)</span>
        <span class="nf">.with_line_number</span><span class="p">(</span><span class="k">false</span><span class="p">)</span>
        <span class="nf">.with_thread_ids</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
        <span class="nf">.with_thread_names</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
        <span class="nf">.init</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">cancellation_token</span> <span class="o">=</span> <span class="nn">CancellationToken</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="c1">// TODO: Add ctrlc handler.</span>

    <span class="c1">// TODO: Add code to use the `tokio` runtime and run some futures on it.</span>

    <span class="nn">tokio_uring</span><span class="p">::</span><span class="nf">start</span><span class="p">(</span><span class="nf">start_server</span><span class="p">(</span><span class="n">cancellation_token</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>You can get the source code for this example
<a href="https://github.com/nazmulidris/rust-scratch/tree/main/tokio-uring/src/socketserver.rs">here</a>.</p>
</blockquote>

<p>Next, we will add the code to handle the server logic. The following code handles the
incoming connections (using <code class="language-plaintext highlighter-rouge">tokio_uring</code> structs). This code is very similar to what we
would write if we were using <code class="language-plaintext highlighter-rouge">tokio</code> directly.</p>

<ul>
  <li>The main difference is that we are checking for port availability before binding to the
address, and we are using <code class="language-plaintext highlighter-rouge">tokio_uring::spawn</code> to spawn the futures, to handle incoming
connections.</li>
  <li>We will also use <code class="language-plaintext highlighter-rouge">tokio::select!</code> to create the main event loop. Since <code class="language-plaintext highlighter-rouge">tokio_uring</code> is
in the same family as <code class="language-plaintext highlighter-rouge">tokio</code>, we can do that!</li>
  <li>The <code class="language-plaintext highlighter-rouge">port_availability</code> module comes from <code class="language-plaintext highlighter-rouge">r3bl_terminal_async</code> crate, which is a
dependency in the <code class="language-plaintext highlighter-rouge">Cargo.toml</code> file. It allows us to check whether a port is available
or not, and find a free port in a given port range.</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">fn</span> <span class="nf">start_server</span><span class="p">(</span><span class="n">cancellation_token</span><span class="p">:</span> <span class="n">CancellationToken</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">tcp_listener</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">addr</span><span class="p">:</span> <span class="n">SocketAddr</span> <span class="o">=</span> <span class="s">"0.0.0.0:8080"</span><span class="nf">.parse</span><span class="p">()</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
        <span class="c1">// You can bind to the same address repeatedly, and it won't return</span>
        <span class="c1">// an error! Might have to check to see whether the port is open or</span>
        <span class="c1">// not before binding to it!</span>
        <span class="k">match</span> <span class="nn">port_availability</span><span class="p">::</span><span class="nf">check</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span> <span class="p">{</span>
            <span class="nn">port_availability</span><span class="p">::</span><span class="nn">Status</span><span class="p">::</span><span class="n">Free</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"Port {} is available"</span><span class="p">,</span> <span class="n">addr</span><span class="nf">.port</span><span class="p">());</span>
            <span class="p">}</span>
            <span class="nn">port_availability</span><span class="p">::</span><span class="nn">Status</span><span class="p">::</span><span class="n">Occupied</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span>
                    <span class="s">"Port {} is NOT available, can't bind to it"</span><span class="p">,</span>
                    <span class="n">addr</span><span class="nf">.port</span><span class="p">()</span>
                <span class="p">);</span>
                <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">miette</span><span class="p">::</span><span class="nd">miette!</span><span class="p">(</span>
                    <span class="s">"Port {} is NOT available, can't bind to it"</span><span class="p">,</span>
                    <span class="n">addr</span><span class="nf">.port</span><span class="p">()</span>
                <span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nn">TcpListener</span><span class="p">::</span><span class="nf">bind</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span>
    <span class="p">};</span>

    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"server - started"</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.red</span><span class="p">()</span><span class="nf">.bold</span><span class="p">());</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">abort_handles</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">AbortHandle</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span> <span class="p">{</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">cancellation_token</span><span class="nf">.cancelled</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">abort_handles</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.for_each</span><span class="p">(|</span><span class="n">handle</span><span class="p">|</span> <span class="n">handle</span><span class="nf">.abort</span><span class="p">());</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">it</span> <span class="o">=</span> <span class="n">tcp_listener</span><span class="nf">.accept</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">tcp_stream</span><span class="p">,</span> <span class="n">_addr</span><span class="p">)</span> <span class="o">=</span> <span class="n">it</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
                <span class="k">let</span> <span class="n">join_handle</span> <span class="o">=</span> <span class="nn">tokio_uring</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span>
                    <span class="nf">handle_connection</span><span class="p">(</span><span class="n">tcp_stream</span><span class="p">)</span>
                <span class="p">);</span>
                <span class="n">abort_handles</span><span class="nf">.push</span><span class="p">(</span><span class="n">join_handle</span><span class="nf">.abort_handle</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"server - stopped"</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.red</span><span class="p">()</span><span class="nf">.bold</span><span class="p">());</span>
    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Add the following code to handle the echo logic. This code reads from the stream using
<code class="language-plaintext highlighter-rouge">tokio_uring</code> and its function signature is quite different from what we would write if we
were using <code class="language-plaintext highlighter-rouge">tokio</code> directly. It is similar to what happens with <code class="language-plaintext highlighter-rouge">read_at</code> in the previous
example, and it moves ownership to <code class="language-plaintext highlighter-rouge">read</code>. Which returns a tuple:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">Result</code> containing the number of bytes read.</li>
  <li>Buffer that was passed from the kernel.</li>
</ol>

<p>The <code class="language-plaintext highlighter-rouge">write_all</code> function also returns a tuple that is similar.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">fn</span> <span class="nf">handle_connection</span><span class="p">(</span><span class="n">stream</span><span class="p">:</span> <span class="n">TcpStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"handle_connection - start"</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">total_bytes_read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">buf</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0u8</span><span class="p">;</span> <span class="mi">10</span><span class="p">];</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="c1">// Read from the stream.</span>
        <span class="c1">// Read some data, the buffer is passed by ownership and submitted</span>
        <span class="c1">// to the kernel. When the operation completes, we get the buffer</span>
        <span class="c1">// back.</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">result_num_bytes_read</span><span class="p">,</span> <span class="n">return_buf</span><span class="p">)</span> <span class="o">=</span> <span class="n">stream</span><span class="nf">.read</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="n">return_buf</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">num_bytes_read</span> <span class="o">=</span> <span class="n">result_num_bytes_read</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

        <span class="c1">// Check for EOF.</span>
        <span class="k">if</span> <span class="n">num_bytes_read</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Write to the stream.</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">result_num_bytes_written</span><span class="p">,</span> <span class="n">slice</span><span class="p">)</span> <span class="o">=</span>
            <span class="n">stream</span><span class="nf">.write_all</span><span class="p">(</span><span class="n">buf</span><span class="nf">.slice</span><span class="p">(</span><span class="o">..</span><span class="n">num_bytes_read</span><span class="p">))</span><span class="k">.await</span><span class="p">;</span>
        <span class="n">result_num_bytes_written</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span> <span class="c1">// Make sure no errors.</span>

        <span class="c1">// Update the buffer.</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="n">slice</span><span class="nf">.into_inner</span><span class="p">();</span>
        <span class="n">total_bytes_read</span> <span class="o">+=</span> <span class="n">num_bytes_read</span><span class="p">;</span>

        <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span>
            <span class="s">"{}: {}"</span><span class="p">,</span>
            <span class="s">"handle_connection - num_bytes_read"</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.red</span><span class="p">(),</span>
            <span class="n">num_bytes_read</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span>
        <span class="s">"handle_connection - end, total_bytes_read: {}"</span><span class="p">,</span>
        <span class="n">total_bytes_read</span>
    <span class="p">);</span>
    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To test this, you can run the server using <code class="language-plaintext highlighter-rouge">cargo run --bin socketserver</code>. Then you can
connect to the server using <code class="language-plaintext highlighter-rouge">netcat</code> (or <code class="language-plaintext highlighter-rouge">nc</code>) by running <code class="language-plaintext highlighter-rouge">netcat localhost 8080</code>. You can
type some text and hit enter, and you should see the text echoed back to you.</p>

<p>This is what the output from <code class="language-plaintext highlighter-rouge">netcat</code> might look like:</p>

<pre class="pre-manual-highlight">netcat localhost 8080
echo echo echo
echo echo echo
</pre>

<p>This is what the output from the server might look like:</p>

<pre class="pre-manual-highlight"> cargo run --bin socketserver
<span style="color:#A3BE8C"> INFO</span> main ThreadId(01) Port is available
<span style="color:#A3BE8C"> INFO</span> main ThreadId(01) <span style="color:#BF616A"><b>server - started</b></span> - 0.0.0.0:8080
<span style="color:#A3BE8C"> INFO</span> main ThreadId(01) <span style="color:#BF616A"><b>handle_connection - start</b></span>
<span style="color:#A3BE8C"> INFO</span> main ThreadId(01) <span style="color:#BF616A">handle_connection - num_bytes_read</span>: 10
<span style="color:#A3BE8C"> INFO</span> main ThreadId(01) <span style="color:#BF616A">handle_connection - num_bytes_read</span>: 5
<span style="color:#A3BE8C"> INFO</span> main ThreadId(01) <span style="color:#BF616A"><b>handle_connection - end, total bytes read</b></span> : 15 bytes
</pre>

<p>There are two more bonus rounds that we can add to this example:</p>
<ol>
  <li>Add a <code class="language-plaintext highlighter-rouge">ctrlc</code> handler to gracefully shutdown the server, when the user types
<kbd>Ctrl+C</kbd>.</li>
  <li>Add code to use the <code class="language-plaintext highlighter-rouge">tokio</code> runtime and run some futures on it.</li>
</ol>

<p>In the <code class="language-plaintext highlighter-rouge">socketserver.rs</code> file, you can add the following code to replace
the comment <kbd>//TODO: Add ctrlc handler.</kbd>.
The following code will add a <code class="language-plaintext highlighter-rouge">ctrlc</code> handler to gracefully
shutdown the server, by cancelling the <code class="language-plaintext highlighter-rouge">cancellation_token</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">cancellation_token_clone</span> <span class="o">=</span> <span class="n">cancellation_token</span><span class="nf">.clone</span><span class="p">();</span>
<span class="nn">ctrlc</span><span class="p">::</span><span class="nf">set_handler</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"Received Ctrl+C!"</span><span class="p">);</span>
    <span class="n">cancellation_token_clone</span><span class="nf">.cancel</span><span class="p">();</span>
<span class="p">})</span>
<span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
</code></pre></div></div>

<p>And finally, the following code will replace the comment <kbd>// TODO: Add code to use the `tokio` runtime and run some futures on it.</kbd>.
This code will spawn a new OS thread (using <code class="language-plaintext highlighter-rouge">std</code>) and then create a new multi-threaded
<code class="language-plaintext highlighter-rouge">tokio</code> runtime on that thread. We will then run some futures on that runtime by passing an async
block to the <code class="language-plaintext highlighter-rouge">block_on</code> function of the runtime.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Can't use #[tokio::main] for `main()`, so we have to use the</span>
<span class="c1">// `tokio::runtime::Builder` API. However, we have to launch this in a separate</span>
<span class="c1">// thread, because we don't want it to collide with the `tokio_uring::start()`</span>
<span class="c1">// call.</span>
<span class="k">let</span> <span class="n">cancellation_token_clone</span> <span class="o">=</span> <span class="n">cancellation_token</span><span class="nf">.clone</span><span class="p">();</span>
<span class="nn">std</span><span class="p">::</span><span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
    <span class="c1">// If you use `Builder::new_current_thread()`, the runtime will</span>
    <span class="c1">// use the single / current thread scheduler.</span>
    <span class="c1">// `Builder::new_multi_thread()` will use a thread pool.</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nn">runtime</span><span class="p">::</span><span class="nn">Builder</span><span class="p">::</span><span class="nf">new_multi_thread</span><span class="p">()</span>
        <span class="nf">.enable_all</span><span class="p">()</span>
        <span class="nf">.worker_threads</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="nf">.build</span><span class="p">()</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span>
        <span class="nf">.unwrap</span><span class="p">()</span>
        <span class="nf">.block_on</span><span class="p">(</span><span class="nf">async_main</span><span class="p">(</span><span class="n">cancellation_token_clone</span><span class="p">))</span>
<span class="p">});</span>
</code></pre></div></div>

<p>Here‚Äôs the <code class="language-plaintext highlighter-rouge">async_main</code> function that we are calling in the code above. This function
simply runs some futures on the <code class="language-plaintext highlighter-rouge">tokio</code> runtime that we created in the code above. You can
see from the log output that the tasks are run in parallel (sometimes on the same thread
and sometimes on different threads), and are scheduled in a non-deterministic order.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">fn</span> <span class="nf">async_main</span><span class="p">(</span><span class="n">cancellation_token</span><span class="p">:</span> <span class="n">CancellationToken</span><span class="p">)</span> <span class="p">{</span>
    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"async_main - start"</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.magenta</span><span class="p">()</span><span class="nf">.bold</span><span class="p">());</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">interval</span> <span class="o">=</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">interval</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">2_500</span><span class="p">));</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span> <span class="p">{</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">interval</span><span class="nf">.tick</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span>
                    <span class="s">"{}"</span><span class="p">,</span>
                    <span class="s">"async_main - tick"</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.magenta</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span>
                    <span class="p">);</span>

                <span class="c1">// Notice in the output, that these tasks are NOT spawned</span>
                <span class="c1">// in the same order repeatedly. They are run in parallel</span>
                <span class="c1">// on different threads. And these are scheduled in a</span>
                <span class="c1">// non-deterministic order.</span>
                <span class="k">let</span> <span class="n">task_1</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="p">{</span>
                    <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span>
                        <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
                    <span class="p">)</span><span class="k">.await</span><span class="p">;</span>
                    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"async_main - tick {} - spawn"</span><span class="p">,</span> <span class="s">"#1"</span>
                        <span class="nf">.to_string</span><span class="p">()</span><span class="nf">.on_green</span><span class="p">()</span><span class="nf">.black</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span>
                    <span class="p">);</span>
                <span class="p">});</span>
                <span class="k">let</span> <span class="n">task_2</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="p">{</span>
                    <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span>
                        <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
                    <span class="p">)</span><span class="k">.await</span><span class="p">;</span>
                    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"async_main - tick {} - spawn"</span><span class="p">,</span> <span class="s">"#2"</span>
                        <span class="nf">.to_string</span><span class="p">()</span><span class="nf">.on_red</span><span class="p">()</span><span class="nf">.black</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span>
                    <span class="p">);</span>
                <span class="p">});</span>
                <span class="k">let</span> <span class="n">task_3</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="p">{</span>
                    <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span>
                        <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
                    <span class="p">)</span><span class="k">.await</span><span class="p">;</span>
                    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"async_main - tick {} - spawn"</span><span class="p">,</span> <span class="s">"#3"</span>
                        <span class="nf">.to_string</span><span class="p">()</span><span class="nf">.on_blue</span><span class="p">()</span><span class="nf">.black</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span>
                    <span class="p">);</span>
                <span class="p">});</span>
                <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nd">join!</span><span class="p">(</span><span class="n">task_1</span><span class="p">,</span> <span class="n">task_2</span><span class="p">,</span> <span class="n">task_3</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">cancellation_token</span><span class="nf">.cancelled</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"async_main - cancelled"</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"async_main - end"</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.magenta</span><span class="p">()</span><span class="nf">.bold</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here‚Äôs what the output from the server might look like, after adding the <code class="language-plaintext highlighter-rouge">ctrlc</code> handler and
the <code class="language-plaintext highlighter-rouge">tokio</code> runtime code and running it for about 10 seconds.</p>

<pre class="pre-manual-highlight"> cargo run --bin socketserver
<span style="color:#A3BE8C"> INFO</span> main ThreadId(01) Port is available
<span style="color:#A3BE8C"> INFO</span> ThreadId(03) <span style="color:#B48EAD"><b>async_main - start</b></span>
<span style="color:#A3BE8C"> INFO</span> main ThreadId(01) <span style="color:#BF616A"><b>server - started</b></span> - 0.0.0.0:8080
<span style="color:#A3BE8C"> INFO</span> ThreadId(03) <span style="color:#B48EAD"><b>async_main - tick</b></span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(04) async_main - tick <span style="background-color:#81A1C1"><span style="color:#3B4252"><b>#3</b></span></span> - spawn
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(06) async_main - tick <span style="background-color:#BF616A"><span style="color:#3B4252"><b>#2</b></span></span> - spawn
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) async_main - tick <span style="background-color:#A3BE8C"><span style="color:#3B4252"><b>#1</b></span></span> - spawn
<span style="color:#A3BE8C"> INFO</span> ThreadId(03) <span style="color:#B48EAD"><b>async_main - tick</b></span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(06) async_main - tick <span style="background-color:#BF616A"><span style="color:#3B4252"><b>#2</b></span></span> - spawn
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) async_main - tick <span style="background-color:#A3BE8C"><span style="color:#3B4252"><b>#1</b></span></span> - spawn
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(04) async_main - tick <span style="background-color:#81A1C1"><span style="color:#3B4252"><b>#3</b></span></span> - spawn
<span style="color:#A3BE8C"> INFO</span> ThreadId(03) <span style="color:#B48EAD"><b>async_main - tick</b></span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(06) async_main - tick <span style="background-color:#81A1C1"><span style="color:#3B4252"><b>#3</b></span></span> - spawn
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) async_main - tick <span style="background-color:#A3BE8C"><span style="color:#3B4252"><b>#1</b></span></span> - spawn
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(04) async_main - tick <span style="background-color:#BF616A"><span style="color:#3B4252"><b>#2</b></span></span> - spawn
<span style="color:#A3BE8C"> INFO</span> ThreadId(03) <span style="color:#B48EAD"><b>async_main - tick</b></span>
</pre>

<h3 id="parting-thoughts">Parting thoughts</h3>
<p><a id="markdown-parting-thoughts" name="parting-thoughts"></a></p>

<p>There are areas of improvement in this codebase, such as port binding issues, and
connection management issues.</p>
<ol>
  <li>If you run more than one instance of the process <code class="language-plaintext highlighter-rouge">cargo run --bin startserver</code> then the
log output is pretty strange. The 2nd process that‚Äôs started seems to trigger the
<code class="language-plaintext highlighter-rouge">handle_connection</code> function of the first process.</li>
  <li>When you run the server and connect a client to it using <code class="language-plaintext highlighter-rouge">netcat</code>, and then kill the
server process, using <kbd>Ctrl+C</kbd>, the client doesn‚Äôt drop the connection.</li>
</ol>

<p>If you can figure out how to fix these issues, please raise a PR on the <a href="https://github.com/nazmulidris/rust-scratch/issues">GitHub
repo</a>. I‚Äôd love to see how you solve
these problems!</p>

<h2 id="build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</h2>
<p><a id="markdown-build-with-naz-video-series-on-developerlife.com-youtube-channel" name="build-with-naz-video-series-on-developerlife.com-youtube-channel"></a></p>

<blockquote>
  <p>If you have comments and feedback on this content, or would like to request new content
(articles &amp; videos) on developerlife.com, please join our <a href="https://discord.gg/8M2ePAevaMi">discord
server</a>.</p>
</blockquote>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a></li>
  <li>Playlists
    <ul>
      <li><a href="https://www.youtube.com/watch?v=bolScvh4x7I&amp;list=PLofhE49PEwmw3MKOU1Kn3xbP4FRQR4Mb3">Build with Naz, Linux TTY, process, signals, commands in async Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmza94sS7UmJnN9gSCHTVTfz">Build with Naz, fundamental effective Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmwO69E7eiQ-ewnMME8ydgQ5">Build with Naz, effective async Rust and tokio</a></li>
      <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><summary type="html"><![CDATA[Explore the Linux io_uring syscall with the tokio-uring crate in Rust. This article, video, and repo will show you how to use the tokio-uring do async file IO at the OS level, and how to use it to build a simple echo TCP server, for use with netcat.]]></summary></entry><entry><title type="html">Build with Naz : Rust async, non-blocking, concurrent, parallel, event loops, graceful shutdown</title><link href="http://developerlife.com/2024/05/19/effective-async-rust/" rel="alternate" type="text/html" title="Build with Naz : Rust async, non-blocking, concurrent, parallel, event loops, graceful shutdown" /><published>2024-05-19T10:00:00-05:00</published><updated>2024-05-19T10:00:00-05:00</updated><id>http://developerlife.com/2024/05/19/effective-async-rust</id><content type="html" xml:base="http://developerlife.com/2024/05/19/effective-async-rust/"><![CDATA[<p><img class="post-hero-image" src="/assets/rust_async_event_loops.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#what-is-async-rust-sequential-vs-concurrent-code--parallelism-as-a-resource">What is async Rust? Sequential vs concurrent code &amp; parallelism as a resource</a></li>
  <li><a href="#what-async-rust-is-not">What async Rust is not</a></li>
  <li><a href="#youtube-video-for-this-article">YouTube video for this article</a></li>
  <li><a href="#effective-async-rust-patterns-by-example">Effective async Rust patterns by example</a>
    <ul>
      <li><a href="#example-1-build-a-timer-future-using-waker">Example 1: Build a timer future using Waker</a></li>
      <li><a href="#example-2-build-an-async-runtime-to-run-futures-to-completion">Example 2: Build an async runtime to run futures to completion</a></li>
      <li><a href="#example-3-running-async-code-concurrently-on-a-single-thread">Example 3: Running async code, concurrently, on a single thread</a></li>
      <li><a href="#example-4-join-select-spawn-control-flow-constructors">Example 4: join!, select, spawn control flow constructors</a></li>
      <li><a href="#example-5-async-streams">Example 5: async streams</a></li>
      <li><a href="#example-6-non-blocking-event-loops-channel-safety-and-graceful-shutdown">Example 6: Non-blocking event loops, channel safety, and graceful shutdown</a></li>
      <li><a href="#parting-thoughts">Parting thoughts</a></li>
    </ul>
  </li>
  <li><a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</a></li>
</ul>

<!-- /TOC -->

<h2 id="introduction">Introduction</h2>
<p><a id="markdown-introduction" name="introduction"></a></p>

<p>In this article, video, and repo learn effective async Rust using real world patterns that
show up consistently when creating non blocking, async, event loops, using channels. Delve
into implementing the Future trait and async executor manually. Also explore graceful
shutdown, when not to use async, and how to think about testing async code.</p>

<h2 id="what-is-async-rust-sequential-vs-concurrent-code--parallelism-as-a-resource">What is async Rust? Sequential vs concurrent code &amp; parallelism as a resource</h2>
<p><a id="markdown-what-is-async-rust%3F-sequential-vs-concurrent-code-%26-parallelism-as-a-resource" name="what-is-async-rust%3F-sequential-vs-concurrent-code-%26-parallelism-as-a-resource"></a></p>

<p>In Rust, you can write sequential code, and concurrent code:</p>
<ul>
  <li>Sequential code can be run sequentially, or in parallel (using <code class="language-plaintext highlighter-rouge">thread::spawn()</code>).</li>
  <li>Concurrent code can be run on a single thread or multiple threads.</li>
</ul>

<p>Concurrency is a way to structure code into separate tasks. This does not define the
resources on a machine that will be used to run or execute tasks.</p>

<p>Parallelism is a way to specify what resources (CPU cores, or threads) will be used on a
machine‚Äôs operating system to run tasks.</p>

<p>These 2 concepts are not the same. They are related but not the same.</p>

<h2 id="what-async-rust-is-not">What async Rust is not</h2>
<p><a id="markdown-what-async-rust-is-not" name="what-async-rust-is-not"></a></p>

<p>Generally speaking, using async Rust is not just a matter of attaching <code class="language-plaintext highlighter-rouge">async</code> as a prefix
to a function, when you define it, and postfix <code class="language-plaintext highlighter-rouge">.await</code> when you call it. In fact, if you
don‚Äôt have at least one <code class="language-plaintext highlighter-rouge">.await</code> in your async function body, then it <a href="https://ryhl.io/blog/async-what-is-blocking/">might not need to
be async</a>. This article and video are a deep
dive into what async code is, what Rust <code class="language-plaintext highlighter-rouge">Future</code>s are, along with what async Runtimes are.
Along with some common patterns and anti-patterns when thinking in async Rust.</p>

<h2 id="youtube-video-for-this-article">YouTube video for this article</h2>
<p><a id="markdown-youtube-video-for-this-article" name="youtube-video-for-this-article"></a></p>

<p>This blog post only has short examples on how to use Rust async effectively. To see how
these ideas can be used in production code, with real-world examples, please watch the
following video on the <a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube
channel</a>.</p>

<!-- rust tokio tracing and otel for async rust & playlist -->
<iframe src="https://www.youtube.com/embed/qvIt8MF-pCM?si=S40pbhnvVDAohj-6" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<p><br /></p>

<h2 id="effective-async-rust-patterns-by-example">Effective async Rust patterns by example</h2>
<p><a id="markdown-effective-async-rust-patterns-by-example" name="effective-async-rust-patterns-by-example"></a></p>

<p>Let‚Äôs create some examples to illustrate how to use async Rust effectively. You can run
<code class="language-plaintext highlighter-rouge">cargo new --lib effective-async-rust</code> to create a new library crate.</p>

<blockquote>
  <p>The code in the video and this tutorial are all in this GitHub repo:
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/async_con_par/">https://github.com/nazmulidris/rust-scratch/blob/main/async_con_par/</a></p>
</blockquote>

<p>Then add the following to the <code class="language-plaintext highlighter-rouge">Cargo.toml</code> file that‚Äôs generated. These pull in all the
dependencies that we need for these examples.</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[package]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"effective-async-rust"</span>
<span class="py">version</span> <span class="p">=</span> <span class="s">"0.1.0"</span>
<span class="py">edition</span> <span class="p">=</span> <span class="s">"2021"</span>

<span class="nn">[dependencies]</span>
<span class="py">crossterm</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.27.0"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"event-stream"</span><span class="p">]</span> <span class="p">}</span>
<span class="py">tokio</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"1.37.0"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"full"</span><span class="p">,</span> <span class="s">"tracing"</span><span class="p">]</span> <span class="p">}</span>
<span class="py">tracing</span> <span class="p">=</span> <span class="s">"0.1.40"</span>
<span class="py">tracing-subscriber</span> <span class="p">=</span> <span class="s">"0.3.18"</span>
<span class="py">futures</span> <span class="p">=</span> <span class="s">"0.3.30"</span>
<span class="py">async-stream</span> <span class="p">=</span> <span class="s">"0.3.5"</span>
</code></pre></div></div>

<h3 id="example-1-build-a-timer-future-using-waker">Example 1: Build a timer future using Waker</h3>
<p><a id="markdown-example-1%3A-build-a-timer-future-using-waker" name="example-1%3A-build-a-timer-future-using-waker"></a></p>

<p>Then you can add the following code to the <code class="language-plaintext highlighter-rouge">src/lib.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="k">pub</span> <span class="k">mod</span> <span class="n">build_a_timer_future_using_waker</span><span class="p">;</span>
</code></pre></div></div>

<p>We will implement the <code class="language-plaintext highlighter-rouge">Future</code> trait manually, in this example. Typically any <code class="language-plaintext highlighter-rouge">async</code> code
block is converted into a finite state machine which implements the <code class="language-plaintext highlighter-rouge">Future</code> trait.
Progress on the future only occurs when it is polled by the runtime or executor (eg:
Tokio).</p>

<ul>
  <li>When a future is polled and it is <code class="language-plaintext highlighter-rouge">Ready</code> then the future is complete.</li>
  <li>If it is <code class="language-plaintext highlighter-rouge">Pending</code> then the future is not complete. And when it is ready (at some point
in the future, due to some event like network IO available via <code class="language-plaintext highlighter-rouge">epoll</code> or <code class="language-plaintext highlighter-rouge">io_uring</code>),
the runtime expects the future to wake up the, by calling <code class="language-plaintext highlighter-rouge">wake()</code> on the <code class="language-plaintext highlighter-rouge">Waker</code> that
is passed to this future by the runtime, via the <code class="language-plaintext highlighter-rouge">Context</code> object.</li>
</ul>

<p>Here are more details on this:</p>

<ol>
  <li><a href="https://rust-lang.github.io/async-book/01_getting_started/04_async_await_primer.html">Primer on async and await</a>.</li>
  <li><a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code class="language-plaintext highlighter-rouge">Future</code> trait</a>.</li>
  <li><a href="https://rust-lang.github.io/async-book/02_execution/03_wakeups.html">Timer example</a>.</li>
</ol>

<blockquote>
  <p>The code for this example is
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/async_con_par/src/build_a_timer_future_using_waker.rs">here</a>.</p>
</blockquote>

<p>Create a new file <code class="language-plaintext highlighter-rouge">src/build_a_timer_future_using_waker.rs</code>. In this file, we are going
to:</p>
<ul>
  <li>Build a timer that wakes up a task after a certain amount of time, to explore how
<code class="language-plaintext highlighter-rouge">Waker</code> works.</li>
  <li>We‚Äôll just spin up a new thread when the timer is created, sleep for the required time,
and then signal the timer future when the time window has elapsed.</li>
</ul>

<p>Add the following code to the file, to define a new struct that will implement the
<code class="language-plaintext highlighter-rouge">Future</code> trait. This struct will have a <code class="language-plaintext highlighter-rouge">SharedState</code> struct that will contain the state
of the future, and an optional <code class="language-plaintext highlighter-rouge">Waker</code> that will be used to wake up the future when the
timer has elapsed. This <code class="language-plaintext highlighter-rouge">Waker</code> is not available until the very first time the future is
polled by the runtime.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Default)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">TimerFuture</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">shared_state</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">SharedState</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Default)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">SharedState</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">completed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">waker</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Waker</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Add the following code to implement the <code class="language-plaintext highlighter-rouge">Future</code> trait for the <code class="language-plaintext highlighter-rouge">TimerFuture</code> struct.</p>
<ul>
  <li>This code will be used to poll the future, by the runtime, and check if the timer has
elapsed.</li>
  <li>If it has, then the future is complete, and the runtime can move on to the next task. If
the timer has not elapsed, then the future is not complete, and the runtime won‚Äôt do
anything further with this future. And will go on to the next task (top level <code class="language-plaintext highlighter-rouge">Future</code>)
that it can make progress on.</li>
</ul>

<p>Something has to wake up this future to let the runtime know that the timer has elapsed,
and that it needs to call <code class="language-plaintext highlighter-rouge">poll()</code> again on this <code class="language-plaintext highlighter-rouge">Future</code>. This is where the <code class="language-plaintext highlighter-rouge">Waker</code> comes
in.</p>
<ul>
  <li>The first time <code class="language-plaintext highlighter-rouge">poll()</code> is called on this future, the runtime passes in a <code class="language-plaintext highlighter-rouge">Waker</code> and we
save that to the <code class="language-plaintext highlighter-rouge">SharedState</code> struct.</li>
  <li>This will be used by the timer thread to wake up the future, when the timer has elapsed
(which we will do next).</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">Future</span> <span class="k">for</span> <span class="n">TimerFuture</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="p">();</span>

    <span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span><span class="k">self</span><span class="p">:</span> <span class="nb">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="k">Self</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">cx</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Context</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Poll</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Output</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">shared_state</span> <span class="o">=</span> <span class="k">self</span><span class="py">.shared_state</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="k">match</span> <span class="n">shared_state</span><span class="py">.completed</span> <span class="p">{</span>
            <span class="k">true</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"TimerFuture is completed"</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.green</span><span class="p">());</span>
                <span class="nn">Poll</span><span class="p">::</span><span class="nf">Ready</span><span class="p">(())</span>
            <span class="p">}</span>
            <span class="k">false</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"TimerFuture is not completed"</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.red</span><span class="p">());</span>
                <span class="c1">// Importantly, we have to update the Waker every time the</span>
                <span class="c1">// future is polled because the future may have moved to</span>
                <span class="c1">// a different task with a different Waker. This will happen</span>
                <span class="c1">// when futures are passed around between tasks after being</span>
                <span class="c1">// polled.</span>
                <span class="n">shared_state</span><span class="py">.waker</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">cx</span><span class="nf">.waker</span><span class="p">()</span><span class="nf">.clone</span><span class="p">());</span>
                <span class="nn">Poll</span><span class="p">::</span><span class="n">Pending</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Add the following code to create a new timer <code class="language-plaintext highlighter-rouge">Future</code>, and start a new thread that will
sleep for the required time, and then wake up the <code class="language-plaintext highlighter-rouge">Future</code> when the timer has elapsed, by
using the optional <code class="language-plaintext highlighter-rouge">Waker</code> that was saved in the <code class="language-plaintext highlighter-rouge">SharedState</code> struct (when <code class="language-plaintext highlighter-rouge">poll()</code> is
called on the <code class="language-plaintext highlighter-rouge">Future</code>, by the runtime).</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">TimerFuture</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">duration</span><span class="p">:</span> <span class="n">Duration</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">new_instance</span> <span class="o">=</span> <span class="nn">TimerFuture</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>

        <span class="k">let</span> <span class="n">shared_state_clone</span> <span class="o">=</span> <span class="n">new_instance</span><span class="py">.shared_state</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="nn">thread</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="n">duration</span><span class="p">);</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">shared_state</span> <span class="o">=</span> <span class="n">shared_state_clone</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="n">shared_state</span><span class="py">.completed</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="n">shared_state</span><span class="py">.waker</span><span class="nf">.take</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.wake</span><span class="p">();</span>
        <span class="p">});</span>

        <span class="n">new_instance</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Add the following test to run this code. The <code class="language-plaintext highlighter-rouge">#[tokio::test]</code> attribute macro generates
code to start a single threaded executor to run the test code.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[tokio::test]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">run_timer_future_with_tokio</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">timer_future</span> <span class="o">=</span> <span class="nn">TimerFuture</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
    <span class="k">let</span> <span class="n">shared_state</span> <span class="o">=</span> <span class="n">timer_future</span><span class="py">.shared_state</span><span class="nf">.clone</span><span class="p">();</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="o">!</span><span class="n">shared_state</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.completed</span><span class="p">);</span>
    <span class="n">timer_future</span><span class="k">.await</span><span class="p">;</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="n">shared_state</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.completed</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When you run this test, it should produce the following output:</p>

<pre class="pre-manual-highlight">
running 1 test
<span style="color:#BF616A">TimerFuture is not completed</span>
<span style="color:#A3BE8C">TimerFuture is completed</span>
test build_a_timer_future_using_waker::run_timer_future_with_tokio ... ok
</pre>

<h3 id="example-2-build-an-async-runtime-to-run-futures-to-completion">Example 2: Build an async runtime to run futures to completion</h3>
<p><a id="markdown-example-2%3A-build-an-async-runtime-to-run-futures-to-completion" name="example-2%3A-build-an-async-runtime-to-run-futures-to-completion"></a></p>

<p>For this example, let‚Äôs add the following code to the <code class="language-plaintext highlighter-rouge">src/lib.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="k">pub</span> <span class="k">mod</span> <span class="n">build_an_executor_to_run_future</span><span class="p">;</span>
</code></pre></div></div>

<p>In the example above, we use <code class="language-plaintext highlighter-rouge">tokio</code> to run the <code class="language-plaintext highlighter-rouge">TimerFuture</code> to completion. But in this
example, we will implement our own <em>simple</em> async runtime.</p>

<ul>
  <li>This is a very simple runtime that will run futures to completion, by polling them until
they are ready.</li>
  <li>It should highlight how the <code class="language-plaintext highlighter-rouge">Waker</code> and <code class="language-plaintext highlighter-rouge">Context</code> are supplied by the runtime to the
<code class="language-plaintext highlighter-rouge">Future</code>.</li>
</ul>

<blockquote>
  <p>You can get the source code for this example
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/async_con_par/src/build_an_executor_to_run_future.rs">here</a>.</p>
</blockquote>

<p>We will need a few things to implement this runtime:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">Task</code> struct that will contain the <code class="language-plaintext highlighter-rouge">Future</code> that needs to be run to completion.</li>
  <li><code class="language-plaintext highlighter-rouge">Task</code> queue that will contain all the tasks that need to be run. This will be a
<code class="language-plaintext highlighter-rouge">std::sync::mpsc::sync_channel</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">Waker</code> that will be used to wake up the runtime when a task is ready to be polled.
<code class="language-plaintext highlighter-rouge">Context</code> that will be used to pass the <code class="language-plaintext highlighter-rouge">Waker</code> to the <code class="language-plaintext highlighter-rouge">Future</code> that is being polled.</li>
  <li><code class="language-plaintext highlighter-rouge">Spawner</code> struct that will be used to spawn new tasks into the runtime.</li>
  <li><code class="language-plaintext highlighter-rouge">Executor</code> struct that will be used to run the runtime.</li>
</ol>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">src/build_an_executor_to_run_future.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">new_executor_and_spawner</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">Executor</span><span class="p">,</span> <span class="n">Spawner</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">MAX_TASKS</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">10_000</span><span class="p">;</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">task_sender</span><span class="p">,</span> <span class="n">task_receiver</span><span class="p">)</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">mpsc</span><span class="p">::</span><span class="nf">sync_channel</span><span class="p">(</span><span class="n">MAX_TASKS</span><span class="p">);</span>
    <span class="p">(</span><span class="n">Executor</span> <span class="p">{</span> <span class="n">task_receiver</span> <span class="p">},</span> <span class="n">Spawner</span> <span class="p">{</span> <span class="n">task_sender</span> <span class="p">})</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Executor</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">task_receiver</span><span class="p">:</span> <span class="n">Receiver</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Spawner</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">task_sender</span><span class="p">:</span> <span class="n">SyncSender</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Task</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">future</span><span class="p">:</span> <span class="n">Mutex</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">BoxFuture</span><span class="o">&lt;</span><span class="k">'static</span><span class="p">,</span> <span class="p">()</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">task_sender</span><span class="p">:</span> <span class="n">SyncSender</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">Spawner</code> struct to spawn new tasks into the runtime.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">Spawner</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">spawn</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">future</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Future</span><span class="o">&lt;</span><span class="n">Output</span> <span class="o">=</span> <span class="p">()</span><span class="o">&gt;</span> <span class="o">+</span> <span class="k">'static</span> <span class="o">+</span> <span class="nb">Send</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">pinned_boxed_future</span> <span class="o">=</span> <span class="n">future</span><span class="nf">.boxed</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">task</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Task</span> <span class="p">{</span>
            <span class="n">future</span><span class="p">:</span> <span class="nn">Mutex</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">pinned_boxed_future</span><span class="p">)),</span>
            <span class="n">task_sender</span><span class="p">:</span> <span class="k">self</span><span class="py">.task_sender</span><span class="nf">.clone</span><span class="p">(),</span>
        <span class="p">});</span>
        <span class="nd">eprintln!</span><span class="p">(</span>
            <span class="s">"{}"</span><span class="p">,</span>
            <span class="s">"sending task to executor, adding to channel"</span>
                <span class="nf">.to_string</span><span class="p">()</span>
                <span class="nf">.blue</span><span class="p">()</span>
        <span class="p">);</span>
        <span class="k">self</span><span class="py">.task_sender</span>
            <span class="nf">.send</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="nf">.expect</span><span class="p">(</span><span class="s">"too many tasks in channel"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">Executor</code> struct to run the runtime. This code will poll
the task queue, and block until it can get a task to run. Once it has a task, which it has
removed from the task channel or queue, it polls it (with the <code class="language-plaintext highlighter-rouge">Context</code> and <code class="language-plaintext highlighter-rouge">Waker</code>) to
check whether it is ready.</p>

<ul>
  <li>If it is ready, then it is done.</li>
  <li>If it is not ready, then it does not do anything further with it. When the task is ready
to be polled (eg: when the duration has passed in the <code class="language-plaintext highlighter-rouge">TimerFuture</code>‚Äôs thread), it will
use the <code class="language-plaintext highlighter-rouge">Waker</code> to wake up the task when it is ready to be polled). The <code class="language-plaintext highlighter-rouge">ArcWake</code>
implementation for the <code class="language-plaintext highlighter-rouge">Task</code> struct is used for this; all it does is send the task back
to the task channel, so that it can be polled again by the executor üéâ.</li>
  <li>Here‚Äôs what a real world implementation of <code class="language-plaintext highlighter-rouge">ArcWake</code> might look like using something
like Linux <code class="language-plaintext highlighter-rouge">epoll</code> or <code class="language-plaintext highlighter-rouge">io_uring</code>:
<a href="https://rust-lang.github.io/async-book/02_execution/05_io.html">https://rust-lang.github.io/async-book/02_execution/05_io.html</a>.</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">ArcWake</span> <span class="k">for</span> <span class="n">Task</span> <span class="p">{</span>
    <span class="cd">/// Implement `wake` by sending this task back onto the task</span>
    <span class="cd">/// channel so that it will be polled again by the executor,</span>
    <span class="cd">/// since it is now ready.</span>
    <span class="k">fn</span> <span class="nf">wake_by_ref</span><span class="p">(</span><span class="n">arc_self</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">cloned</span> <span class="o">=</span> <span class="n">arc_self</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="n">arc_self</span>
            <span class="py">.task_sender</span>
            <span class="nf">.send</span><span class="p">(</span><span class="n">cloned</span><span class="p">)</span>
            <span class="nf">.expect</span><span class="p">(</span><span class="s">"too many tasks in channel"</span><span class="p">);</span>
        <span class="nd">eprintln!</span><span class="p">(</span>
            <span class="s">"{}"</span><span class="p">,</span>
            <span class="s">"task woken up, added back to channel"</span>
                <span class="nf">.to_string</span><span class="p">()</span>
                <span class="nf">.underlined</span><span class="p">()</span>
                <span class="nf">.green</span><span class="p">()</span>
                <span class="nf">.bold</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Executor</span> <span class="p">{</span>
    <span class="nd">#[allow(clippy::while_let_loop)]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Remove task from receiver, or block if nothing available.</span>
        <span class="k">loop</span> <span class="p">{</span>
            <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"executor loop"</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.red</span><span class="p">());</span>
            <span class="c1">// Remove the task from the receiver.</span>
            <span class="c1">// If it is pending, then the ArcWaker</span>
            <span class="c1">// will add it back to the channel.</span>
            <span class="k">match</span> <span class="k">self</span><span class="py">.task_receiver</span><span class="nf">.recv</span><span class="p">()</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">arc_task</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">eprintln!</span><span class="p">(</span>
                        <span class="s">"{}"</span><span class="p">,</span>
                        <span class="s">"running task - start, got task from receiver"</span>
                            <span class="nf">.to_string</span><span class="p">()</span>
                            <span class="nf">.red</span><span class="p">()</span>
                    <span class="p">);</span>
                    <span class="k">let</span> <span class="k">mut</span> <span class="n">future_in_task</span> <span class="o">=</span> <span class="n">arc_task</span><span class="py">.future</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                    <span class="k">match</span> <span class="n">future_in_task</span><span class="nf">.take</span><span class="p">()</span> <span class="p">{</span>
                        <span class="nf">Some</span><span class="p">(</span><span class="k">mut</span> <span class="n">future</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                            <span class="k">let</span> <span class="n">waker</span> <span class="o">=</span> <span class="nf">waker_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arc_task</span><span class="p">);</span>
                            <span class="k">let</span> <span class="n">context</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">Context</span><span class="p">::</span><span class="nf">from_waker</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waker</span><span class="p">);</span>
                            <span class="k">let</span> <span class="n">poll_result</span> <span class="o">=</span> <span class="n">future</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.poll</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
                            <span class="nd">eprintln!</span><span class="p">(</span>
                                <span class="s">"{}"</span><span class="p">,</span>
                                <span class="nd">format!</span><span class="p">(</span>
                                  <span class="s">"poll_result: {:?}"</span><span class="p">,</span> <span class="n">poll_result</span><span class="p">)</span>
                                  <span class="nf">.to_string</span><span class="p">()</span><span class="nf">.red</span><span class="p">()</span>
                            <span class="p">);</span>
                            <span class="k">if</span> <span class="n">poll_result</span><span class="nf">.is_pending</span><span class="p">()</span> <span class="p">{</span>
                                <span class="c1">// We're not done processing the future, so put it</span>
                                <span class="c1">// back in its task to be run again in the future.</span>
                                <span class="o">*</span><span class="n">future_in_task</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">future</span><span class="p">);</span>
                                <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span>
                                  <span class="s">"putting task back in slot"</span>
                                  <span class="nf">.to_string</span><span class="p">()</span><span class="nf">.red</span><span class="p">()</span>
                                <span class="p">);</span>
                            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                                <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"task is done"</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.red</span><span class="p">());</span>
                            <span class="p">}</span>
                        <span class="p">}</span>
                        <span class="nb">None</span> <span class="k">=&gt;</span> <span class="p">{</span>
                            <span class="nd">panic!</span><span class="p">(</span><span class="s">"this never runs"</span><span class="p">);</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                    <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"running task - end"</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.red</span><span class="p">());</span>
                <span class="p">}</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"no more tasks to run, breaking out of loop"</span><span class="p">);</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And finally, add this test to run this code. Notice this code does not use <code class="language-plaintext highlighter-rouge">tokio</code> to run
the <code class="language-plaintext highlighter-rouge">TimerFuture</code> to completion. Instead, it uses the <code class="language-plaintext highlighter-rouge">Executor</code> and <code class="language-plaintext highlighter-rouge">Spawner</code> structs
that we implemented above.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">run_executor_and_spawner</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="nn">build_a_timer_future_using_waker</span><span class="p">::</span><span class="n">TimerFuture</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">results</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">Mutex</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">()));</span>

    <span class="k">let</span> <span class="p">(</span><span class="n">executor</span><span class="p">,</span> <span class="n">spawner</span><span class="p">)</span> <span class="o">=</span> <span class="nf">new_executor_and_spawner</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">results_clone</span> <span class="o">=</span> <span class="n">results</span><span class="nf">.clone</span><span class="p">();</span>
    <span class="n">spawner</span><span class="nf">.spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="n">results_clone</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.push</span><span class="p">(</span><span class="s">"hello, start timer!"</span><span class="p">);</span>
        <span class="nn">TimerFuture</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span><span class="k">.await</span><span class="p">;</span>
        <span class="n">results_clone</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.push</span><span class="p">(</span><span class="s">"bye, timer finished!"</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="nf">drop</span><span class="p">(</span><span class="n">spawner</span><span class="p">);</span>

    <span class="n">executor</span><span class="nf">.run</span><span class="p">();</span>

    <span class="nd">assert_eq!</span><span class="p">(</span>
        <span class="o">*</span><span class="n">results</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span>
        <span class="nd">vec!</span><span class="p">[</span><span class="s">"hello, start timer!"</span><span class="p">,</span> <span class="s">"bye, timer finished!"</span><span class="p">]</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This should produce the following output, which maps to the flow that we described above:</p>

<pre class="pre-manual-highlight">running 1 test
<span style="color:#81A1C1">sending task to executor, adding to channel</span>
<span style="color:#BF616A">executor loop</span>
<span style="color:#BF616A">running task - start, got task from receiver</span>
<span style="color:#BF616A">TimerFuture is not completed</span>
<span style="color:#BF616A">poll_result: Pending</span>
<span style="color:#BF616A">putting task back in slot</span>
<span style="color:#BF616A">running task - end</span>
<span style="color:#BF616A">executor loop</span>
<span style="color:#A3BE8C"><u style="text-decoration-style:single"><b>task woken up, added back to channel</b></u></span>
<span style="color:#BF616A">running task - start, got task from receiver</span>
<span style="color:#A3BE8C">TimerFuture is completed</span>
<span style="color:#BF616A">poll_result: Ready(())</span>
<span style="color:#BF616A">task is done</span>
<span style="color:#BF616A">running task - end</span>
<span style="color:#BF616A">executor loop</span>
no more tasks to run, breaking out of loop
test build_an_executor_to_run_future::run_executor_and_spawner ... ok
</pre>

<h3 id="example-3-running-async-code-concurrently-on-a-single-thread">Example 3: Running async code, concurrently, on a single thread</h3>
<p><a id="markdown-example-3%3A-running-async-code%2C-concurrently%2C-on-a-single-thread" name="example-3%3A-running-async-code%2C-concurrently%2C-on-a-single-thread"></a></p>

<p>For this example, let‚Äôs add the following code to the <code class="language-plaintext highlighter-rouge">src/lib.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="k">pub</span> <span class="k">mod</span> <span class="n">local_set</span><span class="p">;</span>
</code></pre></div></div>

<p>If you have async code, you can use a <code class="language-plaintext highlighter-rouge">LocalSet</code> to run the async code, in different
tasks, on a <em>single</em> thread. This ensures that any data that you have to pass between
these tasks can be <code class="language-plaintext highlighter-rouge">!Send</code>. Instead of wrapping the shared data in a <code class="language-plaintext highlighter-rouge">Arc</code> or
<code class="language-plaintext highlighter-rouge">Arc&lt;Mutex&gt;</code>, you can just wrap it in an <code class="language-plaintext highlighter-rouge">Rc</code>.</p>

<p>In this example, we will explore how to run async code concurrently, on a single thread.
This is an important concept to understand, as it is the basis for how async code can be
run concurrently, using non-blocking event loops.</p>

<blockquote>
  <p>The code for this example is
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/async_con_par/src/local_set.rs#L39">here</a>.</p>
</blockquote>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">src/local_set.rs</code> file.</p>
<ul>
  <li>It shows how you can create a <code class="language-plaintext highlighter-rouge">Future</code> that uses a <code class="language-plaintext highlighter-rouge">Rc</code> to share data concurrently,
running on a single thread.</li>
  <li>This is why the data is <code class="language-plaintext highlighter-rouge">!Send</code>, and we don‚Äôt need to use an <code class="language-plaintext highlighter-rouge">Arc</code> or <code class="language-plaintext highlighter-rouge">Arc&lt;Mutex&gt;</code> to
share it between tasks.</li>
  <li>Once the <code class="language-plaintext highlighter-rouge">LocalSet</code> is created, and <code class="language-plaintext highlighter-rouge">local_spawn()</code> is called, the task doesn‚Äôt actually
run until <code class="language-plaintext highlighter-rouge">local_set.run_until(..)</code> is called, or <code class="language-plaintext highlighter-rouge">local_set.await</code> is called.</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[tokio::test]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">run_local_set_and_spawn_local</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Can't send this data across threads (not wrapped in `Arc` or `Arc&lt;Mutex&gt;`).</span>
    <span class="k">let</span> <span class="n">non_send_data</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"!SEND DATA"</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">local_set</span> <span class="o">=</span> <span class="nn">LocalSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="c1">// Spawn a local task (bound to same thread) that uses the non-send data.</span>
    <span class="k">let</span> <span class="n">non_send_data_clone</span> <span class="o">=</span> <span class="n">non_send_data</span><span class="nf">.clone</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">async_block_1</span> <span class="o">=</span> <span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span>
            <span class="c1">// https://doc.rust-lang.org/std/fmt/index.html#fillalignment</span>
            <span class="s">"{:&lt;7} {}"</span><span class="p">,</span>
            <span class="s">"start"</span><span class="p">,</span>
            <span class="n">non_send_data_clone</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.yellow</span><span class="p">()</span><span class="nf">.bold</span><span class="p">(),</span>
        <span class="p">);</span>
    <span class="p">};</span>
    <span class="c1">// Does not run anything.</span>
    <span class="k">let</span> <span class="n">join_handle_1</span> <span class="o">=</span> <span class="n">local_set</span><span class="nf">.spawn_local</span><span class="p">(</span><span class="n">async_block_1</span><span class="p">);</span>

    <span class="c1">// This is required to run `async_block_1`.</span>
    <span class="k">let</span> <span class="n">_it</span> <span class="o">=</span> <span class="n">local_set</span><span class="nf">.run_until</span><span class="p">(</span><span class="n">join_handle_1</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
</code></pre></div></div>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">src/local_set.rs</code> file. This is just a different variant
(from the first example) of creating a new async block, and running it using the
<code class="language-plaintext highlighter-rouge">LocalSet</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// Create a 2nd async block.</span>
    <span class="k">let</span> <span class="n">non_send_data_clone</span> <span class="o">=</span> <span class="n">non_send_data</span><span class="nf">.clone</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">async_block_2</span> <span class="o">=</span> <span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="nf">sleep</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span><span class="k">.await</span><span class="p">;</span>
        <span class="nd">println!</span><span class="p">(</span>
            <span class="c1">// https://doc.rust-lang.org/std/fmt/index.html#fillalignment</span>
            <span class="s">"{:&lt;7} {}"</span><span class="p">,</span>
            <span class="s">"middle"</span><span class="p">,</span>
            <span class="n">non_send_data_clone</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.green</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">};</span>

    <span class="c1">// This is required to run `async_block_2`.</span>
    <span class="k">let</span> <span class="n">_it</span> <span class="o">=</span> <span class="n">local_set</span><span class="nf">.run_until</span><span class="p">(</span><span class="n">async_block_2</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
</code></pre></div></div>

<p>Finally add the following code to the <code class="language-plaintext highlighter-rouge">src/local_set.rs</code> file. This yet another way of how
you can create a new async block, and run it using the <code class="language-plaintext highlighter-rouge">LocalSet</code>. This one uses <code class="language-plaintext highlighter-rouge">local_set.await</code>
which runs all the futures that are associated with the <code class="language-plaintext highlighter-rouge">local_set</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// Spawn another local task (bound to same thread) that uses</span>
    <span class="c1">// the non-send data.</span>
    <span class="k">let</span> <span class="n">non_send_data_clone</span> <span class="o">=</span> <span class="n">non_send_data</span><span class="nf">.clone</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">async_block_3</span> <span class="o">=</span> <span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="nf">sleep</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span><span class="k">.await</span><span class="p">;</span>
        <span class="nd">println!</span><span class="p">(</span>
            <span class="c1">// https://doc.rust-lang.org/std/fmt/index.html#fillalignment</span>
            <span class="s">"{:&lt;7} {}"</span><span class="p">,</span>
            <span class="s">"end"</span><span class="p">,</span>
            <span class="n">non_send_data_clone</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.cyan</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">};</span>
    <span class="c1">// Does not run anything.</span>
    <span class="k">let</span> <span class="n">_join_handle_3</span> <span class="o">=</span> <span class="n">local_set</span><span class="nf">.spawn_local</span><span class="p">(</span><span class="n">async_block_3</span><span class="p">);</span>

    <span class="c1">// `async_block_3` won't run until this is called.</span>
    <span class="n">local_set</span><span class="k">.await</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here‚Äôs the output when you run this test:</p>

<pre class="pre-manual-highlight">running 1 test
start   <span style="color: #EBCB8B"><b>!SEND DATA</b></span>
middle  <span style="color: #A3BE8C"><b>!SEND DATA</b></span>
end     <span style="color: #8FBCBB"><b>!SEND DATA</b></span>
test local_set::run_local_set_and_spawn_local ... ok
</pre>

<h3 id="example-4-join-select-spawn-control-flow-constructors">Example 4: join!, select, spawn control flow constructors</h3>
<p><a id="markdown-example-4%3A-join!%2C-select%2C-spawn-control-flow-constructors" name="example-4%3A-join!%2C-select%2C-spawn-control-flow-constructors"></a></p>

<p>For this example, let‚Äôs add the following code to the <code class="language-plaintext highlighter-rouge">src/lib.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="k">pub</span> <span class="k">mod</span> <span class="n">demo_join_select_spawn</span><span class="p">;</span>
</code></pre></div></div>

<p>You can use <code class="language-plaintext highlighter-rouge">join!</code>, <code class="language-plaintext highlighter-rouge">select!</code>, and <code class="language-plaintext highlighter-rouge">spawn</code> to control the flow of async code. These are
macros that are provided by the <code class="language-plaintext highlighter-rouge">tokio</code> crate. They are used to run multiple futures
concurrent, in parallel, and wait for them to complete.</p>

<blockquote>
  <p>The code for this example is
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/async_con_par/src/demo_join_select_spawn.rs">here</a>.</p>
</blockquote>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">src/demo_join_select_spawn.rs</code> file. This code shows how
you can use <code class="language-plaintext highlighter-rouge">join!</code> to run multiple futures concurrently, and wait for them to complete.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">task_1</span><span class="p">(</span><span class="n">time</span><span class="p">:</span> <span class="nb">u64</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">sleep</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="n">time</span><span class="p">))</span><span class="k">.await</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"task_1"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">task_2</span><span class="p">(</span><span class="n">time</span><span class="p">:</span> <span class="nb">u64</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">sleep</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="n">time</span><span class="p">))</span><span class="k">.await</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"task_2"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">task_3</span><span class="p">(</span><span class="n">time</span><span class="p">:</span> <span class="nb">u64</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">sleep</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="n">time</span><span class="p">))</span><span class="k">.await</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"task_3"</span><span class="p">);</span>
<span class="p">}</span>

<span class="nd">#[tokio::test]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">test_join</span><span class="p">()</span> <span class="p">{</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nd">join!</span><span class="p">(</span><span class="nf">task_1</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="nf">task_2</span><span class="p">(</span><span class="mi">200</span><span class="p">),</span> <span class="nf">task_3</span><span class="p">(</span><span class="mi">300</span><span class="p">));</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"all tasks done"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here‚Äôs the output when you run this test:</p>
<pre class="pre-manual-highlight">running 1 test
task_1
task_2
task_3
all tasks done
test demo_join_select_spawn::test_join ... ok
</pre>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">src/demo_join_select_spawn.rs</code> file. This code shows how
you can use <code class="language-plaintext highlighter-rouge">select!</code> to run multiple futures concurrently, and wait for the first one to
complete.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[tokio::test]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">test_select</span><span class="p">()</span> <span class="p">{</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span> <span class="p">{</span>
        <span class="n">_</span> <span class="o">=</span> <span class="nf">task_1</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"task_1 done"</span><span class="p">),</span>
        <span class="n">_</span> <span class="o">=</span> <span class="nf">task_2</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"task_2 done"</span><span class="p">),</span>
        <span class="n">_</span> <span class="o">=</span> <span class="nf">task_3</span><span class="p">(</span><span class="mi">300</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"task_3 done"</span><span class="p">),</span>
    <span class="p">}</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"one task done"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here‚Äôs the output when you run this test:</p>
<pre class="pre-manual-highlight">running 1 test
task_1 done
one task done
test demo_join_select_spawn::test_select ... ok
</pre>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">src/demo_join_select_spawn.rs</code> file. This code shows how
you can use <code class="language-plaintext highlighter-rouge">spawn</code> to run multiple futures in parallel, and wait for them to complete. We
pass the following to the <code class="language-plaintext highlighter-rouge">#[tokio::test]</code> attribute macro: <code class="language-plaintext highlighter-rouge">flavor = "multi_thread",
worker_threads = 5</code> which tells it to run the test on multiple threads (max of 5).</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[tokio::test(flavor</span> <span class="nd">=</span> <span class="s">"multi_thread"</span><span class="nd">,</span> <span class="nd">worker_threads</span> <span class="nd">=</span> <span class="mi">5</span><span class="nd">)]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">test_spawn</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">handle_1</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="nf">task_1</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>
    <span class="k">let</span> <span class="n">handle_2</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="nf">task_2</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>
    <span class="k">let</span> <span class="n">handle_3</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="nf">task_3</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>

    <span class="n">handle_1</span><span class="k">.await</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="n">handle_2</span><span class="k">.await</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="n">handle_3</span><span class="k">.await</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"all tasks done"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When you run this test, it should produce the following output (the ordering of the tasks
which run first, second, and third, will vary):</p>

<pre class="pre-manual-highlight">running 1 test
task_3
task_1
task_2
all tasks done
test demo_join_select_spawn::test_spawn ... ok
</pre>

<h3 id="example-5-async-streams">Example 5: async streams</h3>
<p><a id="markdown-example-5%3A-async-streams" name="example-5%3A-async-streams"></a></p>

<p>For this example, let‚Äôs add the following code to the <code class="language-plaintext highlighter-rouge">src/lib.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="k">pub</span> <span class="k">mod</span> <span class="n">async_stream</span><span class="p">;</span>
</code></pre></div></div>

<p>You can use async streams to create a stream of values that are produced asynchronously.
This is useful for testing, for example in the <code class="language-plaintext highlighter-rouge">r3bl_terminal_async</code> crate <a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/terminal_async/src/readline_impl/readline.rs#L796">in
<code class="language-plaintext highlighter-rouge">readline.rs</code> in <code class="language-plaintext highlighter-rouge">test_streams</code>
module</a>.</p>

<blockquote>
  <p>The code for this example is
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/async_con_par/src/async_stream.rs">here</a>.</p>
</blockquote>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">src/async_stream.rs</code> file.</p>
<ul>
  <li>This code shows how you can use <code class="language-plaintext highlighter-rouge">async_stream</code> crate‚Äôs <code class="language-plaintext highlighter-rouge">stream!</code> macro to create a
stream of values that are generated from a vector of strings.</li>
  <li>This stream is then converted into a <code class="language-plaintext highlighter-rouge">PinnedInputStream</code> which is a <code class="language-plaintext highlighter-rouge">Pin&lt;Box&lt;dyn
Stream&lt;Item = Result&lt;String, String&gt;&gt;&gt;</code>.</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">type</span> <span class="n">PinnedInputStream</span> <span class="o">=</span> <span class="nb">Pin</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="nb">String</span><span class="o">&gt;&gt;&gt;&gt;</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">gen_input_stream</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">PinnedInputStream</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="nn">async_stream</span><span class="p">::</span><span class="nd">stream!</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">event</span> <span class="k">in</span> <span class="nf">get_input_vec</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">yield</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="nn">Box</span><span class="p">::</span><span class="nf">pin</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_input_vec</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">vec!</span><span class="p">[</span>
        <span class="s">"a"</span><span class="nf">.to_string</span><span class="p">(),</span>
        <span class="s">"b"</span><span class="nf">.to_string</span><span class="p">(),</span>
        <span class="s">"c"</span><span class="nf">.to_string</span><span class="p">(),</span>
        <span class="s">"d"</span><span class="nf">.to_string</span><span class="p">(),</span>
    <span class="p">]</span>
<span class="p">}</span>

<span class="nd">#[tokio::test]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">test_stream</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">it</span> <span class="o">=</span> <span class="nf">gen_input_stream</span><span class="p">();</span>
    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="o">=</span> <span class="n">it</span><span class="nf">.next</span><span class="p">()</span><span class="k">.await</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">lhs</span> <span class="o">=</span> <span class="n">event</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">rhs</span> <span class="o">=</span> <span class="nf">get_input_vec</span><span class="p">()[</span><span class="n">count</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="example-6-non-blocking-event-loops-channel-safety-and-graceful-shutdown">Example 6: Non-blocking event loops, channel safety, and graceful shutdown</h3>
<p><a id="markdown-example-6%3A-non-blocking-event-loops%2C-channel-safety%2C-and-graceful-shutdown" name="example-6%3A-non-blocking-event-loops%2C-channel-safety%2C-and-graceful-shutdown"></a></p>

<p>Let‚Äôs add the following code to the <code class="language-plaintext highlighter-rouge">src/lib.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="k">pub</span> <span class="k">mod</span> <span class="n">non_blocking_async_event_loops</span><span class="p">;</span>
</code></pre></div></div>

<p>You can use non-blocking event loops to create a loop that runs async code, and waits for
events to occur. This is useful for creating servers, clients, and other networked
applications. You can even use the same pattern to create
<a href="https://crates.io/crates/r3bl_terminal_async">CLI</a> and
<a href="https://crates.io/crates/r3bl_tui">TUI</a> applications that are non-blocking, and can
handle multiple events concurrently, such as when you‚Äôre creating an interactive async
REPL.</p>

<blockquote>
  <p>The source code for this example is
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/async_con_par/src/non_blocking_async_event_loops.rs">here</a>.</p>
</blockquote>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">src/non_blocking_async_event_loops.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[tokio::test(flavor</span> <span class="nd">=</span> <span class="s">"multi_thread"</span><span class="nd">,</span> <span class="nd">worker_threads</span> <span class="nd">=</span> <span class="mi">5</span><span class="nd">)]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">test_main_loop</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Register tracing subscriber.</span>
    <span class="nn">tracing_subscriber</span><span class="p">::</span><span class="nf">fmt</span><span class="p">()</span>
        <span class="nf">.without_time</span><span class="p">()</span>
        <span class="nf">.compact</span><span class="p">()</span>
        <span class="nf">.with_target</span><span class="p">(</span><span class="k">false</span><span class="p">)</span>
        <span class="nf">.with_line_number</span><span class="p">(</span><span class="k">false</span><span class="p">)</span>
        <span class="nf">.with_thread_ids</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
        <span class="nf">.with_thread_names</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
        <span class="nf">.init</span><span class="p">();</span>

    <span class="c1">// Create channels for events and shutdown signals.</span>
    <span class="k">let</span> <span class="n">event_channel</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">mpsc</span><span class="p">::</span><span class="nn">channel</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1_000</span><span class="p">);</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">event_sender</span><span class="p">,</span> <span class="k">mut</span> <span class="n">event_receiver</span><span class="p">)</span> <span class="o">=</span> <span class="n">event_channel</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">shutdown_channel</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">broadcast</span><span class="p">::</span><span class="nn">channel</span><span class="p">::</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1_000</span><span class="p">);</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">shutdown_sender</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">shutdown_channel</span><span class="p">;</span>

    <span class="c1">// Spawn the main event loop.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">shutdown_receiver</span> <span class="o">=</span> <span class="n">shutdown_sender</span><span class="nf">.subscribe</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">safe_count</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">safe_count_clone</span> <span class="o">=</span> <span class="n">safe_count</span><span class="nf">.clone</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">join_handle</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="k">loop</span> <span class="p">{</span>
            <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span> <span class="p">{</span>
                <span class="n">event</span> <span class="o">=</span> <span class="n">event_receiver</span><span class="nf">.recv</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="o">?</span><span class="n">event</span><span class="p">,</span> <span class="s">"task got event: event"</span><span class="p">);</span>
                    <span class="k">let</span> <span class="k">mut</span> <span class="n">count</span> <span class="o">=</span> <span class="n">safe_count_clone</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                    <span class="o">*</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">_</span> <span class="o">=</span> <span class="n">shutdown_receiver</span><span class="nf">.recv</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"task got shutdown signal"</span><span class="p">);</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">});</span>

    <span class="c1">// Send events, in parallel.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">handles</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">10</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">event_sender_clone</span> <span class="o">=</span> <span class="n">event_sender</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">join_handle</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
            <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s">"sending event"</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">event</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"event {}"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="n">event_sender_clone</span><span class="nf">.send</span><span class="p">(</span><span class="n">event</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
            <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span><span class="k">.await</span><span class="p">;</span>
        <span class="p">});</span>
        <span class="n">handles</span><span class="nf">.push</span><span class="p">(</span><span class="n">join_handle</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Wait for all events to be sent using tokio.</span>
    <span class="nn">futures</span><span class="p">::</span><span class="nn">future</span><span class="p">::</span><span class="nf">join_all</span><span class="p">(</span><span class="n">handles</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>

    <span class="c1">// Shutdown the event loops.</span>
    <span class="n">shutdown_sender</span><span class="nf">.send</span><span class="p">(())</span><span class="nf">.unwrap</span><span class="p">();</span>

    <span class="c1">// Wait for the event loop to shutdown.</span>
    <span class="n">join_handle</span><span class="k">.await</span><span class="nf">.unwrap</span><span class="p">();</span>

    <span class="c1">// Assertions.</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">shutdown_sender</span><span class="nf">.receiver_count</span><span class="p">(),</span> <span class="mi">1</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="o">*</span><span class="n">safe_count</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span> <span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here are key points to note about this code:</p>
<ul>
  <li>We use <code class="language-plaintext highlighter-rouge">tokio::sync::mpsc::channel</code> to create a channel for events, and
<code class="language-plaintext highlighter-rouge">tokio::sync::broadcast::channel</code> to create a channel for shutdown signals.</li>
  <li>We spawn the main event loop, which listens for events and shutdown signals, and updates
a shared counter.</li>
  <li>We spawn multiple tasks that send events to the event channel, in parallel.
    <ul>
      <li>The <code class="language-plaintext highlighter-rouge">#[tokio::test(flavor = "multi_thread", worker_threads = 5)]</code> attribute macro
tells <code class="language-plaintext highlighter-rouge">tokio</code> to run the test on multiple threads (max of 5).</li>
      <li>You can see this in the output when you run the test. By configuring Tokio <code class="language-plaintext highlighter-rouge">tracing</code>
subscriber, we can see the thread IDs and names in the output
(<code class="language-plaintext highlighter-rouge">.with_thread_ids(true)</code>, <code class="language-plaintext highlighter-rouge">.with_thread_names(true)</code>).</li>
      <li>We wait for all events to be sent using <code class="language-plaintext highlighter-rouge">futures::future::join_all(handles).await</code>.</li>
    </ul>
  </li>
  <li>We shutdown the event loop (using <code class="language-plaintext highlighter-rouge">shutdown_sender.send(())</code>), and wait for it to
shutdown using <code class="language-plaintext highlighter-rouge">join_handle.await</code>..</li>
</ul>

<p>When you run this test, it will produce the following output:</p>
<pre class="pre-manual-highlight">running 1 test
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) sending event <i>i</i><span style="color:#90949B">=2</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(04) sending event <i>i</i><span style="color:#90949B">=6</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(06) sending event <i>i</i><span style="color:#90949B">=0</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(07) sending event <i>i</i><span style="color:#90949B">=4</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(03) sending event <i>i</i><span style="color:#90949B">=7</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(04) sending event <i>i</i><span style="color:#90949B">=8</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(06) sending event <i>i</i><span style="color:#90949B">=1</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) task got event: event <i>event</i><span style="color:#90949B">=Some(&quot;event 2&quot;)</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(07) sending event <i>i</i><span style="color:#90949B">=5</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(03) sending event <i>i</i><span style="color:#90949B">=9</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) task got event: event <i>event</i><span style="color:#90949B">=Some(&quot;event 6&quot;)</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(04) sending event <i>i</i><span style="color:#90949B">=3</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) task got event: event <i>event</i><span style="color:#90949B">=Some(&quot;event 0&quot;)</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) task got event: event <i>event</i><span style="color:#90949B">=Some(&quot;event 4&quot;)</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) task got event: event <i>event</i><span style="color:#90949B">=Some(&quot;event 7&quot;)</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) task got event: event <i>event</i><span style="color:#90949B">=Some(&quot;event 8&quot;)</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) task got event: event <i>event</i><span style="color:#90949B">=Some(&quot;event 1&quot;)</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) task got event: event <i>event</i><span style="color:#90949B">=Some(&quot;event 5&quot;)</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) task got event: event <i>event</i><span style="color:#90949B">=Some(&quot;event 9&quot;)</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) task got event: event <i>event</i><span style="color:#90949B">=Some(&quot;event 3&quot;)</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) task got shutdown signal
test non_blocking_async_event_loops::test_main_loop ... ok
</pre>

<p>Interesting code links:</p>
<ul>
  <li>Testing async code: <a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/terminal_async/src/readline_impl/readline.rs#L612">https://github.com/r3bl-org/r3bl-open-core/blob/main/terminal_async/src/readline_impl/readline.rs#L612</a></li>
  <li>Using dependency injection and dealing with <code class="language-plaintext highlighter-rouge">dyn T</code> (trait objects): <a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/terminal_async/src/readline_impl/readline.rs#L344">https://github.com/r3bl-org/r3bl-open-core/blob/main/terminal_async/src/readline_impl/readline.rs#L344</a>.</li>
  <li>Event <code class="language-plaintext highlighter-rouge">loop</code>s and breaking out of them (lifecycle control mechanisms):
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/tcp-api-server/src/server_task.rs#L43">https://github.com/nazmulidris/rust-scratch/blob/main/tcp-api-server/src/server_task.rs#L43</a>
and
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/tcp-api-server/src/client_task.rs#L108">https://github.com/nazmulidris/rust-scratch/blob/main/tcp-api-server/src/client_task.rs#L108</a>.</li>
</ul>

<h3 id="parting-thoughts">Parting thoughts</h3>
<p><a id="markdown-parting-thoughts" name="parting-thoughts"></a></p>

<ul>
  <li>Try not to use cancellation token:
<a href="https://docs.rs/tokio-util/latest/tokio_util/sync/struct.CancellationToken.html">https://docs.rs/tokio-util/latest/tokio_util/sync/struct.CancellationToken.html</a>,
instead do this: <a href="https://github.com/nazmulidris/rust-scratch/pull/32">https://github.com/nazmulidris/rust-scratch/pull/32</a> and
<a href="https://github.com/nazmulidris/rust-scratch/commit/e129b0f681dd1eea1bcdd3372cd08a05081922ff">https://github.com/nazmulidris/rust-scratch/commit/e129b0f681dd1eea1bcdd3372cd08a05081922ff</a></li>
  <li>Do not use async or Tokio for underlying sync OS file copy:
<a href="https://users.rust-lang.org/t/tokio-copy-slower-than-std-io-copy/111242">https://users.rust-lang.org/t/tokio-copy-slower-than-std-io-copy/111242</a>.</li>
  <li>Using the right <code class="language-plaintext highlighter-rouge">Mutex</code> in conjunction with <code class="language-plaintext highlighter-rouge">Arc</code> and holding them across await points
from <a href="https://docs.rs/tokio/latest/tokio/sync/struct.Mutex.html#which-kind-of-mutex-should-you-use">tokio
docs</a>.</li>
  <li>Good videos:
    <ul>
      <li><a href="https://www.youtube.com/watch?v=1zOd52_tUWg&amp;t=2088s">Async Rust: the good, the bad, and the ugly - Steve Klabnik</a>.</li>
      <li><a href="https://www.youtube.com/watch?v=04gTQmLETFI">Nicholas Matsakis - Rust 2024 and beyond</a>.</li>
    </ul>
  </li>
</ul>

<h2 id="build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</h2>
<p><a id="markdown-build-with-naz-video-series-on-developerlife.com-youtube-channel" name="build-with-naz-video-series-on-developerlife.com-youtube-channel"></a></p>

<blockquote>
  <p>If you have comments and feedback on this content, or would like to request new content
(articles &amp; videos) on developerlife.com, please join our <a href="https://discord.gg/8M2ePAevaMi">discord
server</a>.</p>
</blockquote>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a></li>
  <li>Playlists
    <ul>
      <li><a href="https://www.youtube.com/watch?v=bolScvh4x7I&amp;list=PLofhE49PEwmw3MKOU1Kn3xbP4FRQR4Mb3">Build with Naz, Linux TTY, process, signals, commands in async Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmza94sS7UmJnN9gSCHTVTfz">Build with Naz, fundamental effective Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmwO69E7eiQ-ewnMME8ydgQ5">Build with Naz, effective async Rust and tokio</a></li>
      <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><summary type="html"><![CDATA[In this article, video, and repo learn effective async Rust using real world patterns that show up consistently when creating non blocking, async, event loops, using channels. Delve into implementing the Future trait and async executor manually. Also explore graceful shutdown, when not to use async, and how to think about testing async code.]]></summary></entry></feed>