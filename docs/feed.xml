<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://developerlife.com/feed.xml" rel="self" type="application/atom+xml" /><link href="http://developerlife.com/" rel="alternate" type="text/html" /><updated>2024-05-27T16:10:38-05:00</updated><id>http://developerlife.com/feed.xml</id><title type="html">developerlife.com</title><subtitle>Rust, TUI, Android, Web, Desktop, Cloud technologies, and UX engineering and design tutorials.</subtitle><author><name>Nazmul Idris</name></author><entry><title type="html">Build with Naz : Linux io_uring and tokio-uring exploration with Rust</title><link href="http://developerlife.com/2024/05/25/tokio-uring-exploration-rust/" rel="alternate" type="text/html" title="Build with Naz : Linux io_uring and tokio-uring exploration with Rust" /><published>2024-05-25T10:00:00-05:00</published><updated>2024-05-25T10:00:00-05:00</updated><id>http://developerlife.com/2024/05/25/tokio-uring-exploration-rust</id><content type="html" xml:base="http://developerlife.com/2024/05/25/tokio-uring-exploration-rust/"><![CDATA[<p><img class="post-hero-image" src="/assets/rust_tokio_uring.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#what-is-linux-io_uring">What is Linux io_uring?</a></li>
  <li><a href="#youtube-video-for-this-article">YouTube video for this article</a></li>
  <li><a href="#examples-of-using-tokio-uring-in-rust">Examples of using tokio-uring in Rust</a>
    <ul>
      <li><a href="#example-1-read-a-file-using-tokio-uring-and-async-non-blocking-io">Example 1: Read a file using tokio-uring and async, non-blocking IO</a></li>
      <li><a href="#example-2-building-a-tcp-echo-server-using-tokio-uring-that-also-uses-tokio">Example 2: Building a TCP echo server using tokio-uring that also uses tokio</a></li>
      <li><a href="#parting-thoughts">Parting thoughts</a></li>
    </ul>
  </li>
  <li><a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</a></li>
</ul>

<!-- /TOC -->

<h2 id="what-is-linux-io_uring">What is Linux io_uring?</h2>
<p><a id="markdown-what-is-linux-io_uring%3F" name="what-is-linux-io_uring%3F"></a></p>

<p>When using async Rust and <code class="language-plaintext highlighter-rouge">tokio</code>, you don’t get async file IO at the OS level. Here are
links from the official docs that discourage using <code class="language-plaintext highlighter-rouge">tokio</code> for file IO:</p>
<ul>
  <li><a href="https://tokio.rs/tokio/tutorial">Tokio tutorial, when not to use Tokio</a>.</li>
  <li><a href="https://users.rust-lang.org/t/tokio-copy-slower-than-std-io-copy/111242">Tokio::io::copy slower than std
io::copy</a>.</li>
</ul>

<p>This is because <code class="language-plaintext highlighter-rouge">tokio</code> uses the <code class="language-plaintext highlighter-rouge">mio</code> crate, which uses <code class="language-plaintext highlighter-rouge">epoll</code> on Linux. These are not
the most efficient ways to do async IO on Linux. The most efficient way to do async IO on
Linux is to use the <code class="language-plaintext highlighter-rouge">io_uring</code> syscall. This is a new syscall that was added to the Linux
kernel in version 5.1. It is a more efficient way to do async IO on Linux, and is used by
the <code class="language-plaintext highlighter-rouge">tokio-uring</code> crate. Here are some great links to learn more about <code class="language-plaintext highlighter-rouge">io_uring</code>:</p>
<ul>
  <li><a href="https://unixism.net/loti/what_is_io_uring.html#the-io-uring-interface">io_uring mental
model</a>.</li>
  <li><a href="https://www.scylladb.com/2020/05/05/how-io_uring-and-ebpf-will-revolutionize-programming-in-linux/0/">How io_uring and eBPF Will Revolutionize Programming in
Linux</a>.</li>
  <li><a href="https://lore.kernel.org/io-uring/4af91b50-4a9c-8a16-9470-a51430bd7733@kernel.dk/T/#u">io_uring and Intel Optane
stats</a>.</li>
  <li><a href="https://tokio.rs/blog/2021-07-tokio-uring">Announcing io_uring support for Tokio -
tokio-uring</a>.</li>
</ul>

<p>In this article, we will explore how to use <code class="language-plaintext highlighter-rouge">tokio-uring</code> to do async file IO at the OS
level, and how to use it to build a simple echo TCP server, for use with <code class="language-plaintext highlighter-rouge">netcat</code>.</p>

<h2 id="youtube-video-for-this-article">YouTube video for this article</h2>
<p><a id="markdown-youtube-video-for-this-article" name="youtube-video-for-this-article"></a></p>

<p>This blog post has short examples on how to use the <code class="language-plaintext highlighter-rouge">tokio-uring</code> crate. If you like to
learn via video, please watch the companion video on the <a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube
channel</a>.</p>

<!-- rust tokio-uring exploration & async rust playlist -->
<iframe src="https://www.youtube.com/embed/VKL52XmY6Os?si=RgUKu-CZSXvKpJ7M" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<p><br /></p>

<h2 id="examples-of-using-tokio-uring-in-rust">Examples of using tokio-uring in Rust</h2>
<p><a id="markdown-examples-of-using-tokio-uring-in-rust" name="examples-of-using-tokio-uring-in-rust"></a></p>

<p>Let’s create some examples to illustrate how to use <code class="language-plaintext highlighter-rouge">tokio-uring</code>. You can run
<code class="language-plaintext highlighter-rouge">cargo new --bin tokio-uring</code> to create a new binary crate.</p>

<blockquote>
  <p>The code in the video and this tutorial are all in <a href="https://github.com/nazmulidris/rust-scratch/tree/main/tokio-uring">this GitHub
repo</a>.</p>
</blockquote>

<p>Then add the following to the <code class="language-plaintext highlighter-rouge">Cargo.toml</code> file that’s generated. These pull in all the
dependencies that we need for these examples.</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[package]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"tokio-uring"</span>
<span class="py">version</span> <span class="p">=</span> <span class="s">"0.1.0"</span>
<span class="py">edition</span> <span class="p">=</span> <span class="s">"2021"</span>

<span class="nn">[[bin]]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"readfile"</span>
<span class="py">path</span> <span class="p">=</span> <span class="s">"src/readfile.rs"</span>

<span class="nn">[[bin]]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"socketserver"</span>
<span class="py">path</span> <span class="p">=</span> <span class="s">"src/socketserver.rs"</span>

<span class="nn">[dependencies]</span>
<span class="py">tokio-uring</span> <span class="p">=</span> <span class="s">"0.4.0"</span>
<span class="py">tokio</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"1.37.0"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"full"</span><span class="p">,</span> <span class="s">"tracing"</span><span class="p">]</span> <span class="p">}</span>
<span class="py">tokio-util</span> <span class="p">=</span> <span class="s">"0.7.11"</span>
<span class="py">tracing</span> <span class="p">=</span> <span class="s">"0.1.40"</span>
<span class="py">tracing-subscriber</span> <span class="p">=</span> <span class="s">"0.3.18"</span>

<span class="py">ctrlc</span> <span class="p">=</span> <span class="s">"3.4.4"</span>
<span class="py">miette</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"7.2.0"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"fancy"</span><span class="p">]</span> <span class="p">}</span>

<span class="py">crossterm</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.27.0"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"event-stream"</span><span class="p">]</span> <span class="p">}</span>

<span class="py">r3bl_terminal_async</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.5.3"</span> <span class="p">}</span>
</code></pre></div></div>

<h3 id="example-1-read-a-file-using-tokio-uring-and-async-non-blocking-io">Example 1: Read a file using tokio-uring and async, non-blocking IO</h3>
<p><a id="markdown-example-1%3A-read-a-file-using-tokio-uring-and-async%2C-non-blocking-io" name="example-1%3A-read-a-file-using-tokio-uring-and-async%2C-non-blocking-io"></a></p>

<p>Then you can add the following code to the <code class="language-plaintext highlighter-rouge">src/readfile.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">crossterm</span><span class="p">::</span><span class="nn">style</span><span class="p">::</span><span class="n">Stylize</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">miette</span><span class="p">::</span><span class="n">IntoDiagnostic</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">path</span><span class="p">::</span><span class="n">Path</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nn">tokio_uring</span><span class="p">::</span><span class="nf">start</span><span class="p">(</span><span class="nf">read_file</span><span class="p">(</span><span class="s">"Cargo.toml"</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">async</span> <span class="k">fn</span> <span class="nf">read_file</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="k">impl</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">file</span> <span class="o">=</span> <span class="nn">tokio_uring</span><span class="p">::</span><span class="nn">fs</span><span class="p">::</span><span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="k">.await</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">buf_move</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">4096</span><span class="p">];</span>

    <span class="c1">// Read some data, the buffer is passed by ownership and submitted</span>
    <span class="c1">// to the kernel. When the operation completes, we get the buffer</span>
    <span class="c1">// back.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">buf_from_kernel</span><span class="p">)</span> <span class="o">=</span> <span class="n">file</span><span class="nf">.read_at</span><span class="p">(</span><span class="n">buf_move</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">bytes_read</span> <span class="o">=</span> <span class="n">result</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"{}"</span><span class="p">,</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"Read {} bytes"</span><span class="p">,</span> <span class="n">bytes_read</span><span class="p">)</span>
            <span class="nf">.yellow</span><span class="p">()</span>
            <span class="nf">.underlined</span><span class="p">()</span>
            <span class="nf">.bold</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"{}</span><span class="se">\n</span><span class="s">{}"</span><span class="p">,</span>
        <span class="s">"Data (bytes):"</span><span class="nf">.yellow</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">(),</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf_from_kernel</span><span class="p">[</span><span class="o">..</span><span class="n">bytes_read</span><span class="p">])</span>
            <span class="nf">.blue</span><span class="p">()</span>
            <span class="nf">.bold</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"{}</span><span class="se">\n</span><span class="s">{}"</span><span class="p">,</span>
        <span class="s">"Data (string):"</span><span class="nf">.yellow</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span><span class="nf">.underlined</span><span class="p">(),</span>
        <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_lossy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf_from_kernel</span><span class="p">[</span><span class="o">..</span><span class="n">bytes_read</span><span class="p">])</span>
            <span class="nf">.cyan</span><span class="p">()</span>
            <span class="nf">.bold</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>The code for this example is
<a href="https://github.com/nazmulidris/rust-scratch/tree/main/tokio-uring/src/readfile.rs">here</a>.</p>
</blockquote>

<p>The main things to note about this code.</p>

<ul>
  <li>We use the <code class="language-plaintext highlighter-rouge">tokio_uring::fs::File</code> struct to open a file.</li>
  <li>We use the <code class="language-plaintext highlighter-rouge">read_at</code> method to read from the file at a specific offset. The buffer is
passed by ownership to the kernel, and when the operation completes, we get the buffer
back. This is different than how it works with <code class="language-plaintext highlighter-rouge">tokio</code> and <code class="language-plaintext highlighter-rouge">std</code>.</li>
  <li>We print out the bytes that were read from the file, and the string representation of
those bytes.</li>
</ul>

<p>When you run this code (using <code class="language-plaintext highlighter-rouge">cargo run --bin readfile</code>), it should produce the following
output:</p>

<pre class="pre-manual-highlight">
<span style="color:#81A1C1"><u style="text-decoration-style:single">read file using tokio_uring: </u></span><span style="color:#BF616A"><u style="text-decoration-style:single"><b>Cargo.toml</b></u></span>
<span style="color:#81A1C1"><u style="text-decoration-style:single">read </u></span><span style="color:#EBCB8B"><u style="text-decoration-style:single"><b>604</b></u></span> bytes from file
<span style="color:#A3BE8C">file contents: [package]</span>
<span style="color:#A3BE8C">name = &quot;tokio-uring&quot;</span>
<span style="color:#A3BE8C">version = &quot;0.1.0&quot;</span>
<span style="color:#A3BE8C">edition = &quot;2021&quot;</span>

<span style="color:#A3BE8C">[[bin]]</span>
<span style="color:#A3BE8C">name = &quot;readfile&quot;</span>
<span style="color:#A3BE8C">path = &quot;src/readfile.rs&quot;</span>

<span style="color:#A3BE8C">[[bin]]</span>
<span style="color:#A3BE8C">name = &quot;socketserver&quot;</span>
<span style="color:#A3BE8C">path = &quot;src/socketserver.rs&quot;</span>

<span style="color:#A3BE8C">[dependencies]</span>
<span style="color:#A3BE8C">tokio-uring = &quot;0.4.0&quot;</span>
<span style="color:#A3BE8C">tokio = { version = &quot;1.37.0&quot;, features = [&quot;full&quot;, &quot;tracing&quot;] }</span>
<span style="color:#A3BE8C">tokio-util = &quot;0.7.11&quot;</span>
<span style="color:#A3BE8C">tracing = &quot;0.1.40&quot;</span>
<span style="color:#A3BE8C">tracing-subscriber = &quot;0.3.18&quot;</span>

<span style="color:#A3BE8C">ctrlc = &quot;3.4.4&quot;</span>

<span style="color:#A3BE8C">miette = { version = &quot;7.2.0&quot;, features = [&quot;fancy&quot;] }</span>

<span style="color:#A3BE8C">crossterm = { version = &quot;0.27.0&quot;, features = [&quot;event-stream&quot;] }</span>

<span style="color:#A3BE8C">r3bl_terminal_async = { version = &quot;0.5.3&quot; }</span>
<span style="color:#A3BE8C"># r3bl_terminal_async = { path = &quot;../../r3bl-open-core/terminal_async&quot; }</span>
</pre>

<h3 id="example-2-building-a-tcp-echo-server-using-tokio-uring-that-also-uses-tokio">Example 2: Building a TCP echo server using tokio-uring that also uses tokio</h3>
<p><a id="markdown-example-2%3A-building-a-tcp-echo-server-using-tokio-uring-that-also-uses-tokio" name="example-2%3A-building-a-tcp-echo-server-using-tokio-uring-that-also-uses-tokio"></a></p>

<p>For this example, let’s add the following code to the <code class="language-plaintext highlighter-rouge">src/socketserver.rs</code> file.</p>
<ul>
  <li>This will simply add the required imports to <code class="language-plaintext highlighter-rouge">tokio_uring</code> for <code class="language-plaintext highlighter-rouge">TcpListener</code> and
<code class="language-plaintext highlighter-rouge">TcpStream</code>.</li>
  <li>And we will also configure the <code class="language-plaintext highlighter-rouge">tracing_subscriber</code> to use the formatted subscriber, so
that we get pretty printed log output to stdout and we have information about what thread
generated that log event.</li>
  <li>We use the <code class="language-plaintext highlighter-rouge">tokio_uring::start</code> function to spawn the runtime. This runtime isn’t the
same as the one that we get from using <code class="language-plaintext highlighter-rouge">#[tokio::main]</code> and later in this example, we
will see how we can handle both.</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">crossterm</span><span class="p">::</span><span class="nn">style</span><span class="p">::</span><span class="n">Stylize</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">miette</span><span class="p">::</span><span class="n">IntoDiagnostic</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">r3bl_terminal_async</span><span class="p">::</span><span class="n">port_availability</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">net</span><span class="p">::</span><span class="n">SocketAddr</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">task</span><span class="p">::</span><span class="n">AbortHandle</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">tokio_uring</span><span class="p">::{</span>
    <span class="nn">buf</span><span class="p">::</span><span class="n">IoBuf</span><span class="p">,</span>
    <span class="nn">net</span><span class="p">::{</span><span class="n">TcpListener</span><span class="p">,</span> <span class="n">TcpStream</span><span class="p">},</span>
<span class="p">};</span>
<span class="k">use</span> <span class="nn">tokio_util</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="n">CancellationToken</span><span class="p">;</span>

<span class="cd">/// Run `netcat localhost:8080` to test this server (once you run this main function).</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Register tracing subscriber.</span>
    <span class="nn">tracing_subscriber</span><span class="p">::</span><span class="nf">fmt</span><span class="p">()</span>
        <span class="nf">.without_time</span><span class="p">()</span>
        <span class="nf">.compact</span><span class="p">()</span>
        <span class="nf">.with_target</span><span class="p">(</span><span class="k">false</span><span class="p">)</span>
        <span class="nf">.with_line_number</span><span class="p">(</span><span class="k">false</span><span class="p">)</span>
        <span class="nf">.with_thread_ids</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
        <span class="nf">.with_thread_names</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
        <span class="nf">.init</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">cancellation_token</span> <span class="o">=</span> <span class="nn">CancellationToken</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="c1">// TODO: Add ctrlc handler.</span>

    <span class="c1">// TODO: Add code to use the `tokio` runtime and run some futures on it.</span>

    <span class="nn">tokio_uring</span><span class="p">::</span><span class="nf">start</span><span class="p">(</span><span class="nf">start_server</span><span class="p">(</span><span class="n">cancellation_token</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>You can get the source code for this example
<a href="https://github.com/nazmulidris/rust-scratch/tree/main/tokio-uring/src/socketserver.rs">here</a>.</p>
</blockquote>

<p>Next, we will add the code to handle the server logic. The following code handles the
incoming connections (using <code class="language-plaintext highlighter-rouge">tokio_uring</code> structs). This code is very similar to what we
would write if we were using <code class="language-plaintext highlighter-rouge">tokio</code> directly.</p>

<ul>
  <li>The main difference is that we are checking for port availability before binding to the
address, and we are using <code class="language-plaintext highlighter-rouge">tokio_uring::spawn</code> to spawn the futures, to handle incoming
connections.</li>
  <li>We will also use <code class="language-plaintext highlighter-rouge">tokio::select!</code> to create the main event loop. Since <code class="language-plaintext highlighter-rouge">tokio_uring</code> is
in the same family as <code class="language-plaintext highlighter-rouge">tokio</code>, we can do that!</li>
  <li>The <code class="language-plaintext highlighter-rouge">port_availability</code> module comes from <code class="language-plaintext highlighter-rouge">r3bl_terminal_async</code> crate, which is a
dependency in the <code class="language-plaintext highlighter-rouge">Cargo.toml</code> file. It allows us to check whether a port is available
or not, and find a free port in a given port range.</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">fn</span> <span class="nf">start_server</span><span class="p">(</span><span class="n">cancellation_token</span><span class="p">:</span> <span class="n">CancellationToken</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">tcp_listener</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">addr</span><span class="p">:</span> <span class="n">SocketAddr</span> <span class="o">=</span> <span class="s">"0.0.0.0:8080"</span><span class="nf">.parse</span><span class="p">()</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
        <span class="c1">// You can bind to the same address repeatedly, and it won't return</span>
        <span class="c1">// an error! Might have to check to see whether the port is open or</span>
        <span class="c1">// not before binding to it!</span>
        <span class="k">match</span> <span class="nn">port_availability</span><span class="p">::</span><span class="nf">check</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span> <span class="p">{</span>
            <span class="nn">port_availability</span><span class="p">::</span><span class="nn">Status</span><span class="p">::</span><span class="n">Free</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"Port {} is available"</span><span class="p">,</span> <span class="n">addr</span><span class="nf">.port</span><span class="p">());</span>
            <span class="p">}</span>
            <span class="nn">port_availability</span><span class="p">::</span><span class="nn">Status</span><span class="p">::</span><span class="n">Occupied</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span>
                    <span class="s">"Port {} is NOT available, can't bind to it"</span><span class="p">,</span>
                    <span class="n">addr</span><span class="nf">.port</span><span class="p">()</span>
                <span class="p">);</span>
                <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">miette</span><span class="p">::</span><span class="nd">miette!</span><span class="p">(</span>
                    <span class="s">"Port {} is NOT available, can't bind to it"</span><span class="p">,</span>
                    <span class="n">addr</span><span class="nf">.port</span><span class="p">()</span>
                <span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nn">TcpListener</span><span class="p">::</span><span class="nf">bind</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span>
    <span class="p">};</span>

    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"server - started"</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.red</span><span class="p">()</span><span class="nf">.bold</span><span class="p">());</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">abort_handles</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">AbortHandle</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span> <span class="p">{</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">cancellation_token</span><span class="nf">.cancelled</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">abort_handles</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.for_each</span><span class="p">(|</span><span class="n">handle</span><span class="p">|</span> <span class="n">handle</span><span class="nf">.abort</span><span class="p">());</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">it</span> <span class="o">=</span> <span class="n">tcp_listener</span><span class="nf">.accept</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">tcp_stream</span><span class="p">,</span> <span class="n">_addr</span><span class="p">)</span> <span class="o">=</span> <span class="n">it</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
                <span class="k">let</span> <span class="n">join_handle</span> <span class="o">=</span> <span class="nn">tokio_uring</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span>
                    <span class="nf">handle_connection</span><span class="p">(</span><span class="n">tcp_stream</span><span class="p">)</span>
                <span class="p">);</span>
                <span class="n">abort_handles</span><span class="nf">.push</span><span class="p">(</span><span class="n">join_handle</span><span class="nf">.abort_handle</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"server - stopped"</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.red</span><span class="p">()</span><span class="nf">.bold</span><span class="p">());</span>
    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Add the following code to handle the echo logic. This code reads from the stream using
<code class="language-plaintext highlighter-rouge">tokio_uring</code> and its function signature is quite different from what we would write if we
were using <code class="language-plaintext highlighter-rouge">tokio</code> directly. It is similar to what happens with <code class="language-plaintext highlighter-rouge">read_at</code> in the previous
example, and it moves ownership to <code class="language-plaintext highlighter-rouge">read</code>. Which returns a tuple:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">Result</code> containing the number of bytes read.</li>
  <li>Buffer that was passed from the kernel.</li>
</ol>

<p>The <code class="language-plaintext highlighter-rouge">write_all</code> function also returns a tuple that is similar.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">fn</span> <span class="nf">handle_connection</span><span class="p">(</span><span class="n">stream</span><span class="p">:</span> <span class="n">TcpStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"handle_connection - start"</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">total_bytes_read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">buf</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0u8</span><span class="p">;</span> <span class="mi">10</span><span class="p">];</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="c1">// Read from the stream.</span>
        <span class="c1">// Read some data, the buffer is passed by ownership and submitted</span>
        <span class="c1">// to the kernel. When the operation completes, we get the buffer</span>
        <span class="c1">// back.</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">result_num_bytes_read</span><span class="p">,</span> <span class="n">return_buf</span><span class="p">)</span> <span class="o">=</span> <span class="n">stream</span><span class="nf">.read</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="n">return_buf</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">num_bytes_read</span> <span class="o">=</span> <span class="n">result_num_bytes_read</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

        <span class="c1">// Check for EOF.</span>
        <span class="k">if</span> <span class="n">num_bytes_read</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Write to the stream.</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">result_num_bytes_written</span><span class="p">,</span> <span class="n">slice</span><span class="p">)</span> <span class="o">=</span>
            <span class="n">stream</span><span class="nf">.write_all</span><span class="p">(</span><span class="n">buf</span><span class="nf">.slice</span><span class="p">(</span><span class="o">..</span><span class="n">num_bytes_read</span><span class="p">))</span><span class="k">.await</span><span class="p">;</span>
        <span class="n">result_num_bytes_written</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span> <span class="c1">// Make sure no errors.</span>

        <span class="c1">// Update the buffer.</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="n">slice</span><span class="nf">.into_inner</span><span class="p">();</span>
        <span class="n">total_bytes_read</span> <span class="o">+=</span> <span class="n">num_bytes_read</span><span class="p">;</span>

        <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span>
            <span class="s">"{}: {}"</span><span class="p">,</span>
            <span class="s">"handle_connection - num_bytes_read"</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.red</span><span class="p">(),</span>
            <span class="n">num_bytes_read</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span>
        <span class="s">"handle_connection - end, total_bytes_read: {}"</span><span class="p">,</span>
        <span class="n">total_bytes_read</span>
    <span class="p">);</span>
    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To test this, you can run the server using <code class="language-plaintext highlighter-rouge">cargo run --bin socketserver</code>. Then you can
connect to the server using <code class="language-plaintext highlighter-rouge">netcat</code> (or <code class="language-plaintext highlighter-rouge">nc</code>) by running <code class="language-plaintext highlighter-rouge">netcat localhost 8080</code>. You can
type some text and hit enter, and you should see the text echoed back to you.</p>

<p>This is what the output from <code class="language-plaintext highlighter-rouge">netcat</code> might look like:</p>

<pre class="pre-manual-highlight">netcat localhost 8080
echo echo echo
echo echo echo
</pre>

<p>This is what the output from the server might look like:</p>

<pre class="pre-manual-highlight"> cargo run --bin socketserver
<span style="color:#A3BE8C"> INFO</span> main ThreadId(01) Port is available
<span style="color:#A3BE8C"> INFO</span> main ThreadId(01) <span style="color:#BF616A"><b>server - started</b></span> - 0.0.0.0:8080
<span style="color:#A3BE8C"> INFO</span> main ThreadId(01) <span style="color:#BF616A"><b>handle_connection - start</b></span>
<span style="color:#A3BE8C"> INFO</span> main ThreadId(01) <span style="color:#BF616A">handle_connection - num_bytes_read</span>: 10
<span style="color:#A3BE8C"> INFO</span> main ThreadId(01) <span style="color:#BF616A">handle_connection - num_bytes_read</span>: 5
<span style="color:#A3BE8C"> INFO</span> main ThreadId(01) <span style="color:#BF616A"><b>handle_connection - end, total bytes read</b></span> : 15 bytes
</pre>

<p>There are two more bonus rounds that we can add to this example:</p>
<ol>
  <li>Add a <code class="language-plaintext highlighter-rouge">ctrlc</code> handler to gracefully shutdown the server, when the user types
<kbd>Ctrl+C</kbd>.</li>
  <li>Add code to use the <code class="language-plaintext highlighter-rouge">tokio</code> runtime and run some futures on it.</li>
</ol>

<p>In the <code class="language-plaintext highlighter-rouge">socketserver.rs</code> file, you can add the following code to replace
the comment <kbd>//TODO: Add ctrlc handler.</kbd>.
The following code will add a <code class="language-plaintext highlighter-rouge">ctrlc</code> handler to gracefully
shutdown the server, by cancelling the <code class="language-plaintext highlighter-rouge">cancellation_token</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">cancellation_token_clone</span> <span class="o">=</span> <span class="n">cancellation_token</span><span class="nf">.clone</span><span class="p">();</span>
<span class="nn">ctrlc</span><span class="p">::</span><span class="nf">set_handler</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"Received Ctrl+C!"</span><span class="p">);</span>
    <span class="n">cancellation_token_clone</span><span class="nf">.cancel</span><span class="p">();</span>
<span class="p">})</span>
<span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
</code></pre></div></div>

<p>And finally, the following code will replace the comment <kbd>// TODO: Add code to use the `tokio` runtime and run some futures on it.</kbd>.
This code will spawn a new OS thread (using <code class="language-plaintext highlighter-rouge">std</code>) and then create a new multi-threaded
<code class="language-plaintext highlighter-rouge">tokio</code> runtime on that thread. We will then run some futures on that runtime by passing an async
block to the <code class="language-plaintext highlighter-rouge">block_on</code> function of the runtime.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Can't use #[tokio::main] for `main()`, so we have to use the</span>
<span class="c1">// `tokio::runtime::Builder` API. However, we have to launch this in a separate</span>
<span class="c1">// thread, because we don't want it to collide with the `tokio_uring::start()`</span>
<span class="c1">// call.</span>
<span class="k">let</span> <span class="n">cancellation_token_clone</span> <span class="o">=</span> <span class="n">cancellation_token</span><span class="nf">.clone</span><span class="p">();</span>
<span class="nn">std</span><span class="p">::</span><span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
    <span class="c1">// If you use `Builder::new_current_thread()`, the runtime will</span>
    <span class="c1">// use the single / current thread scheduler.</span>
    <span class="c1">// `Builder::new_multi_thread()` will use a thread pool.</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nn">runtime</span><span class="p">::</span><span class="nn">Builder</span><span class="p">::</span><span class="nf">new_multi_thread</span><span class="p">()</span>
        <span class="nf">.enable_all</span><span class="p">()</span>
        <span class="nf">.worker_threads</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="nf">.build</span><span class="p">()</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span>
        <span class="nf">.unwrap</span><span class="p">()</span>
        <span class="nf">.block_on</span><span class="p">(</span><span class="nf">async_main</span><span class="p">(</span><span class="n">cancellation_token_clone</span><span class="p">))</span>
<span class="p">});</span>
</code></pre></div></div>

<p>Here’s the <code class="language-plaintext highlighter-rouge">async_main</code> function that we are calling in the code above. This function
simply runs some futures on the <code class="language-plaintext highlighter-rouge">tokio</code> runtime that we created in the code above. You can
see from the log output that the tasks are run in parallel (sometimes on the same thread
and sometimes on different threads), and are scheduled in a non-deterministic order.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">fn</span> <span class="nf">async_main</span><span class="p">(</span><span class="n">cancellation_token</span><span class="p">:</span> <span class="n">CancellationToken</span><span class="p">)</span> <span class="p">{</span>
    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"async_main - start"</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.magenta</span><span class="p">()</span><span class="nf">.bold</span><span class="p">());</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">interval</span> <span class="o">=</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">interval</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">2_500</span><span class="p">));</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span> <span class="p">{</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">interval</span><span class="nf">.tick</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span>
                    <span class="s">"{}"</span><span class="p">,</span>
                    <span class="s">"async_main - tick"</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.magenta</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span>
                    <span class="p">);</span>

                <span class="c1">// Notice in the output, that these tasks are NOT spawned</span>
                <span class="c1">// in the same order repeatedly. They are run in parallel</span>
                <span class="c1">// on different threads. And these are scheduled in a</span>
                <span class="c1">// non-deterministic order.</span>
                <span class="k">let</span> <span class="n">task_1</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="p">{</span>
                    <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span>
                        <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
                    <span class="p">)</span><span class="k">.await</span><span class="p">;</span>
                    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"async_main - tick {} - spawn"</span><span class="p">,</span> <span class="s">"#1"</span>
                        <span class="nf">.to_string</span><span class="p">()</span><span class="nf">.on_green</span><span class="p">()</span><span class="nf">.black</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span>
                    <span class="p">);</span>
                <span class="p">});</span>
                <span class="k">let</span> <span class="n">task_2</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="p">{</span>
                    <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span>
                        <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
                    <span class="p">)</span><span class="k">.await</span><span class="p">;</span>
                    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"async_main - tick {} - spawn"</span><span class="p">,</span> <span class="s">"#2"</span>
                        <span class="nf">.to_string</span><span class="p">()</span><span class="nf">.on_red</span><span class="p">()</span><span class="nf">.black</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span>
                    <span class="p">);</span>
                <span class="p">});</span>
                <span class="k">let</span> <span class="n">task_3</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="p">{</span>
                    <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span>
                        <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
                    <span class="p">)</span><span class="k">.await</span><span class="p">;</span>
                    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"async_main - tick {} - spawn"</span><span class="p">,</span> <span class="s">"#3"</span>
                        <span class="nf">.to_string</span><span class="p">()</span><span class="nf">.on_blue</span><span class="p">()</span><span class="nf">.black</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span>
                    <span class="p">);</span>
                <span class="p">});</span>
                <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nd">join!</span><span class="p">(</span><span class="n">task_1</span><span class="p">,</span> <span class="n">task_2</span><span class="p">,</span> <span class="n">task_3</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">cancellation_token</span><span class="nf">.cancelled</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"async_main - cancelled"</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"async_main - end"</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.magenta</span><span class="p">()</span><span class="nf">.bold</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here’s what the output from the server might look like, after adding the <code class="language-plaintext highlighter-rouge">ctrlc</code> handler and
the <code class="language-plaintext highlighter-rouge">tokio</code> runtime code and running it for about 10 seconds.</p>

<pre class="pre-manual-highlight"> cargo run --bin socketserver
<span style="color:#A3BE8C"> INFO</span> main ThreadId(01) Port is available
<span style="color:#A3BE8C"> INFO</span> ThreadId(03) <span style="color:#B48EAD"><b>async_main - start</b></span>
<span style="color:#A3BE8C"> INFO</span> main ThreadId(01) <span style="color:#BF616A"><b>server - started</b></span> - 0.0.0.0:8080
<span style="color:#A3BE8C"> INFO</span> ThreadId(03) <span style="color:#B48EAD"><b>async_main - tick</b></span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(04) async_main - tick <span style="background-color:#81A1C1"><span style="color:#3B4252"><b>#3</b></span></span> - spawn
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(06) async_main - tick <span style="background-color:#BF616A"><span style="color:#3B4252"><b>#2</b></span></span> - spawn
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) async_main - tick <span style="background-color:#A3BE8C"><span style="color:#3B4252"><b>#1</b></span></span> - spawn
<span style="color:#A3BE8C"> INFO</span> ThreadId(03) <span style="color:#B48EAD"><b>async_main - tick</b></span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(06) async_main - tick <span style="background-color:#BF616A"><span style="color:#3B4252"><b>#2</b></span></span> - spawn
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) async_main - tick <span style="background-color:#A3BE8C"><span style="color:#3B4252"><b>#1</b></span></span> - spawn
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(04) async_main - tick <span style="background-color:#81A1C1"><span style="color:#3B4252"><b>#3</b></span></span> - spawn
<span style="color:#A3BE8C"> INFO</span> ThreadId(03) <span style="color:#B48EAD"><b>async_main - tick</b></span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(06) async_main - tick <span style="background-color:#81A1C1"><span style="color:#3B4252"><b>#3</b></span></span> - spawn
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) async_main - tick <span style="background-color:#A3BE8C"><span style="color:#3B4252"><b>#1</b></span></span> - spawn
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(04) async_main - tick <span style="background-color:#BF616A"><span style="color:#3B4252"><b>#2</b></span></span> - spawn
<span style="color:#A3BE8C"> INFO</span> ThreadId(03) <span style="color:#B48EAD"><b>async_main - tick</b></span>
</pre>

<h3 id="parting-thoughts">Parting thoughts</h3>
<p><a id="markdown-parting-thoughts" name="parting-thoughts"></a></p>

<p>There are areas of improvement in this codebase, such as port binding issues, and
connection management issues.</p>
<ol>
  <li>If you run more than one instance of the process <code class="language-plaintext highlighter-rouge">cargo run --bin startserver</code> then the
log output is pretty strange. The 2nd process that’s started seems to trigger the
<code class="language-plaintext highlighter-rouge">handle_connection</code> function of the first process.</li>
  <li>When you run the server and connect a client to it using <code class="language-plaintext highlighter-rouge">netcat</code>, and then kill the
server process, using <kbd>Ctrl+C</kbd>, the client doesn’t drop the connection.</li>
</ol>

<p>If you can figure out how to fix these issues, please raise a PR on the <a href="https://github.com/nazmulidris/rust-scratch/issues">GitHub
repo</a>. I’d love to see how you solve
these problems!</p>

<h2 id="build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</h2>
<p><a id="markdown-build-with-naz-video-series-on-developerlife.com-youtube-channel" name="build-with-naz-video-series-on-developerlife.com-youtube-channel"></a></p>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a></li>
  <li>Playlists
    <ul>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmwO69E7eiQ-ewnMME8ydgQ5">Build with Naz, effective async Rust and tokio</a></li>
      <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><summary type="html"><![CDATA[Explore the Linux io_uring syscall with the tokio-uring crate in Rust. This article and video will show you how to use the tokio-uring do async file IO at the OS level, and how to use it to build a simple echo TCP server, for use with netcat.]]></summary></entry><entry><title type="html">Build with Naz : Rust async, non-blocking, concurrent, parallel, event loops, cancellation safety</title><link href="http://developerlife.com/2024/05/19/effective-async-rust/" rel="alternate" type="text/html" title="Build with Naz : Rust async, non-blocking, concurrent, parallel, event loops, cancellation safety" /><published>2024-05-19T10:00:00-05:00</published><updated>2024-05-19T10:00:00-05:00</updated><id>http://developerlife.com/2024/05/19/effective-async-rust</id><content type="html" xml:base="http://developerlife.com/2024/05/19/effective-async-rust/"><![CDATA[<p><img class="post-hero-image" src="/assets/rust_async_event_loops.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#what-is-async-rust-sequential-vs-concurrent-code--parallelism-as-a-resource">What is async Rust? Sequential vs concurrent code &amp; parallelism as a resource</a></li>
  <li><a href="#what-async-rust-is-not">What async Rust is not</a></li>
  <li><a href="#youtube-video-for-this-article">YouTube video for this article</a></li>
  <li><a href="#effective-async-rust-patterns-by-example">Effective async Rust patterns by example</a>
    <ul>
      <li><a href="#example-1-build-a-timer-future-using-waker">Example 1: Build a timer future using Waker</a></li>
      <li><a href="#example-2-build-an-async-runtime-to-run-futures-to-completion">Example 2: Build an async runtime to run futures to completion</a></li>
      <li><a href="#example-3-running-async-code-concurrently-on-a-single-thread">Example 3: Running async code, concurrently, on a single thread</a></li>
      <li><a href="#example-4-join-select-spawn-control-flow-constructors">Example 4: join!, select, spawn control flow constructors</a></li>
      <li><a href="#example-5-async-streams">Example 5: async streams</a></li>
      <li><a href="#example-6-non-blocking-event-loops-channel-safety-and-safe-cancellation">Example 6: Non-blocking event loops, channel safety, and safe cancellation</a></li>
      <li><a href="#parting-thoughts">Parting thoughts</a></li>
    </ul>
  </li>
  <li><a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</a></li>
</ul>

<!-- /TOC -->

<h2 id="what-is-async-rust-sequential-vs-concurrent-code--parallelism-as-a-resource">What is async Rust? Sequential vs concurrent code &amp; parallelism as a resource</h2>
<p><a id="markdown-what-is-async-rust%3F-sequential-vs-concurrent-code-%26-parallelism-as-a-resource" name="what-is-async-rust%3F-sequential-vs-concurrent-code-%26-parallelism-as-a-resource"></a></p>

<p>In Rust, you can write sequential code, and concurrent code:</p>
<ul>
  <li>Sequential code can be run sequentially, or in parallel (using <code class="language-plaintext highlighter-rouge">thread::spawn()</code>).</li>
  <li>Concurrent code can be run on a single thread or multiple threads.</li>
</ul>

<p>Concurrency is a way to structure code into separate tasks. This does not define the
resources on a machine that will be used to run or execute tasks.</p>

<p>Parallelism is a way to specify what resources (CPU cores, or threads) will be used on a
machine’s operating system to run tasks.</p>

<p>These 2 concepts are not the same. They are related but not the same.</p>

<h2 id="what-async-rust-is-not">What async Rust is not</h2>
<p><a id="markdown-what-async-rust-is-not" name="what-async-rust-is-not"></a></p>

<p>Generally speaking, using async Rust is not just a matter of attaching <code class="language-plaintext highlighter-rouge">async</code> as a prefix
to a function, when you define it, and postfix <code class="language-plaintext highlighter-rouge">.await</code> when you call it. In fact, if you
don’t have at least one <code class="language-plaintext highlighter-rouge">.await</code> in your async function body, then it <a href="https://ryhl.io/blog/async-what-is-blocking/">might not need to
be async</a>. This article and video are a deep
dive into what async code is, what Rust <code class="language-plaintext highlighter-rouge">Future</code>s are, along with what async Runtimes are.
Along with some common patterns and anti-patterns when thinking in async Rust.</p>

<h2 id="youtube-video-for-this-article">YouTube video for this article</h2>
<p><a id="markdown-youtube-video-for-this-article" name="youtube-video-for-this-article"></a></p>

<p>This blog post only has short examples on how to use Rust async effectively. To see how
these ideas can be used in production code, with real-world examples, please watch the
following video on the <a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube
channel</a>.</p>

<!-- rust tokio tracing and otel for async rust & playlist -->
<iframe src="https://www.youtube.com/embed/qvIt8MF-pCM?si=S40pbhnvVDAohj-6" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<p><br /></p>

<h2 id="effective-async-rust-patterns-by-example">Effective async Rust patterns by example</h2>
<p><a id="markdown-effective-async-rust-patterns-by-example" name="effective-async-rust-patterns-by-example"></a></p>

<p>Let’s create some examples to illustrate how to use async Rust effectively. You can run
<code class="language-plaintext highlighter-rouge">cargo new --lib effective-async-rust</code> to create a new library crate.</p>

<blockquote>
  <p>The code in the video and this tutorial are all in this GitHub repo:
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/async_con_par/">https://github.com/nazmulidris/rust-scratch/blob/main/async_con_par/</a></p>
</blockquote>

<p>Then add the following to the <code class="language-plaintext highlighter-rouge">Cargo.toml</code> file that’s generated. These pull in all the
dependencies that we need for these examples.</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[package]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"effective-async-rust"</span>
<span class="py">version</span> <span class="p">=</span> <span class="s">"0.1.0"</span>
<span class="py">edition</span> <span class="p">=</span> <span class="s">"2021"</span>

<span class="nn">[dependencies]</span>
<span class="py">crossterm</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.27.0"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"event-stream"</span><span class="p">]</span> <span class="p">}</span>
<span class="py">tokio</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"1.37.0"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"full"</span><span class="p">,</span> <span class="s">"tracing"</span><span class="p">]</span> <span class="p">}</span>
<span class="py">tracing</span> <span class="p">=</span> <span class="s">"0.1.40"</span>
<span class="py">tracing-subscriber</span> <span class="p">=</span> <span class="s">"0.3.18"</span>
<span class="py">futures</span> <span class="p">=</span> <span class="s">"0.3.30"</span>
<span class="py">async-stream</span> <span class="p">=</span> <span class="s">"0.3.5"</span>
</code></pre></div></div>

<h3 id="example-1-build-a-timer-future-using-waker">Example 1: Build a timer future using Waker</h3>
<p><a id="markdown-example-1%3A-build-a-timer-future-using-waker" name="example-1%3A-build-a-timer-future-using-waker"></a></p>

<p>Then you can add the following code to the <code class="language-plaintext highlighter-rouge">src/lib.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="k">pub</span> <span class="k">mod</span> <span class="n">build_a_timer_future_using_waker</span><span class="p">;</span>
</code></pre></div></div>

<p>We will implement the <code class="language-plaintext highlighter-rouge">Future</code> trait manually, in this example. Typically any <code class="language-plaintext highlighter-rouge">async</code> code
block is converted into a finite state machine which implements the <code class="language-plaintext highlighter-rouge">Future</code> trait.
Progress on the future only occurs when it is polled by the runtime or executor (eg:
Tokio).</p>

<ul>
  <li>When a future is polled and it is <code class="language-plaintext highlighter-rouge">Ready</code> then the future is complete.</li>
  <li>If it is <code class="language-plaintext highlighter-rouge">Pending</code> then the future is not complete. And when it is ready (at some point
in the future, due to some event like network IO available via <code class="language-plaintext highlighter-rouge">epoll</code> or <code class="language-plaintext highlighter-rouge">io_uring</code>),
the runtime expects the future to wake up the, by calling <code class="language-plaintext highlighter-rouge">wake()</code> on the <code class="language-plaintext highlighter-rouge">Waker</code> that
is passed to this future by the runtime, via the <code class="language-plaintext highlighter-rouge">Context</code> object.</li>
</ul>

<p>Here are more details on this:</p>

<ol>
  <li><a href="https://rust-lang.github.io/async-book/01_getting_started/04_async_await_primer.html">Primer on async and await</a>.</li>
  <li><a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code class="language-plaintext highlighter-rouge">Future</code> trait</a>.</li>
  <li><a href="https://rust-lang.github.io/async-book/02_execution/03_wakeups.html">Timer example</a>.</li>
</ol>

<blockquote>
  <p>The code for this example is
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/async_con_par/src/build_a_timer_future_using_waker.rs">here</a>.</p>
</blockquote>

<p>Create a new file <code class="language-plaintext highlighter-rouge">src/build_a_timer_future_using_waker.rs</code>. In this file, we are going
to:</p>
<ul>
  <li>Build a timer that wakes up a task after a certain amount of time, to explore how
<code class="language-plaintext highlighter-rouge">Waker</code> works.</li>
  <li>We’ll just spin up a new thread when the timer is created, sleep for the required time,
and then signal the timer future when the time window has elapsed.</li>
</ul>

<p>Add the following code to the file, to define a new struct that will implement the
<code class="language-plaintext highlighter-rouge">Future</code> trait. This struct will have a <code class="language-plaintext highlighter-rouge">SharedState</code> struct that will contain the state
of the future, and an optional <code class="language-plaintext highlighter-rouge">Waker</code> that will be used to wake up the future when the
timer has elapsed. This <code class="language-plaintext highlighter-rouge">Waker</code> is not available until the very first time the future is
polled by the runtime.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Default)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">TimerFuture</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">shared_state</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">SharedState</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Default)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">SharedState</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">completed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">waker</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Waker</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Add the following code to implement the <code class="language-plaintext highlighter-rouge">Future</code> trait for the <code class="language-plaintext highlighter-rouge">TimerFuture</code> struct.</p>
<ul>
  <li>This code will be used to poll the future, by the runtime, and check if the timer has
elapsed.</li>
  <li>If it has, then the future is complete, and the runtime can move on to the next task. If
the timer has not elapsed, then the future is not complete, and the runtime won’t do
anything further with this future. And will go on to the next task (top level <code class="language-plaintext highlighter-rouge">Future</code>)
that it can make progress on.</li>
</ul>

<p>Something has to wake up this future to let the runtime know that the timer has elapsed,
and that it needs to call <code class="language-plaintext highlighter-rouge">poll()</code> again on this <code class="language-plaintext highlighter-rouge">Future</code>. This is where the <code class="language-plaintext highlighter-rouge">Waker</code> comes
in.</p>
<ul>
  <li>The first time <code class="language-plaintext highlighter-rouge">poll()</code> is called on this future, the runtime passes in a <code class="language-plaintext highlighter-rouge">Waker</code> and we
save that to the <code class="language-plaintext highlighter-rouge">SharedState</code> struct.</li>
  <li>This will be used by the timer thread to wake up the future, when the timer has elapsed
(which we will do next).</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">Future</span> <span class="k">for</span> <span class="n">TimerFuture</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="p">();</span>

    <span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span><span class="k">self</span><span class="p">:</span> <span class="nb">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="k">Self</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">cx</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Context</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Poll</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Output</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">shared_state</span> <span class="o">=</span> <span class="k">self</span><span class="py">.shared_state</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="k">match</span> <span class="n">shared_state</span><span class="py">.completed</span> <span class="p">{</span>
            <span class="k">true</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"TimerFuture is completed"</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.green</span><span class="p">());</span>
                <span class="nn">Poll</span><span class="p">::</span><span class="nf">Ready</span><span class="p">(())</span>
            <span class="p">}</span>
            <span class="k">false</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"TimerFuture is not completed"</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.red</span><span class="p">());</span>
                <span class="c1">// Importantly, we have to update the Waker every time the</span>
                <span class="c1">// future is polled because the future may have moved to</span>
                <span class="c1">// a different task with a different Waker. This will happen</span>
                <span class="c1">// when futures are passed around between tasks after being</span>
                <span class="c1">// polled.</span>
                <span class="n">shared_state</span><span class="py">.waker</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">cx</span><span class="nf">.waker</span><span class="p">()</span><span class="nf">.clone</span><span class="p">());</span>
                <span class="nn">Poll</span><span class="p">::</span><span class="n">Pending</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Add the following code to create a new timer <code class="language-plaintext highlighter-rouge">Future</code>, and start a new thread that will
sleep for the required time, and then wake up the <code class="language-plaintext highlighter-rouge">Future</code> when the timer has elapsed, by
using the optional <code class="language-plaintext highlighter-rouge">Waker</code> that was saved in the <code class="language-plaintext highlighter-rouge">SharedState</code> struct (when <code class="language-plaintext highlighter-rouge">poll()</code> is
called on the <code class="language-plaintext highlighter-rouge">Future</code>, by the runtime).</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">TimerFuture</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">duration</span><span class="p">:</span> <span class="n">Duration</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">new_instance</span> <span class="o">=</span> <span class="nn">TimerFuture</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>

        <span class="k">let</span> <span class="n">shared_state_clone</span> <span class="o">=</span> <span class="n">new_instance</span><span class="py">.shared_state</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="nn">thread</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="n">duration</span><span class="p">);</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">shared_state</span> <span class="o">=</span> <span class="n">shared_state_clone</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="n">shared_state</span><span class="py">.completed</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="n">shared_state</span><span class="py">.waker</span><span class="nf">.take</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.wake</span><span class="p">();</span>
        <span class="p">});</span>

        <span class="n">new_instance</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Add the following test to run this code. The <code class="language-plaintext highlighter-rouge">#[tokio::test]</code> attribute macro generates
code to start a single threaded executor to run the test code.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[tokio::test]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">run_timer_future_with_tokio</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">timer_future</span> <span class="o">=</span> <span class="nn">TimerFuture</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
    <span class="k">let</span> <span class="n">shared_state</span> <span class="o">=</span> <span class="n">timer_future</span><span class="py">.shared_state</span><span class="nf">.clone</span><span class="p">();</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="o">!</span><span class="n">shared_state</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.completed</span><span class="p">);</span>
    <span class="n">timer_future</span><span class="k">.await</span><span class="p">;</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="n">shared_state</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.completed</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When you run this test, it should produce the following output:</p>

<pre class="pre-manual-highlight">
running 1 test
<span style="color:#BF616A">TimerFuture is not completed</span>
<span style="color:#A3BE8C">TimerFuture is completed</span>
test build_a_timer_future_using_waker::run_timer_future_with_tokio ... ok
</pre>

<h3 id="example-2-build-an-async-runtime-to-run-futures-to-completion">Example 2: Build an async runtime to run futures to completion</h3>
<p><a id="markdown-example-2%3A-build-an-async-runtime-to-run-futures-to-completion" name="example-2%3A-build-an-async-runtime-to-run-futures-to-completion"></a></p>

<p>For this example, let’s add the following code to the <code class="language-plaintext highlighter-rouge">src/lib.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="k">pub</span> <span class="k">mod</span> <span class="n">build_an_executor_to_run_future</span><span class="p">;</span>
</code></pre></div></div>

<p>In the example above, we use <code class="language-plaintext highlighter-rouge">tokio</code> to run the <code class="language-plaintext highlighter-rouge">TimerFuture</code> to completion. But in this
example, we will implement our own <em>simple</em> async runtime.</p>

<ul>
  <li>This is a very simple runtime that will run futures to completion, by polling them until
they are ready.</li>
  <li>It should highlight how the <code class="language-plaintext highlighter-rouge">Waker</code> and <code class="language-plaintext highlighter-rouge">Context</code> are supplied by the runtime to the
<code class="language-plaintext highlighter-rouge">Future</code>.</li>
</ul>

<blockquote>
  <p>You can get the source code for this example
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/async_con_par/src/build_an_executor_to_run_future.rs">here</a>.</p>
</blockquote>

<p>We will need a few things to implement this runtime:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">Task</code> struct that will contain the <code class="language-plaintext highlighter-rouge">Future</code> that needs to be run to completion.</li>
  <li><code class="language-plaintext highlighter-rouge">Task</code> queue that will contain all the tasks that need to be run. This will be a
<code class="language-plaintext highlighter-rouge">std::sync::mpsc::sync_channel</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">Waker</code> that will be used to wake up the runtime when a task is ready to be polled.
<code class="language-plaintext highlighter-rouge">Context</code> that will be used to pass the <code class="language-plaintext highlighter-rouge">Waker</code> to the <code class="language-plaintext highlighter-rouge">Future</code> that is being polled.</li>
  <li><code class="language-plaintext highlighter-rouge">Spawner</code> struct that will be used to spawn new tasks into the runtime.</li>
  <li><code class="language-plaintext highlighter-rouge">Executor</code> struct that will be used to run the runtime.</li>
</ol>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">src/build_an_executor_to_run_future.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">new_executor_and_spawner</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">Executor</span><span class="p">,</span> <span class="n">Spawner</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">MAX_TASKS</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">10_000</span><span class="p">;</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">task_sender</span><span class="p">,</span> <span class="n">task_receiver</span><span class="p">)</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">mpsc</span><span class="p">::</span><span class="nf">sync_channel</span><span class="p">(</span><span class="n">MAX_TASKS</span><span class="p">);</span>
    <span class="p">(</span><span class="n">Executor</span> <span class="p">{</span> <span class="n">task_receiver</span> <span class="p">},</span> <span class="n">Spawner</span> <span class="p">{</span> <span class="n">task_sender</span> <span class="p">})</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Executor</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">task_receiver</span><span class="p">:</span> <span class="n">Receiver</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Spawner</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">task_sender</span><span class="p">:</span> <span class="n">SyncSender</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Task</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">future</span><span class="p">:</span> <span class="n">Mutex</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">BoxFuture</span><span class="o">&lt;</span><span class="k">'static</span><span class="p">,</span> <span class="p">()</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">task_sender</span><span class="p">:</span> <span class="n">SyncSender</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">Spawner</code> struct to spawn new tasks into the runtime.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">Spawner</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">spawn</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">future</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Future</span><span class="o">&lt;</span><span class="n">Output</span> <span class="o">=</span> <span class="p">()</span><span class="o">&gt;</span> <span class="o">+</span> <span class="k">'static</span> <span class="o">+</span> <span class="nb">Send</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">pinned_boxed_future</span> <span class="o">=</span> <span class="n">future</span><span class="nf">.boxed</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">task</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Task</span> <span class="p">{</span>
            <span class="n">future</span><span class="p">:</span> <span class="nn">Mutex</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">pinned_boxed_future</span><span class="p">)),</span>
            <span class="n">task_sender</span><span class="p">:</span> <span class="k">self</span><span class="py">.task_sender</span><span class="nf">.clone</span><span class="p">(),</span>
        <span class="p">});</span>
        <span class="nd">eprintln!</span><span class="p">(</span>
            <span class="s">"{}"</span><span class="p">,</span>
            <span class="s">"sending task to executor, adding to channel"</span>
                <span class="nf">.to_string</span><span class="p">()</span>
                <span class="nf">.blue</span><span class="p">()</span>
        <span class="p">);</span>
        <span class="k">self</span><span class="py">.task_sender</span>
            <span class="nf">.send</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="nf">.expect</span><span class="p">(</span><span class="s">"too many tasks in channel"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">Executor</code> struct to run the runtime. This code will poll
the task queue, and block until it can get a task to run. Once it has a task, which it has
removed from the task channel or queue, it polls it (with the <code class="language-plaintext highlighter-rouge">Context</code> and <code class="language-plaintext highlighter-rouge">Waker</code>) to
check whether it is ready.</p>

<ul>
  <li>If it is ready, then it is done.</li>
  <li>If it is not ready, then it does not do anything further with it. When the task is ready
to be polled (eg: when the duration has passed in the <code class="language-plaintext highlighter-rouge">TimerFuture</code>’s thread), it will
use the <code class="language-plaintext highlighter-rouge">Waker</code> to wake up the task when it is ready to be polled). The <code class="language-plaintext highlighter-rouge">ArcWake</code>
implementation for the <code class="language-plaintext highlighter-rouge">Task</code> struct is used for this; all it does is send the task back
to the task channel, so that it can be polled again by the executor 🎉.</li>
  <li>Here’s what a real world implementation of <code class="language-plaintext highlighter-rouge">ArcWake</code> might look like using something
like Linux <code class="language-plaintext highlighter-rouge">epoll</code> or <code class="language-plaintext highlighter-rouge">io_uring</code>:
<a href="https://rust-lang.github.io/async-book/02_execution/05_io.html">https://rust-lang.github.io/async-book/02_execution/05_io.html</a>.</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">ArcWake</span> <span class="k">for</span> <span class="n">Task</span> <span class="p">{</span>
    <span class="cd">/// Implement `wake` by sending this task back onto the task</span>
    <span class="cd">/// channel so that it will be polled again by the executor,</span>
    <span class="cd">/// since it is now ready.</span>
    <span class="k">fn</span> <span class="nf">wake_by_ref</span><span class="p">(</span><span class="n">arc_self</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">cloned</span> <span class="o">=</span> <span class="n">arc_self</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="n">arc_self</span>
            <span class="py">.task_sender</span>
            <span class="nf">.send</span><span class="p">(</span><span class="n">cloned</span><span class="p">)</span>
            <span class="nf">.expect</span><span class="p">(</span><span class="s">"too many tasks in channel"</span><span class="p">);</span>
        <span class="nd">eprintln!</span><span class="p">(</span>
            <span class="s">"{}"</span><span class="p">,</span>
            <span class="s">"task woken up, added back to channel"</span>
                <span class="nf">.to_string</span><span class="p">()</span>
                <span class="nf">.underlined</span><span class="p">()</span>
                <span class="nf">.green</span><span class="p">()</span>
                <span class="nf">.bold</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Executor</span> <span class="p">{</span>
    <span class="nd">#[allow(clippy::while_let_loop)]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Remove task from receiver, or block if nothing available.</span>
        <span class="k">loop</span> <span class="p">{</span>
            <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"executor loop"</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.red</span><span class="p">());</span>
            <span class="c1">// Remove the task from the receiver.</span>
            <span class="c1">// If it is pending, then the ArcWaker</span>
            <span class="c1">// will add it back to the channel.</span>
            <span class="k">match</span> <span class="k">self</span><span class="py">.task_receiver</span><span class="nf">.recv</span><span class="p">()</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">arc_task</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">eprintln!</span><span class="p">(</span>
                        <span class="s">"{}"</span><span class="p">,</span>
                        <span class="s">"running task - start, got task from receiver"</span>
                            <span class="nf">.to_string</span><span class="p">()</span>
                            <span class="nf">.red</span><span class="p">()</span>
                    <span class="p">);</span>
                    <span class="k">let</span> <span class="k">mut</span> <span class="n">future_in_task</span> <span class="o">=</span> <span class="n">arc_task</span><span class="py">.future</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                    <span class="k">match</span> <span class="n">future_in_task</span><span class="nf">.take</span><span class="p">()</span> <span class="p">{</span>
                        <span class="nf">Some</span><span class="p">(</span><span class="k">mut</span> <span class="n">future</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                            <span class="k">let</span> <span class="n">waker</span> <span class="o">=</span> <span class="nf">waker_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arc_task</span><span class="p">);</span>
                            <span class="k">let</span> <span class="n">context</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">Context</span><span class="p">::</span><span class="nf">from_waker</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waker</span><span class="p">);</span>
                            <span class="k">let</span> <span class="n">poll_result</span> <span class="o">=</span> <span class="n">future</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.poll</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
                            <span class="nd">eprintln!</span><span class="p">(</span>
                                <span class="s">"{}"</span><span class="p">,</span>
                                <span class="nd">format!</span><span class="p">(</span>
                                  <span class="s">"poll_result: {:?}"</span><span class="p">,</span> <span class="n">poll_result</span><span class="p">)</span>
                                  <span class="nf">.to_string</span><span class="p">()</span><span class="nf">.red</span><span class="p">()</span>
                            <span class="p">);</span>
                            <span class="k">if</span> <span class="n">poll_result</span><span class="nf">.is_pending</span><span class="p">()</span> <span class="p">{</span>
                                <span class="c1">// We're not done processing the future, so put it</span>
                                <span class="c1">// back in its task to be run again in the future.</span>
                                <span class="o">*</span><span class="n">future_in_task</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">future</span><span class="p">);</span>
                                <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span>
                                  <span class="s">"putting task back in slot"</span>
                                  <span class="nf">.to_string</span><span class="p">()</span><span class="nf">.red</span><span class="p">()</span>
                                <span class="p">);</span>
                            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                                <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"task is done"</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.red</span><span class="p">());</span>
                            <span class="p">}</span>
                        <span class="p">}</span>
                        <span class="nb">None</span> <span class="k">=&gt;</span> <span class="p">{</span>
                            <span class="nd">panic!</span><span class="p">(</span><span class="s">"this never runs"</span><span class="p">);</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                    <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"running task - end"</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.red</span><span class="p">());</span>
                <span class="p">}</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"no more tasks to run, breaking out of loop"</span><span class="p">);</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And finally, add this test to run this code. Notice this code does not use <code class="language-plaintext highlighter-rouge">tokio</code> to run
the <code class="language-plaintext highlighter-rouge">TimerFuture</code> to completion. Instead, it uses the <code class="language-plaintext highlighter-rouge">Executor</code> and <code class="language-plaintext highlighter-rouge">Spawner</code> structs
that we implemented above.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">run_executor_and_spawner</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="nn">build_a_timer_future_using_waker</span><span class="p">::</span><span class="n">TimerFuture</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">results</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">Mutex</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">()));</span>

    <span class="k">let</span> <span class="p">(</span><span class="n">executor</span><span class="p">,</span> <span class="n">spawner</span><span class="p">)</span> <span class="o">=</span> <span class="nf">new_executor_and_spawner</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">results_clone</span> <span class="o">=</span> <span class="n">results</span><span class="nf">.clone</span><span class="p">();</span>
    <span class="n">spawner</span><span class="nf">.spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="n">results_clone</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.push</span><span class="p">(</span><span class="s">"hello, start timer!"</span><span class="p">);</span>
        <span class="nn">TimerFuture</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span><span class="k">.await</span><span class="p">;</span>
        <span class="n">results_clone</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.push</span><span class="p">(</span><span class="s">"bye, timer finished!"</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="nf">drop</span><span class="p">(</span><span class="n">spawner</span><span class="p">);</span>

    <span class="n">executor</span><span class="nf">.run</span><span class="p">();</span>

    <span class="nd">assert_eq!</span><span class="p">(</span>
        <span class="o">*</span><span class="n">results</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span>
        <span class="nd">vec!</span><span class="p">[</span><span class="s">"hello, start timer!"</span><span class="p">,</span> <span class="s">"bye, timer finished!"</span><span class="p">]</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This should produce the following output, which maps to the flow that we described above:</p>

<pre class="pre-manual-highlight">running 1 test
<span style="color:#81A1C1">sending task to executor, adding to channel</span>
<span style="color:#BF616A">executor loop</span>
<span style="color:#BF616A">running task - start, got task from receiver</span>
<span style="color:#BF616A">TimerFuture is not completed</span>
<span style="color:#BF616A">poll_result: Pending</span>
<span style="color:#BF616A">putting task back in slot</span>
<span style="color:#BF616A">running task - end</span>
<span style="color:#BF616A">executor loop</span>
<span style="color:#A3BE8C"><u style="text-decoration-style:single"><b>task woken up, added back to channel</b></u></span>
<span style="color:#BF616A">running task - start, got task from receiver</span>
<span style="color:#A3BE8C">TimerFuture is completed</span>
<span style="color:#BF616A">poll_result: Ready(())</span>
<span style="color:#BF616A">task is done</span>
<span style="color:#BF616A">running task - end</span>
<span style="color:#BF616A">executor loop</span>
no more tasks to run, breaking out of loop
test build_an_executor_to_run_future::run_executor_and_spawner ... ok
</pre>

<h3 id="example-3-running-async-code-concurrently-on-a-single-thread">Example 3: Running async code, concurrently, on a single thread</h3>
<p><a id="markdown-example-3%3A-running-async-code%2C-concurrently%2C-on-a-single-thread" name="example-3%3A-running-async-code%2C-concurrently%2C-on-a-single-thread"></a></p>

<p>For this example, let’s add the following code to the <code class="language-plaintext highlighter-rouge">src/lib.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="k">pub</span> <span class="k">mod</span> <span class="n">local_set</span><span class="p">;</span>
</code></pre></div></div>

<p>If you have async code, you can use a <code class="language-plaintext highlighter-rouge">LocalSet</code> to run the async code, in different
tasks, on a <em>single</em> thread. This ensures that any data that you have to pass between
these tasks can be <code class="language-plaintext highlighter-rouge">!Send</code>. Instead of wrapping the shared data in a <code class="language-plaintext highlighter-rouge">Arc</code> or
<code class="language-plaintext highlighter-rouge">Arc&lt;Mutex&gt;</code>, you can just wrap it in an <code class="language-plaintext highlighter-rouge">Rc</code>.</p>

<p>In this example, we will explore how to run async code concurrently, on a single thread.
This is an important concept to understand, as it is the basis for how async code can be
run concurrently, using non-blocking event loops.</p>

<blockquote>
  <p>The code for this example is
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/async_con_par/src/local_set.rs#L39">here</a>.</p>
</blockquote>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">src/local_set.rs</code> file.</p>
<ul>
  <li>It shows how you can create a <code class="language-plaintext highlighter-rouge">Future</code> that uses a <code class="language-plaintext highlighter-rouge">Rc</code> to share data concurrently,
running on a single thread.</li>
  <li>This is why the data is <code class="language-plaintext highlighter-rouge">!Send</code>, and we don’t need to use an <code class="language-plaintext highlighter-rouge">Arc</code> or <code class="language-plaintext highlighter-rouge">Arc&lt;Mutex&gt;</code> to
share it between tasks.</li>
  <li>Once the <code class="language-plaintext highlighter-rouge">LocalSet</code> is created, and <code class="language-plaintext highlighter-rouge">local_spawn()</code> is called, the task doesn’t actually
run until <code class="language-plaintext highlighter-rouge">local_set.run_until(..)</code> is called, or <code class="language-plaintext highlighter-rouge">local_set.await</code> is called.</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[tokio::test]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">run_local_set_and_spawn_local</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Can't send this data across threads (not wrapped in `Arc` or `Arc&lt;Mutex&gt;`).</span>
    <span class="k">let</span> <span class="n">non_send_data</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"!SEND DATA"</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">local_set</span> <span class="o">=</span> <span class="nn">LocalSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="c1">// Spawn a local task (bound to same thread) that uses the non-send data.</span>
    <span class="k">let</span> <span class="n">non_send_data_clone</span> <span class="o">=</span> <span class="n">non_send_data</span><span class="nf">.clone</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">async_block_1</span> <span class="o">=</span> <span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span>
            <span class="c1">// https://doc.rust-lang.org/std/fmt/index.html#fillalignment</span>
            <span class="s">"{:&lt;7} {}"</span><span class="p">,</span>
            <span class="s">"start"</span><span class="p">,</span>
            <span class="n">non_send_data_clone</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.yellow</span><span class="p">()</span><span class="nf">.bold</span><span class="p">(),</span>
        <span class="p">);</span>
    <span class="p">};</span>
    <span class="c1">// Does not run anything.</span>
    <span class="k">let</span> <span class="n">join_handle_1</span> <span class="o">=</span> <span class="n">local_set</span><span class="nf">.spawn_local</span><span class="p">(</span><span class="n">async_block_1</span><span class="p">);</span>

    <span class="c1">// This is required to run `async_block_1`.</span>
    <span class="k">let</span> <span class="n">_it</span> <span class="o">=</span> <span class="n">local_set</span><span class="nf">.run_until</span><span class="p">(</span><span class="n">join_handle_1</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
</code></pre></div></div>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">src/local_set.rs</code> file. This is just a different variant
(from the first example) of creating a new async block, and running it using the
<code class="language-plaintext highlighter-rouge">LocalSet</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// Create a 2nd async block.</span>
    <span class="k">let</span> <span class="n">non_send_data_clone</span> <span class="o">=</span> <span class="n">non_send_data</span><span class="nf">.clone</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">async_block_2</span> <span class="o">=</span> <span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="nf">sleep</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span><span class="k">.await</span><span class="p">;</span>
        <span class="nd">println!</span><span class="p">(</span>
            <span class="c1">// https://doc.rust-lang.org/std/fmt/index.html#fillalignment</span>
            <span class="s">"{:&lt;7} {}"</span><span class="p">,</span>
            <span class="s">"middle"</span><span class="p">,</span>
            <span class="n">non_send_data_clone</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.green</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">};</span>

    <span class="c1">// This is required to run `async_block_2`.</span>
    <span class="k">let</span> <span class="n">_it</span> <span class="o">=</span> <span class="n">local_set</span><span class="nf">.run_until</span><span class="p">(</span><span class="n">async_block_2</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
</code></pre></div></div>

<p>Finally add the following code to the <code class="language-plaintext highlighter-rouge">src/local_set.rs</code> file. This yet another way of how
you can create a new async block, and run it using the <code class="language-plaintext highlighter-rouge">LocalSet</code>. This one uses <code class="language-plaintext highlighter-rouge">local_set.await</code>
which runs all the futures that are associated with the <code class="language-plaintext highlighter-rouge">local_set</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// Spawn another local task (bound to same thread) that uses</span>
    <span class="c1">// the non-send data.</span>
    <span class="k">let</span> <span class="n">non_send_data_clone</span> <span class="o">=</span> <span class="n">non_send_data</span><span class="nf">.clone</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">async_block_3</span> <span class="o">=</span> <span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="nf">sleep</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span><span class="k">.await</span><span class="p">;</span>
        <span class="nd">println!</span><span class="p">(</span>
            <span class="c1">// https://doc.rust-lang.org/std/fmt/index.html#fillalignment</span>
            <span class="s">"{:&lt;7} {}"</span><span class="p">,</span>
            <span class="s">"end"</span><span class="p">,</span>
            <span class="n">non_send_data_clone</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.cyan</span><span class="p">()</span><span class="nf">.bold</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">};</span>
    <span class="c1">// Does not run anything.</span>
    <span class="k">let</span> <span class="n">_join_handle_3</span> <span class="o">=</span> <span class="n">local_set</span><span class="nf">.spawn_local</span><span class="p">(</span><span class="n">async_block_3</span><span class="p">);</span>

    <span class="c1">// `async_block_3` won't run until this is called.</span>
    <span class="n">local_set</span><span class="k">.await</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here’s the output when you run this test:</p>

<pre class="pre-manual-highlight">running 1 test
start   <span style="color: #EBCB8B"><b>!SEND DATA</b></span>
middle  <span style="color: #A3BE8C"><b>!SEND DATA</b></span>
end     <span style="color: #8FBCBB"><b>!SEND DATA</b></span>
test local_set::run_local_set_and_spawn_local ... ok
</pre>

<h3 id="example-4-join-select-spawn-control-flow-constructors">Example 4: join!, select, spawn control flow constructors</h3>
<p><a id="markdown-example-4%3A-join!%2C-select%2C-spawn-control-flow-constructors" name="example-4%3A-join!%2C-select%2C-spawn-control-flow-constructors"></a></p>

<p>For this example, let’s add the following code to the <code class="language-plaintext highlighter-rouge">src/lib.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="k">pub</span> <span class="k">mod</span> <span class="n">demo_join_select_spawn</span><span class="p">;</span>
</code></pre></div></div>

<p>You can use <code class="language-plaintext highlighter-rouge">join!</code>, <code class="language-plaintext highlighter-rouge">select!</code>, and <code class="language-plaintext highlighter-rouge">spawn</code> to control the flow of async code. These are
macros that are provided by the <code class="language-plaintext highlighter-rouge">tokio</code> crate. They are used to run multiple futures
concurrent, in parallel, and wait for them to complete.</p>

<blockquote>
  <p>The code for this example is
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/async_con_par/src/demo_join_select_spawn.rs">here</a>.</p>
</blockquote>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">src/demo_join_select_spawn.rs</code> file. This code shows how
you can use <code class="language-plaintext highlighter-rouge">join!</code> to run multiple futures concurrently, and wait for them to complete.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">task_1</span><span class="p">(</span><span class="n">time</span><span class="p">:</span> <span class="nb">u64</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">sleep</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="n">time</span><span class="p">))</span><span class="k">.await</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"task_1"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">task_2</span><span class="p">(</span><span class="n">time</span><span class="p">:</span> <span class="nb">u64</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">sleep</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="n">time</span><span class="p">))</span><span class="k">.await</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"task_2"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">task_3</span><span class="p">(</span><span class="n">time</span><span class="p">:</span> <span class="nb">u64</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">sleep</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="n">time</span><span class="p">))</span><span class="k">.await</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"task_3"</span><span class="p">);</span>
<span class="p">}</span>

<span class="nd">#[tokio::test]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">test_join</span><span class="p">()</span> <span class="p">{</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nd">join!</span><span class="p">(</span><span class="nf">task_1</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="nf">task_2</span><span class="p">(</span><span class="mi">200</span><span class="p">),</span> <span class="nf">task_3</span><span class="p">(</span><span class="mi">300</span><span class="p">));</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"all tasks done"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here’s the output when you run this test:</p>
<pre class="pre-manual-highlight">running 1 test
task_1
task_2
task_3
all tasks done
test demo_join_select_spawn::test_join ... ok
</pre>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">src/demo_join_select_spawn.rs</code> file. This code shows how
you can use <code class="language-plaintext highlighter-rouge">select!</code> to run multiple futures concurrently, and wait for the first one to
complete.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[tokio::test]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">test_select</span><span class="p">()</span> <span class="p">{</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span> <span class="p">{</span>
        <span class="n">_</span> <span class="o">=</span> <span class="nf">task_1</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"task_1 done"</span><span class="p">),</span>
        <span class="n">_</span> <span class="o">=</span> <span class="nf">task_2</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"task_2 done"</span><span class="p">),</span>
        <span class="n">_</span> <span class="o">=</span> <span class="nf">task_3</span><span class="p">(</span><span class="mi">300</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"task_3 done"</span><span class="p">),</span>
    <span class="p">}</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"one task done"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here’s the output when you run this test:</p>
<pre class="pre-manual-highlight">running 1 test
task_1 done
one task done
test demo_join_select_spawn::test_select ... ok
</pre>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">src/demo_join_select_spawn.rs</code> file. This code shows how
you can use <code class="language-plaintext highlighter-rouge">spawn</code> to run multiple futures in parallel, and wait for them to complete. We
pass the following to the <code class="language-plaintext highlighter-rouge">#[tokio::test]</code> attribute macro: <code class="language-plaintext highlighter-rouge">flavor = "multi_thread",
worker_threads = 5</code> which tells it to run the test on multiple threads (max of 5).</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[tokio::test(flavor</span> <span class="nd">=</span> <span class="s">"multi_thread"</span><span class="nd">,</span> <span class="nd">worker_threads</span> <span class="nd">=</span> <span class="mi">5</span><span class="nd">)]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">test_spawn</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">handle_1</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="nf">task_1</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>
    <span class="k">let</span> <span class="n">handle_2</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="nf">task_2</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>
    <span class="k">let</span> <span class="n">handle_3</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="nf">task_3</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>

    <span class="n">handle_1</span><span class="k">.await</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="n">handle_2</span><span class="k">.await</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="n">handle_3</span><span class="k">.await</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"all tasks done"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When you run this test, it should produce the following output (the ordering of the tasks
which run first, second, and third, will vary):</p>

<pre class="pre-manual-highlight">running 1 test
task_3
task_1
task_2
all tasks done
test demo_join_select_spawn::test_spawn ... ok
</pre>

<h3 id="example-5-async-streams">Example 5: async streams</h3>
<p><a id="markdown-example-5%3A-async-streams" name="example-5%3A-async-streams"></a></p>

<p>For this example, let’s add the following code to the <code class="language-plaintext highlighter-rouge">src/lib.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="k">pub</span> <span class="k">mod</span> <span class="n">async_stream</span><span class="p">;</span>
</code></pre></div></div>

<p>You can use async streams to create a stream of values that are produced asynchronously.
This is useful for testing, for example in the <code class="language-plaintext highlighter-rouge">r3bl_terminal_async</code> crate <a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/terminal_async/src/readline_impl/readline.rs#L796">in
<code class="language-plaintext highlighter-rouge">readline.rs</code> in <code class="language-plaintext highlighter-rouge">test_streams</code>
module</a>.</p>

<blockquote>
  <p>The code for this example is
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/async_con_par/src/async_stream.rs">here</a>.</p>
</blockquote>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">src/async_stream.rs</code> file.</p>
<ul>
  <li>This code shows how you can use <code class="language-plaintext highlighter-rouge">async_stream</code> crate’s <code class="language-plaintext highlighter-rouge">stream!</code> macro to create a
stream of values that are generated from a vector of strings.</li>
  <li>This stream is then converted into a <code class="language-plaintext highlighter-rouge">PinnedInputStream</code> which is a <code class="language-plaintext highlighter-rouge">Pin&lt;Box&lt;dyn
Stream&lt;Item = Result&lt;String, String&gt;&gt;&gt;</code>.</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">type</span> <span class="n">PinnedInputStream</span> <span class="o">=</span> <span class="nb">Pin</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="nb">String</span><span class="o">&gt;&gt;&gt;&gt;</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">gen_input_stream</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">PinnedInputStream</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="nn">async_stream</span><span class="p">::</span><span class="nd">stream!</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">event</span> <span class="k">in</span> <span class="nf">get_input_vec</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">yield</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="nn">Box</span><span class="p">::</span><span class="nf">pin</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_input_vec</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">vec!</span><span class="p">[</span>
        <span class="s">"a"</span><span class="nf">.to_string</span><span class="p">(),</span>
        <span class="s">"b"</span><span class="nf">.to_string</span><span class="p">(),</span>
        <span class="s">"c"</span><span class="nf">.to_string</span><span class="p">(),</span>
        <span class="s">"d"</span><span class="nf">.to_string</span><span class="p">(),</span>
    <span class="p">]</span>
<span class="p">}</span>

<span class="nd">#[tokio::test]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">test_stream</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">it</span> <span class="o">=</span> <span class="nf">gen_input_stream</span><span class="p">();</span>
    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="o">=</span> <span class="n">it</span><span class="nf">.next</span><span class="p">()</span><span class="k">.await</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">lhs</span> <span class="o">=</span> <span class="n">event</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">rhs</span> <span class="o">=</span> <span class="nf">get_input_vec</span><span class="p">()[</span><span class="n">count</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="example-6-non-blocking-event-loops-channel-safety-and-safe-cancellation">Example 6: Non-blocking event loops, channel safety, and safe cancellation</h3>
<p><a id="markdown-example-6%3A-non-blocking-event-loops%2C-channel-safety%2C-and-safe-cancellation" name="example-6%3A-non-blocking-event-loops%2C-channel-safety%2C-and-safe-cancellation"></a></p>

<p>Let’s add the following code to the <code class="language-plaintext highlighter-rouge">src/lib.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="k">pub</span> <span class="k">mod</span> <span class="n">non_blocking_async_event_loops</span><span class="p">;</span>
</code></pre></div></div>

<p>You can use non-blocking event loops to create a loop that runs async code, and waits for
events to occur. This is useful for creating servers, clients, and other networked
applications. You can even use the same pattern to create
<a href="https://crates.io/crates/r3bl_terminal_async">CLI</a> and
<a href="https://crates.io/crates/r3bl_tui">TUI</a> applications that are non-blocking, and can
handle multiple events concurrently, such as when you’re creating an interactive async
REPL.</p>

<blockquote>
  <p>The source code for this example is
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/async_con_par/src/non_blocking_async_event_loops.rs">here</a>.</p>
</blockquote>

<p>Add the following code to the <code class="language-plaintext highlighter-rouge">src/non_blocking_async_event_loops.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[tokio::test(flavor</span> <span class="nd">=</span> <span class="s">"multi_thread"</span><span class="nd">,</span> <span class="nd">worker_threads</span> <span class="nd">=</span> <span class="mi">5</span><span class="nd">)]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">test_main_loop</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Register tracing subscriber.</span>
    <span class="nn">tracing_subscriber</span><span class="p">::</span><span class="nf">fmt</span><span class="p">()</span>
        <span class="nf">.without_time</span><span class="p">()</span>
        <span class="nf">.compact</span><span class="p">()</span>
        <span class="nf">.with_target</span><span class="p">(</span><span class="k">false</span><span class="p">)</span>
        <span class="nf">.with_line_number</span><span class="p">(</span><span class="k">false</span><span class="p">)</span>
        <span class="nf">.with_thread_ids</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
        <span class="nf">.with_thread_names</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
        <span class="nf">.init</span><span class="p">();</span>

    <span class="c1">// Create channels for events and shutdown signals.</span>
    <span class="k">let</span> <span class="n">event_channel</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">mpsc</span><span class="p">::</span><span class="nn">channel</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1_000</span><span class="p">);</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">event_sender</span><span class="p">,</span> <span class="k">mut</span> <span class="n">event_receiver</span><span class="p">)</span> <span class="o">=</span> <span class="n">event_channel</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">shutdown_channel</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">broadcast</span><span class="p">::</span><span class="nn">channel</span><span class="p">::</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1_000</span><span class="p">);</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">shutdown_sender</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">shutdown_channel</span><span class="p">;</span>

    <span class="c1">// Spawn the main event loop.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">shutdown_receiver</span> <span class="o">=</span> <span class="n">shutdown_sender</span><span class="nf">.subscribe</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">safe_count</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">safe_count_clone</span> <span class="o">=</span> <span class="n">safe_count</span><span class="nf">.clone</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">join_handle</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="k">loop</span> <span class="p">{</span>
            <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span> <span class="p">{</span>
                <span class="n">event</span> <span class="o">=</span> <span class="n">event_receiver</span><span class="nf">.recv</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="o">?</span><span class="n">event</span><span class="p">,</span> <span class="s">"task got event: event"</span><span class="p">);</span>
                    <span class="k">let</span> <span class="k">mut</span> <span class="n">count</span> <span class="o">=</span> <span class="n">safe_count_clone</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                    <span class="o">*</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">_</span> <span class="o">=</span> <span class="n">shutdown_receiver</span><span class="nf">.recv</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"task got shutdown signal"</span><span class="p">);</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">});</span>

    <span class="c1">// Send events, in parallel.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">handles</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">10</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">event_sender_clone</span> <span class="o">=</span> <span class="n">event_sender</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">join_handle</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
            <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s">"sending event"</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">event</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"event {}"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="n">event_sender_clone</span><span class="nf">.send</span><span class="p">(</span><span class="n">event</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
            <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span><span class="k">.await</span><span class="p">;</span>
        <span class="p">});</span>
        <span class="n">handles</span><span class="nf">.push</span><span class="p">(</span><span class="n">join_handle</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Wait for all events to be sent using tokio.</span>
    <span class="nn">futures</span><span class="p">::</span><span class="nn">future</span><span class="p">::</span><span class="nf">join_all</span><span class="p">(</span><span class="n">handles</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>

    <span class="c1">// Shutdown the event loops.</span>
    <span class="n">shutdown_sender</span><span class="nf">.send</span><span class="p">(())</span><span class="nf">.unwrap</span><span class="p">();</span>

    <span class="c1">// Wait for the event loop to shutdown.</span>
    <span class="n">join_handle</span><span class="k">.await</span><span class="nf">.unwrap</span><span class="p">();</span>

    <span class="c1">// Assertions.</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">shutdown_sender</span><span class="nf">.receiver_count</span><span class="p">(),</span> <span class="mi">1</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="o">*</span><span class="n">safe_count</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span> <span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here are key points to note about this code:</p>
<ul>
  <li>We use <code class="language-plaintext highlighter-rouge">tokio::sync::mpsc::channel</code> to create a channel for events, and
<code class="language-plaintext highlighter-rouge">tokio::sync::broadcast::channel</code> to create a channel for shutdown signals.</li>
  <li>We spawn the main event loop, which listens for events and shutdown signals, and updates
a shared counter.</li>
  <li>We spawn multiple tasks that send events to the event channel, in parallel.
    <ul>
      <li>The <code class="language-plaintext highlighter-rouge">#[tokio::test(flavor = "multi_thread", worker_threads = 5)]</code> attribute macro
tells <code class="language-plaintext highlighter-rouge">tokio</code> to run the test on multiple threads (max of 5).</li>
      <li>You can see this in the output when you run the test. By configuring Tokio <code class="language-plaintext highlighter-rouge">tracing</code>
subscriber, we can see the thread IDs and names in the output
(<code class="language-plaintext highlighter-rouge">.with_thread_ids(true)</code>, <code class="language-plaintext highlighter-rouge">.with_thread_names(true)</code>).</li>
      <li>We wait for all events to be sent using <code class="language-plaintext highlighter-rouge">futures::future::join_all(handles).await</code>.</li>
    </ul>
  </li>
  <li>We shutdown the event loop (using <code class="language-plaintext highlighter-rouge">shutdown_sender.send(())</code>), and wait for it to
shutdown using <code class="language-plaintext highlighter-rouge">join_handle.await</code>..</li>
</ul>

<p>When you run this test, it will produce the following output:</p>
<pre class="pre-manual-highlight">running 1 test
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) sending event <i>i</i><span style="color:#90949B">=2</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(04) sending event <i>i</i><span style="color:#90949B">=6</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(06) sending event <i>i</i><span style="color:#90949B">=0</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(07) sending event <i>i</i><span style="color:#90949B">=4</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(03) sending event <i>i</i><span style="color:#90949B">=7</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(04) sending event <i>i</i><span style="color:#90949B">=8</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(06) sending event <i>i</i><span style="color:#90949B">=1</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) task got event: event <i>event</i><span style="color:#90949B">=Some(&quot;event 2&quot;)</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(07) sending event <i>i</i><span style="color:#90949B">=5</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(03) sending event <i>i</i><span style="color:#90949B">=9</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) task got event: event <i>event</i><span style="color:#90949B">=Some(&quot;event 6&quot;)</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(04) sending event <i>i</i><span style="color:#90949B">=3</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) task got event: event <i>event</i><span style="color:#90949B">=Some(&quot;event 0&quot;)</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) task got event: event <i>event</i><span style="color:#90949B">=Some(&quot;event 4&quot;)</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) task got event: event <i>event</i><span style="color:#90949B">=Some(&quot;event 7&quot;)</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) task got event: event <i>event</i><span style="color:#90949B">=Some(&quot;event 8&quot;)</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) task got event: event <i>event</i><span style="color:#90949B">=Some(&quot;event 1&quot;)</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) task got event: event <i>event</i><span style="color:#90949B">=Some(&quot;event 5&quot;)</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) task got event: event <i>event</i><span style="color:#90949B">=Some(&quot;event 9&quot;)</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) task got event: event <i>event</i><span style="color:#90949B">=Some(&quot;event 3&quot;)</span>
<span style="color:#A3BE8C"> INFO</span> tokio-runtime-worker ThreadId(05) task got shutdown signal
test non_blocking_async_event_loops::test_main_loop ... ok
</pre>

<p>Interesting code links:</p>
<ul>
  <li>Testing async code: <a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/terminal_async/src/readline_impl/readline.rs#L612">https://github.com/r3bl-org/r3bl-open-core/blob/main/terminal_async/src/readline_impl/readline.rs#L612</a></li>
  <li>Using dependency injection and dealing with <code class="language-plaintext highlighter-rouge">dyn T</code> (trait objects): <a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/terminal_async/src/readline_impl/readline.rs#L344">https://github.com/r3bl-org/r3bl-open-core/blob/main/terminal_async/src/readline_impl/readline.rs#L344</a>.</li>
  <li>Event <code class="language-plaintext highlighter-rouge">loop</code>s and breaking out of them (lifecycle control mechanisms):
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/tcp-api-server/src/server_task.rs#L43">https://github.com/nazmulidris/rust-scratch/blob/main/tcp-api-server/src/server_task.rs#L43</a>
and
<a href="https://github.com/nazmulidris/rust-scratch/blob/main/tcp-api-server/src/client_task.rs#L108">https://github.com/nazmulidris/rust-scratch/blob/main/tcp-api-server/src/client_task.rs#L108</a>.</li>
</ul>

<h3 id="parting-thoughts">Parting thoughts</h3>
<p><a id="markdown-parting-thoughts" name="parting-thoughts"></a></p>

<ul>
  <li>Try not to use cancellation token:
<a href="https://docs.rs/tokio-util/latest/tokio_util/sync/struct.CancellationToken.html">https://docs.rs/tokio-util/latest/tokio_util/sync/struct.CancellationToken.html</a>,
instead do this: <a href="https://github.com/nazmulidris/rust-scratch/pull/32">https://github.com/nazmulidris/rust-scratch/pull/32</a> and
<a href="https://github.com/nazmulidris/rust-scratch/commit/e129b0f681dd1eea1bcdd3372cd08a05081922ff">https://github.com/nazmulidris/rust-scratch/commit/e129b0f681dd1eea1bcdd3372cd08a05081922ff</a></li>
  <li>Do not use async or Tokio for underlying sync OS file copy:
<a href="https://users.rust-lang.org/t/tokio-copy-slower-than-std-io-copy/111242">https://users.rust-lang.org/t/tokio-copy-slower-than-std-io-copy/111242</a>.</li>
  <li>Using the right <code class="language-plaintext highlighter-rouge">Mutex</code> in conjunction with <code class="language-plaintext highlighter-rouge">Arc</code> and holding them across await points
from <a href="https://docs.rs/tokio/latest/tokio/sync/struct.Mutex.html#which-kind-of-mutex-should-you-use">tokio
docs</a>.</li>
  <li>Good videos:
    <ul>
      <li><a href="https://www.youtube.com/watch?v=1zOd52_tUWg&amp;t=2088s">Async Rust: the good, the bad, and the ugly - Steve Klabnik</a>.</li>
      <li><a href="https://www.youtube.com/watch?v=04gTQmLETFI">Nicholas Matsakis - Rust 2024 and beyond</a>.</li>
    </ul>
  </li>
</ul>

<h2 id="build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</h2>
<p><a id="markdown-build-with-naz-video-series-on-developerlife.com-youtube-channel" name="build-with-naz-video-series-on-developerlife.com-youtube-channel"></a></p>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a></li>
  <li>Playlists
    <ul>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmwO69E7eiQ-ewnMME8ydgQ5">Build with Naz, async Rust and tokio</a></li>
      <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><summary type="html"><![CDATA[Learn effective async Rust using real world patterns that show up consistently when creating non blocking, async, event loops, using channels. Delve into implementing the Future trait and async executor manually. Also explore safe cancellation, when not to use async, and how to think about testing async code.]]></summary></entry><entry><title type="html">Build with Naz : tokio tracing &amp;amp; OTel and how to use it in Rust</title><link href="http://developerlife.com/2024/05/15/tokio-tracing-otel-rust/" rel="alternate" type="text/html" title="Build with Naz : tokio tracing &amp;amp; OTel and how to use it in Rust" /><published>2024-05-15T10:00:00-05:00</published><updated>2024-05-15T10:00:00-05:00</updated><id>http://developerlife.com/2024/05/15/tokio-tracing-otel-rust</id><content type="html" xml:base="http://developerlife.com/2024/05/15/tokio-tracing-otel-rust/"><![CDATA[<p><img class="post-hero-image" src="/assets/tracing_otel_rust.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#why-use-observability-in-async-rust">Why use observability in async Rust?</a></li>
  <li><a href="#tokio-tracing-usage">Tokio tracing usage</a></li>
  <li><a href="#video-of-this-in-action-in-the-real-world">Video of this in action in the real world</a></li>
  <li><a href="#short-example-to-illustrate-the-use-of-tracing-and-otel-in-rust">Short example to illustrate the use of tracing and OTel in Rust</a></li>
  <li><a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</a></li>
</ul>

<!-- /TOC -->

<h2 id="why-use-observability-in-async-rust">Why use observability in async Rust?</h2>
<p><a id="markdown-why-use-observability-in-async-rust%3F" name="why-use-observability-in-async-rust%3F"></a></p>

<p>In synchronous systems, it’s often easy to understand the flow of execution by looking at
log messages. For example, if a thread walking through a single function ends up calling a whole
host of other functions, and they all emit log messages, you can often piece together what
happened by looking at the log messages in order.</p>

<p>However, in asynchronous systems, this is challenging. When using Tokio, for example,
different threads might be executing the same task, as it goes from being parked, to being
woken up, to being parked again. Both temporality (when a log event happened) and
causality (what caused the event) get muddled. This is where observability comes in,
provided by Tokio <code class="language-plaintext highlighter-rouge">tracing</code> crate and OpenTelemetry (OTel) crates.</p>

<p>The <code class="language-plaintext highlighter-rouge">tracing</code> crate expands upon logging-style diagnostics by allowing libraries and
applications to record structured events with additional information about temporality and
causality. Unlike a log message, a <code class="language-plaintext highlighter-rouge">Span</code> in tracing has a beginning and end time, may be
entered and exited by the flow of execution, and may exist within a nested tree of similar
spans.</p>

<p>For representing things that occur at a single moment in time, tracing provides the
complementary concept of events. Both <code class="language-plaintext highlighter-rouge">Spans</code> and <code class="language-plaintext highlighter-rouge">Events</code> are structured, with the ability to
record typed data as well as textual messages.</p>

<h2 id="tokio-tracing-usage">Tokio tracing usage</h2>
<p><a id="markdown-tokio-tracing-usage" name="tokio-tracing-usage"></a></p>

<p>Code:</p>
<ul>
  <li><a href="https://github.com/nazmulidris/rust-scratch/tree/main/tcp-api-server"><code class="language-plaintext highlighter-rouge">tcp-api-server</code> crate is the sample project that uses <code class="language-plaintext highlighter-rouge">tracing</code> and OTel and the
modules below (provided by the <code class="language-plaintext highlighter-rouge">r3bl_terminal_async</code>
crate</a>.</li>
  <li><a href="https://github.com/r3bl-org/r3bl-open-core/blob/nazmulidris/otel/terminal_async/src/public_api/tracing_setup.rs"><code class="language-plaintext highlighter-rouge">r3bl_terminal_async</code> Tokio <code class="language-plaintext highlighter-rouge">tracing</code>
setup</a>.</li>
  <li><a href="https://github.com/r3bl-org/r3bl-open-core/blob/nazmulidris/otel/terminal_async/src/public_api/jaeger_setup.rs#L1"><code class="language-plaintext highlighter-rouge">r3bl_terminal_async</code> Jaeger &amp; OTel
setup</a>.</li>
</ul>

<p>Here’s an example of using the <code class="language-plaintext highlighter-rouge">tracing</code> crate. Some key symbols to note are::</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">#[instrument]</code> attribute is used to create a span.</li>
  <li><code class="language-plaintext highlighter-rouge">Span::current().record()</code> is used to add fields to the span (when the function is
running, and this information is not known statically beforehand).</li>
  <li><code class="language-plaintext highlighter-rouge">info!</code>, <code class="language-plaintext highlighter-rouge">error!</code>, etc are used to emit log or tracing events. However, these are not
used to create spans; they are used to emit events within a span.</li>
  <li><code class="language-plaintext highlighter-rouge">#[tokio::main]</code> is used to run the async main function.</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">tracing</span><span class="p">::{</span><span class="n">info</span><span class="p">,</span> <span class="n">instrument</span><span class="p">,</span> <span class="n">Span</span><span class="p">};</span>

<span class="nd">#[tokio::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Set up the tracing subscriber, so you can see the output of log events in stdout.</span>
    <span class="c1">// https://docs.rs/tracing-subscriber/latest/tracing_subscriber/fmt/fn.fmt.html</span>
    <span class="nn">tracing_subscriber</span><span class="p">::</span><span class="nf">fmt</span><span class="p">()</span>
        <span class="nf">.with_test_writer</span><span class="p">()</span>
        <span class="nf">.with_env_filter</span><span class="p">(</span><span class="s">"info"</span><span class="p">)</span>
        <span class="nf">.init</span><span class="p">();</span>

    <span class="c1">// Call the entry point function.</span>
    <span class="nn">client_task</span><span class="p">::</span><span class="nf">entry_point</span><span class="p">(</span><span class="mi">1234</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">mod</span> <span class="n">client_task</span> <span class="p">{</span>
    <span class="nd">#[instrument(name</span> <span class="nd">=</span> <span class="s">"caller"</span><span class="nd">,</span> <span class="nd">skip_all,</span> <span class="nd">fields(</span><span class="err">?</span><span class="nd">client_id))]</span>
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">entry_point</span><span class="p">(</span><span class="n">client_id</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">info!</span><span class="p">(</span><span class="s">"entry point"</span><span class="p">);</span>
        <span class="nf">more_context</span><span class="p">(</span><span class="s">"bar"</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
        <span class="nf">handle_message</span><span class="p">(</span><span class="n">client_id</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
        <span class="nf">no_instrument</span><span class="p">(</span><span class="s">"baz"</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nd">#[instrument(name</span> <span class="nd">=</span> <span class="s">"callee"</span><span class="nd">,</span> <span class="nd">skip_all,</span> <span class="nd">fields(</span><span class="err">%</span><span class="nd">message))]</span>
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">handle_message</span><span class="p">(</span><span class="n">client_id</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">info!</span><span class="p">(</span><span class="s">"handling message"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">#[instrument(fields(extra))]</span>
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">more_context</span><span class="p">(</span><span class="n">extra</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="nn">CurrentSpan</span><span class="p">::</span><span class="nf">current</span><span class="p">()</span><span class="nf">.record</span><span class="p">(</span><span class="s">"extra"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">extra</span><span class="p">);</span>
        <span class="nd">info!</span><span class="p">(</span><span class="s">"more context"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">no_instrument</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">info!</span><span class="p">(</span><span class="s">"no instrument fn"</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<p>Here are some key points to remember when using <code class="language-plaintext highlighter-rouge">tracing</code> from the code above:</p>

<ul>
  <li>
    <p>You have to be careful about recording the same field multiple times, in an async call
chain. In the example above, <code class="language-plaintext highlighter-rouge">client_task::entry_point()</code> is the entry point, and is the
only function that should log the <code class="language-plaintext highlighter-rouge">?client_id</code>; <code class="language-plaintext highlighter-rouge">?</code> means debug. And not any other
functions that it calls, like <code class="language-plaintext highlighter-rouge">handle_message()</code>.</p>
  </li>
  <li>
    <p>When you call <code class="language-plaintext highlighter-rouge">entry_point()</code>, it will call <code class="language-plaintext highlighter-rouge">handle_message()</code>, and the span that is
generated by <code class="language-plaintext highlighter-rouge">handle_message()</code> will have the <code class="language-plaintext highlighter-rouge">client_id</code> field added to it, because of
the call chain. So the output of <code class="language-plaintext highlighter-rouge">info!("handling message")</code> will have the <code class="language-plaintext highlighter-rouge">client_id</code>
included in it (for free). It will also have the <code class="language-plaintext highlighter-rouge">%message</code> field in it; <code class="language-plaintext highlighter-rouge">%</code> means
display. You don’t have to explicitly add either of these fields to the <code class="language-plaintext highlighter-rouge">info!()</code> call 🎉.</p>
  </li>
  <li>
    <p>If you use the <code class="language-plaintext highlighter-rouge">client_id</code> field in multiple <code class="language-plaintext highlighter-rouge">#[instrument..]</code> attributes in functions
(that are in the call chain), then this will show up multiple times in the log output
(when using <code class="language-plaintext highlighter-rouge">info!</code>, <code class="language-plaintext highlighter-rouge">debug!</code>, etc) of the leaf function in the call chain. So when you
see the same fields showing up multiple times in the output from <code class="language-plaintext highlighter-rouge">info!</code>, <code class="language-plaintext highlighter-rouge">debug!</code>, etc,
then you know that you have to remove that field from the <code class="language-plaintext highlighter-rouge">#[instrument..]</code> attribute
somewhere in the call chain (that the span covers).</p>
  </li>
  <li>
    <p>You have to be careful about how to use
<a href="https://docs.rs/tracing/latest/tracing/attr.instrument.html"><code class="language-plaintext highlighter-rouge">[#instrument]</code></a> attribute
with <code class="language-plaintext highlighter-rouge">tracing::Span::record</code>. You have to call
<code class="language-plaintext highlighter-rouge">tracing::Span::current().record("foo","bar")</code> in the same function where the
<code class="language-plaintext highlighter-rouge">#[instrument(fields(foo))]</code> attribute is used.</p>
  </li>
  <li>
    <p>When a function is called that isn’t instrumented, by another one, which is, any log
events generated in the un-instrumented function will be associated with the span of the
instrumented function. In the <code class="language-plaintext highlighter-rouge">no_instrument</code> function’s log output, you will see
addition context from the <code class="language-plaintext highlighter-rouge">entry_point</code> function that looks something like <code class="language-plaintext highlighter-rouge">INFO
caller{client_id=1234}: no instrument fn</code>.</p>
  </li>
</ul>

<p>Here are some helpful links to learn more about this topic:</p>

<ul>
  <li><a href="https://tokio.rs/tokio/topics/tracing">Tokio tracing docs</a>.</li>
  <li><a href="https://gemini.google.com/app/5b106a8100c4dcf4">Difference between <code class="language-plaintext highlighter-rouge">#[instrument]</code> (create spans) and emitting events (eg: <code class="language-plaintext highlighter-rouge">info!</code>, <code class="language-plaintext highlighter-rouge">debug!</code>, etc:</a>.</li>
  <li><a href="https://tokio.rs/tokio/topics/tracing-next-steps">Tokio and OTel integration docs</a>.</li>
  <li><a href="https://github.com/tokio-rs/tracing-opentelemetry">Tokio tracing and OTel integration crate</a>.</li>
  <li><a href="https://broch.tech/posts/rust-tracing-opentelemetry/">Blog post to connect tracing and OTel</a>.</li>
  <li><a href="https://github.com/open-telemetry/opentelemetry-rust/blob/main/examples/tracing-jaeger/src/main.rs">Code examples for using Jaeger with tracing</a>.</li>
  <li><a href="https://opentelemetry.io/docs/concepts/observability-primer/#spans">OTel primer</a>.</li>
  <li><a href="https://www.jaegertracing.io/docs/1.57/getting-started/">Jaeger docs</a>.</li>
</ul>

<h2 id="video-of-this-in-action-in-the-real-world">Video of this in action in the real world</h2>
<p><a id="markdown-video-of-this-in-action-in-the-real-world" name="video-of-this-in-action-in-the-real-world"></a></p>

<p>This blog post only has a short example to illustrate how to use Rust tracing and OTel
with Jaeger. To see how these ideas can be used in production code, with real-world
examples, please watch the following video on the <a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube
channel</a>.</p>

<!-- rust tokio tracing and otel for async rust & playlist -->
<iframe src="https://www.youtube.com/embed/Wf8JrLgBuKI?si=cmLaUWs-pbJ39lLc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<p>Here’s the code for this real world example:</p>

<ul>
  <li><a href="https://github.com/nazmulidris/rust-scratch/tree/main/tcp-api-server">Repo for the <code class="language-plaintext highlighter-rouge">tcp-api-server</code> crate, which is an example of creating a TCP server and
client that are observable using <code class="language-plaintext highlighter-rouge">tracing</code> and
OTel</a>.
    <ul>
      <li>It uses the <code class="language-plaintext highlighter-rouge">r3bl_terminal_async</code> crate to allow async, non-blocking readline
functionality, along with <code class="language-plaintext highlighter-rouge">stdout</code> and <code class="language-plaintext highlighter-rouge">stderr</code> that are also async.</li>
      <li>This crate is also used to configure Jaeger and tracing subscribers for file, stdout
logging.</li>
    </ul>
  </li>
  <li>
    <p><a href="https://github.com/nazmulidris/rust-scratch/tree/main/tcp-api-server#tokio-tracing-usage">README for <code class="language-plaintext highlighter-rouge">tcp-api-server</code> crate, which shows how to use Jaeger, and configure file
logging and stdout
logging</a>.</p>
  </li>
  <li>
    <p><a href="https://github.com/r3bl-org/r3bl-open-core/blob/nazmulidris/refactor-tokio-tracing/terminal_async/src/public_api/tracing_setup.rs">How to build up tracing subscribers using layers (type erasure, decl macros,
etc)</a>.</p>
  </li>
  <li>
    <p><a href="https://github.com/nazmulidris/rust-scratch/pull/34">How to add an OTel layer to a
subscriber</a>.</p>
  </li>
  <li><a href="https://github.com/r3bl-org/r3bl-open-core/pull/326">How the subscriber is configured with custom layers in <code class="language-plaintext highlighter-rouge">r3bl_terminal_async</code>
crate</a>.</li>
</ul>

<h2 id="short-example-to-illustrate-the-use-of-tracing-and-otel-in-rust">Short example to illustrate the use of tracing and OTel in Rust</h2>
<p><a id="markdown-short-example-to-illustrate-the-use-of-tracing-and-otel-in-rust" name="short-example-to-illustrate-the-use-of-tracing-and-otel-in-rust"></a></p>

<p>Let’s look a single example (that fits in one file) that illustrates the use of tracing
in Rust. You can run <code class="language-plaintext highlighter-rouge">cargo new --lib tracing-otel</code> to create a new library crate, and then run
the following:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo add miette <span class="nt">--features</span> fancy
cargo add tracing tracing-subscriber
cargo add tokio <span class="nt">--features</span> full
</code></pre></div></div>

<p>Then you can add the following code to the <code class="language-plaintext highlighter-rouge">src/main.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">miette</span><span class="p">::</span><span class="n">IntoDiagnostic</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">tracing</span><span class="p">::</span><span class="n">Span</span><span class="p">;</span>

<span class="nd">#[tokio::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">subscriber</span> <span class="o">=</span> <span class="nn">tracing_subscriber</span><span class="p">::</span><span class="nf">fmt</span><span class="p">()</span>
        <span class="nf">.without_time</span><span class="p">()</span>
        <span class="nf">.pretty</span><span class="p">()</span>
        <span class="nf">.with_max_level</span><span class="p">(</span><span class="nn">tracing</span><span class="p">::</span><span class="nn">Level</span><span class="p">::</span><span class="n">DEBUG</span><span class="p">)</span>
        <span class="nf">.finish</span><span class="p">();</span>

    <span class="nn">tracing</span><span class="p">::</span><span class="nn">subscriber</span><span class="p">::</span><span class="nf">set_global_default</span><span class="p">(</span><span class="n">subscriber</span><span class="p">)</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">print_message</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The first part of the code sets up the tracing subscriber. In this case we are using a formatting
subscriber that prints logs to the console. This subscriber is configured to not print the time of
the log message, to pretty print the logs, and to print logs at the <code class="language-plaintext highlighter-rouge">DEBUG</code> level or higher.</p>

<p>When you use <code class="language-plaintext highlighter-rouge">#[attribute]</code> along with <code class="language-plaintext highlighter-rouge">info!</code>, <code class="language-plaintext highlighter-rouge">debug!</code>, etc, Tokio will emit log events
that are associated with a span. This is the “emitter” side of the process. The other side
is the “subscriber” side, which is where the logs are actually printed to the console, or
sent to a file, or sent to an OTel collector service like Jaeger (using OTLP protocol over
gRPC).</p>

<p>Tokio <code class="language-plaintext highlighter-rouge">tracing</code> allows us to use this simple default subscriber, or create our own custom
subscribers. It even allows a subscriber to be composed from layers. We can create our own
custom layers, or use some default ones (like the level filter layer).</p>

<p>OTel is itself a tracing layer. In the video &amp; <code class="language-plaintext highlighter-rouge">tcp-api-server</code> repo, you will see how to
use OTel with Jaeger, and how to configure the OTel layer with a custom layer.</p>

<p>Next you can add the following code to the <code class="language-plaintext highlighter-rouge">src/main.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[tracing::instrument(fields(arg</span> <span class="nd">=</span> <span class="err">?</span><span class="nd">arg,</span> <span class="nd">client_id),</span> <span class="nd">ret)]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">print_message</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="nn">tracing</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"log message one"</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">prepare_message</span><span class="p">()</span><span class="k">.await</span><span class="p">);</span>

    <span class="nn">Span</span><span class="p">::</span><span class="nf">current</span><span class="p">()</span><span class="nf">.record</span><span class="p">(</span><span class="s">"client_id"</span><span class="p">,</span> <span class="mi">1234</span><span class="p">);</span>

    <span class="nn">tracing</span><span class="p">::</span><span class="nd">warn!</span><span class="p">(</span><span class="s">"log message two"</span><span class="p">);</span>
<span class="p">}</span>

<span class="nd">#[tracing::instrument(ret)]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">prepare_message</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="nn">tracing</span><span class="p">::</span><span class="nd">debug!</span><span class="p">(</span><span class="s">"preparing message"</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="s">"Hello, world!"</span><span class="nf">.to_string</span><span class="p">();</span>
    <span class="nn">tracing</span><span class="p">::</span><span class="nd">debug!</span><span class="p">(</span><span class="s">"message prepared"</span><span class="p">);</span>
    <span class="n">it</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">print_message</code> function is annotated with the <code class="language-plaintext highlighter-rouge">#[tracing::instrument]</code> attribute.
This attribute creates a span for the function, and adds the <code class="language-plaintext highlighter-rouge">arg</code> field to the span along
with the <code class="language-plaintext highlighter-rouge">client_id</code> field. In all the log events are emitted within the span, the <code class="language-plaintext highlighter-rouge">arg</code>
and <code class="language-plaintext highlighter-rouge">client_id</code> field will be included in the log output. This additional context is
provided by a span. And you don’t have to write any code to the <code class="language-plaintext highlighter-rouge">info!</code>, <code class="language-plaintext highlighter-rouge">warn!</code>, etc
calls to include these fields in the log output.</p>

<p>You can run the code using <code class="language-plaintext highlighter-rouge">cargo run</code>. The code will produce the following output.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   INFO tracing_otel: log message one
    at src/main.rs:38
    in tracing_otel::print_message with arg: "foo"

  DEBUG tracing_otel: preparing message
    at src/main.rs:48
    in tracing_otel::prepare_message
    in tracing_otel::print_message with arg: "foo"

  DEBUG tracing_otel: message prepared
    at src/main.rs:50
    in tracing_otel::prepare_message
    in tracing_otel::print_message with arg: "foo"

   INFO tracing_otel: return: "Hello, world!"
    at src/main.rs:46
    in tracing_otel::prepare_message
    in tracing_otel::print_message with arg: "foo"

Hello, world!

   WARN tracing_otel: log message two
    at src/main.rs:43
    in tracing_otel::print_message with arg: "foo", client_id: 1234

   INFO tracing_otel: return: ()
    at src/main.rs:36
    in tracing_otel::print_message with arg: "foo", client_id: 1234
</code></pre></div></div>

<p>Beyond this simple example, to dive deeper, please check out the video and the
<code class="language-plaintext highlighter-rouge">tcp-api-server</code> repo to get a sense of how this can all be used in a real world example
that has lots of moving parts and pieces. Observability here can tell the story of what
happened in the system, so it can be another way of getting an understanding of the
system’s behavior.</p>

<h2 id="build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</h2>
<p><a id="markdown-build-with-naz-video-series-on-developerlife.com-youtube-channel" name="build-with-naz-video-series-on-developerlife.com-youtube-channel"></a></p>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a></li>
  <li>Playlists
    <ul>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmwO69E7eiQ-ewnMME8ydgQ5">Build with Naz, async Rust and tokio</a></li>
      <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><summary type="html"><![CDATA[Learn how to use tokio tracing and OpenTelemetry (with Jaeger) in async Rust to instrument your code and collect telemetry data for observability.]]></summary></entry><entry><title type="html">Build with Naz : Rust Polymorphism, dyn, impl, using existing traits, trait objects for testing and extensibility</title><link href="http://developerlife.com/2024/04/28/rust-polymorphism-dyn-impl-trait-objects-for-testing-and-extensibiity/" rel="alternate" type="text/html" title="Build with Naz : Rust Polymorphism, dyn, impl, using existing traits, trait objects for testing and extensibility" /><published>2024-04-28T10:00:00-05:00</published><updated>2024-04-28T10:00:00-05:00</updated><id>http://developerlife.com/2024/04/28/rust-polymorphism-dyn-impl-trait-objects-for-testing-and-extensibiity</id><content type="html" xml:base="http://developerlife.com/2024/04/28/rust-polymorphism-dyn-impl-trait-objects-for-testing-and-extensibiity/"><![CDATA[<p><img class="post-hero-image" src="/assets/rust_polymorphism.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#why-use-polymorphism-in-rust">Why use polymorphism in Rust?</a></li>
  <li><a href="#short-example-to-illustrate-both-approaches">Short example to illustrate both approaches</a></li>
  <li><a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</a></li>
</ul>

<!-- /TOC -->

<h2 id="why-use-polymorphism-in-rust">Why use polymorphism in Rust?</h2>
<p><a id="markdown-why-use-polymorphism-in-rust%3F" name="why-use-polymorphism-in-rust%3F"></a></p>

<p>When it comes to polymorphism in Rust, which means that you want to be intentionally “vague” about
what arguments a function can receive or what values it can return, there are roughly two
approaches: static dispatch and dynamic dispatch. They are both tightly related to the notion of
sidedness in Rust.</p>

<p>There are many legitimate reasons to be intentionally vague about the types of arguments a function
can receive or the values it can return. Here are a few:</p>

<ul>
  <li>Testing: You want swap out the implementation of a function with a test mock or test fixture, so
that you can test the function in isolation.</li>
  <li>Extensibility: You want to accommodate integrations with other code that you don’t control, and
you want to be able to use dependency injection to provide the intended behaviors (from) systems
that you don’t control.</li>
  <li>Reuse: You want to reuse the same code in multiple places, since they only operate on on aspect
(or trait) of the data.</li>
</ul>

<p>Here are the two approaches to polymorphism in Rust:</p>

<table>
  <thead>
    <tr>
      <th>static</th>
      <th>dynamic</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>receive</td>
      <td>receive</td>
    </tr>
    <tr>
      <td>return</td>
      <td>return</td>
    </tr>
  </tbody>
</table>

<p>There are pros and cons to each approach:</p>

<table>
  <thead>
    <tr>
      <th>approach</th>
      <th>pros</th>
      <th>cons</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>static</td>
      <td>Compile time checks and dispatch. No runtime overhead.</td>
      <td>Code is more difficult to read and write since generics and their often verbose trait bounds have to be spread to the caller.</td>
    </tr>
    <tr>
      <td>dynamic</td>
      <td>Code is more concise and easier to read and write since the trait objects are localized to the function that accepts or returns them.</td>
      <td>Runtime overhead due to dynamic dispatch. Vtable lookup is required due to type erasure.</td>
    </tr>
  </tbody>
</table>

<p>Here are some helpful links to learn more about this topic:</p>

<ul>
  <li><a href="https://www.youtube.com/watch?v=xcygqF5LVmM&amp;t=1162s">Great Crust of Rust video on monomorphization, generics, vtables, fat pointers, static dispatch, and dynamic dispatch</a></li>
  <li><a href="https://developerlife.com/2022/03/12/rust-redux/#of-things-and-their-managers">Vtables</a></li>
  <li><a href="https://developerlife.com/assets/rust-container-cheat-sheet.svg">Diagram of sizes</a></li>
  <li><a href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/sizedness-in-rust.md">Sizedness</a></li>
  <li><a href="https://gemini.google.com/app/157980ca7d9b588c">Difference between using <code class="language-plaintext highlighter-rouge">Arc</code> and <code class="language-plaintext highlighter-rouge">Box</code> with <code class="language-plaintext highlighter-rouge">dyn</code></a></li>
  <li><a href="https://rust-unofficial.github.io/too-many-lists/index.html">Book on <code class="language-plaintext highlighter-rouge">dyn</code> and <code class="language-plaintext highlighter-rouge">Box</code></a></li>
</ul>

<h2 id="video-of-this-in-action-in-the-real-world">Video of this in action in the real world</h2>
<p><a id="markdown-video-of-this-in-action-in-the-real-world" name="video-of-this-in-action-in-the-real-world"></a></p>

<p>This blog post only has a short example to illustrate both approaches to polymorphism in
Rust. To see how these ideas can be used in production code, with real-world examples,
please watch the following video on the <a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube
channel</a>.</p>

<!-- video on rust polymorphism (no playlist) -->
<iframe src="https://www.youtube.com/embed/kYTgGtJjSro?si=XmW-_CAvCfB5e269" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<h2 id="short-example-to-illustrate-both-approaches">Short example to illustrate both approaches</h2>
<p><a id="markdown-short-example-to-illustrate-both-approaches" name="short-example-to-illustrate-both-approaches"></a></p>

<p>The code for this example lives
<a href="https://github.com/nazmulidris/rust-scratch/tree/main/dyn-dispatch/src">here</a>.</p>

<p>Let’s look a single example (that fits in one file) that illustrates both approaches to polymorphism
in Rust. You can run <code class="language-plaintext highlighter-rouge">cargo new --lib dyn-dispatch</code> to create a new library crate, and then run
<code class="language-plaintext highlighter-rouge">cargo add rand</code>. Then you can add the following code to the <code class="language-plaintext highlighter-rouge">src/lib.rs</code> file.</p>

<p>This first part is the setup for this example. We have two structs, each of which
implements the <a href="https://doc.rust-lang.org/std/io/struct.Error.html"><code class="language-plaintext highlighter-rouge">Error</code></a> trait. We
want to be able to use both structs in functions that can receive or return
<a href="https://doc.rust-lang.org/std/io/struct.Error.html"><code class="language-plaintext highlighter-rouge">Error</code></a> trait objects.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span><span class="p">;</span>

<span class="c1">// ErrorOne.</span>
<span class="k">mod</span> <span class="n">error_one</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="nd">#[derive(Debug)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">ErrorOne</span><span class="p">;</span>

    <span class="k">impl</span> <span class="n">Display</span> <span class="k">for</span> <span class="n">ErrorOne</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"ErrorOne"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">impl</span> <span class="n">Error</span> <span class="k">for</span> <span class="n">ErrorOne</span> <span class="p">{}</span>
<span class="p">}</span>
<span class="k">use</span> <span class="nn">error_one</span><span class="p">::</span><span class="n">ErrorOne</span><span class="p">;</span>

<span class="c1">// ErrorTwo.</span>
<span class="k">mod</span> <span class="n">error_two</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="nd">#[derive(Debug)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">ErrorTwo</span><span class="p">;</span>

    <span class="k">impl</span> <span class="n">Display</span> <span class="k">for</span> <span class="n">ErrorTwo</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
            <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"ErrorTwo"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">impl</span> <span class="n">Error</span> <span class="k">for</span> <span class="n">ErrorTwo</span> <span class="p">{}</span>
<span class="p">}</span>
<span class="k">use</span> <span class="nn">error_two</span><span class="p">::</span><span class="n">ErrorTwo</span><span class="p">;</span>
</code></pre></div></div>

<p>In some of the code we will need to make a random decision, so we’ll use the <code class="language-plaintext highlighter-rouge">rand</code> crate to
generate random booleans.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Random boolean generator.</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">random_bool</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="nn">rand</span><span class="p">::</span><span class="nf">random</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here’s the code for the static dispatch approach, using generics, trait bounds, and compiler
monomorphisation.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Static dispatch.</span>
<span class="k">mod</span> <span class="n">static_dispatch</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">mod</span> <span class="n">receives</span> <span class="p">{</span>
        <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="n">accept_error</span><span class="o">&lt;</span><span class="n">E</span><span class="p">:</span> <span class="n">Error</span><span class="o">&gt;</span><span class="p">(</span><span class="n">error</span><span class="p">:</span> <span class="n">E</span><span class="p">)</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Handling ErrorOne Debug: {:?}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Handling ErrorOne Display: {}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">accept_error_with_syntactic_sugar</span><span class="p">(</span><span class="n">error</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Error</span><span class="p">)</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Handling ErrorOne Debug: {:?}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Handling ErrorOne Display: {}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">mod</span> <span class="n">returns</span> <span class="p">{</span>
        <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">return_error_one</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">ErrorOne</span> <span class="p">{</span>
            <span class="n">ErrorOne</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">return_error_two</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">ErrorTwo</span> <span class="p">{</span>
            <span class="n">ErrorTwo</span>
        <span class="p">}</span>

        <span class="c1">// 🚨 DOES NOT WORK! Need dynamic dispatch.</span>
        <span class="c1">// pub fn return_single_error() -&gt; impl Error {</span>
        <span class="c1">//     if random_bool() {</span>
        <span class="c1">//         ErrorOne</span>
        <span class="c1">//     } else {</span>
        <span class="c1">//         ErrorTwo</span>
        <span class="c1">//     }</span>
        <span class="c1">// }</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">return_single_error</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="n">Error</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">ErrorOne</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Finally, here’s the code for the dynamic dispatch approach, using trait objects and vtables to
enable runtime polymorphism.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Dynamic dispatch.</span>
<span class="k">mod</span> <span class="n">dynamic_dispatch</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">mod</span> <span class="n">receives</span> <span class="p">{</span>
        <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">recieve_error_by_ref</span><span class="p">(</span><span class="n">error</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">dyn</span> <span class="n">Error</span><span class="p">)</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Handling Error Debug: {:?}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Handling Error Display: {}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">example_1</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">error_one</span> <span class="o">=</span> <span class="n">ErrorOne</span><span class="p">;</span>
            <span class="nf">recieve_error_by_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">error_one</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">error_two</span> <span class="o">=</span> <span class="n">ErrorTwo</span><span class="p">;</span>
            <span class="nf">recieve_error_by_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">error_two</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">receive_error_by_box</span><span class="p">(</span><span class="n">error</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">Error</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Handling Error Debug: {:?}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Handling Error Display: {}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">example_2</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">error_one</span> <span class="o">=</span> <span class="n">ErrorOne</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">error_one</span><span class="p">);</span>
            <span class="nf">receive_error_by_box</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">error_two</span> <span class="o">=</span> <span class="n">ErrorTwo</span><span class="p">;</span>
            <span class="nf">receive_error_by_box</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">error_two</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">receive_slice_of_errors</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="o">&amp;</span><span class="k">dyn</span> <span class="n">Error</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">for</span> <span class="n">error</span> <span class="k">in</span> <span class="n">arg</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"Handling Error Debug: {:?}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"Handling Error Display: {}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">mod</span> <span class="n">returns</span> <span class="p">{</span>
        <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">return_one_of_two_errors</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nf">random_bool</span><span class="p">()</span> <span class="p">{</span>
                <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">ErrorOne</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">ErrorTwo</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">return_one_of_two_errors_with_arc</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nf">random_bool</span><span class="p">()</span> <span class="p">{</span>
                <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">ErrorOne</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">ErrorTwo</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">return_slice_of_errors</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="k">'static</span> <span class="k">dyn</span> <span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">errors</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="k">dyn</span> <span class="n">Error</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
            <span class="k">if</span> <span class="nf">random_bool</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">errors</span><span class="nf">.push</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ErrorOne</span><span class="p">));</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">errors</span><span class="nf">.push</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ErrorTwo</span><span class="p">));</span>
            <span class="p">}</span>
            <span class="n">errors</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">mut_vec_containing_different_types_of_errors</span><span class="p">(</span><span class="n">mut_vec</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="k">dyn</span> <span class="n">Error</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">mut_vec</span><span class="nf">.push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ErrorOne</span><span class="p">);</span>
            <span class="n">mut_vec</span><span class="nf">.push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ErrorTwo</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</h2>
<p><a id="markdown-build-with-naz-video-series-on-developerlife.com-youtube-channel" name="build-with-naz-video-series-on-developerlife.com-youtube-channel"></a></p>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a>
    <ul>
      <li><a href="https://youtu.be/6LhVx0xM86c">Part 1: Why?</a></li>
      <li><a href="https://youtu.be/3vQJguti02I">Part 2: What?</a></li>
      <li><a href="https://youtu.be/uxgyZzOmVIw">Part 3: Do the refactor and rename the crate</a></li>
      <li><a href="https://www.youtube.com/watch?v=fcb6rstRniI">Part 4: Build the spinner</a></li>
      <li><a href="https://www.youtube.com/watch?v=_QjsGDds270">Part 5: Add color gradient animation to spinner</a></li>
      <li><a href="https://youtu.be/X5wDVaZENOo">Part 6: Publish the crate and overview</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Testing playlist</a>
        <ul>
          <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk">Part 1: Intro</a></li>
          <li><a href="https://www.youtube.com/watch?v=4iM9t5dgvU4">Part 2: Deep dive</a></li>
          <li><a href="https://www.youtube.com/watch?v=kYTgGtJjSro">Part 3: Polymorphism, static and dynamic dispatch</a></li>
        </ul>
      </li>
      <li>Playlists
        <ul>
          <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
          <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><summary type="html"><![CDATA[Learn how to implement effective Rust polymorphism, using `dyn`, `impl`, existing traits, and trait objects for testing and extensibility, in real world projects.]]></summary></entry><entry><title type="html">Build with Naz : Build interactive and non blocking CLI apps with ease in Rust using r3bl_terminal_async</title><link href="http://developerlife.com/2024/04/21/build-async-interactive-cli-apps-in-rust/" rel="alternate" type="text/html" title="Build with Naz : Build interactive and non blocking CLI apps with ease in Rust using r3bl_terminal_async" /><published>2024-04-21T10:00:00-05:00</published><updated>2024-04-21T10:00:00-05:00</updated><id>http://developerlife.com/2024/04/21/build-async-interactive-cli-apps-in-rust</id><content type="html" xml:base="http://developerlife.com/2024/04/21/build-async-interactive-cli-apps-in-rust/"><![CDATA[<p><img class="post-hero-image" src="/assets/r3bl_terminal_async-hero.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#why-use-this-crate">Why use this crate</a></li>
  <li><a href="#demo-of-this-in-action">Demo of this in action</a></li>
  <li><a href="#example-of-using-this-crate">Example of using this crate</a></li>
  <li><a href="#video-series-on-developerlifecom-youtube-channel-on-building-this-crate-with-naz">Video series on developerlife.com YouTube channel on building this crate with Naz</a></li>
</ul>

<!-- /TOC -->

<p>The <code class="language-plaintext highlighter-rouge">r3bl_terminal_async</code> library lets your CLI program be asynchronous and interactive without
blocking the main thread. Your spawned tasks can use it to concurrently write to the display output,
pause and resume it. You can also display of colorful animated spinners ⌛🌈 for long running tasks.
With it, you can create beautiful, powerful, and interactive REPLs (read execute print loops) with
ease.</p>

<h2 id="why-use-this-crate">Why use this crate</h2>

<p><a id="markdown-why-use-this-crate" name="why-use-this-crate"></a></p>

<ul>
  <li>Because <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line">read_line()</a> is
blocking. And there is no way to terminate an OS thread that is blocking in Rust. To do this you
have to exit the process (who’s thread is blocked in <code class="language-plaintext highlighter-rouge">read_line()</code>).</li>
  <li>Another annoyance is that when a thread is blocked in <code class="language-plaintext highlighter-rouge">read_line()</code>, and you have to display
output to stdout concurrently, this poses some challenges.</li>
</ul>

<h2 id="demo-of-this-in-action">Demo of this in action</h2>

<p><a id="markdown-demo-of-this-in-action" name="demo-of-this-in-action"></a></p>

<p>Here’s a screen capture of the types of interactive REPLs that you can expect to build in Rust,
using this crate.</p>

<p><img src="https://github.com/r3bl-org/r3bl-open-core/blob/main/terminal_async/docs/r3bl_terminal_async_clip_ffmpeg.gif?raw=true" alt="" /></p>

<p>A couple of things to note about this demo:</p>

<ol>
  <li>You can use up, down to access history in the multi-line editor.</li>
  <li>You can use left, right, ctrl+left, ctrl+right, to jump around in the multi-line editor.</li>
  <li>You can edit content in this multi-line editor without blocking the main thread, and while other
tasks (started via <code class="language-plaintext highlighter-rouge">tokio::spawn</code> are concurrently producing output to the display.</li>
  <li>You can pause the output while spinners are being displayed, and these spinners support many
different kinds of animations!</li>
</ol>

<h2 id="example-of-using-this-crate">Example of using this crate</h2>

<p><a id="markdown-example-of-using-this-crate" name="example-of-using-this-crate"></a></p>

<p>There are great examples in the <code class="language-plaintext highlighter-rouge">examples</code> folder of the repo
<a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/terminal_async/examples">here</a>. Let’s walk
through a simple example of using this crate. Let’s create a new example using the following
commands:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo new <span class="nt">--bin</span> async-cli
<span class="nb">cd </span>async-cli
cargo add r3bl_terminal_async
cargo add miette <span class="nt">--features</span> fancy
cargo add tokio <span class="nt">--features</span> full
</code></pre></div></div>

<p>Now, let’s add a <code class="language-plaintext highlighter-rouge">main.rs</code> file in the <code class="language-plaintext highlighter-rouge">src</code> folder.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="n">Duration</span><span class="p">;</span>

<span class="k">use</span> <span class="nn">r3bl_terminal_async</span><span class="p">::{</span><span class="n">tracing_setup</span><span class="p">,</span> <span class="n">TerminalAsync</span><span class="p">,</span> <span class="n">TracingConfig</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="n">interval</span><span class="p">;</span>

<span class="nd">#[tokio::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">maybe_terminal_async</span> <span class="o">=</span> <span class="nn">TerminalAsync</span><span class="p">::</span><span class="nf">try_new</span><span class="p">(</span><span class="s">"&gt; "</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// If the terminal is not fully interactive, then return early.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">terminal_async</span> <span class="o">=</span> <span class="k">match</span> <span class="n">maybe_terminal_async</span> <span class="p">{</span>
        <span class="nb">None</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nf">Ok</span><span class="p">(()),</span>
        <span class="n">_</span> <span class="k">=&gt;</span> <span class="n">maybe_terminal_async</span><span class="nf">.unwrap</span><span class="p">(),</span>
    <span class="p">};</span>

    <span class="c1">// Initialize tracing w/ the "async stdout".</span>
    <span class="nn">tracing_setup</span><span class="p">::</span><span class="nf">init</span><span class="p">(</span><span class="nn">TracingConfig</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span>
        <span class="n">terminal_async</span><span class="nf">.clone_shared_writer</span><span class="p">(),</span>
    <span class="p">)))</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Start tasks.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">interval_1_task</span> <span class="o">=</span> <span class="nf">interval</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">interval_2_task</span> <span class="o">=</span> <span class="nf">interval</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>

    <span class="n">terminal_async</span>
        <span class="nf">.println</span><span class="p">(</span><span class="s">"Welcome to your async repl! press Ctrl+D or Ctrl+C to exit."</span><span class="p">)</span>
        <span class="k">.await</span><span class="p">;</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span> <span class="p">{</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">interval_1_task</span><span class="nf">.tick</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">terminal_async</span><span class="nf">.println</span><span class="p">(</span><span class="s">"interval_1_task ticked"</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
            <span class="p">},</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">interval_2_task</span><span class="nf">.tick</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">terminal_async</span><span class="nf">.println</span><span class="p">(</span><span class="s">"interval_1_task ticked"</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
            <span class="p">},</span>
            <span class="n">user_input</span> <span class="o">=</span> <span class="n">terminal_async</span><span class="nf">.get_readline_event</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="k">match</span> <span class="n">user_input</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">readline_event</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">match</span> <span class="n">readline_event</span> <span class="p">{</span>
                        <span class="nn">r3bl_terminal_async</span><span class="p">::</span><span class="nn">ReadlineEvent</span><span class="p">::</span><span class="n">Eof</span> <span class="k">=&gt;</span> <span class="k">break</span><span class="p">,</span>
                        <span class="nn">r3bl_terminal_async</span><span class="p">::</span><span class="nn">ReadlineEvent</span><span class="p">::</span><span class="n">Interrupted</span> <span class="k">=&gt;</span> <span class="k">break</span><span class="p">,</span>
                        <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">(),</span>
                    <span class="p">}</span>

                    <span class="k">let</span> <span class="n">msg</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">readline_event</span><span class="p">);</span>
                    <span class="n">terminal_async</span><span class="nf">.println</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
                <span class="p">},</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="n">msg</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"Received err: {:?}. Exiting."</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
                    <span class="n">terminal_async</span><span class="nf">.println</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">},</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Flush all writers to stdout</span>
    <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="n">terminal_async</span><span class="nf">.flush</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>You can then run this program using <code class="language-plaintext highlighter-rouge">cargo run</code>. Play with it to get a sense of the asynchronous and
non blocking nature of the REPL. Press Ctrl+C, or Ctrl+D to exit this program.</p>

<h2 id="video-series-on-developerlifecom-youtube-channel-on-building-this-crate-with-naz">Video series on developerlife.com YouTube channel on building this crate with Naz</h2>

<p><a id="markdown-video-series-on-developerlife.com-youtube-channel-on-building-this-crate-with-naz" name="video-series-on-developerlife.com-youtube-channel-on-building-this-crate-with-naz"></a></p>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<p>Here’s the video that is tied to this blog post:</p>

<iframe src="https://www.youtube.com/embed/X5wDVaZENOo?si=yYfXuCxSilWh4Gd5" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a>
    <ul>
      <li><a href="https://youtu.be/6LhVx0xM86c">Part 1: Why?</a></li>
      <li><a href="https://youtu.be/3vQJguti02I">Part 2: What?</a></li>
      <li><a href="https://youtu.be/uxgyZzOmVIw">Part 3: Do the refactor and rename the crate</a></li>
      <li><a href="https://www.youtube.com/watch?v=fcb6rstRniI">Part 4: Build the spinner</a></li>
      <li><a href="https://www.youtube.com/watch?v=_QjsGDds270">Part 5: Add color gradient animation to spinner</a></li>
      <li><a href="https://youtu.be/X5wDVaZENOo">Part 6: Publish the crate and overview</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Testing playlist</a>
        <ul>
          <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk">Part 1: Intro</a></li>
          <li><a href="https://www.youtube.com/watch?v=4iM9t5dgvU4">Part 2: Deep dive</a></li>
        </ul>
      </li>
      <li>Playlists
        <ul>
          <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
          <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><summary type="html"><![CDATA[The r3bl_terminal_async library lets your CLI program be asynchronous and interactive without blocking the main thread. Your spawned tasks can use it to concurrently write to the display output, pause and resume it. You can also display of colorful animated spinners ⌛🌈 for long running tasks. With it, you can create beautiful, powerful, and interactive REPLs (read execute print loops) with ease.]]></summary></entry><entry><title type="html">Write a simple TCP chat server in Rust</title><link href="http://developerlife.com/2024/01/13/write-simple-chat-server-in-rust/" rel="alternate" type="text/html" title="Write a simple TCP chat server in Rust" /><published>2024-01-13T09:00:00-06:00</published><updated>2024-01-13T09:00:00-06:00</updated><id>http://developerlife.com/2024/01/13/write-simple-chat-server-in-rust</id><content type="html" xml:base="http://developerlife.com/2024/01/13/write-simple-chat-server-in-rust/"><![CDATA[<p><img class="post-hero-image" src="/assets/chatserver-hero.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#build-a-chat-server-using-tokio">Build a chat server using Tokio</a></li>
  <li><a href="#the-chat-server-comprises-all-these-pieces">The chat server comprises all these pieces</a></li>
  <li><a href="#add-dependencies-to-cargotoml">Add dependencies to Cargo.toml</a></li>
  <li><a href="#main-function">Main function</a>
    <ul>
      <li><a href="#tokiospawn-does-not-spawn-a-new-thread-so-what-does-it-actually-do">tokio::spawn does not spawn a new thread, so what does it actually do?</a></li>
    </ul>
  </li>
  <li><a href="#handle-client-task-function">Handle client task function</a>
    <ul>
      <li><a href="#two-concurrent-tasks-in-the-tokioselect-block">Two concurrent tasks in the tokio::select! block</a></li>
      <li><a href="#handle-read-from-broadcast-channel-function">Handle read from broadcast channel function</a></li>
      <li><a href="#handle-socket-read-function">Handle socket read function</a></li>
    </ul>
  </li>
  <li><a href="#next-steps">Next steps</a></li>
</ul>

<!-- /TOC -->

<h2 id="build-a-chat-server-using-tokio">Build a chat server using Tokio</h2>
<p><a id="markdown-build-a-chat-server-using-tokio" name="build-a-chat-server-using-tokio"></a></p>

<p>In this tutorial we will build a simple chat server using Tokio. The server will be able
to handle multiple clients, and each client will be able to send messages to the server,
which will then broadcast the message to all other connected clients.</p>

<ul>
  <li>We will use Tokio’s <code class="language-plaintext highlighter-rouge">tokio::net::TcpListener</code> and <code class="language-plaintext highlighter-rouge">tokio::net::TcpStream</code> to create a
TCP server that listens for incoming connections and handles them concurrently.</li>
  <li>We will also use Tokio’s <code class="language-plaintext highlighter-rouge">tokio::sync::broadcast</code> to broadcast messages to all connected
clients.</li>
</ul>

<p>Read <a href="/2024/01/13/write-simple-netcat-in-rust/">this tutorial</a> to
learn more about the basics of TCP client and server programming in Rust (without using
Tokio).</p>

<!--
simple-netcat-in-rust video
Source: https://github.com/nazmulidris/developerlife.com/issues/4
-->
<blockquote>
  <p>Here’s a video of the app that we are going to build in action.</p>
  <video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/14ce32ce-0988-4853-acd5-1174b1864d57" type="video/mp4" />
</video>
</blockquote>
<blockquote>

👀 Watch Rust 🦀 live coding videos on our <a href="https://www.youtube.com/@developerlifecom">YouTube Channel</a>.

<br />
<br />

<!-- video on rust polymorphism (no playlist) -->
<iframe src="https://www.youtube.com/embed/kYTgGtJjSro?si=XmW-_CAvCfB5e269" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<br />
<br />

📦 Install our useful Rust command line apps using <code>cargo install r3bl-cmdr</code>
(they are from the <a href="https://github.com/r3bl-org/r3bl-open-core">r3bl-open-core</a>
project):
<ul>
  <li>🐱<code>giti</code>: run interactive git commands with confidence in your terminal</li>
  <li>🦜<code>edi</code>: edit Markdown with style in your terminal</li>
</ul>

<p>
<kbd>giti in action</kbd>
<video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/262f59d1-a95c-4af3-accf-c3d6cac6e586" type="video/mp4" />
</video>
</p>

<p>
<kbd>edi in action</kbd>
<video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/f2c4b07d-b5a2-4f41-af7a-06d1b6660c41" type="video/mp4" />
</video>
</p>

</blockquote>
<blockquote>
  <p>You can find the finished source code for this tutorial
<a href="https://github.com/nazmulidris/rust-scratch/tree/main/tcp-server-netcat-client">here</a>.</p>
</blockquote>

<h2 id="the-chat-server-comprises-all-these-pieces">The chat server comprises all these pieces</h2>
<p><a id="markdown-the-chat-server-comprises-all-these-pieces" name="the-chat-server-comprises-all-these-pieces"></a></p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   ┌─CLIENT-1───────┐      ┌─CLIENT─2───────┐        ┌─CLIENT─3──────┐
   │                │      │                │        │               │
   └───────┼────────┘      └──────┼─────────┘        └─────┼─────────┘
           │                      │                        │
┌─SERVER───┼──────────────────────┼────────────────────────┼────────────┐
│          │                      │                        │            │
│                                                                       │
│ handle_client_task()   handle_client_task()    handle_client_task()   │
│ ┌───────────────────┐ ┌────────────────────┐  ┌─────────────────────┐ │
│ │   ┌────┐ ┌────┐   │ │   ┌────┐ ┌────┐    │  │    ┌────┐ ┌────┐    │ │
│ │   │ TX │ │ RX │   │ │   │ TX │ │ RX │    │  │    │ TX │ │ RX │    │ │
│ │   └─┬──┘ └─▲──┘   │ │   └─┬──┘ └─▲──┘    │  │    └─┬──┘ └─▲──┘    │ │
│ │     │      │      │ │     │      │       │  │      │      │       │ │
│ └─────┼──────┼──────┘ └─────┼──────┼───────┘  └──────┼──────┼───────┘ │
│       │      │              │      │                 │      │         │
│       │      │              │      │                 │      │         │
│ ┌─────▼──────┴──────────────▼──────┴─────────────────▼──────┴───────┐ │
│ │                    (TX, RX) = channel::broadcast()                │ │
│ └───────────────────────────────────────────────────────────────────┘ │
└───────────────────────────────────────────────────────────────────────┘
</code></pre></div></div>

<!-- Diagram source
https://asciiflow.com/#/share/eJztVs1Kw0AQfpVlTy1E0ApiA54kB0E8xCI5LJTYBhRjhDZCSylIzh56CCXP4TlP0ydxwzbtbnY2bdL1p9VhApOdmW9mv0yWneDAffawGbz6voF9d%2BwNsIknBI8INtvnxwbBY2q1ztrUCr1RSF8IRpks4pTq5fWVddM5OmFvsqKlLOL3RfzGoqnRog%2BkM0X8qSqekCDvBhVEqB7J3qjcexjIAqCMzbcAoRf8B4RfQ9dAMTSLqWJGmSa7ZeedA2QUpcSV%2BSgS286tZd9Zdj0q9kXZZvUQp%2BRSmVRTeOAHN%2Bj7XrfnP3pB2A3d4VOjyaKUHnUKD6yFXpQf1LvpTBtMcYsl3xI4QZfeaIPzZ4oA7IMfRCwu8TqDlgpNVU6CmkUdZ2XaDoKbi1gUM22Ho4RrZkNQBabmH2VMxeJBnORLWVa%2BJDVXMQmYnVUzwijx86OKiLYI%2BC%2F45QU1naP8tSAVf7aSRV4TbTDCFpGSDrSNV%2B389iIC7XOtdw2NaHWh5M3KJGbS6DgGPUeb6AL16GUh8HzTvB%2B8uP2eOwzzuwLArvax%2F7UKzKY22WPgP6gET%2FH0Ex1Q3VY%3D)
-->

<p>The server has a <code class="language-plaintext highlighter-rouge">main</code> function that creates a <code class="language-plaintext highlighter-rouge">tokio::net::TcpListener</code> and listens for
incoming connections. When a new connection is received, it spawns a new task to handle
the connection using <code class="language-plaintext highlighter-rouge">tokio::spawn()</code>.</p>

<p>Using <code class="language-plaintext highlighter-rouge">tokio::select!</code>, the task tries to do the following concurrently, and waits until
one of them completes:</p>
<ol>
  <li>The task reads messages from its client and broadcasts them to all other connected
clients. It also echoes the message back to its client.</li>
  <li>The task listens for messages from other clients and sends them to its client.</li>
</ol>

<p>When one task above completes, the other is dropped. Then the code path with the completed
task executes. Then the code returns to the infinite loop, if it hasn’t returned already.</p>

<p>A client can be any TCP client, such as <code class="language-plaintext highlighter-rouge">telnet</code>, <code class="language-plaintext highlighter-rouge">nc</code>, or PuTTY.</p>

<h2 id="add-dependencies-to-cargotoml">Add dependencies to Cargo.toml</h2>
<p><a id="markdown-add-dependencies-to-cargo.toml" name="add-dependencies-to-cargo.toml"></a></p>

<p>Let’s create a new project by running <code class="language-plaintext highlighter-rouge">cargo create --bin tcp-server-netcat-client</code>. Then
we will add the following dependencies to our <code class="language-plaintext highlighter-rouge">Cargo.toml</code> file.</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># tokio.</span>
<span class="py">tokio</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"1.35.1"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"full"</span><span class="p">]</span> <span class="p">}</span>

<span class="c"># stdout logging.</span>
<span class="py">femme</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"2.2.1"</span> <span class="p">}</span>
<span class="py">log</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.4.20"</span> <span class="p">}</span>

<span class="c"># r3bl_rs_utils_core - friendly name generator.</span>
<span class="py">r3bl_rs_utils_core</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.9.12"</span> <span class="p">}</span>
<span class="py">r3bl_tui</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.5.1"</span> <span class="p">}</span>
</code></pre></div></div>

<h2 id="main-function">Main function</h2>
<p><a id="markdown-main-function" name="main-function"></a></p>

<p>We will implement the following algorithm for our server in our main function:</p>
<ol>
  <li>Create a broadcast channel. It will be shared by all the client tasks.</li>
  <li>Create <code class="language-plaintext highlighter-rouge">TcpListener</code> and bind to an address &amp; port.</li>
  <li>Loop:
    <ul>
      <li>Accept socket connection, and get its <code class="language-plaintext highlighter-rouge">TCPStream</code>.</li>
      <li>Use <code class="language-plaintext highlighter-rouge">tokio::spawn()</code> to spawn a task to handle this client connection and its
<code class="language-plaintext highlighter-rouge">TCPStream</code>.</li>
    </ul>
  </li>
</ol>

<p>In the task that handles the connection:</p>
<ol>
  <li>Get <code class="language-plaintext highlighter-rouge">BufReader</code> &amp; <code class="language-plaintext highlighter-rouge">BufWriter</code> from the <code class="language-plaintext highlighter-rouge">TCPStream</code>. The reader and writer allow us to
read data from and write data to the client socket.</li>
  <li>Loop:
    <ul>
      <li>Use <code class="language-plaintext highlighter-rouge">tokio::select!</code> to concurrently:
        <ul>
          <li>Read from broadcast channel (via <code class="language-plaintext highlighter-rouge">recv()</code>):
            <ul>
              <li>Send the message to the client (only if it is from a different client) over the
socket (use <code class="language-plaintext highlighter-rouge">BufWriter</code> to write the message).</li>
            </ul>
          </li>
          <li>Read from socket (via <code class="language-plaintext highlighter-rouge">BufReader::read_line()</code>):
            <ul>
              <li>Read <code class="language-plaintext highlighter-rouge">incoming</code> from reader.</li>
              <li>Call <code class="language-plaintext highlighter-rouge">process(incoming)</code> and generate <code class="language-plaintext highlighter-rouge">outgoing</code>. This colorizes the <code class="language-plaintext highlighter-rouge">incoming</code>
message with a lolcat effect to generate the <code class="language-plaintext highlighter-rouge">outgoing</code> message.</li>
              <li>Send <code class="language-plaintext highlighter-rouge">incoming</code> message to other connected clients (via the broadcast channel).</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<blockquote>
  <p>You can find the finished source code for this tutorial
<a href="https://github.com/nazmulidris/rust-scratch/tree/main/tcp-server-netcat-client">here</a>.</p>
</blockquote>

<p>Here’s the code for the main function, and some supporting type aliases and structs:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">type</span> <span class="n">IOResult</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">MsgType</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">socket_addr</span><span class="p">:</span> <span class="n">SocketAddr</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">payload</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">from_id</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[tokio::main]</span>
<span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">IOResult</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">addr</span> <span class="o">=</span> <span class="s">"127.0.0.1:3000"</span><span class="p">;</span>

    <span class="c1">// Start logging.</span>
    <span class="nn">femme</span><span class="p">::</span><span class="nf">start</span><span class="p">();</span>

    <span class="c1">// Create TCP listener.</span>
    <span class="k">let</span> <span class="n">tcp_listener</span> <span class="o">=</span> <span class="nn">TcpListener</span><span class="p">::</span><span class="nf">bind</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
    <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"Server is ready to accept connections on {}"</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

    <span class="c1">// Create channel shared among all clients that connect to the server loop.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="nn">broadcast</span><span class="p">::</span><span class="nn">channel</span><span class="p">::</span><span class="o">&lt;</span><span class="n">MsgType</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

    <span class="c1">// Server loop.</span>
    <span class="k">loop</span> <span class="p">{</span>
        <span class="c1">// Accept incoming socket connections.</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">tcp_stream</span><span class="p">,</span> <span class="n">socket_addr</span><span class="p">)</span> <span class="o">=</span> <span class="n">tcp_listener</span><span class="nf">.accept</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>

        <span class="k">let</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">tx</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">handle_client_task</span><span class="p">(</span><span class="n">tcp_stream</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="n">socket_addr</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
            <span class="k">match</span> <span class="n">result</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"handle_client_task() terminated gracefully"</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="nf">Err</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">log</span><span class="p">::</span><span class="nd">error!</span><span class="p">(</span><span class="s">"handle_client_task() encountered error: {}"</span><span class="p">,</span> <span class="n">error</span><span class="p">),</span>
            <span class="p">}</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To run the server, you can run <code class="language-plaintext highlighter-rouge">cargo run</code>. There are no command line arguments to pass or
parse.</p>

<h3 id="tokiospawn-does-not-spawn-a-new-thread-so-what-does-it-actually-do">tokio::spawn does not spawn a new thread, so what does it actually do?</h3>
<p><a id="markdown-tokio%3A%3Aspawn-does-not-spawn-a-new-thread%2C-so-what-does-it-actually-do%3F" name="tokio%3A%3Aspawn-does-not-spawn-a-new-thread%2C-so-what-does-it-actually-do%3F"></a></p>

<p>Since <code class="language-plaintext highlighter-rouge">tokio::spawn</code> sounds similar to <code class="language-plaintext highlighter-rouge">thread::spawn</code> it might be easy to assume that
<code class="language-plaintext highlighter-rouge">tokio::spawn</code> creates a new thread. This would go against the idea of even using tokio
(which is all about concurrency and non blocking IO), since handling one connection per
thread isn’t <a href="https://g.co/bard/share/74f433bad400">scalable</a>, which is what we did in
this tutorial: <a href="/2024/01/13/write-simple-netcat-in-rust/">Write a simple TCP chat server in Rust</a>.</p>

<p><code class="language-plaintext highlighter-rouge">tokio::spawn</code> does not create a thread; it creates a Tokio task, which is a
co-operatively scheduled entity that Tokio knows how to schedule on the Tokio runtime (in
turn, the Tokio runtime can have as many worker threads as you want - from 1 upwards).</p>

<p>By using <code class="language-plaintext highlighter-rouge">tokio::spawn</code>, you allow the Tokio runtime to switch to another task at points
in the task where it has a <code class="language-plaintext highlighter-rouge">.await</code>, and only those points. Your alternative, if you don’t
want multiple tasks, is to use things like <code class="language-plaintext highlighter-rouge">select!</code>, <code class="language-plaintext highlighter-rouge">join!</code> and functions with <code class="language-plaintext highlighter-rouge">select</code>
or ` join` in their name to have concurrent I/O in a single task.</p>

<p>The point of spawning in Tokio is twofold:</p>

<ol>
  <li>If your runtime has multiple threads, then two tasks can execute in parallel on
different threads, reducing latency.</li>
  <li>It is almost always easier to understand a complex program in terms of different tasks
doing their work, than in terms of a single large task doing lots of work concurrently
(e.g. using <code class="language-plaintext highlighter-rouge">select</code> to wait for one of many options, or <code class="language-plaintext highlighter-rouge">join</code> to wait for all options
to finish).</li>
</ol>

<p>More information:</p>
<ol>
  <li>You can get more info on this topic
 <a href="https://users.rust-lang.org/t/socket-per-thread-in-tokio/83712/7">here</a>.</li>
  <li>For an even deeper dive into how Tokio tasks themselves are implemented for intra-task
concurrency, please take a look at this <a href="https://without.boats/blog/let-futures-be-futures/">excellent
article</a>.</li>
</ol>

<h2 id="handle-client-task-function">Handle client task function</h2>
<p><a id="markdown-handle-client-task-function" name="handle-client-task-function"></a></p>

<p>The <code class="language-plaintext highlighter-rouge">handle_client_task</code> function is where all the magic happens.</p>
<ol>
  <li>It reads messages from its client (over TCP socket) and broadcasts them to all other
connected clients.</li>
  <li>It processes the message from its client and echoes it back to its client (over TCP
socket).</li>
  <li>It reads messages from other clients (over broadcast channel) and sends them to its
client (over socket).</li>
</ol>

<p>Here’s the code for the <code class="language-plaintext highlighter-rouge">handle_client_task()</code> function:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">fn</span> <span class="nf">handle_client_task</span><span class="p">(</span>
    <span class="k">mut</span> <span class="n">tcp_stream</span><span class="p">:</span> <span class="n">TcpStream</span><span class="p">,</span>
    <span class="n">tx</span><span class="p">:</span> <span class="n">Sender</span><span class="o">&lt;</span><span class="n">MsgType</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">socket_addr</span><span class="p">:</span> <span class="n">SocketAddr</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IOResult</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"Handle socket connection from client"</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">id</span> <span class="o">=</span> <span class="nn">friendly_random_id</span><span class="p">::</span><span class="nf">generate_friendly_random_id</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">tx</span><span class="nf">.subscribe</span><span class="p">();</span>

    <span class="c1">// Set up buf reader and writer.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="n">writer</span><span class="p">)</span> <span class="o">=</span> <span class="n">tcp_stream</span><span class="nf">.split</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">reader</span> <span class="o">=</span> <span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">reader</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">writer</span> <span class="o">=</span> <span class="nn">BufWriter</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">writer</span><span class="p">);</span>

    <span class="c1">// Send welcome message to client w/ ids.</span>
    <span class="k">let</span> <span class="n">welcome_msg_for_client</span> <span class="o">=</span>
        <span class="nn">ColorWheel</span><span class="p">::</span><span class="nf">lolcat_into_string</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span><span class="s">"addr: {}, id: {}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">socket_addr</span><span class="p">,</span> <span class="n">id</span><span class="p">));</span>
    <span class="n">writer</span><span class="nf">.write</span><span class="p">(</span><span class="n">welcome_msg_for_client</span><span class="nf">.as_bytes</span><span class="p">())</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
    <span class="n">writer</span><span class="nf">.flush</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">incoming</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">tx</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span> <span class="p">{</span>
            <span class="c1">// Read from broadcast channel.</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">rx</span><span class="nf">.recv</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nf">read_from_broadcast_channel</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">socket_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">writer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// Read from socket.</span>
            <span class="n">network_read_result</span> <span class="o">=</span> <span class="n">reader</span><span class="nf">.read_line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">incoming</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">num_bytes_read</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="n">network_read_result</span><span class="o">?</span><span class="p">;</span>
                <span class="c1">// EOF check.</span>
                <span class="k">if</span> <span class="n">num_bytes_read</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="nf">handle_socket_read</span><span class="p">(</span><span class="n">num_bytes_read</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">incoming</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">writer</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="n">socket_addr</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
                <span class="n">incoming</span><span class="nf">.clear</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="two-concurrent-tasks-in-the-tokioselect-block">Two concurrent tasks in the tokio::select! block</h3>
<p><a id="markdown-two-concurrent-tasks-in-the-tokio%3A%3Aselect!-block" name="two-concurrent-tasks-in-the-tokio%3A%3Aselect!-block"></a></p>

<ol>
  <li>Read from broadcast channel. The function <code class="language-plaintext highlighter-rouge">read_from_broadcast_channel()</code> does this work.</li>
  <li>Read from socket. The function <code class="language-plaintext highlighter-rouge">handle_socket_read()</code> does this work.</li>
</ol>

<p>Whichever task completes first, the <code class="language-plaintext highlighter-rouge">tokio::select!</code> block will go down that code path,
and drop the other task.</p>

<h3 id="handle-read-from-broadcast-channel-function">Handle read from broadcast channel function</h3>
<p><a id="markdown-handle-read-from-broadcast-channel-function" name="handle-read-from-broadcast-channel-function"></a></p>

<p>Here’s the code for the <code class="language-plaintext highlighter-rouge">read_from_broadcast_channel()</code> function:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">fn</span> <span class="nf">read_from_broadcast_channel</span><span class="p">(</span>
    <span class="n">result</span><span class="p">:</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">MsgType</span><span class="p">,</span> <span class="n">RecvError</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">socket_addr</span><span class="p">:</span> <span class="n">SocketAddr</span><span class="p">,</span>
    <span class="n">writer</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">BufWriter</span><span class="o">&lt;</span><span class="n">WriteHalf</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">id</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IOResult</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">result</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">msg</span><span class="p">:</span> <span class="n">MsgType</span> <span class="o">=</span> <span class="n">it</span><span class="p">;</span>
            <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"[{}]: channel: {:?}"</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
            <span class="k">if</span> <span class="n">msg</span><span class="py">.socket_addr</span> <span class="o">!=</span> <span class="n">socket_addr</span> <span class="p">{</span>
                <span class="n">writer</span><span class="nf">.write</span><span class="p">(</span><span class="n">msg</span><span class="py">.payload</span><span class="nf">.as_bytes</span><span class="p">())</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
                <span class="n">writer</span><span class="nf">.flush</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nf">Err</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">log</span><span class="p">::</span><span class="nd">error!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="handle-socket-read-function">Handle socket read function</h3>
<p><a id="markdown-handle-socket-read-function" name="handle-socket-read-function"></a></p>

<p>Here’s the code for the <code class="language-plaintext highlighter-rouge">handle_socket_read()</code> function:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">fn</span> <span class="nf">handle_socket_read</span><span class="p">(</span>
    <span class="n">num_bytes_read</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">id</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
    <span class="n">incoming</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
    <span class="n">writer</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">BufWriter</span><span class="o">&lt;</span><span class="n">WriteHalf</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">tx</span><span class="p">:</span> <span class="n">Sender</span><span class="o">&lt;</span><span class="n">MsgType</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">socket_addr</span><span class="p">:</span> <span class="n">SocketAddr</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IOResult</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span>
        <span class="s">"[{}]: incoming: {}, size: {}"</span><span class="p">,</span>
        <span class="n">id</span><span class="p">,</span>
        <span class="n">incoming</span><span class="nf">.trim</span><span class="p">(),</span>
        <span class="n">num_bytes_read</span>
    <span class="p">);</span>

    <span class="c1">// Process incoming -&gt; outgoing.</span>
    <span class="k">let</span> <span class="n">outgoing</span> <span class="o">=</span> <span class="nf">process</span><span class="p">(</span><span class="o">&amp;</span><span class="n">incoming</span><span class="p">);</span>

    <span class="c1">// outgoing -&gt; Writer.</span>
    <span class="n">writer</span><span class="nf">.write</span><span class="p">(</span><span class="n">outgoing</span><span class="nf">.as_bytes</span><span class="p">())</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
    <span class="n">writer</span><span class="nf">.flush</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Broadcast outgoing to the channel.</span>
    <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="n">tx</span><span class="nf">.send</span><span class="p">(</span><span class="n">MsgType</span> <span class="p">{</span>
        <span class="n">socket_addr</span><span class="p">,</span>
        <span class="n">payload</span><span class="p">:</span> <span class="n">incoming</span><span class="nf">.to_string</span><span class="p">(),</span>
        <span class="n">from_id</span><span class="p">:</span> <span class="n">id</span><span class="nf">.to_string</span><span class="p">(),</span>
    <span class="p">});</span>

    <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span>
        <span class="s">"[{}]: outgoing: {}, size: {}"</span><span class="p">,</span>
        <span class="n">id</span><span class="p">,</span>
        <span class="n">outgoing</span><span class="nf">.trim</span><span class="p">(),</span>
        <span class="n">num_bytes_read</span>
    <span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">process</span><span class="p">(</span><span class="n">incoming</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="c1">// Remove new line from incoming.</span>
    <span class="k">let</span> <span class="n">incoming_trimmed</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">incoming</span><span class="nf">.trim</span><span class="p">());</span>
    <span class="c1">// Colorize it.</span>
    <span class="k">let</span> <span class="n">outgoing</span> <span class="o">=</span> <span class="nn">ColorWheel</span><span class="p">::</span><span class="nf">lolcat_into_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">incoming_trimmed</span><span class="p">);</span>
    <span class="c1">// Add new line back to outgoing.</span>
    <span class="nd">format!</span><span class="p">(</span><span class="s">"{}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">outgoing</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="next-steps">Next steps</h2>
<p><a id="markdown-next-steps" name="next-steps"></a></p>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><summary type="html"><![CDATA[A guide on how to create write a simple TCP chat server in Rust using Tokio]]></summary></entry><entry><title type="html">Write a simple netcat client and server in Rust</title><link href="http://developerlife.com/2024/01/13/write-simple-netcat-in-rust/" rel="alternate" type="text/html" title="Write a simple netcat client and server in Rust" /><published>2024-01-13T09:00:00-06:00</published><updated>2024-01-13T09:00:00-06:00</updated><id>http://developerlife.com/2024/01/13/write-simple-netcat-in-rust</id><content type="html" xml:base="http://developerlife.com/2024/01/13/write-simple-netcat-in-rust/"><![CDATA[<p><img class="post-hero-image" src="/assets/netcat-hero.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#build-a-swiss-army-knife-for-networking">Build a Swiss Army knife for networking</a></li>
  <li><a href="#add-dependencies-to-cargotoml">Add dependencies to Cargo.toml</a></li>
  <li><a href="#configure-clap-to-parse-command-line-arguments">Configure clap to parse command line arguments</a></li>
  <li><a href="#create-the-client">Create the client</a></li>
  <li><a href="#create-the-server">Create the server</a></li>
  <li><a href="#next-steps">Next steps</a></li>
</ul>

<!-- /TOC -->

<h2 id="build-a-swiss-army-knife-for-networking">Build a Swiss Army knife for networking</h2>
<p><a id="markdown-build-a-swiss-army-knife-for-networking" name="build-a-swiss-army-knife-for-networking"></a></p>

<p>In this tutorial we will learn how to use Rust to write a simple netcat client and server
using the standard library only. A netcat client is like a Swiss Army knife for
networking. It is similar to PuTTY and telnet. You can use it to connect to a server and
send and receive data. We will create an app that can behave both as a client and server.</p>

<ol>
  <li>Our client will allow the user to type a message and send it to any TCP socket server,
and display the response from the server, in an endless loop.</li>
  <li>Our server will listen for incoming TCP connections from clients, and display the
message from the client, and send a response back to the client.</li>
</ol>

<!--
simple-netcat-in-rust video
Source: https://github.com/nazmulidris/developerlife.com/issues/3
-->
<blockquote>
  <p>Here’s a video of the app that we are going to build in action.</p>
  <video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/ffe83b3e-6997-4afc-bdf3-5d867f995611" type="video/mp4" />
</video>
</blockquote>
<blockquote>

👀 Watch Rust 🦀 live coding videos on our <a href="https://www.youtube.com/@developerlifecom">YouTube Channel</a>.

<br />
<br />

<!-- video on rust polymorphism (no playlist) -->
<iframe src="https://www.youtube.com/embed/kYTgGtJjSro?si=XmW-_CAvCfB5e269" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<br />
<br />

📦 Install our useful Rust command line apps using <code>cargo install r3bl-cmdr</code>
(they are from the <a href="https://github.com/r3bl-org/r3bl-open-core">r3bl-open-core</a>
project):
<ul>
  <li>🐱<code>giti</code>: run interactive git commands with confidence in your terminal</li>
  <li>🦜<code>edi</code>: edit Markdown with style in your terminal</li>
</ul>

<p>
<kbd>giti in action</kbd>
<video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/262f59d1-a95c-4af3-accf-c3d6cac6e586" type="video/mp4" />
</video>
</p>

<p>
<kbd>edi in action</kbd>
<video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/f2c4b07d-b5a2-4f41-af7a-06d1b6660c41" type="video/mp4" />
</video>
</p>

</blockquote>
<blockquote>
  <p>You can find the finished source code for this tutorial
<a href="https://github.com/nazmulidris/rust-scratch/tree/main/rtelnet">here</a>.</p>
</blockquote>

<h2 id="add-dependencies-to-cargotoml">Add dependencies to Cargo.toml</h2>
<p><a id="markdown-add-dependencies-to-cargo.toml" name="add-dependencies-to-cargo.toml"></a></p>

<p>Let’s create a new project by running <code class="language-plaintext highlighter-rouge">cargo create --bin rtelnet</code>. Then we will add the
following dependencies to our <code class="language-plaintext highlighter-rouge">Cargo.toml</code> file.</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Command line argument parsing.</span>
<span class="py">clap</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"4.4.13"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"derive"</span><span class="p">]</span> <span class="p">}</span>

<span class="c"># Pretty logging.</span>
<span class="py">femme</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"2.2.1"</span> <span class="p">}</span>
<span class="py">log</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.4.20"</span> <span class="p">}</span>

<span class="c"># Colorization and ANSI escape sequence codes.</span>
<span class="py">r3bl_tui</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.5.1"</span> <span class="p">}</span>
<span class="py">r3bl_ansi_color</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.6.9"</span> <span class="p">}</span>
</code></pre></div></div>

<h2 id="configure-clap-to-parse-command-line-arguments">Configure clap to parse command line arguments</h2>
<p><a id="markdown-configure-clap-to-parse-command-line-arguments" name="configure-clap-to-parse-command-line-arguments"></a></p>

<p>This Rust app has a single binary, and depending on the command line arguments, it will behave
either as a client or server. We will use the <code class="language-plaintext highlighter-rouge">clap</code> crate to parse the command line arguments.</p>

<p>We will configure <code class="language-plaintext highlighter-rouge">clap</code> so that the following commands will work:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo run server
cargo run client
</code></pre></div></div>

<p>We want to allow the user to specify the following options and chose their own address and
port. If the user does not specify any options, we will use the default values. The
default value for <code class="language-plaintext highlighter-rouge">--address</code> is <code class="language-plaintext highlighter-rouge">127.0.0.1</code>, and the default value for <code class="language-plaintext highlighter-rouge">--port</code> is
<code class="language-plaintext highlighter-rouge">3000</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo run server <span class="nt">--address</span> 127.0.0.1 <span class="nt">--port</span> 8080
cargo run server <span class="nt">--address</span> 127.0.0.1
cargo run server <span class="nt">--port</span> 8080

cargo run client <span class="nt">--address</span> 127.0.0.1 <span class="nt">--port</span> 8080
cargo run client <span class="nt">--address</span> 127.0.0.1
cargo run client <span class="nt">--port</span> 8080
</code></pre></div></div>

<p>Let’s also add an option that we can use to disable log output to stdout. By default, we
will log to stdout. But if the user specifies the <code class="language-plaintext highlighter-rouge">--log-disable</code> flag, then we disable
all log output.</p>

<p>Here’s the clap configuration that gives us this behavior.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">clap</span><span class="p">::{</span><span class="n">Parser</span><span class="p">,</span> <span class="n">Subcommand</span><span class="p">};</span>

<span class="k">pub</span> <span class="k">use</span> <span class="nn">defaults</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
<span class="k">mod</span> <span class="n">defaults</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">pub</span> <span class="k">const</span> <span class="n">DEFAULT_PORT</span><span class="p">:</span> <span class="nb">u16</span> <span class="o">=</span> <span class="mi">3000</span><span class="p">;</span>
    <span class="k">pub</span> <span class="k">const</span> <span class="n">DEFAULT_ADDRESS</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">"127.0.0.1"</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">use</span> <span class="nn">clap_config</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
<span class="k">mod</span> <span class="n">clap_config</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="nd">#[derive(Parser,</span> <span class="nd">Debug)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">CLIArg</span> <span class="p">{</span>
        <span class="cd">/// IP Address to connect to or start a server on</span>
        <span class="nd">#[clap(long,</span> <span class="nd">short,</span> <span class="nd">default_value</span> <span class="nd">=</span> <span class="nd">DEFAULT_ADDRESS,</span> <span class="nd">global</span> <span class="nd">=</span> <span class="kc">true</span><span class="nd">)]</span>
        <span class="k">pub</span> <span class="n">address</span><span class="p">:</span> <span class="n">IpAddr</span><span class="p">,</span>

        <span class="cd">/// TCP Port to connect to or start a server on</span>
        <span class="nd">#[clap(long,</span> <span class="nd">short,</span> <span class="nd">default_value_t</span> <span class="nd">=</span> <span class="nd">DEFAULT_PORT,</span> <span class="nd">global</span> <span class="nd">=</span> <span class="kc">true</span><span class="nd">)]</span>
        <span class="k">pub</span> <span class="n">port</span><span class="p">:</span> <span class="nb">u16</span><span class="p">,</span>

        <span class="cd">/// Logs to stdout by default, set this flag to disable it</span>
        <span class="nd">#[clap(long,</span> <span class="nd">short</span> <span class="nd">=</span> <span class="sc">'d'</span><span class="nd">,</span> <span class="nd">global</span> <span class="nd">=</span> <span class="kc">true</span><span class="nd">)]</span>
        <span class="k">pub</span> <span class="n">log_disable</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>

        <span class="cd">/// The subcommand to run</span>
        <span class="nd">#[clap(subcommand)]</span>
        <span class="k">pub</span> <span class="n">subcommand</span><span class="p">:</span> <span class="n">CLISubcommand</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="nd">#[derive(Subcommand,</span> <span class="nd">Debug)]</span>
    <span class="k">pub</span> <span class="k">enum</span> <span class="n">CLISubcommand</span> <span class="p">{</span>
        <span class="cd">/// Start a server on the given address and port</span>
        <span class="n">Server</span><span class="p">,</span>
        <span class="cd">/// Connect to a server running on the given address and port</span>
        <span class="n">Client</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="create-the-client">Create the client</h2>
<p><a id="markdown-create-the-client" name="create-the-client"></a></p>

<p>Let’s start with the simpler of the two, the client. We will use <code class="language-plaintext highlighter-rouge">std::net::TcpStream</code> to
create a TCP socket client. We will need an IP address and port in order to make a TCP
connection. And to run the client we will need to run the following command:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo run client
</code></pre></div></div>

<p>Here’s what the main function of our app looks like:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Welcome to rtelnet"</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">cli_arg</span> <span class="o">=</span> <span class="nn">CLIArg</span><span class="p">::</span><span class="nf">parse</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">address</span> <span class="o">=</span> <span class="n">cli_arg</span><span class="py">.address</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">port</span> <span class="o">=</span> <span class="n">cli_arg</span><span class="py">.port</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">socket_address</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{}:{}"</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>

    <span class="k">if</span> <span class="o">!</span><span class="n">cli_arg</span><span class="py">.log_disable</span> <span class="p">{</span>
        <span class="nn">femme</span><span class="p">::</span><span class="nf">start</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">match</span> <span class="k">match</span> <span class="n">cli_arg</span><span class="py">.subcommand</span> <span class="p">{</span>
        <span class="nn">CLISubcommand</span><span class="p">::</span><span class="n">Server</span> <span class="k">=&gt;</span> <span class="nf">start_server</span><span class="p">(</span><span class="n">socket_address</span><span class="p">),</span>
        <span class="nn">CLISubcommand</span><span class="p">::</span><span class="n">Client</span> <span class="k">=&gt;</span> <span class="nf">start_client</span><span class="p">(</span><span class="n">socket_address</span><span class="p">),</span>
    <span class="p">}</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Program exited successfully"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nf">Err</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Program exited with an error: {}"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The function that performs the client logic looks like this.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">start_client</span><span class="p">(</span><span class="n">socket_address</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IOResult</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"Start client connection"</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">tcp_stream</span> <span class="o">=</span> <span class="nn">TcpStream</span><span class="p">::</span><span class="nf">connect</span><span class="p">(</span><span class="n">socket_address</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="p">(</span><span class="k">mut</span> <span class="n">reader</span><span class="p">,</span> <span class="k">mut</span> <span class="n">writer</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_stream</span><span class="p">),</span> <span class="nn">BufWriter</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_stream</span><span class="p">));</span>

    <span class="c1">// Client loop.</span>
    <span class="k">loop</span> <span class="p">{</span>
        <span class="c1">// Read user input.</span>
        <span class="k">let</span> <span class="n">outgoing</span> <span class="o">=</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">it</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="nf">stdin</span><span class="p">()</span><span class="nf">.read_line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">it</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="n">it</span><span class="nf">.as_bytes</span><span class="p">()</span><span class="nf">.to_vec</span><span class="p">()</span>
        <span class="p">};</span>

        <span class="c1">// Tx user input to writer.</span>
        <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="n">writer</span><span class="nf">.write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">outgoing</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="n">writer</span><span class="nf">.flush</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

        <span class="c1">// Rx response from reader.</span>
        <span class="k">let</span> <span class="n">incoming</span> <span class="o">=</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">it</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
            <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="n">reader</span><span class="nf">.read_until</span><span class="p">(</span><span class="sc">b'\n'</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">it</span><span class="p">);</span>
            <span class="n">it</span>
        <span class="p">};</span>

        <span class="k">let</span> <span class="n">display_msg</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_lossy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">incoming</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">display_msg</span> <span class="o">=</span> <span class="n">display_msg</span><span class="nf">.trim</span><span class="p">();</span>

        <span class="k">let</span> <span class="n">reset</span> <span class="o">=</span> <span class="nn">SgrCode</span><span class="p">::</span><span class="n">Reset</span><span class="nf">.to_string</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">display_msg</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{}{}"</span><span class="p">,</span> <span class="n">display_msg</span><span class="p">,</span> <span class="n">reset</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">display_msg</span><span class="p">);</span>

        <span class="c1">// Print debug.</span>
        <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span>
            <span class="s">"-&gt; Tx: '{}', size: {} bytes{}"</span><span class="p">,</span>
            <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_lossy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">outgoing</span><span class="p">)</span><span class="nf">.trim</span><span class="p">(),</span>
            <span class="n">outgoing</span><span class="nf">.len</span><span class="p">(),</span>
            <span class="n">reset</span><span class="p">,</span>
        <span class="p">);</span>
        <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span>
            <span class="s">"&lt;- Rx: '{}', size: {} bytes{}"</span><span class="p">,</span>
            <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_lossy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">incoming</span><span class="p">)</span><span class="nf">.trim</span><span class="p">(),</span>
            <span class="n">incoming</span><span class="nf">.len</span><span class="p">(),</span>
            <span class="n">reset</span><span class="p">,</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here are a few things to note about the client code:</p>
<ul>
  <li>We create a <code class="language-plaintext highlighter-rouge">BufReader</code> and <code class="language-plaintext highlighter-rouge">BufWriter</code> for the <code class="language-plaintext highlighter-rouge">TcpStream</code> that we get from
<code class="language-plaintext highlighter-rouge">TcpStream::connect()</code>. This is because we want to read and write data in chunks, and
not one byte at a time, for performance reasons, and to simplify the logic. These two
structs allow us to read and write data very easily in chunks that are delimited by new
lines (<code class="language-plaintext highlighter-rouge">\n</code>).</li>
  <li>There’s a client loop that runs forever. This is because we want to keep the client
running forever, so that the user can type a message and send it to the server, and
receive a response from the server.</li>
  <li>How do we exit this infinite client loop? Only when the user presses <code class="language-plaintext highlighter-rouge">Ctrl+C</code> will the
client exit. The <a href="https://g.co/bard/share/ac5d3480eb37">default behavior</a> for Rust is to
exit the process when this happens. This drops the TCP connection causing the server to exit as
well.</li>
  <li>When we read data from user input, it too uses a stream, not a <code class="language-plaintext highlighter-rouge">TcpStream</code>, but the
<code class="language-plaintext highlighter-rouge">stdin()</code> stream. This behaves very similarly to the <code class="language-plaintext highlighter-rouge">TcpStream</code> stream. We can read
data from it in chunks delimited by new lines (<code class="language-plaintext highlighter-rouge">\n</code>). Once the user types a message and
presses enter that message, eg: <code class="language-plaintext highlighter-rouge">"hi"</code>, and the new line are stored in the <code class="language-plaintext highlighter-rouge">it</code>
variable, eg: <code class="language-plaintext highlighter-rouge">"hi\n"</code>. We then convert the String into a byte array, eg: <code class="language-plaintext highlighter-rouge">[104, 105,
10]</code>, and then convert it into a <code class="language-plaintext highlighter-rouge">Vec&lt;u8&gt;</code>. We then send it to the server. We must call
<code class="language-plaintext highlighter-rouge">flush()</code> since <code class="language-plaintext highlighter-rouge">BufWriter</code> buffers the data and does not send it to the server until we
call <code class="language-plaintext highlighter-rouge">flush()</code> for IO performance reasons. It queue’s up the data and sends it in
chunks, instead of sending it one byte at a time.</li>
  <li>Reading there response from the server is similar to reading it from <code class="language-plaintext highlighter-rouge">stdin()</code> as we
have already seen. The main thread blocks until there is some data that can be read from
the server. Or if the TCP connection errors out in any way (timeout or closed by various
means). If there is an error, then this function returns an error, and the main thread
exits. Note that the <code class="language-plaintext highlighter-rouge">start_client()</code> function itself returns an <code class="language-plaintext highlighter-rouge">IOResult</code>, which is
just a type alias for <code class="language-plaintext highlighter-rouge">pub type IOResult&lt;T&gt; = std::io::Result&lt;T&gt;;</code>. The error handling
is quite simple. If there is an error, we print it out and exit the program.</li>
  <li>We read the data from the server into the <code class="language-plaintext highlighter-rouge">incoming</code> variable using
<code class="language-plaintext highlighter-rouge">reader.read_until(b'\n', &amp;mut it);)</code>. This is because we expect the server to send us
data that is terminated by a new line (<code class="language-plaintext highlighter-rouge">\n</code>). So we read the data until we encounter a
new line. This is a blocking call, so the main thread blocks until there is some data
that can be read from the server. Note that the <code class="language-plaintext highlighter-rouge">\n</code> is included in <code class="language-plaintext highlighter-rouge">incoming</code> variable,
much like it is in <code class="language-plaintext highlighter-rouge">stdin()</code>.
    <ul>
      <li>We use this function <code class="language-plaintext highlighter-rouge">String::from_utf8_lossy(&amp;incoming);</code> to convert this <code class="language-plaintext highlighter-rouge">incoming:
Vec&lt;u8&gt;</code> into a <code class="language-plaintext highlighter-rouge">String</code>. We call <code class="language-plaintext highlighter-rouge">.trim()</code> on the String, so that the trailing <code class="language-plaintext highlighter-rouge">\n</code>
is removed.</li>
      <li>Note that <code class="language-plaintext highlighter-rouge">trim()</code> returns a <code class="language-plaintext highlighter-rouge">&amp;str</code>, so if you want to turn it into a String, you have
to run in through this expression <code class="language-plaintext highlighter-rouge">format!("{}",
String::from_utf8_lossy(&amp;incoming).trim())</code> function.</li>
    </ul>
  </li>
  <li>This is a pedagogical example and this algorithm is somewhat contrived to demonstrate
how to send bytes back and forth between client and server and have them interpret the
bytes in a certain way. A more formalized version of this “dance” is called a
“protocol”, eg: HTTP, SMTP, etc.</li>
  <li>In the final step of the <code class="language-plaintext highlighter-rouge">loop</code>, after the incoming data has been read from the server,
we print it out to the terminal. Since the server will send us ANSI escape sequence
codes that colorize the text that we print to the terminal, we want to reset the color
after we print the text, so it does not pollute our <code class="language-plaintext highlighter-rouge">stdout()</code> output stream. We use the
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/ansi_color/src/ansi_escape_codes.rs#L23"><code class="language-plaintext highlighter-rouge">SgrCode::Reset</code> code to reset the
color</a>
of the text that we print to the terminal.</li>
</ul>

<h2 id="create-the-server">Create the server</h2>
<p><a id="markdown-create-the-server" name="create-the-server"></a></p>

<p>Now let’s create the server. We will use <code class="language-plaintext highlighter-rouge">std::net::TcpListener</code> to create a TCP socket
server. We will need an IP address and port in order to make a TCP connection. To run the
server we will need to run the following command:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo run server
</code></pre></div></div>

<p>The server code is very similar to the client code. We need a server loop that runs
forever, and we need to first read (blocking until there is any data available) and then
write data in chunks delimited by new lines (<code class="language-plaintext highlighter-rouge">\n</code>). When there is no data available to
read <code class="language-plaintext highlighter-rouge">EOF</code> is reached on the reader (aka, input TCP stream) then we break out of this loop
and exit. When data comes in (delimited by <code class="language-plaintext highlighter-rouge">\n</code>) we process it and send a response back to
the client. We process this data by applying a <a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tui/src/tui/color_wheel/color_wheel_struct.rs#L457">lolcat
effect</a>
on it, so the client will get a very colorful version of whatever text message that they
sent to the server.</p>

<p>One more thing we will see when implementing the server is having to spawn multiple
threads to handle each incoming client connection. While the client is a single threaded
app, the server is a multi-threaded app. The client is only concerned w/ a single TCP
connection, but the server is concerned with multiple TCP connections, each connection
emanating from a different client process running the <code class="language-plaintext highlighter-rouge">cargo run client</code> and creating a
new OS process. Fortunately Rust is built for fearless concurrency and parallelism from
the ground up.</p>

<p>Here’s the main function of our server app:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">start_server</span><span class="p">(</span><span class="n">socket_address</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IOResult</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">tcp_listener</span> <span class="o">=</span> <span class="nn">TcpListener</span><span class="p">::</span><span class="nf">bind</span><span class="p">(</span><span class="n">socket_address</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="c1">// Server connection accept loop.</span>
    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"Waiting for a incoming connection..."</span><span class="p">);</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">tcp_stream</span><span class="p">,</span> <span class="o">..</span><span class="p">)</span> <span class="o">=</span> <span class="n">tcp_listener</span><span class="nf">.accept</span><span class="p">()</span><span class="o">?</span><span class="p">;</span> <span class="c1">// This is a blocking call.</span>

        <span class="c1">// Spawn a new thread to handle this connection.</span>
        <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(||</span> <span class="k">match</span> <span class="nf">handle_connection</span><span class="p">(</span><span class="n">tcp_stream</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"Successfully closed connection to client..."</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="nf">Err</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">log</span><span class="p">::</span><span class="nd">error!</span><span class="p">(</span><span class="s">"Problem with client connection..."</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here are a few things to note about the server code:</p>
<ul>
  <li>We are using <code class="language-plaintext highlighter-rouge">IOResult</code> just like the client code. There are frequent calls to the <code class="language-plaintext highlighter-rouge">?</code>
operator, which is shorthand for matching on the <code class="language-plaintext highlighter-rouge">Result</code> and returning early if there’s
an error. This is rudimentary error handling, and its good enough for this pedagogical
example. Note that even in this pedagogical example, we don’t use the <code class="language-plaintext highlighter-rouge">unwrap()</code> method
which will induce a panic if there’s an error. We always use the <code class="language-plaintext highlighter-rouge">?</code> operator, which
will return early if there’s an error. It isn’t a good idea to get into the habit of
using <code class="language-plaintext highlighter-rouge">unwrap()</code> outside of tests. These habits are hard to break once they’re formed.
You can even add the following
<a href="https://rust-lang.github.io/rust-clippy/master/index.html#/unwrap_used"><code class="language-plaintext highlighter-rouge">#![warn(clippy::unwrap_in_result)]</code></a>
in the top level module of your project to have the compiler warn you if you use
<code class="language-plaintext highlighter-rouge">unwrap()</code> outside of tests. Here’s an
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/ansi_color/src/lib.rs#L171">example</a>.</li>
  <li>The first thing the server has to do is reserve a port on the given address. This is called
binding, and we do it using <code class="language-plaintext highlighter-rouge">TcpListener::bind(socket_address)?;</code>. This does not start a server
yet. It just reserves a port on the given address, assuming that it is available. If some other
process has already bound to that port, then this will return an error.</li>
  <li>Once we have a <code class="language-plaintext highlighter-rouge">TcpListener</code> instance, we can call <code class="language-plaintext highlighter-rouge">accept()</code> on it to start listening
for incoming connections. This is a blocking call, so the main thread blocks until there
is an incoming connection. Once there is an incoming connection, we get a <code class="language-plaintext highlighter-rouge">TcpStream</code>
instance, which we can use to read and write data to the client. This is a blocking
call. Which means that the main thread won’t be able to do anything else, like process
other incoming connections, while it is waiting here, for a connection to come in.</li>
  <li>This is why we use <code class="language-plaintext highlighter-rouge">thread::spawn()</code> to create a new thread and have it handle the
incoming connection. We spawn a new thread for each incoming connection. This is <a href="https://g.co/bard/share/74f433bad400">not a
scalable solution</a>, but it is good enough for this
pedagogical example. We will learn about more scalable solutions in a the <a href="/2024/01/13/write-simple-chat-server-in-rust/">Write a
simple TCP chat server in Rust</a> tutorial.</li>
</ul>

<p>Now, let’s look at the <code class="language-plaintext highlighter-rouge">handle_connection()</code> function that is called by the spawned
thread. This is the function that handles the incoming connection from the client. And it
defines our “protocol”, along with the client code. We aren’t using any formalized
protocol like HTTP or SMTP. We are just sending bytes back and forth between the client
and server, and interpreting them in a certain way, which is our informal protocol. This
code is very similar to the client side code, including the <code class="language-plaintext highlighter-rouge">loop</code> and the <code class="language-plaintext highlighter-rouge">BufReader</code> and
<code class="language-plaintext highlighter-rouge">BufWriter</code> structs. And even looking for <code class="language-plaintext highlighter-rouge">EOF</code> to break out of the loop. Except that we
don’t block on <code class="language-plaintext highlighter-rouge">stdin()</code> for input here.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">handle_connection</span><span class="p">(</span><span class="n">tcp_stream</span><span class="p">:</span> <span class="n">TcpStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">IOResult</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"Start handle connection"</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">reader</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_stream</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">write</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">BufWriter</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_stream</span><span class="p">);</span>

    <span class="c1">// Process client connection loop.</span>
    <span class="k">loop</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">incoming</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

        <span class="c1">// Read from reader.</span>
        <span class="k">let</span> <span class="n">num_bytes_read</span> <span class="o">=</span> <span class="n">reader</span><span class="nf">.read_until</span><span class="p">(</span><span class="sc">b'\n'</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">incoming</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

        <span class="c1">// Check for EOF. The stream is closed.</span>
        <span class="k">if</span> <span class="n">num_bytes_read</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Process.</span>
        <span class="k">let</span> <span class="n">outgoing</span> <span class="o">=</span> <span class="nf">process</span><span class="p">(</span><span class="o">&amp;</span><span class="n">incoming</span><span class="p">);</span>

        <span class="c1">// Write to writer.</span>
        <span class="n">write</span><span class="nf">.write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">outgoing</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="n">write</span><span class="nf">.flush</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

        <span class="c1">// Print debug.</span>
        <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"-&gt; Rx(bytes) : {:?}"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">incoming</span><span class="p">);</span>
        <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span>
            <span class="s">"-&gt; Rx(string): '{}', size: {} bytes"</span><span class="p">,</span>
            <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_lossy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">incoming</span><span class="p">)</span><span class="nf">.trim</span><span class="p">(),</span>
            <span class="n">incoming</span><span class="nf">.len</span><span class="p">(),</span>
        <span class="p">);</span>
        <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span>
            <span class="s">"&lt;- Tx(string): '{}', size: {} bytes"</span><span class="p">,</span>
            <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_lossy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">outgoing</span><span class="p">)</span><span class="nf">.trim</span><span class="p">(),</span>
            <span class="n">outgoing</span><span class="nf">.len</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">log</span><span class="p">::</span><span class="nd">info!</span><span class="p">(</span><span class="s">"End handle connection - connection closed"</span><span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Finally, let’s look at the <code class="language-plaintext highlighter-rouge">process()</code> function that takes the incoming bytes to the
outgoing bytes. This is where we add some fun and color and flair to our app. We colorize
the incoming bytes using a lolcat effect and send it back to the client.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">r3bl_tui</span><span class="p">::</span><span class="n">ColorWheel</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">process</span><span class="p">(</span><span class="n">incoming</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Convert incoming to String, and remove any trailing whitespace (includes newline).</span>
    <span class="k">let</span> <span class="n">incoming</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_lossy</span><span class="p">(</span><span class="n">incoming</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">incoming</span> <span class="o">=</span> <span class="n">incoming</span><span class="nf">.trim</span><span class="p">();</span>

    <span class="c1">// Prepare outgoing payload.</span>
    <span class="k">let</span> <span class="n">outgoing</span> <span class="o">=</span> <span class="n">incoming</span><span class="nf">.to_string</span><span class="p">();</span>

    <span class="c1">// Colorize it w/ a gradient.</span>
    <span class="k">let</span> <span class="n">outgoing</span> <span class="o">=</span> <span class="nn">ColorWheel</span><span class="p">::</span><span class="nf">lolcat_into_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">outgoing</span><span class="p">);</span>

    <span class="c1">// Generate outgoing response. Add newline to the end of output (so client can process it).</span>
    <span class="k">let</span> <span class="n">outgoing</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">outgoing</span><span class="p">);</span>

    <span class="c1">// Return outgoing payload.</span>
    <span class="n">outgoing</span><span class="nf">.as_bytes</span><span class="p">()</span><span class="nf">.to_vec</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="next-steps">Next steps</h2>
<p><a id="markdown-next-steps" name="next-steps"></a></p>

<p>Now that you have a handle on the basics of writing a simple netcat client and server, you
can read <a href="/2024/01/13/write-simple-chat-server-in-rust/">this tutorial</a> to learn more about creating a more advanced TCP server that netcat,
telnet, or PuTTY clients can connect to, in order to have multiple client apps chat with
each other.</p>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><category term="Server" /><summary type="html"><![CDATA[A guide on how to a simple Rust netcat client and server]]></summary></entry><entry><title type="html">How to overcome your fear of git merge conflicts</title><link href="http://developerlife.com/2023/09/22/overcome-your-fear-of-merge-conflicts/" rel="alternate" type="text/html" title="How to overcome your fear of git merge conflicts" /><published>2023-09-22T00:00:00-05:00</published><updated>2023-09-22T00:00:00-05:00</updated><id>http://developerlife.com/2023/09/22/overcome-your-fear-of-merge-conflicts</id><content type="html" xml:base="http://developerlife.com/2023/09/22/overcome-your-fear-of-merge-conflicts/"><![CDATA[<p><img class="post-hero-image" src="/assets/git-merge-conflict-hero.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#setting-the-stage-for-a-merge-conflict">Setting the stage for a merge conflict</a></li>
  <li><a href="#picture-1-how-we-got-here">Picture 1: How we got here</a></li>
  <li><a href="#picture-2-the-conflict-when-develop-is-applied-to-main">Picture 2: The conflict when develop is applied to main</a></li>
  <li><a href="#picture-3-how-to-understand-the-diff">Picture 3: How to understand the diff</a></li>
  <li><a href="#picture-4-how-to-resolve-the-conflict">Picture 4: How to resolve the conflict</a></li>
  <li><a href="#next-steps">Next steps</a></li>
</ul>

<!-- /TOC -->

<h2 id="introduction">Introduction</h2>
<p><a id="markdown-introduction" name="introduction"></a></p>

<p>There are few things that generate as much fear and anxiety in developers as <code class="language-plaintext highlighter-rouge">git</code> merge
conflicts. <code class="language-plaintext highlighter-rouge">git</code> is very popular and very powerful, and it is a low level command line
tool. And it is not very user friendly. It is meant to be orchestrate-able and automated
using scripts and CI/CD tools, and build systems; it is extremely flexible. It is not
meant to be used in an interactive manner w/ a human user at the keyboard.</p>

<p>This just creates an opportunity for others to come along and craft user experiences on
top of <code class="language-plaintext highlighter-rouge">git</code> that are more use case driven. And these UXes can come in the form or GUIs,
TUIs, or even conversational interfaces.</p>

<p>But that’s not the focus of this article which is all about the CLI experience of inducing
and resolving merge conflicts. So let’s get started.</p>
<blockquote>

👀 Watch Rust 🦀 live coding videos on our <a href="https://www.youtube.com/@developerlifecom">YouTube Channel</a>.

<br />
<br />

<!-- video on rust polymorphism (no playlist) -->
<iframe src="https://www.youtube.com/embed/kYTgGtJjSro?si=XmW-_CAvCfB5e269" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<br />
<br />

📦 Install our useful Rust command line apps using <code>cargo install r3bl-cmdr</code>
(they are from the <a href="https://github.com/r3bl-org/r3bl-open-core">r3bl-open-core</a>
project):
<ul>
  <li>🐱<code>giti</code>: run interactive git commands with confidence in your terminal</li>
  <li>🦜<code>edi</code>: edit Markdown with style in your terminal</li>
</ul>

<p>
<kbd>giti in action</kbd>
<video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/262f59d1-a95c-4af3-accf-c3d6cac6e586" type="video/mp4" />
</video>
</p>

<p>
<kbd>edi in action</kbd>
<video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/f2c4b07d-b5a2-4f41-af7a-06d1b6660c41" type="video/mp4" />
</video>
</p>

</blockquote>
<h2 id="setting-the-stage-for-a-merge-conflict">Setting the stage for a merge conflict</h2>
<p><a id="markdown-setting-the-stage-for-a-merge-conflict" name="setting-the-stage-for-a-merge-conflict"></a></p>

<p>Let’s create a local repo from scratch and set things up so that we can predictably
generate a merge conflict. Here’s what we will do at a high level:</p>
<ol>
  <li>Create a local repo.</li>
  <li>Create a <code class="language-plaintext highlighter-rouge">main</code> branch.</li>
  <li>Create a file in the <code class="language-plaintext highlighter-rouge">main</code> branch and add some content to it.</li>
  <li>Create a <code class="language-plaintext highlighter-rouge">feature</code> branch based on the <code class="language-plaintext highlighter-rouge">main</code> branch.</li>
  <li>Modify the file in the <code class="language-plaintext highlighter-rouge">feature</code> branch.</li>
  <li>Modify the same file in the <code class="language-plaintext highlighter-rouge">main</code> branch with a change that is going to conflict w/ a change in <code class="language-plaintext highlighter-rouge">feature</code> branch.</li>
  <li>Merge the <code class="language-plaintext highlighter-rouge">feature</code> branch into the <code class="language-plaintext highlighter-rouge">main</code> branch.</li>
</ol>

<p>Here’s a script to get you started:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/usr/bin/env bash</span>

<span class="c"># Create a local repo.</span>
<span class="nb">export </span><span class="nv">TMP_REPO_DIR</span><span class="o">=</span><span class="s2">"~/Downloads/tmp/git-merge-conflict-demo"</span>
<span class="k">if</span> <span class="o">[</span> <span class="nt">-d</span> <span class="nv">$TMP_REPO_DIR</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"Folder exists, recreating </span><span class="nv">$TMP_REPO_DIR</span><span class="s2">"</span>
  <span class="nb">rm</span> <span class="nt">-rf</span> <span class="nv">$TMP_REPO_DIR</span>
  <span class="nb">mkdir</span> <span class="nt">-p</span> <span class="nv">$TMP_REPO_DIR</span>
<span class="k">else
  </span><span class="nb">echo</span> <span class="s2">"Folder does not exist, creating </span><span class="nv">$TMP_REPO_DIR</span><span class="s2">"</span>
  <span class="nb">mkdir</span> <span class="nt">-p</span> <span class="nv">$TMP_REPO_DIR</span>
<span class="k">fi
</span><span class="nb">cd</span> <span class="nv">$TMP_REPO_DIR</span>
git init
git checkout <span class="nt">-b</span> main

<span class="c"># Create a file in the main branch and add some content to it.</span>
<span class="c"># This is the "OG change".</span>
<span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"This is a new feature.</span><span class="se">\n</span><span class="s2">## 3. Example 3"</span> <span class="o">&gt;</span> file.txt
git add file.txt
git commit <span class="nt">-m</span> <span class="s2">"Add myexample3"</span>

<span class="c"># Create a develop branch based on the main branch.</span>
git checkout <span class="nt">-b</span> develop main

<span class="c"># Person A comes along and changes this line w/ a plus in the develop branch.</span>
<span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"This is a new feature.</span><span class="se">\n</span><span class="s2">## 3. Example 3+"</span> <span class="o">&gt;</span> file.txt
git add file.txt
git commit <span class="nt">-m</span> <span class="s2">"Fix typo w/ plus in develop branch"</span>

<span class="c"># Person B comes along and change this line w/ a minus in the main branch.</span>
<span class="c"># This is going to conflict with the change in the develop branch.</span>
git checkout main
<span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"This is a new feature.</span><span class="se">\n</span><span class="s2">## 3. Example 3-"</span> <span class="o">&gt;</span> file.txt
git add file.txt
git commit <span class="nt">-m</span> <span class="s2">"Fix typo w/ minus in main branch"</span>

<span class="c"># Merge (using rebase, so no extra commit) the develop branch into the main branch.</span>
git rebase develop
</code></pre></div></div>

<p>This results in a merge conflict. And when you run <code class="language-plaintext highlighter-rouge">git diff</code> it looks like this:</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh">diff --cc file.txt
index 89da142,ef43c8f..0000000
</span><span class="gd">--- a/file.txt
</span><span class="gi">+++ b/file.txt
</span>@@@ -1,2 -1,2 +1,8 @@@
  This is a new feature.
<span class="gi">++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
</span> +## 3. Example 3+
<span class="gi">++||||||| parent of 7c0f0e4 (Fix typo w/ - in main branch)
++## 3. Example 3
++=======
+ ## 3. Example 3-
++&gt;&gt;&gt;&gt;&gt;&gt;&gt; 7c0f0e4 (Fix typo w/ - in main branch)
</span></code></pre></div></div>

<p>Let’s use some pictures to understand the story of how we got here. And how to resolve this.</p>

<h2 id="picture-1-how-we-got-here">Picture 1: How we got here</h2>
<p><a id="markdown-picture-1%3A-how-we-got-here" name="picture-1%3A-how-we-got-here"></a></p>

<p><img src="/assets/git-merge-conflicts/act1.svg" alt="" /></p>

<h2 id="picture-2-the-conflict-when-develop-is-applied-to-main">Picture 2: The conflict when develop is applied to main</h2>
<p><a id="markdown-picture-2%3A-the-conflict-when-develop-is-applied-to-main" name="picture-2%3A-the-conflict-when-develop-is-applied-to-main"></a></p>

<p><img src="/assets/git-merge-conflicts/act2.svg" alt="" /></p>

<h2 id="picture-3-how-to-understand-the-diff">Picture 3: How to understand the diff</h2>
<p><a id="markdown-picture-3%3A-how-to-understand-the-diff" name="picture-3%3A-how-to-understand-the-diff"></a></p>

<p><img src="/assets/git-merge-conflicts/act3.svg" alt="" /></p>

<h2 id="picture-4-how-to-resolve-the-conflict">Picture 4: How to resolve the conflict</h2>
<p><a id="markdown-picture-4%3A-how-to-resolve-the-conflict" name="picture-4%3A-how-to-resolve-the-conflict"></a></p>

<p><img src="/assets/git-merge-conflicts/act4.svg" alt="" /></p>

<h2 id="next-steps">Next steps</h2>
<p><a id="markdown-next-steps" name="next-steps"></a></p>]]></content><author><name>Nazmul Idris</name></author><category term="CLI" /><summary type="html"><![CDATA[A visual guide on how to understand git merge conflict messages and resolve them with confidence.]]></summary></entry><entry><title type="html">tuify your clap CLI apps and make them more interactive</title><link href="http://developerlife.com/2023/09/17/tuify-clap/" rel="alternate" type="text/html" title="tuify your clap CLI apps and make them more interactive" /><published>2023-09-17T10:00:00-05:00</published><updated>2023-09-17T10:00:00-05:00</updated><id>http://developerlife.com/2023/09/17/tuify-clap</id><content type="html" xml:base="http://developerlife.com/2023/09/17/tuify-clap/"><![CDATA[<p><img class="post-hero-image" src="/assets/tuify-clap-hero.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#cli-design-concepts">CLI design concepts</a></li>
  <li><a href="#show-me">Show me</a></li>
  <li><a href="#the-r3bl_tuify-crate-and-clap">The r3bl_tuify crate and clap</a>
    <ul>
      <li><a href="#example-1-add-interactivity-using-a-list-selection-component">Example 1: Add interactivity using a list selection component</a></li>
      <li><a href="#example-2-adding-interactivity-using-a-text-input-field">Example 2: Adding interactivity using a text input field</a></li>
    </ul>
  </li>
  <li><a href="#next-steps">Next steps</a></li>
</ul>

<!-- /TOC -->

<h2 id="introduction">Introduction</h2>
<p><a id="markdown-introduction" name="introduction"></a></p>

<p>As developers we tend to spend a lot of time in the terminal. It is a great place to exercise
precise control over our computers. And it is a great place to automate tasks. However, there are
some rough edges to this experience. For example, even though the interaction metaphor w/ CLI apps
is a conversation, we have to be very precise in the language we use in this conversation. Lots of
trial and error, patience and resilience are required to make it work. And it does not have to be
this way.</p>

<p>To use a racing analogy, terminals are like race cars. They are fast and powerful, and you can
exercise direct and precise control over them. But if you get things wrong, there can be
consequences. Porsche is a car company that
<a href="https://en.wikipedia.org/wiki/List_of_24_Hours_of_Le_Mans_winners#By_manufacturer">wins endurance races</a>,
and a very long time ago, they decided to make a race car that was friendly to the ergonomics of
their drivers.</p>

<p>The thinking was that if the driver is comfortable, they will perform better, and the 24 hour race
wins will be just a little bit closer within reach. Similarly, we can add some interactivity to our
CLI apps to make them more ergonomic to use. And we can do this without going full TUI. We can do
this in a way that is additive to the existing CLI experience. We can “tuify” our CLI apps that are
built using <code class="language-plaintext highlighter-rouge">clap</code>.</p>
<blockquote>

👀 Watch Rust 🦀 live coding videos on our <a href="https://www.youtube.com/@developerlifecom">YouTube Channel</a>.

<br />
<br />

<!-- video on rust polymorphism (no playlist) -->
<iframe src="https://www.youtube.com/embed/kYTgGtJjSro?si=XmW-_CAvCfB5e269" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<br />
<br />

📦 Install our useful Rust command line apps using <code>cargo install r3bl-cmdr</code>
(they are from the <a href="https://github.com/r3bl-org/r3bl-open-core">r3bl-open-core</a>
project):
<ul>
  <li>🐱<code>giti</code>: run interactive git commands with confidence in your terminal</li>
  <li>🦜<code>edi</code>: edit Markdown with style in your terminal</li>
</ul>

<p>
<kbd>giti in action</kbd>
<video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/262f59d1-a95c-4af3-accf-c3d6cac6e586" type="video/mp4" />
</video>
</p>

<p>
<kbd>edi in action</kbd>
<video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/f2c4b07d-b5a2-4f41-af7a-06d1b6660c41" type="video/mp4" />
</video>
</p>

</blockquote>
<blockquote>
  <p>For more information on general Rust type system design (functional approach rather than
object oriented), please take a look at this <a href="https://arxiv.org/pdf/2307.07069.pdf">paper</a>
by Will Crichton demonstrating Typed Design Patterns with Rust.</p>
</blockquote>

<h2 id="cli-design-concepts">CLI design concepts</h2>
<p><a id="markdown-cli-design-concepts" name="cli-design-concepts"></a></p>

<p>Here are some great resources to learn more about good CLI design concepts. The Rust crate <code class="language-plaintext highlighter-rouge">clap</code> is
used by a lot of Rust apps to implement this CLI. And in this tutorial we will take a look at how to
add some interactivity to these <code class="language-plaintext highlighter-rouge">clap</code> CLI apps using the <code class="language-plaintext highlighter-rouge">r3bl_tuify</code> crate.</p>

<blockquote>
  <p>Note that these resources are all about CLI and not TUI. There isn’t very much information out
there about TUIs. It is a new and evolving space.</p>
</blockquote>

<ol>
  <li><a href="https://clig.dev/#foreword">Command Line Interface Guidelines</a></li>
  <li><a href="https://docs.rs/clap/latest/clap/_derive/#overview"><code class="language-plaintext highlighter-rouge">clap</code> docs</a></li>
  <li><a href="https://rust-cli-recommendations.sunshowers.io/handling-arguments.html"><code class="language-plaintext highlighter-rouge">clap</code> command and subcommand structure guidelines</a></li>
  <li><a href="https://rust-cli-recommendations.sunshowers.io/hierarchical-config.html">Hierarchy of configuration</a></li>
</ol>

<p>The CLI guidelines above do a great job of explaining how to create a good CLI experience. However
they do not cover how to add interactivity to your CLI apps. Why would we want to do this? Let’s
take a real example to illustrate the benefits of this next.</p>

<h2 id="show-me">Show me</h2>
<p><a id="markdown-show-me" name="show-me"></a></p>

<p>This example is a little “meta”. The <code class="language-plaintext highlighter-rouge">r3bl_tuify</code> crate, that allows interactivity to be added to
<code class="language-plaintext highlighter-rouge">clap</code> CLI apps, is available as a binary and library. The binary which can be used from the command
line (and uses <code class="language-plaintext highlighter-rouge">clap</code>) uses the library to provide an interactive experience when certain arguments
aren’t provided on the command line.</p>

<p>The idea with the binary target is that you might want to quickly incorporate some interactivity
into your shell scripts without getting into the Rust library. In this case, you can use the <code class="language-plaintext highlighter-rouge">rt</code>
binary target to do that. This binary takes quite a few arguments as you might imagine. However, you
don’t have to supply all of them at the start.</p>

<p>So instead of typing this massive command at the start (where <code class="language-plaintext highlighter-rouge">cargo run --</code> simply runs the binary
called <code class="language-plaintext highlighter-rouge">rt</code>):</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>TODO.todo | cargo run <span class="nt">--</span> <span class="k">select</span><span class="nt">-from-list</span> <span class="se">\</span>
    <span class="nt">--selection-mode</span> single <span class="se">\</span>
    <span class="nt">--command-to-run-with-each-selection</span> <span class="s2">"echo %"</span>
</code></pre></div></div>

<p>You can simply type the following shorter command and have the app prompt you for the rest of the
information that it needs:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>TODO.todo | cargo run <span class="nt">--</span> <span class="k">select</span><span class="nt">-from-list</span>
</code></pre></div></div>

<p>Here’s a video of this in action, where the app is prompting the user for two items:</p>

<ol>
  <li>the <code class="language-plaintext highlighter-rouge">selection-mode</code> and</li>
  <li><code class="language-plaintext highlighter-rouge">command-to-run-with-each-selection</code> interactively 🎉:</li>
</ol>

<!-- tuify-interactive-happy-path -->
<video width="100%" controls="">
  <source src="https://github.com/r3bl-org/r3bl-open-core/assets/2966499/51de8867-513b-429f-aff2-63dd25d71c82" type="video/mp4" />
</video>

<h2 id="the-r3bl_tuify-crate-and-clap">The r3bl_tuify crate and clap</h2>
<p><a id="markdown-the-r3bl_tuify-crate-and-clap" name="the-r3bl_tuify-crate-and-clap"></a></p>

<p>The <code class="language-plaintext highlighter-rouge">r3bl_tuify</code> app itself uses <code class="language-plaintext highlighter-rouge">clap</code> to parse the command line arguments. Here’s an overview of
what that looks like (all of it using the <code class="language-plaintext highlighter-rouge">derive</code> macro approach). Here’s a link to the
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tuify/src/main.rs#L30"><code class="language-plaintext highlighter-rouge">main.rs::AppArgs</code></a>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Debug,</span> <span class="nd">Parser)]</span>
<span class="nd">#[command(bin_name</span> <span class="nd">=</span> <span class="s">"rt"</span><span class="nd">)]</span>
<span class="nd">#[command(about</span> <span class="nd">=</span> <span class="s">"Easily add lightweight TUI capabilities to any CLI apps using pipes"</span><span class="nd">,</span> <span class="nd">long_about</span> <span class="nd">=</span> <span class="nd">None)]</span>
<span class="nd">#[command(version)]</span>
<span class="nd">#[command(next_line_help</span> <span class="nd">=</span> <span class="kc">true</span><span class="nd">)]</span>
<span class="nd">#[command(arg_required_else_help(</span><span class="kc">true</span><span class="nd">))]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">AppArgs</span> <span class="p">{</span>
    <span class="nd">#[clap(subcommand)]</span>
    <span class="n">command</span><span class="p">:</span> <span class="n">CLICommand</span><span class="p">,</span>

    <span class="nd">#[clap(flatten)]</span>
    <span class="n">global_opts</span><span class="p">:</span> <span class="n">GlobalOpts</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Args)]</span>
<span class="k">struct</span> <span class="n">GlobalOpts</span> <span class="p">{</span>
    <span class="cd">/// Print debug output to log file (log.txt)</span>
    <span class="nd">#[arg(long,</span> <span class="nd">short</span> <span class="nd">=</span> <span class="sc">'l'</span><span class="nd">)]</span>
    <span class="n">enable_logging</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>

    <span class="cd">/// Optional maximum height of the TUI (rows)</span>
    <span class="nd">#[arg(value_name</span> <span class="nd">=</span> <span class="s">"height"</span><span class="nd">,</span> <span class="nd">long,</span> <span class="nd">short</span> <span class="nd">=</span> <span class="sc">'r'</span><span class="nd">)]</span>
    <span class="n">tui_height</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>

    <span class="cd">/// Optional maximum width of the TUI (columns)</span>
    <span class="nd">#[arg(value_name</span> <span class="nd">=</span> <span class="s">"width"</span><span class="nd">,</span> <span class="nd">long,</span> <span class="nd">short</span> <span class="nd">=</span> <span class="sc">'c'</span><span class="nd">)]</span>
    <span class="n">tui_width</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Subcommand)]</span>
<span class="k">enum</span> <span class="n">CLICommand</span> <span class="p">{</span>
    <span class="cd">/// Show TUI to allow you to select one or more options from a list, piped in via stdin 👉</span>
    <span class="n">SelectFromList</span> <span class="p">{</span>
        <span class="cd">/// Would you like to select one or more items?</span>
        <span class="nd">#[arg(value_name</span> <span class="nd">=</span> <span class="s">"mode"</span><span class="nd">,</span> <span class="nd">long,</span> <span class="nd">short</span> <span class="nd">=</span> <span class="sc">'s'</span><span class="nd">)]</span>
        <span class="n">selection_mode</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">SelectionMode</span><span class="o">&gt;</span><span class="p">,</span>

        <span class="cd">/// Each selected item is passed to this command as `%` and executed in your shell.</span>
        <span class="cd">/// For eg: "echo %". Please wrap the command in quotes 💡</span>
        <span class="nd">#[arg(value_name</span> <span class="nd">=</span> <span class="s">"command"</span><span class="nd">,</span> <span class="nd">long,</span> <span class="nd">short</span> <span class="nd">=</span> <span class="sc">'c'</span><span class="nd">)]</span>
        <span class="n">command_to_run_with_each_selection</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The things to note are that the <code class="language-plaintext highlighter-rouge">selection_mode</code> and <code class="language-plaintext highlighter-rouge">command_to_run_with_each_selection</code> fields of
the <code class="language-plaintext highlighter-rouge">CliCommand::SelectFromList</code> enum are optional. This is where the <code class="language-plaintext highlighter-rouge">r3bl_tuify</code> crate comes in.
It will prompt the user for these two fields if they are not supplied on the command line.</p>

<p>You can add this programmatically using the library to your existing CLI apps.</p>

<blockquote>
  <p>The piping option using the binary is severely limited, so the library option is strongly
recommended. The binary is more of a convenience for shell scripts only on Linux.</p>
</blockquote>

<p>You can see how to use the library to perform this interactivity in
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/tuify/src/main.rs#L179"><code class="language-plaintext highlighter-rouge">main.rs::show_tui()</code></a>.</p>

<p>Here are two examples of adding interactivity.</p>

<h3 id="example-1-add-interactivity-using-a-list-selection-component">Example 1: Add interactivity using a list selection component</h3>
<p><a id="markdown-example-1%3A-add-interactivity-using-a-list-selection-component" name="example-1%3A-add-interactivity-using-a-list-selection-component"></a></p>

<p>Here’s an example of adding interactivity using a list selection component. This is useful
when the values that a field can take are known in advance. In this example, they are
since <code class="language-plaintext highlighter-rouge">selection-mode</code> is a <code class="language-plaintext highlighter-rouge">clap</code> <code class="language-plaintext highlighter-rouge">EnumValue</code> that can only take one of the following
values: <code class="language-plaintext highlighter-rouge">single</code>, or <code class="language-plaintext highlighter-rouge">multiple</code>.</p>

<p>In this scenario, <code class="language-plaintext highlighter-rouge">--selection-mode</code> is <em>not</em> passed in the command line. So it only
interactively prompts the user for this piece of information. Similarly, if the user does
not provide this information, the app exits and provides a help message.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>TODO.todo | cargo run <span class="nt">--</span> <span class="k">select</span><span class="nt">-from-list</span> <span class="nt">--command-to-run-with-each-selection</span> <span class="s2">"echo %"</span>
</code></pre></div></div>

<!-- tuify-interactive-selection-mode-not-provided -->
<video width="100%" controls="">
  <source src="https://github.com/r3bl-org/r3bl-open-core/assets/2966499/be65d9b2-575b-47c0-8291-110340bd2fe7" type="video/mp4" />
</video>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Handle `selection-mode` is not passed in.</span>
<span class="k">let</span> <span class="n">selection_mode</span> <span class="o">=</span> <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">selection_mode</span><span class="p">)</span> <span class="o">=</span> <span class="n">maybe_selection_mode</span> <span class="p">{</span>
    <span class="n">selection_mode</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">possible_values_for_selection_mode</span> <span class="o">=</span>
        <span class="nf">get_possible_values_for_subcommand_and_option</span><span class="p">(</span>
            <span class="s">"select-from-list"</span><span class="p">,</span>
            <span class="s">"selection-mode"</span><span class="p">,</span>
        <span class="p">);</span>
    <span class="nf">print_help_for_subcommand_and_option</span><span class="p">(</span><span class="s">"select-from-list"</span><span class="p">,</span> <span class="s">"selection-mode"</span><span class="p">)</span><span class="nf">.ok</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">user_selection</span> <span class="o">=</span> <span class="nf">select_from_list</span><span class="p">(</span>
        <span class="s">"Choose selection-mode"</span><span class="nf">.to_string</span><span class="p">(),</span>
        <span class="n">possible_values_for_selection_mode</span><span class="p">,</span>
        <span class="n">max_height_row_count</span><span class="p">,</span>
        <span class="n">max_width_col_count</span><span class="p">,</span>
        <span class="nn">SelectionMode</span><span class="p">::</span><span class="n">Single</span><span class="p">,</span>
    <span class="p">);</span>

    <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">user_selection</span><span class="p">)</span> <span class="o">=</span> <span class="n">user_selection</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="o">=</span> <span class="n">user_selection</span><span class="nf">.first</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"selection-mode: {}"</span><span class="p">,</span> <span class="n">it</span><span class="p">);</span>
            <span class="nn">SelectionMode</span><span class="p">::</span><span class="nf">from_str</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span><span class="nf">.unwrap_or</span><span class="p">(</span><span class="nn">SelectionMode</span><span class="p">::</span><span class="n">Single</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">print_help_for</span><span class="p">(</span><span class="s">"select-from-list"</span><span class="p">)</span><span class="nf">.ok</span><span class="p">();</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nf">print_help_for</span><span class="p">(</span><span class="s">"select-from-list"</span><span class="p">)</span><span class="nf">.ok</span><span class="p">();</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">it</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="example-2-adding-interactivity-using-a-text-input-field">Example 2: Adding interactivity using a text input field</h3>
<p><a id="markdown-example-2%3A-adding-interactivity-using-a-text-input-field" name="example-2%3A-adding-interactivity-using-a-text-input-field"></a></p>

<p>Here’s an example of adding interactivity using a text input field. This is useful when the values
that a field can take are not known in advance. The <code class="language-plaintext highlighter-rouge">r3bl_tuify</code> crate uses the <code class="language-plaintext highlighter-rouge">reedline</code> crate to
do this.</p>

<blockquote>
  <p>Fun fact: <a href="https://docs.rs/reedline/"><code class="language-plaintext highlighter-rouge">reedline</code></a> is the text input field (line editor)
that is used in <a href="https://github.com/nushell/nushell"><code class="language-plaintext highlighter-rouge">nushell</code></a>.</p>
</blockquote>

<p>In this scenario, <code class="language-plaintext highlighter-rouge">--command-to-run-with-each-selection</code> is <em>not</em> passed in the command
line. So it only interactively prompts the user for this piece of information. Similarly,
if the user does not provide this information, the app exits and provides a help message.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>TODO.todo | cargo run <span class="nt">--</span> <span class="k">select</span><span class="nt">-from-list</span> <span class="nt">--selection-mode</span> single
</code></pre></div></div>

<!-- tuify-interactive-command-to-run-with-selection-not-provided -->
<video width="100%" controls="">
  <source src="https://github.com/r3bl-org/r3bl-open-core/assets/2966499/d8d7d419-c85e-4c10-bea5-345aa31a92a3" type="video/mp4" />
</video>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Handle `command-to-run-with-each-selection` is not passed in.</span>
<span class="k">let</span> <span class="n">command_to_run_with_each_selection</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">maybe_command_to_run_with_each_selection</span> <span class="p">{</span>
        <span class="nf">Some</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">it</span><span class="p">,</span>
        <span class="nb">None</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nf">print_help_for_subcommand_and_option</span><span class="p">(</span>
                <span class="s">"select-from-list"</span><span class="p">,</span>
                <span class="s">"command-to-run-with-each-selection"</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="nf">.ok</span><span class="p">();</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">line_editor</span> <span class="o">=</span> <span class="nn">Reedline</span><span class="p">::</span><span class="nf">create</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">prompt</span> <span class="o">=</span> <span class="n">DefaultPrompt</span> <span class="p">{</span>
                <span class="n">left_prompt</span><span class="p">:</span> <span class="nn">DefaultPromptSegment</span><span class="p">::</span><span class="nf">Basic</span><span class="p">(</span>
                    <span class="s">"Enter command to run w/ each selection `%`: "</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="p">),</span>
                <span class="n">right_prompt</span><span class="p">:</span> <span class="nn">DefaultPromptSegment</span><span class="p">::</span><span class="n">Empty</span><span class="p">,</span>
            <span class="p">};</span>

            <span class="k">let</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">line_editor</span><span class="nf">.read_line</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prompt</span><span class="p">);</span>
            <span class="k">match</span> <span class="n">sig</span> <span class="p">{</span>
                <span class="nf">Ok</span><span class="p">(</span><span class="nn">Signal</span><span class="p">::</span><span class="nf">Success</span><span class="p">(</span><span class="n">buffer</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="n">buffer</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
                        <span class="nf">print_help_for</span><span class="p">(</span><span class="s">"select-from-list"</span><span class="p">)</span><span class="nf">.ok</span><span class="p">();</span>
                        <span class="k">return</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="nd">println!</span><span class="p">(</span><span class="s">"Command to run w/ each selection: {}"</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
                    <span class="n">buffer</span>
                <span class="p">}</span>
                <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="nf">print_help_for</span><span class="p">(</span><span class="s">"select-from-list"</span><span class="p">)</span><span class="nf">.ok</span><span class="p">();</span>
                    <span class="k">return</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">};</span>

<span class="c1">// Actually get input from the user.</span>
<span class="k">let</span> <span class="n">selected_items</span> <span class="o">=</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="nf">select_from_list</span><span class="p">(</span>
        <span class="s">"Select one line"</span><span class="nf">.to_string</span><span class="p">(),</span>
        <span class="n">lines</span><span class="p">,</span>
        <span class="n">max_height_row_count</span><span class="p">,</span>
        <span class="n">max_width_col_count</span><span class="p">,</span>
        <span class="n">selection_mode</span><span class="p">,</span>
    <span class="p">);</span>
    <span class="nf">convert_user_input_into_vec_of_strings</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="next-steps">Next steps</h2>
<p><a id="markdown-next-steps" name="next-steps"></a></p>

<p>There are many more components that need to be added to make it easier to “tuify” lots of
existing CLI experiences. Things like multi line editor component w/ syntax highlighting,
scroll view, form input fields, and more. If you would like to contribute to this effort,
it would be great to have your help.</p>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><summary type="html"><![CDATA[A guide on how to add minimal interactivity to your clap CLI apps using tuify. It doesn't have to be an all or nothing approach w/ going full TUI or CLI.]]></summary></entry><entry><title type="html">Use just to manage project specific commands</title><link href="http://developerlife.com/2023/08/28/justfile/" rel="alternate" type="text/html" title="Use just to manage project specific commands" /><published>2023-08-28T10:00:00-05:00</published><updated>2023-08-28T10:00:00-05:00</updated><id>http://developerlife.com/2023/08/28/justfile</id><content type="html" xml:base="http://developerlife.com/2023/08/28/justfile/"><![CDATA[<p><img class="post-hero-image" src="/assets/justfile.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#prerequisites">Prerequisites</a></li>
  <li><a href="#basic-usage">Basic usage</a></li>
  <li><a href="#advanced-usage">Advanced usage</a>
    <ul>
      <li><a href="#running-many-different-commands">Running many different commands</a></li>
      <li><a href="#run-on-windows">Run on Windows</a></li>
      <li><a href="#run-in-ci--cd-environments-github-actions">Run in CI / CD environments Github Actions</a></li>
      <li><a href="#pass-arguments-into-commands">Pass arguments into commands</a></li>
    </ul>
  </li>
  <li><a href="#next-steps">Next steps</a></li>
</ul>

<!-- /TOC -->

<h2 id="introduction">Introduction</h2>
<p><a id="markdown-introduction" name="introduction"></a></p>

<p>In this tutorial we will learn how to use <a href="https://github.com/casey/just"><code class="language-plaintext highlighter-rouge">just</code></a> by example to
manage project specific commands. <code class="language-plaintext highlighter-rouge">just</code> is like <code class="language-plaintext highlighter-rouge">make</code>, but it is written in Rust, and it works
with <code class="language-plaintext highlighter-rouge">cargo</code>.</p>

<p>Before we get started, please take a look at the
<a href="https://github.com/casey/just"><code class="language-plaintext highlighter-rouge">just</code> project README</a>.</p>
<blockquote>

👀 Watch Rust 🦀 live coding videos on our <a href="https://www.youtube.com/@developerlifecom">YouTube Channel</a>.

<br />
<br />

<!-- video on rust polymorphism (no playlist) -->
<iframe src="https://www.youtube.com/embed/kYTgGtJjSro?si=XmW-_CAvCfB5e269" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<br />
<br />

📦 Install our useful Rust command line apps using <code>cargo install r3bl-cmdr</code>
(they are from the <a href="https://github.com/r3bl-org/r3bl-open-core">r3bl-open-core</a>
project):
<ul>
  <li>🐱<code>giti</code>: run interactive git commands with confidence in your terminal</li>
  <li>🦜<code>edi</code>: edit Markdown with style in your terminal</li>
</ul>

<p>
<kbd>giti in action</kbd>
<video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/262f59d1-a95c-4af3-accf-c3d6cac6e586" type="video/mp4" />
</video>
</p>

<p>
<kbd>edi in action</kbd>
<video width="100%" controls="">
  <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/f2c4b07d-b5a2-4f41-af7a-06d1b6660c41" type="video/mp4" />
</video>
</p>

</blockquote>
<p>Let’s say you have a <code class="language-plaintext highlighter-rouge">justfile</code> that looks like this, and it has a single recipe called
<code class="language-plaintext highlighter-rouge">list</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>list:
  ls -l
</code></pre></div></div>

<p>And you run it by typing <code class="language-plaintext highlighter-rouge">just list</code>. It just turns around and runs this <code class="language-plaintext highlighter-rouge">sh -c "ls -l"</code>.
That’s it. So on Windows, this doesn’t work, because <code class="language-plaintext highlighter-rouge">sh</code> isn’t installed by default. So
you have to install cygwin. And then you have to install <code class="language-plaintext highlighter-rouge">just</code> and then you have to
install <code class="language-plaintext highlighter-rouge">sh</code>.</p>

<p>Alternatively, you can specify that you want to use <code class="language-plaintext highlighter-rouge">powershell</code> instead by
adding this to the top of the <code class="language-plaintext highlighter-rouge">justfile</code>: <code class="language-plaintext highlighter-rouge">set shell := ["powershell.exe", "-c"]</code>. Or you
can just run this <code class="language-plaintext highlighter-rouge">just --shell powershell.exe --shell-arg -c list</code> to run <code class="language-plaintext highlighter-rouge">just</code> itself
at the command prompt.</p>

<p>You can also supply different shell interpreters like <code class="language-plaintext highlighter-rouge">python</code> or <code class="language-plaintext highlighter-rouge">node</code>. And you can even
provide <code class="language-plaintext highlighter-rouge">shebang</code> lines like <code class="language-plaintext highlighter-rouge">#!/usr/bin/env python</code> or <code class="language-plaintext highlighter-rouge">#!/usr/bin/env node</code> at the top
of each recipe.</p>

<h2 id="prerequisites">Prerequisites</h2>
<p><a id="markdown-prerequisites" name="prerequisites"></a></p>

<p>🌠 In order for our <code class="language-plaintext highlighter-rouge">just</code> file to work, we must first install the Rust toolchain and <code class="language-plaintext highlighter-rouge">just</code> and
<code class="language-plaintext highlighter-rouge">cargo-watch</code>:</p>

<ol>
  <li>Install the Rust toolchain using <code class="language-plaintext highlighter-rouge">rustup</code> by following the instructions
<a href="https://rustup.rs/">here</a>.</li>
  <li>Install <code class="language-plaintext highlighter-rouge">cargo-watch</code> using <code class="language-plaintext highlighter-rouge">cargo install cargo-watch</code>.</li>
  <li><a href="https://just.systems/man/en/chapter_4.html">Install</a> <code class="language-plaintext highlighter-rouge">just</code> on your system using
<code class="language-plaintext highlighter-rouge">cargo install just</code>. It is available for Linux, macOS, and Windows.
    <ul>
      <li>If you want shell completions for <code class="language-plaintext highlighter-rouge">just</code> you can follow
<a href="https://github.com/casey/just#shell-completion-scripts">these instructions</a>.</li>
      <li>If you install <code class="language-plaintext highlighter-rouge">just</code> using <code class="language-plaintext highlighter-rouge">cargo install just</code> or <code class="language-plaintext highlighter-rouge">brew install just</code> you will not get shell
completions without doing one extra configuration step. So on Linux it is best to use
<code class="language-plaintext highlighter-rouge">sudo apt install -y just</code> if you want them.</li>
    </ul>
  </li>
</ol>

<h2 id="basic-usage">Basic usage</h2>
<p><a id="markdown-basic-usage" name="basic-usage"></a></p>

<p>For Rust projects, typically we will have a build, run, test project specific commands. Let’s start
with these simple ones first. The benefit of <code class="language-plaintext highlighter-rouge">just</code> is that we can use it to run these commands on
any platform (Linux, Mac, Windows). And we don’t need to create OS or shell specific scripts to do
this 🎉.</p>

<p>Let’s start by creating a <code class="language-plaintext highlighter-rouge">justfile</code> in the root of our project. The <code class="language-plaintext highlighter-rouge">justfile</code> is where we will
define our project specific commands. Here is what it looks like for the
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/ansi_color/justfile"><code class="language-plaintext highlighter-rouge">r3bl_ansi_color</code> repo</a>:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>build:
  cargo build

clean:
  cargo clean

run:
  cargo run --example main
</code></pre></div></div>

<p>These are pretty simple commands. The syntax is pretty simple. The first line is the command name.
And the second line is the command to run. The command can be a single command or a series of
commands.</p>

<p>Now in order to run this, we can just run <code class="language-plaintext highlighter-rouge">just --list</code> in the root of our project. And it will show
us the list of commands that we can run.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>just <span class="nt">--list</span>
Available recipes:
    build
    clean
    run
</code></pre></div></div>

<p>Then to run a command, we can just run <code class="language-plaintext highlighter-rouge">just &lt;command_name&gt;</code>. For example, to run the <code class="language-plaintext highlighter-rouge">build</code>
command, we can run <code class="language-plaintext highlighter-rouge">just build</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>just build
</code></pre></div></div>

<h2 id="advanced-usage">Advanced usage</h2>
<p><a id="markdown-advanced-usage" name="advanced-usage"></a></p>

<h3 id="running-many-different-commands">Running many different commands</h3>
<p><a id="markdown-running-many-different-commands" name="running-many-different-commands"></a></p>

<p>This is pretty straightforward. You can just list all other other just commands inline.
Here’s an example.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>all: clean build test clippy docs rustfmt
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">all</code> command will run the other commands in the order they’re written.</p>

<h3 id="run-on-windows">Run on Windows</h3>
<p><a id="markdown-run-on-windows" name="run-on-windows"></a></p>

<p>Currently our <code class="language-plaintext highlighter-rouge">justfile</code> will run on Linux and macOS. To make it run on Windows, we can
run <code class="language-plaintext highlighter-rouge">just</code> itself using <code class="language-plaintext highlighter-rouge">powershell.exe</code>. Here is what it looks like:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>just <span class="nt">--shell</span> powershell.exe <span class="nt">--shell-arg</span> <span class="nt">-c</span> build
</code></pre></div></div>

<p>Or we can add the line <code class="language-plaintext highlighter-rouge">set shell := ["powershell.exe", "-c"]</code> to the top of the
<code class="language-plaintext highlighter-rouge">justfile</code>.</p>

<p>Alternatively, we can use <code class="language-plaintext highlighter-rouge">nu</code> shell instead of <code class="language-plaintext highlighter-rouge">powershell.exe</code> since it is written in
Rust and available via <code class="language-plaintext highlighter-rouge">cargo install nu</code>.</p>

<h3 id="run-in-ci--cd-environments-github-actions">Run in CI / CD environments (Github Actions)</h3>
<p><a id="markdown-run-in-ci-%2F-cd-environments-github-actions" name="run-in-ci-%2F-cd-environments-github-actions"></a></p>

<p>Let’s add a new command called <code class="language-plaintext highlighter-rouge">all</code> to our <code class="language-plaintext highlighter-rouge">justfile</code>. This will just turn around and run the
<code class="language-plaintext highlighter-rouge">build</code> and <code class="language-plaintext highlighter-rouge">clean</code> commands. Here is what it looks like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>all: build clean
</code></pre></div></div>

<p>Now, we can also use <code class="language-plaintext highlighter-rouge">just</code> in CI / CD environments. For example, here is the <a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/ansi_color/.github/workflows/rust.yml"><code class="language-plaintext highlighter-rouge">rust.yml</code>
file</a>
for this repo’s Github Actions. It runs <code class="language-plaintext highlighter-rouge">just all</code> in the <code class="language-plaintext highlighter-rouge">build</code> step.</p>

<p>The one thing to note is that we are installing <code class="language-plaintext highlighter-rouge">just</code> in the docker container before we
run the <code class="language-plaintext highlighter-rouge">just</code> command. We do this by pulling in the prebuilt binary for Ubuntu as shown
<a href="https://github.com/casey/just#pre-built-binaries">here</a>: <code class="language-plaintext highlighter-rouge">curl --proto '=https' --tlsv1.2
-sSf https://just.systems/install.sh | bash -s -- --to DEST</code></p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">jobs</span><span class="pi">:</span>
  <span class="na">build</span><span class="pi">:</span>

    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>

    <span class="na">steps</span><span class="pi">:</span>

    <span class="pi">-</span> <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v3</span>

    <span class="c1"># Install just before running it below.</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Install just</span>
      <span class="na">run</span><span class="pi">:</span> <span class="s">curl --proto '=https' --tlsv1.2 -sSf https://just.systems/install.sh | bash -s -- --to /usr/local/bin</span>

    <span class="c1"># Simply run the `just all` command.</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">all</span>
      <span class="na">run</span><span class="pi">:</span> <span class="s">just all</span>
</code></pre></div></div>

<p>Using <code class="language-plaintext highlighter-rouge">just all</code> is relatively straightforward way to run all our build steps (that would
run in a CI / CD environment) on our local computer w/out installing docker. While
ensuring that these same steps are carried out in the CI / CD environment.</p>

<h3 id="pass-arguments-into-commands">Pass arguments into commands</h3>
<p><a id="markdown-pass-arguments-into-commands" name="pass-arguments-into-commands"></a></p>

<p>We can also pass arguments into our commands. Let’s say that we have a command that we can use to
run a single test. We can pass the name of the test into the command. Here is what it looks like:</p>

<!--
  More info on escaping `` in markdown:
  - https://stackoverflow.com/questions/24102498/escaping-double-curly-braces-inside-a-markdown-code-block-in-jekyll
  - https://jekyllrb.com/docs/liquid/tags/
 -->

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>watch-one-test test_name:
  <span class="c"># More info on cargo test: https://doc.rust-lang.org/cargo/commands/cargo-test.html</span>
  <span class="c"># More info on cargo watch: https://github.com/watchexec/cargo-watch</span>
  cargo watch <span class="nt">-x</span> check <span class="nt">-x</span> <span class="s1">'test -- --test-threads=1 --nocapture {{test_name}}'</span> <span class="nt">-c</span> <span class="nt">-q</span>
</code></pre></div></div>

<p>There are a few things to note here:</p>

<ol>
  <li>The syntax to name the command is still the same as before.</li>
  <li>However, we have added another string after the command name, which is the argument name
<code class="language-plaintext highlighter-rouge">test_name</code>. If an argument is not passed in then <code class="language-plaintext highlighter-rouge">just</code> will display an error and print a
message stating that an argument is required.</li>
  <li>This argument is used just like a variable would in a <code class="language-plaintext highlighter-rouge">justfile</code>. The `` enclose a
variable name.</li>
</ol>

<p>Now we can run this command by passing in the name of the test that we want to run. For example, if
we want to run the <code class="language-plaintext highlighter-rouge">test_ansi_color</code> test, we can run <code class="language-plaintext highlighter-rouge">just watch-one-test test_ansi_color</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>just watch-one-test bold
</code></pre></div></div>

<p>Here’s an example of a <code class="language-plaintext highlighter-rouge">justfile</code> that has a lot more commands for you to look at:
<a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/ansi_color/justfile">r3bl_ansi_color justfile</a>.</p>

<h2 id="next-steps">Next steps</h2>
<p><a id="markdown-next-steps" name="next-steps"></a></p>

<p>The <code class="language-plaintext highlighter-rouge">just</code> project <a href="https://github.com/casey/just">README</a> has lots of information on how to use
<code class="language-plaintext highlighter-rouge">just</code>. It is best to have a specific thing you are looking for before you visit this page. Here are
some interesting links inside the README:</p>

<ol>
  <li><a href="https://github.com/casey/just#recipe-parameters">Command line arguments</a>.</li>
  <li><a href="https://github.com/casey/just#dotenv-integration">Support for .env files</a>.</li>
  <li><a href="https://github.com/casey/just#conditional-expressions">Conditional expressions</a>.</li>
  <li><a href="https://github.com/casey/just#setting-variables-from-the-command-line">Setting variables</a>.</li>
</ol>]]></content><author><name>Nazmul Idris</name></author><category term="Rust" /><category term="CLI" /><summary type="html"><![CDATA[A guide on how to create just files (which are like make files) to manage project specific commands. In a cross platform way.]]></summary></entry></feed>