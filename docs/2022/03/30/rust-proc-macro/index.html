<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" /><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Guide to Rust procedural macros | developerlife.com</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Guide to Rust procedural macros" />
<meta name="author" content="Nazmul Idris" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Procedural macros are a way for you to extend the Rust compiler and provide plugins that you can use to extend the language. They allow you to reduce the need to write manual boilerplate code, and even allow you to create your own DSL (domain specific language). This article goes into the details of creating the 3 kinds of procedural macros in Rust." />
<meta property="og:description" content="Procedural macros are a way for you to extend the Rust compiler and provide plugins that you can use to extend the language. They allow you to reduce the need to write manual boilerplate code, and even allow you to create your own DSL (domain specific language). This article goes into the details of creating the 3 kinds of procedural macros in Rust." />
<link rel="canonical" href="http://developerlife.com/2022/03/30/rust-proc-macro/" />
<meta property="og:url" content="http://developerlife.com/2022/03/30/rust-proc-macro/" />
<meta property="og:site_name" content="developerlife.com" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-03-30T10:00:00-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Guide to Rust procedural macros" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Nazmul Idris"},"dateModified":"2022-03-30T10:00:00-05:00","datePublished":"2022-03-30T10:00:00-05:00","description":"Procedural macros are a way for you to extend the Rust compiler and provide plugins that you can use to extend the language. They allow you to reduce the need to write manual boilerplate code, and even allow you to create your own DSL (domain specific language). This article goes into the details of creating the 3 kinds of procedural macros in Rust.","headline":"Guide to Rust procedural macros","mainEntityOfPage":{"@type":"WebPage","@id":"http://developerlife.com/2022/03/30/rust-proc-macro/"},"url":"http://developerlife.com/2022/03/30/rust-proc-macro/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css" />

  <!-- Add favicon -->
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />

  <!-- Add fontawesome (only for bio.html page) -->
  <link
    rel="stylesheet"
    href="https://use.fontawesome.com/releases/v5.2.0/css/all.css"
    integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ"
    crossorigin="anonymous"
  /><link type="application/atom+xml" rel="alternate" href="http://developerlife.com/feed.xml" title="developerlife.com" /><!-- https://developers.google.com/analytics/devguides/collection/gtagjs -->
<script async
        src="https://www.googletagmanager.com/gtag/js?id=G-NQY9ECC58H"></script>
<script>
  window.dataLayer = window.dataLayer || []

  function gtag() {
    window.dataLayer.push(arguments)
  }

  gtag("js", new Date())
  gtag("config", "G-NQY9ECC58H")
</script>
</head>
<body><!-- https://github.com/mermaid-js/mermaid/blob/develop/docs/n00b-gettingStarted.md -->
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>

<script>
  // https://mermaid-js.github.io/mermaid/#/theming
  mermaid.initialize({
    startOnLoad: true,
    theme: "dark",
    themeVariables: {
      fontFamily: "Fira Code",
      fontSize: "0.95rem",
      darkMode: true,
      primaryColor: "#2f9ece",
      mainBkg: "#303439",
    },
  })
</script>
<header class="site-header" role="banner">

    <div class="wrapper header-wrapper"><div class="logo-container">
        <div class="logo-image">
          <a class="site-title"
             rel="author"
             href="/">
              <!-- This is the logo image placeholder. -->
                <picture>
                  <source srcset="/assets/dl-logo-icon-dark.svg" media="(max-width: 600px)"/>
                  <img  src="/assets/dl-logo-icon-and-text-dark.svg" />
                </picture>
          </a>
        </div>
      </div><nav class="site-nav">
            <input type="checkbox" id="nav-trigger" class="nav-trigger"/>
            <label for="nav-trigger">
          <span class="menu-icon">
              <svg class="svg-icon">
              <use xlink:href="/assets/minima-social-icons.svg#menu">
              </use>
            </svg>
          </span>
            </label>

            <div class="trigger"><!--
    Iterate over all the pages in the site, where page_cursor holds the current
    page for each pass of the for loop.
    Note that page is the currently loaded page itself.
--><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Android/"> Android </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/CC/"> Concurrency </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/CLI/"> CLI </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/CS/"> CS </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/DB/"> Database </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/DI/"> DI </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/FE/"> Frontend </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Hardware/"> Hardware </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/IJ/"> IntelliJ </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/KT/"> Kotlin </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Linux/"> Linux </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/MP/"> MP </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Misc/"> Misc </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Node/"> Node </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Productivity/"> Productivity </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/RN/"> React-Native </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/React/"> React </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Rust/"> Rust </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Server/"> Server </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/State/"> State-Management </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Stories/"> Stories </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/TDD/"> Testing </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/TS/"> TypeScript </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/TUI/"> TUI </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Web/"> Web </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/about-me/"> Nazmul Idris </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/about-site/"> About Us </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/authors/"> Authors </a></div>
        </nav></div>
</header>

<!-- Debug to show the value of page.title and page.category variables -->
<!--<pre>page_cursor.exclude = nil</pre>-->
<!--<pre>page.exclude = nil</pre>-->
<!--<pre>page.title = &quot;Guide to Rust procedural macros&quot;</pre>-->
<!--<pre>page.category = nil</pre>-->
<!--<pre>page.title (json) = Guide to Rust procedural macros</pre>-->
<!--<pre>page.category (json) = </pre>-->
<div class="page-and-sidebar-wrapper">
      <main class="page-content" aria-label="Content">
        <div class="wrapper"><article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting"><header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Guide to Rust procedural macros</h1>

    <!-- Create all the variables needed for this page (and all the includes) -->
    

    <div class="post-meta">
        <p>
            <!-- Date -->Mar 30, 2022

            <!--Author-->
            ‚àô <a href="/about-me">Nazmul Idris</a>

            <!-- One line social blurb --><ul class="contact-list">
    <li class="p-name">Hi, I'm
            <a href="/about-me">Nazmul</a>,
            an ex-Googler, <a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/tui" target="_blank">r3bl_tui maintainer</a>, SWE, entrepreneur, designer, leader,
            TaiChi-er, racer, storyteller.
            <!-- This is fontawesome icon -->
            I <i class="fas fa-heart"></i>
            leadership, authenticity, play,
            <i class="fas fa-code"></i>,
            <i class="fas fa-terminal"></i>, &
            <i class="fas fa-coffee"></i>,
            üòÉ.</li>
</ul>
</p>
    </div><div class="social-media-container">
  <!-- <iframe
    src="https://github.com/sponsors/nazmulidris/button"
    title="Sponsor nazmulidris"
    height="35"
    width="116"
    style="border: 0; padding-right: 6px"
  ></iframe> -->

  <p class="social-media-item">
    <a
      href="https://discord.gg/PhuF4qFpcA"
      target="_blank"
      title="Join our Discord server for comments, feedback, discussions"
    >
      <svg class="svg-icon">
        <use xlink:href="/assets/minima-social-icons.svg#discord"></use>
      </svg>
    </a>
  </p>

  <p class="social-media-item">
    <a href="https://r3bl.com/#services" target="_blank" title="Need help with code?">
      <img class="svg-icon" src="https://r3bl.com/images/logo.svg" alt="R3BL Logo">
    </a>
  </p>

  <!-- <a class="social-media-item" href="https://discord.gg/PhuF4qFpcA" target="_blank"
    >Feedback & comments</a
  > -->

  <!-- <a class="social-media-item" href="https://r3bl.com#services" target="_blank"
    >Need help with code?</a
  > --><p class="social-media-item">
    <a
      href="https://www.youtube.com/channel/UCMcsxfCwzwDevc3NRqFgfEg"
      target="_blank"
      title="developerlife.com YouTube channel"
    >
      <svg class="svg-icon">
        <use xlink:href="/assets/minima-social-icons.svg#youtube"></use>
      </svg>
    </a>
  </p><p class="social-media-item">
    <a
      href="https://www.linkedin.com/in/nazmulidris"
      target="_blank"
      title="Nazmul Idris LinkedIn profile"
    >
      <svg class="svg-icon">
        <use xlink:href="/assets/minima-social-icons.svg#linkedin"></use>
      </svg>
    </a>
  </p><p class="social-media-item">
    <a
      href="https://www.github.com/nazmulidris" target="_blank" title="Nazmul Idris github profile">
      <svg class="svg-icon">
        <use xlink:href="/assets/minima-social-icons.svg#github"></use>
      </svg>
    </a>
  </p><p class="social-media-item">
    <a href="/feed.xml" target="_blank" title="RSS feed">
      <svg class="svg-icon">
        <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
      </svg>
    </a>
  </p></div>
</header>
<div class="post-content e-content" itemprop="articleBody">
        <!-- If a page has a hero-image defined in it, then show it here -->


        <p><img class="post-hero-image" src="/assets/rust-proc-macro.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#what-are-procedural-macros">What are procedural macros</a>
    <ul>
      <li><a href="#declarative-macros-have-limitations">Declarative macros have limitations</a></li>
      <li><a href="#summary-of-proc-vs-decl-macros">Summary of proc vs decl macros</a></li>
      <li><a href="#source-code-examples">Source code examples</a></li>
    </ul>
  </li>
  <li><a href="#how-to-add-a-proc-macro-lib-crate-to-your-existing-project">How to add a proc macro lib crate to your existing project</a>
    <ul>
      <li><a href="#add-an-internal-or-core-crate">Add an internal or core crate</a></li>
    </ul>
  </li>
  <li><a href="#what-does-a-syn-ast-look-like">What does a syn AST look like?</a></li>
  <li><a href="#how-to-write-a-proc-macro-of-any-kind">How to write a proc macro of any kind</a>
    <ul>
      <li><a href="#strategy">Strategy</a></li>
      <li><a href="#examples">Examples</a></li>
      <li><a href="#writing-your-own-parse-trait-impl-in-different-ways">Writing your own Parse trait impl in different ways</a></li>
    </ul>
  </li>
  <li><a href="#eg-1---function-like-macro-that-dumps-the-ast">Eg 1 - Function-like macro that dumps the AST</a></li>
  <li><a href="#eg-2---function-like-macro-that-parses-custom-syntax">Eg 2 - Function-like macro that parses custom syntax</a>
    <ul>
      <li><a href="#desired-syntax-and-behavior">Desired syntax and behavior</a></li>
      <li><a href="#implementing-the-syntax-parser">Implementing the syntax parser</a></li>
      <li><a href="#implementing-the-code-generator">Implementing the code generator</a></li>
    </ul>
  </li>
  <li><a href="#eg-3---derive-macro-that-adds-a-method-to-a-struct">Eg 3 - Derive macro that adds a method to a struct</a>
    <ul>
      <li><a href="#test-for-expected-output">Test for expected output</a></li>
      <li><a href="#watch-macro-expansion">Watch macro expansion</a></li>
      <li><a href="#naive-implementation">Naive implementation</a></li>
      <li><a href="#better-implementation-that-handles-generics">Better implementation that handles generics</a></li>
      <li><a href="#using-quote">Using quote!</a></li>
    </ul>
  </li>
  <li><a href="#eg-4---derive-macro-that-generates-a-builder">Eg 4 - Derive macro that generates a builder</a>
    <ul>
      <li><a href="#stub-out-the-implementation">Stub out the implementation</a></li>
      <li><a href="#testing-the-macro">Testing the macro</a></li>
      <li><a href="#implementation-details">Implementation details</a></li>
    </ul>
  </li>
  <li><a href="#eg-5---attribute-macro-that-adds-logging-to-a-function">Eg 5 - Attribute macro that adds logging to a function</a>
    <ul>
      <li><a href="#create-entry-in-librs">Create entry in lib.rs</a></li>
      <li><a href="#how-to-parse-item">How to parse item?</a></li>
      <li><a href="#how-to-parse-args-containing-attributes-for-variant-1">How to parse args containing attributes for variant 1?</a></li>
      <li><a href="#how-to-parse-args-containing-set-of-identifiers-for-variant-2">How to parse args containing set of identifiers for variant 2?</a></li>
    </ul>
  </li>
  <li><a href="#learning-resources">Learning resources</a></li>
  <li><a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</a></li>
</ul>

<!-- /TOC -->
      <h2 id="what-are-procedural-macros">
        
        
          What are procedural macros <a href="#what-are-procedural-macros">#</a>
        
        
      </h2>
    

<p><strong>Procedural macros</strong> are a way for you to extend the Rust compiler and provide plugins that you can
use to extend the language. They are really powerful and require some more work to setup in an
existing project (you have to create a new library create just for them and they all have to be
declared in the <code class="language-plaintext highlighter-rouge">lib.rs</code> file). Here are the key benefits of procedural macros:</p>

<ul>
  <li>Minimize the amount of manual work you have to do in order to generate boilerplate code üéâ. This
is similar to
<a href="https://developerlife.com/2020/07/11/annotation-processing-kotlin-android/">annotation processing</a>
in Java and Kotlin.</li>
  <li>You can create your own domain specific language like React JSX in Rust üéâ. Create your own
<a href="https://developerlife.com/2020/04/04/kotlin-dsl-intro/">DSL (domain specific language)</a> like in
Kotlin and babel and JavaScript.</li>
</ul>
      <h3 id="declarative-macros-have-limitations">
        
        
          Declarative macros have limitations <a href="#declarative-macros-have-limitations">#</a>
        
        
      </h3>
    

<p>For example they can‚Äôt work with generics. They are easier to write than procedural
macros. If you have simple use cases they work great, since they are so easy to write.
Here are some resources to help you w/ learning declarative macros.</p>

<ol>
  <li><a href="https://github.com/r3bl-org/r3bl-open-core/search?q=macro_rules">Declarative macros in <code class="language-plaintext highlighter-rouge">r3bl-open-core</code> repo</a></li>
  <li><a href="https://github.com/nazmulidris/rust_scratch/blob/main/macros/tests/decl/main.rs">Declarative macros included in this article‚Äôs repo (but not covered in this article)</a></li>
  <li><a href="https://veykril.github.io/tlborm/introduction.html">Little book of Rust macros</a></li>
  <li><a href="https://youtu.be/q6paRBbLgNw">Great YT video on declarative macros</a></li>
</ol>
      <h3 id="summary-of-proc-vs-decl-macros">
        
        
          Summary of proc vs decl macros <a href="#summary-of-proc-vs-decl-macros">#</a>
        
        
      </h3>
    

<table>
  <thead>
    <tr>
      <th>Macro type</th>
      <th>Capabilities &amp; limitations</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Declarative</td>
      <td>Can‚Äôt handle generics, patterns capture items as <em>wholes</em> and can‚Äôt be broken down in the macro body</td>
    </tr>
    <tr>
      <td>Procedural - function like</td>
      <td>Operates on the code passed inside parenthesis of invocation to produce new token stream.</td>
    </tr>
    <tr>
      <td>Procedural - derive</td>
      <td>Can‚Äôt touch token stream of annotated <code class="language-plaintext highlighter-rouge">struct</code> or <code class="language-plaintext highlighter-rouge">enum</code>, only add new token stream below; can declare helper attributes</td>
    </tr>
    <tr>
      <td>Procedural - attribute</td>
      <td>Like function-like, replaces token stream of annotated item (not just <code class="language-plaintext highlighter-rouge">struct</code> or <code class="language-plaintext highlighter-rouge">enum</code>)</td>
    </tr>
  </tbody>
</table>
      <h3 id="source-code-examples">
        
        
          Source code examples <a href="#source-code-examples">#</a>
        
        
      </h3>
    

<ol>
  <li>You can find ‚Äúreal world‚Äù examples of both declarative and procedural macros in the
<code class="language-plaintext highlighter-rouge">r3bl-open-core</code> <a href="https://github.com/r3bl-org/r3bl-open-core">repo</a>.
    <ul>
      <li><a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/macro">proc macros</a></li>
      <li><a href="https://github.com/r3bl-org/r3bl-open-core-archive/tree/main/macro">proc macros</a></li>
      <li><a href="https://github.com/r3bl-org/r3bl-open-core/search?q=macro_rules">decl macros</a></li>
    </ul>
  </li>
  <li>You can find all the pedagogical examples of macros shown in this article in this
<a href="https://github.com/nazmulidris/rust_scratch/blob/main/macros/">repo</a>.</li>
</ol>

<blockquote>
  <p>For more information on general Rust type system design (functional approach rather than
object oriented), please take a look at this <a href="https://arxiv.org/pdf/2307.07069.pdf">paper</a>
by Will Crichton demonstrating Typed Design Patterns with Rust.</p>
</blockquote>
      <h2 id="how-to-add-a-proc-macro-lib-crate-to-your-existing-project">
        
        
          How to add a proc macro lib crate to your existing project <a href="#how-to-add-a-proc-macro-lib-crate-to-your-existing-project">#</a>
        
        
      </h2>
    

<p>Rust has two kinds of macros: declarative and procedural. Declarative macros are made using
<code class="language-plaintext highlighter-rouge">macro_rules!</code> inline in your code w/out creating a new lib crate. This article is about procedural
macros which are the imperative style of creating Rust macros.</p>

<blockquote>
  <p>ü§î One complication with using procedural macros is that they are not allowed to be used in the
same crate where your code lives. This requires us to create a new library create inside our
existing Rust project.</p>
</blockquote>

<p>The first step in using procedural macros is to create a new library crate.</p>

<p>Here are the steps that we must take starting in our existing Rust project (which maybe a lib or bin
or both project).</p>

<ol>
  <li>
    <p>Create a new crate inside our existing Rust project.</p>

    <ul>
      <li>Run the following command to create a new <code class="language-plaintext highlighter-rouge">my_proc_macros_lib</code> crate inside your existing
project.
        <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>cargo new <span class="nt">--lib</span> my_proc_macros_lib
</code></pre></div>        </div>
      </li>
      <li>Inside the newly created <code class="language-plaintext highlighter-rouge">my_proc_macros_lib</code> folder you will find:
        <ul>
          <li>A <code class="language-plaintext highlighter-rouge">Cargo.toml</code> file. Make sure to add these dependencies to this file:
            <ul>
              <li><code class="language-plaintext highlighter-rouge">quote = "*"</code></li>
              <li><code class="language-plaintext highlighter-rouge">syn = { version = "*", features = ["extra-traits"] }</code></li>
              <li><code class="language-plaintext highlighter-rouge">proc-macro2 = "*"</code></li>
            </ul>
          </li>
          <li>A <code class="language-plaintext highlighter-rouge">src</code> folder w/ a <code class="language-plaintext highlighter-rouge">lib.rs</code> file inside of it. All proc macro functions (annotated w/
<code class="language-plaintext highlighter-rouge">#[proc_macro]</code>) must be defined in this file and no other. You can however import code from
other modules just like normal. You can think of this file as a place where you ‚Äúexport‚Äù the
definitions of your macros to other crates. Kind of like a registry or manifest of procedural
macros in this lib crate that the Rust compiler can discover and use easily.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>You now have to This declares this newly created crate as a dependency of your main project.</p>

    <ul>
      <li>Add the following to your main project‚Äôs <code class="language-plaintext highlighter-rouge">Cargo.toml</code> file:
        <div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[dependencies]</span>
<span class="py">my_proc_macros_lib</span> <span class="o">=</span> <span class="p">{</span> <span class="py">path</span> <span class="p">=</span> <span class="s">"my_proc_macros_lib"</span> <span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>You can now use the code in this <code class="language-plaintext highlighter-rouge">my_proc_macros_lib</code> crate by importing them in the code of your
main like so: <code class="language-plaintext highlighter-rouge">use my_proc_macros_lib::*</code>.</p>
  </li>
</ol>

<p>Here‚Äôs an example of a <code class="language-plaintext highlighter-rouge">Cargo.toml</code> for the proc macro lib crate:</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[package]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"my_proc_macros_lib"</span>
<span class="py">version</span> <span class="p">=</span> <span class="s">"0.1.0"</span>
<span class="py">edition</span> <span class="p">=</span> <span class="s">"2021"</span>

<span class="nn">[lib]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"my_proc_macros_lib"</span>
<span class="py">path</span> <span class="p">=</span> <span class="s">"src/lib.rs"</span>
<span class="py">proc-macro</span> <span class="p">=</span> <span class="kc">true</span>

<span class="nn">[dependencies]</span>
<span class="c"># https://github.com/dtolnay/proc-macro-workshop#debugging-tips</span>
<span class="py">syn</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"*"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"extra-traits"</span><span class="p">]</span> <span class="p">}</span>
<span class="py">quote</span> <span class="p">=</span> <span class="s">"*"</span>
<span class="py">proc-macro2</span> <span class="p">=</span> <span class="s">"*"</span>
<span class="py">r3bl_rs_utils</span> <span class="p">=</span> <span class="s">"*"</span>
</code></pre></div></div>

<blockquote>
  <p>üóúÔ∏è It is also a good idea to install <code class="language-plaintext highlighter-rouge">cargo expand</code> to see what your code your macros actually
expand into. You will need two things:</p>

  <ol>
    <li><code class="language-plaintext highlighter-rouge">cargo install cargo-expand</code> which installs <code class="language-plaintext highlighter-rouge">cargo expand</code>.</li>
    <li><code class="language-plaintext highlighter-rouge">rustup toolchain install nightly</code> which installs the Rust nightly toolchain that‚Äôs needed by
<code class="language-plaintext highlighter-rouge">cargo expand</code>.</li>
  </ol>

  <p>Then you can run a command like the following <code class="language-plaintext highlighter-rouge">cargo expand --test test_derive_macro_describe</code> to
expand the test <code class="language-plaintext highlighter-rouge">test_derive_macro_describe</code>.</p>

  <p>üëÄ To watch for changes in your code and run the above command, you can install
<code class="language-plaintext highlighter-rouge">cargo install cargo-watch</code> and then run:
<code class="language-plaintext highlighter-rouge">cargo watch -x 'expand --test test_derive_macro_describe'</code>.</p>

  <ol>
    <li>A script is provided called <code class="language-plaintext highlighter-rouge">cargo-watch-macro-expand-one-test.fish</code> which does this for the
test that you give that script as an argument.</li>
    <li>Another script is provided called <code class="language-plaintext highlighter-rouge">cargo-watch-one-test.fish</code> which watches for changes in your
and then runs the test you give that script as an argument.</li>
  </ol>
</blockquote>
      <h3 id="add-an-internal-or-core-crate">
        
        
          Add an internal or core crate <a href="#add-an-internal-or-core-crate">#</a>
        
        
      </h3>
    

<p>There are situations where you will need to share code between your public crate and your procedural
macro crate. In this case you can add an internal or core crate to your project. The shared files
will all go inside of this core or internal crate.</p>

<p>For more information on this, please check out
<a href="https://stackoverflow.com/a/64288799/2085356">this stackoverflow thread</a>.</p>

<p>The basic steps look like this:</p>

<ol>
  <li>Add a new crate <code class="language-plaintext highlighter-rouge">my_core_lib</code> and create the following dependencies:
    <ul>
      <li>public crate (eg: <code class="language-plaintext highlighter-rouge">r3bl_rs_utils</code>) deps: <code class="language-plaintext highlighter-rouge">[my_core_lib, my_proc_macros_lib]</code></li>
      <li>proc macro crate (eg: <code class="language-plaintext highlighter-rouge">my_proc_macros_lib</code>) deps: <code class="language-plaintext highlighter-rouge">[my_core_lib]</code></li>
    </ul>
  </li>
  <li>The files that need to be shared everywhere (public &amp; proc macro crates) need to go in the
<code class="language-plaintext highlighter-rouge">my_core_lib</code> crate.</li>
</ol>

<blockquote>
  <p>üì¶ Here‚Äôs a real example of this from the
<a href="https://crates.io/crates/r3bl_rs_utils"><code class="language-plaintext highlighter-rouge">r3bl_rs_utils</code></a> crate which applies this change in this
<a href="https://github.com/r3bl-org/r3bl-rs-utils/commit/c5b57f7b81e746a7277191dc1593237b5bc12867">commit</a>.</p>

  <p>üåü Please star the <a href="https://github.com/r3bl-org/r3bl-open-core"><code class="language-plaintext highlighter-rouge">r3bl-open-core</code> repo</a> on github if
you like it üôè.</p>
</blockquote>

<p>If you publish the public crate to crates.io, then you will need to publish each of the dependent
crates as well. This won‚Äôt happen automatically when publishing the public crate, you have to go in
and run <code class="language-plaintext highlighter-rouge">cargo publish</code> on each and every dependent crate and they will be their own installable
crate on crates.io.</p>
      <h2 id="what-does-a-syn-ast-look-like">
        
        
          What does a syn AST look like? <a href="#what-does-a-syn-ast-look-like">#</a>
        
        
      </h2>
    

<p>Before writing macros, let‚Äôs talk about how we need to think about things:</p>

<ol>
  <li>
    <p>Instead of working w/
<a href="https://doc.rust-lang.org/proc_macro/struct.TokenStream.html"><code class="language-plaintext highlighter-rouge">TokenStream</code></a>s, we will work w/
an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">AST (abstract syntax tree)</a> generated by
<a href="https://github.com/dtolnay/syn/tree/master/examples"><code class="language-plaintext highlighter-rouge">syn::*</code></a> functions and macros. This will
make our life much easier.</p>
  </li>
  <li>
    <p>We will then walk parts of this tree and generate code using
<a href="https://docs.rs/quote/latest/quote/macro.quote.html"><code class="language-plaintext highlighter-rouge">quote!</code></a> which will generate a new
<code class="language-plaintext highlighter-rouge">TokenStream</code> that will then be returned by our procedural macro.</p>
  </li>
</ol>

<p>Let‚Äôs take a look at what an AST actually looks like. Here‚Äôs an example of what you get from parsing
the string <code class="language-plaintext highlighter-rouge">"fn foo() -&gt; u32 { 42 }"</code> using
<a href="https://docs.rs/syn/latest/syn/fn.parse_str.html"><code class="language-plaintext highlighter-rouge">syn::parse_str()</code></a>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">attrs</span><span class="p">:</span> <span class="p">[],</span>
    <span class="n">vis</span><span class="p">:</span> <span class="n">Inherited</span><span class="p">,</span>
    <span class="n">sig</span><span class="p">:</span> <span class="n">Signature</span> <span class="p">{</span>
        <span class="n">constness</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
        <span class="n">asyncness</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
        <span class="n">unsafety</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
        <span class="n">abi</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
        <span class="n">fn_token</span><span class="p">:</span> <span class="nb">Fn</span><span class="p">,</span>
        <span class="n">ident</span><span class="p">:</span> <span class="n">Ident</span> <span class="p">{</span>
            <span class="n">ident</span><span class="p">:</span> <span class="s">"foo"</span><span class="p">,</span>
            <span class="n">span</span><span class="p">:</span> <span class="err">#</span><span class="mi">5</span> <span class="nf">bytes</span><span class="p">(</span><span class="mi">91</span><span class="o">..</span><span class="mi">125</span><span class="p">),</span>
        <span class="p">},</span>
        <span class="n">generics</span><span class="p">:</span> <span class="n">Generics</span> <span class="p">{</span>
            <span class="n">lt_token</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
            <span class="n">params</span><span class="p">:</span> <span class="p">[],</span>
            <span class="n">gt_token</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
            <span class="n">where_clause</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">paren_token</span><span class="p">:</span> <span class="n">Paren</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="p">[],</span>
        <span class="n">variadic</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
        <span class="n">output</span><span class="p">:</span> <span class="nf">Type</span><span class="p">(</span>
            <span class="n">RArrow</span><span class="p">,</span>
            <span class="nf">Path</span><span class="p">(</span>
                <span class="n">TypePath</span> <span class="p">{</span>
                    <span class="n">qself</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
                    <span class="n">path</span><span class="p">:</span> <span class="n">Path</span> <span class="p">{</span>
                        <span class="n">leading_colon</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
                        <span class="n">segments</span><span class="p">:</span> <span class="p">[</span>
                            <span class="n">PathSegment</span> <span class="p">{</span>
                                <span class="n">ident</span><span class="p">:</span> <span class="n">Ident</span> <span class="p">{</span>
                                    <span class="n">ident</span><span class="p">:</span> <span class="s">"u32"</span><span class="p">,</span>
                                    <span class="n">span</span><span class="p">:</span> <span class="err">#</span><span class="mi">5</span> <span class="nf">bytes</span><span class="p">(</span><span class="mi">91</span><span class="o">..</span><span class="mi">125</span><span class="p">),</span>
                                <span class="p">},</span>
                                <span class="n">arguments</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
                            <span class="p">},</span>
                        <span class="p">],</span>
                    <span class="p">},</span>
                <span class="p">},</span>
            <span class="p">),</span>
        <span class="p">),</span>
    <span class="p">},</span>
    <span class="n">block</span><span class="p">:</span> <span class="n">Block</span> <span class="p">{</span>
        <span class="n">brace_token</span><span class="p">:</span> <span class="n">Brace</span><span class="p">,</span>
        <span class="n">stmts</span><span class="p">:</span> <span class="p">[</span>
            <span class="nf">Expr</span><span class="p">(</span>
                <span class="nf">Lit</span><span class="p">(</span>
                    <span class="n">ExprLit</span> <span class="p">{</span>
                        <span class="n">attrs</span><span class="p">:</span> <span class="p">[],</span>
                        <span class="n">lit</span><span class="p">:</span> <span class="nf">Int</span><span class="p">(</span>
                            <span class="n">LitInt</span> <span class="p">{</span>
                                <span class="n">token</span><span class="p">:</span> <span class="mi">42</span><span class="p">,</span>
                            <span class="p">},</span>
                        <span class="p">),</span>
                    <span class="p">},</span>
                <span class="p">),</span>
            <span class="p">),</span>
        <span class="p">],</span>
    <span class="p">},</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>üí° Here‚Äôs an example from the syn repo that shows you how to read in a Rust file and dump it into
a syn AST:
<a href="https://github.com/dtolnay/syn/blob/master/examples/dump-syntax/src/main.rs">dump-syntax</a>.</p>
</blockquote>
      <h2 id="how-to-write-a-proc-macro-of-any-kind">
        
        
          How to write a proc macro of any kind <a href="#how-to-write-a-proc-macro-of-any-kind">#</a>
        
        
      </h2>
    

<p>There are 3 kinds of proc macros. Once you‚Äôve created a new library crate for them inside your
project, you write macros like the ones shown below.</p>

<blockquote>
  <p>üìú This article will provide examples of each of these types of macros. You can find them all in
this <a href="https://github.com/nazmulidris/rust_scratch/blob/main/macros/">repo</a>.</p>

  <p>üí° You can also take a look at this tutorial by
<a href="https://blog.jetbrains.com/rust/2022/03/18/procedural-macros-under-the-hood-part-i/">JetBrains</a>
which goes into visual descriptions of the AST, token tree, etc.</p>
</blockquote>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="k">crate</span> <span class="n">proc_macro</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">proc_macro</span><span class="p">::</span><span class="n">TokenStream</span><span class="p">;</span>

<span class="nd">#[proc_macro]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">my_fn_like_proc_macro</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TokenStream</span> <span class="p">{</span>
  <span class="c1">// 1. Use syn to parse the input tokens into a syntax tree.</span>
  <span class="c1">// 2. Use quote to generate new tokens based on what we parsed.</span>
  <span class="c1">// 3. Return the generated tokens.</span>
  <span class="n">input</span>
<span class="p">}</span>

<span class="nd">#[proc_macro_derive(MyDerive)]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">my_derive_proc_macro</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TokenStream</span> <span class="p">{</span>
  <span class="c1">// 1. Use syn to parse the input tokens into a syntax tree.</span>
  <span class="c1">// 2. Generate new tokens based on the syntax tree. This is additive to the `enum` or</span>
  <span class="c1">//    `struct` that is annotated (it doesn't replace them).</span>
  <span class="c1">// 3. Return the generated tokens.</span>
  <span class="n">input</span>
<span class="p">}</span>

<span class="nd">#[proc_macro_attribute]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">log_entry_and_exit</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">,</span> <span class="n">input</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TokenStream</span> <span class="p">{</span>
  <span class="c1">// 1. Use syn to parse the args &amp; input tokens into a syntax tree.</span>
  <span class="c1">// 2. Generate new tokens based on the syntax tree. This will replace whatever `item` is</span>
  <span class="c1">//    annotated w/ this attribute proc macro.</span>
  <span class="c1">// 3. Return the generated tokens.</span>
  <span class="n">input</span>
<span class="p">}</span>
</code></pre></div></div>
      <h3 id="strategy">
        
        
          Strategy <a href="#strategy">#</a>
        
        
      </h3>
    

<p>The rough idea is that we will have to parse ‚Äúthings‚Äù into this <code class="language-plaintext highlighter-rouge">proc_macro2::TokenStream</code> in order
to manipulate them. They can be parsed into this AST from:</p>

<ol>
  <li><a href="https://docs.rs/syn/latest/syn/parse/index.html#the-synparse-functions">Strings</a>,</li>
  <li>Input to a derive macro,</li>
  <li>Input to an attribute macro,</li>
  <li>Input to a function like macro,</li>
  <li>And even other ASTs generated by <code class="language-plaintext highlighter-rouge">quote!()</code> using
<a href="https://docs.rs/syn/latest/syn/macro.parse_quote.html"><code class="language-plaintext highlighter-rouge">parse_quote!()</code></a>.</li>
</ol>

<p>In order to do this parsing you have to use the
<a href="https://docs.rs/syn/latest/syn/parse/index.html#the-synparse-functions"><code class="language-plaintext highlighter-rouge">syn::parse*</code> functions</a>.</p>

<ul>
  <li>When using any of them (macro form or otherwise) you have to provide the type that you want the
<code class="language-plaintext highlighter-rouge">TokenStream</code> to be parsed <strong>into</strong>.</li>
  <li>You have to supply the type that you want the <code class="language-plaintext highlighter-rouge">TokenStream</code> to be parsed <strong>as</strong>. So if you have a
function then you want to tell syn to parse it <code class="language-plaintext highlighter-rouge">as ItemFn</code>. Here‚Äôs an example:
<code class="language-plaintext highlighter-rouge">let fun:ItemFn = parse_macro_input!(input as ItemFn)</code>. This will parse the <code class="language-plaintext highlighter-rouge">input</code> variable into
an <code class="language-plaintext highlighter-rouge">ItemFn</code> AST and then you can work w/ the fields provided by <code class="language-plaintext highlighter-rouge">ItemFn</code> after that.</li>
</ul>
      <h3 id="examples">
        
        
          Examples <a href="#examples">#</a>
        
        
      </h3>
    

<p>So here are some examples of what this looks like.</p>

<ol>
  <li>
    <p>This is how you parse a <code class="language-plaintext highlighter-rouge">TokenStream</code> into a <code class="language-plaintext highlighter-rouge">DeriveInput</code> using the <code class="language-plaintext highlighter-rouge">parse_macro_input!()</code>
function (eg: in a derive macro):</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">derive_proc_macro_impl</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TokenStream</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">DeriveInput</span> <span class="p">{</span>
    <span class="n">ident</span><span class="p">:</span> <span class="n">struct_name_ident</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">generics</span><span class="p">,</span>
    <span class="o">..</span>
  <span class="p">}</span> <span class="o">=</span> <span class="nd">parse_macro_input!</span><span class="p">(</span><span class="n">input</span> <span class="k">as</span> <span class="n">DeriveInput</span><span class="p">);</span> <span class="c1">// Same as: syn::parse(input).unwrap();</span>
  <span class="o">...</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>This is how you parse a string into a <code class="language-plaintext highlighter-rouge">proc_macro2::TokenStream</code> using the <code class="language-plaintext highlighter-rouge">parse_str()</code>
function. Note that we have to provide the type that we want the <code class="language-plaintext highlighter-rouge">String</code> to be parsed <strong>into</strong>
via the turbofish syntax, in this case <code class="language-plaintext highlighter-rouge">syn::Type</code>.</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">traits</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="s">"std::default::Default"</span><span class="p">,</span> <span class="s">"std::fmt::Debug"</span><span class="p">];</span>
<span class="nn">syn</span><span class="p">::</span><span class="nn">parse_str</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">syn</span><span class="p">::</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">traits</span><span class="nf">.join</span><span class="p">(</span><span class="s">" + "</span><span class="p">))</span><span class="nf">.unwrap</span><span class="p">();</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>It is possible to provide your own implementation of the <code class="language-plaintext highlighter-rouge">Parse</code> trait and hand it to syn to
extract the AST you want out of the input <code class="language-plaintext highlighter-rouge">TokenStream</code>. The syn docs have an example of this
<a href="https://docs.rs/syn/latest/syn/parse/index.html#example">here</a>. There‚Äôs also a
<a href="https://docs.rs/syn/latest/syn/parse/index.html#the-parser-trait"><code class="language-plaintext highlighter-rouge">Parser</code> trait</a> that you can
implement which allows you greater control over the parsing process.</p>
  </li>
</ol>
      <h3 id="writing-your-own-parse-trait-impl-in-different-ways">
        
        
          Writing your own Parse trait impl in different ways <a href="#writing-your-own-parse-trait-impl-in-different-ways">#</a>
        
        
      </h3>
    

<p>This might not be intuitive, but you can parse the <strong>same</strong> <code class="language-plaintext highlighter-rouge">TokenStream</code> using various different
parsers. You can parse a <code class="language-plaintext highlighter-rouge">TokenStream</code> as a <code class="language-plaintext highlighter-rouge">Type</code> or <code class="language-plaintext highlighter-rouge">Ident</code> or whatever else depending on what you
need.</p>

<p>Try different traits until you get the one that gets you the AST you want. You can also write
<a href="https://docs.rs/syn/latest/syn/parse/index.html#example">your own parser</a>.</p>

<p>Let‚Äôs illustrate this with an example. Let‚Äôs say you want to provide a function like macro w/ the
following syntax: <code class="language-plaintext highlighter-rouge">fn_macro_custom_syntax! { ThingManager&lt;T&gt; for Vec&lt;T&gt; }</code>. You can write your own
<code class="language-plaintext highlighter-rouge">Parse</code> trait implementation and extract the AST from the <code class="language-plaintext highlighter-rouge">TokenStream</code> and you can write this
parser in many many different ways.</p>

<p>Here‚Äôs one example.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">ManagerOfThingInfo</span> <span class="p">{</span>
  <span class="n">manager_ident</span><span class="p">:</span> <span class="n">Ident</span><span class="p">,</span>
  <span class="n">manager_generics_ident</span><span class="p">:</span> <span class="n">Ident</span><span class="p">,</span>
  <span class="n">thing_type</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span>
<span class="p">}</span>

<span class="cd">/// [Parse docs](https://docs.rs/syn/latest/syn/parse/index.html)</span>
<span class="k">impl</span> <span class="n">Parse</span> <span class="k">for</span> <span class="n">ManagerOfThingInfo</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">parse</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="n">ParseStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">manager_ident</span><span class="p">:</span> <span class="n">Ident</span> <span class="o">=</span> <span class="n">input</span><span class="nf">.parse</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="k">if</span> <span class="n">input</span><span class="nf">.peek</span><span class="p">(</span><span class="nd">Token!</span><span class="p">[</span><span class="o">&lt;</span><span class="p">])</span> <span class="p">{</span>
      <span class="n">input</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nd">Token!</span><span class="p">[</span><span class="o">&lt;</span><span class="p">]</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">let</span> <span class="n">manager_generics_ident</span><span class="p">:</span> <span class="n">Ident</span> <span class="o">=</span> <span class="n">input</span><span class="nf">.parse</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="k">if</span> <span class="n">input</span><span class="nf">.peek</span><span class="p">(</span><span class="nd">Token!</span><span class="p">[</span><span class="o">&gt;</span><span class="p">])</span> <span class="p">{</span>
      <span class="n">input</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nd">Token!</span><span class="p">[</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">input</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nd">Token!</span><span class="p">[</span><span class="k">for</span><span class="p">]</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">thing_type</span><span class="p">:</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">input</span><span class="nf">.parse</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">ManagerOfThingInfo</span> <span class="p">{</span>
      <span class="n">manager_ident</span><span class="p">,</span>
      <span class="n">manager_generics_ident</span><span class="p">,</span>
      <span class="n">thing_type</span><span class="p">,</span>
    <span class="p">})</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And here‚Äôs another way of doing it.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">ManagerOfThingInfo</span> <span class="p">{</span>
  <span class="n">manager_name_ident</span><span class="p">:</span> <span class="n">Ident</span><span class="p">,</span>
  <span class="n">manager_ty</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span>
  <span class="n">thing_ty</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span>
<span class="p">}</span>

<span class="cd">/// [Parse docs](https://docs.rs/syn/latest/syn/parse/index.html)</span>
<span class="k">impl</span> <span class="n">Parse</span> <span class="k">for</span> <span class="n">ManagerOfThingInfo</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">parse</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="n">ParseStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">manager_ty</span><span class="p">:</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">input</span><span class="nf">.parse</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="n">input</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nd">Token!</span><span class="p">[</span><span class="k">for</span><span class="p">]</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">thing_ty</span><span class="p">:</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">input</span><span class="nf">.parse</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">manager_name_ident</span> <span class="o">=</span> <span class="k">match</span> <span class="n">manager_ty</span> <span class="p">{</span>
      <span class="nn">Type</span><span class="p">::</span><span class="nf">Path</span><span class="p">(</span><span class="k">ref</span> <span class="n">type_path</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">path</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">type_path</span><span class="py">.path</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">ident</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">path</span>
          <span class="py">.segments</span>
          <span class="nf">.first</span><span class="p">()</span>
          <span class="nf">.unwrap</span><span class="p">()</span>
          <span class="py">.ident</span><span class="p">;</span>
        <span class="n">ident</span><span class="nf">.clone</span><span class="p">()</span>
      <span class="p">}</span>
      <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"Expected Type::Path::TypePath.segments to have an Ident"</span><span class="p">),</span>
    <span class="p">};</span>

    <span class="nf">Ok</span><span class="p">(</span><span class="n">ManagerOfThingInfo</span> <span class="p">{</span>
      <span class="n">manager_name_ident</span><span class="p">,</span>
      <span class="n">manager_ty</span><span class="p">,</span>
      <span class="n">thing_ty</span><span class="p">,</span>
    <span class="p">})</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>üìú You can find all the syn examples in this
<a href="https://github.com/dtolnay/syn/tree/master/examples">repo</a>.</p>
</blockquote>

<blockquote>
  <p>üìú You can find the solution to the proc macro workshop
<a href="https://github.com/jonhoo/proc-macro-workshop">here</a>.</p>
</blockquote>

<blockquote>
  <p>üìú This <a href="https://ferrous-systems.com/blog/testing-proc-macros/">tutorial</a> from the rust-analyzer
team is also quite helpful.</p>
</blockquote>
      <h2 id="eg-1---function-like-macro-that-dumps-the-ast">
        
        
          Eg 1 - Function-like macro that dumps the AST <a href="#eg-1---function-like-macro-that-dumps-the-ast">#</a>
        
        
      </h2>
    

<p>Let‚Äôs start our procedural macro journey w/ something very simple. It‚Äôs a macro that doesn‚Äôt really
emit any token stream. It just prints out the AST of the input as debug. So we won‚Äôt be using
<code class="language-plaintext highlighter-rouge">quote!()</code> but we will be using syn.</p>

<p>We will start by turning this one line function that‚Äôs represented by this string literal.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">output_token_stream_str</span> <span class="o">=</span> <span class="s">"fn foo() -&gt; u32 { 42 }"</span><span class="p">;</span>
</code></pre></div></div>

<p>The first thing we must do is define the macro in the <code class="language-plaintext highlighter-rouge">lib.rs</code> file.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="k">crate</span> <span class="n">proc_macro</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">proc_macro</span><span class="p">::</span><span class="n">TokenStream</span><span class="p">;</span>

<span class="k">mod</span> <span class="n">ast_viz_debug</span><span class="p">;</span>

<span class="nd">#[proc_macro]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">fn_macro_ast_viz_debug</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TokenStream</span> <span class="p">{</span>
  <span class="nn">ast_viz_debug</span><span class="p">::</span><span class="nf">fn_proc_macro_impl</span><span class="p">(</span><span class="n">input</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Let‚Äôs write the <code class="language-plaintext highlighter-rouge">ast_viz_debug.rs</code> file next.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// https://docs.rs/syn/latest/syn/macro.parse_macro_input.html</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">fn_proc_macro_impl</span><span class="p">(</span><span class="n">_input</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TokenStream</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">output_token_stream_str</span> <span class="o">=</span> <span class="s">"fn foo() -&gt; u32 { 42 }"</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">output</span> <span class="o">=</span> <span class="n">output_token_stream_str</span><span class="nf">.parse</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

  <span class="k">let</span> <span class="n">ast_item_fn</span><span class="p">:</span> <span class="n">ItemFn</span> <span class="o">=</span> <span class="nn">parse_str</span><span class="p">::</span><span class="o">&lt;</span><span class="n">ItemFn</span><span class="o">&gt;</span><span class="p">(</span><span class="n">output_token_stream_str</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
  <span class="nf">viz_ast</span><span class="p">(</span><span class="n">ast_item_fn</span><span class="p">);</span>

  <span class="n">output</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here‚Äôs the function <code class="language-plaintext highlighter-rouge">viz_ast</code> that we‚Äôll use to print out the AST.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">viz_ast</span><span class="p">(</span><span class="n">ast</span><span class="p">:</span> <span class="n">ItemFn</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Simply dump the AST to the console.</span>
  <span class="k">let</span> <span class="n">ast_clone</span> <span class="o">=</span> <span class="n">ast</span><span class="nf">.clone</span><span class="p">();</span>
  <span class="nd">eprintln!</span><span class="p">(</span><span class="s">"{} =&gt; {}"</span><span class="p">,</span> <span class="nf">style_primary</span><span class="p">(</span><span class="s">"Debug::ast"</span><span class="p">),</span> <span class="n">ast_clone</span><span class="p">);</span>

  <span class="c1">// Parse AST to dump some items to the console.</span>
  <span class="k">let</span> <span class="n">ItemFn</span> <span class="p">{</span>
    <span class="n">attrs</span><span class="p">,</span>
    <span class="n">vis</span><span class="p">,</span>
    <span class="n">sig</span><span class="p">,</span>
    <span class="n">block</span><span class="p">,</span>
  <span class="p">}</span> <span class="o">=</span> <span class="n">ast</span><span class="p">;</span>

  <span class="nd">eprintln!</span><span class="p">(</span>
    <span class="s">"{} ast_item_fn &lt; attrs.len:{}, vis:{}, sig:'{}' stmt: '{}' &gt;"</span><span class="p">,</span>
    <span class="nf">style_primary</span><span class="p">(</span><span class="s">"=&gt;"</span><span class="p">),</span>
    <span class="nf">style_prompt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attrs</span><span class="nf">.len</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">()),</span>
    <span class="nf">style_prompt</span><span class="p">(</span><span class="k">match</span> <span class="n">vis</span> <span class="p">{</span>
      <span class="nn">syn</span><span class="p">::</span><span class="nn">Visibility</span><span class="p">::</span><span class="nf">Public</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="s">"public"</span><span class="p">,</span>
      <span class="nn">syn</span><span class="p">::</span><span class="nn">Visibility</span><span class="p">::</span><span class="nf">Crate</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="s">"crate"</span><span class="p">,</span>
      <span class="nn">syn</span><span class="p">::</span><span class="nn">Visibility</span><span class="p">::</span><span class="nf">Restricted</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="s">"restricted"</span><span class="p">,</span>
      <span class="nn">syn</span><span class="p">::</span><span class="nn">Visibility</span><span class="p">::</span><span class="n">Inherited</span> <span class="k">=&gt;</span> <span class="s">"inherited"</span><span class="p">,</span>
    <span class="p">}),</span>
    <span class="nf">style_prompt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig</span><span class="py">.ident</span><span class="nf">.to_string</span><span class="p">()),</span>
    <span class="nf">style_prompt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">match</span> <span class="n">block</span><span class="py">.stmts</span><span class="nf">.first</span><span class="p">()</span> <span class="p">{</span>
      <span class="nf">Some</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">expr_str</span> <span class="o">=</span> <span class="n">stmt</span><span class="nf">.to_token_stream</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="n">expr_str</span>
      <span class="p">}</span>
      <span class="nb">None</span> <span class="k">=&gt;</span> <span class="s">"empty"</span><span class="nf">.to_string</span><span class="p">(),</span>
    <span class="p">}),</span>
  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>‚ö° To learn more about syn APIs, check out the following links:</p>

  <ul>
    <li><a href="https://docs.rs/syn/latest/syn/fn.parse_str.html">https://docs.rs/syn/latest/syn/fn.parse_str.html</a></li>
    <li><a href="https://docs.rs/syn/latest/syn/struct.ItemFn.html">https://docs.rs/syn/latest/syn/struct.ItemFn.html</a></li>
    <li><a href="https://docs.rs/syn/latest/syn/struct.Attribute.html">https://docs.rs/syn/latest/syn/struct.Attribute.html</a></li>
    <li><a href="https://docs.rs/syn/latest/syn/enum.Visibility.html">https://docs.rs/syn/latest/syn/enum.Visibility.html</a></li>
    <li><a href="https://docs.rs/syn/latest/syn/struct.Signature.html">https://docs.rs/syn/latest/syn/struct.Signature.html</a></li>
    <li><a href="https://docs.rs/syn/latest/syn/struct.Block.html">https://docs.rs/syn/latest/syn/struct.Block.html</a></li>
    <li><a href="https://docs.rs/syn/latest/syn/enum.Stmt.html">https://docs.rs/syn/latest/syn/enum.Stmt.html</a></li>
    <li><a href="https://github.com/dtolnay/proc-macro-workshop#debugging-tips">https://github.com/dtolnay/proc-macro-workshop#debugging-tips</a></li>
  </ul>
</blockquote>

<p>To test this function we can write the following test.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">my_proc_macros_lib</span><span class="p">::</span><span class="n">fn_macro_ast_viz_debug</span><span class="p">;</span>

<span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">test_proc_macro</span><span class="p">()</span> <span class="p">{</span>
  <span class="nd">fn_macro_ast_viz_debug!</span><span class="p">();</span>
  <span class="nd">assert_eq!</span><span class="p">(</span><span class="nf">foo</span><span class="p">(),</span> <span class="mi">42</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>We can watch this test run using this script:
<code class="language-plaintext highlighter-rouge">./cargo-watch-one-test.fish test_fn_macro_ast_viz_debug</code></li>
  <li>We can watch the macros generated by this test expanded using this script:
<code class="language-plaintext highlighter-rouge">./cargo-watch-macro-expand-one-test.fish test_fn_macro_ast_viz_debug</code></li>
</ul>

<blockquote>
  <p>üìú You can find another example of a function like procedural macro from the syn docs called
<a href="https://github.com/dtolnay/syn/tree/master/examples/lazy-static"><code class="language-plaintext highlighter-rouge">lazy-static</code></a>. It shows how to
parse a custom syntax.</p>
</blockquote>
      <h2 id="eg-2---function-like-macro-that-parses-custom-syntax">
        
        
          Eg 2 - Function-like macro that parses custom syntax <a href="#eg-2---function-like-macro-that-parses-custom-syntax">#</a>
        
        
      </h2>
    

<p>There are times when you need to create your own syntax or domain specific language. Examples of
this are JSX for React. Or DAO generators for a database. In these cases, it‚Äôs not just about
outputting a token stream, but a large chunk of the work is coming up w/ a syntax that then has to
be parsed üéâ!</p>

<p>The idea is that your users will declaratively define the things that you want to happen, and the
procedural macro will do the rest.</p>

<ul>
  <li>Declarative or the folks who are using the macros.</li>
  <li>For the implementors, it ends up generating imperative code.</li>
</ul>

<blockquote>
  <p>üì¶ To see a real world example of a custom syntax parser, please check out
<a href="https://github.com/r3bl-org/r3bl-open-core-archive/blob/main/macro/src/manager_of_things.rs"><code class="language-plaintext highlighter-rouge">manager_of_things.rs</code></a>.</p>

  <ul>
    <li>You can create your own custom keywords using syn via the
<a href="https://docs.rs/syn/latest/syn/macro.custom_keyword.html"><code class="language-plaintext highlighter-rouge">syn::custom_keyword!()</code></a> macro.</li>
    <li>The code that‚Äôs generated also uses <a href="https://github.com/dtolnay/async-trait">async traits</a> which
are interesting.</li>
  </ul>
</blockquote>

<blockquote>
  <p>üìú Take a look at the syn example called
<a href="https://github.com/dtolnay/syn/tree/master/examples/lazy-static"><code class="language-plaintext highlighter-rouge">lazy-static</code></a> to get some more
ideas on custom syntax parsing and creating custom error messages for the compiler.</p>
</blockquote>
      <h3 id="desired-syntax-and-behavior">
        
        
          Desired syntax and behavior <a href="#desired-syntax-and-behavior">#</a>
        
        
      </h3>
    

<p>Let‚Äôs say that we want to parse a custom syntax like the following, which basically is a declaration
of how a manager for the struct <code class="language-plaintext highlighter-rouge">HashMap&lt;K, V&gt;</code> should be created.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">fn_macro_custom_syntax!</span> <span class="p">{</span>
  <span class="n">ThingManager</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span>
  <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="nb">Send</span> <span class="o">+</span> <span class="nb">Sync</span> <span class="o">+</span> <span class="nb">Default</span> <span class="o">+</span> <span class="k">'static</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="nb">Send</span> <span class="o">+</span> <span class="nb">Sync</span> <span class="o">+</span> <span class="nb">Default</span> <span class="o">+</span> <span class="k">'static</span>
  <span class="k">for</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li><code class="language-plaintext highlighter-rouge">ThingManager</code> is just the name of the <code class="language-plaintext highlighter-rouge">struct</code> that should be generated by the macro.</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;K, V&gt;</code> these are optional generic types.</li>
  <li>The <code class="language-plaintext highlighter-rouge">where</code> clause is optional. If this is missing and optional generic types are provided above,
then a default <code class="language-plaintext highlighter-rouge">where</code> clause will be generated.</li>
  <li>Finally, the <code class="language-plaintext highlighter-rouge">for</code> clause allows you to specify the type that the generated manager will be
managing.</li>
</ol>

<p>So we want the declaration shown above to emit the following code.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Generated manager ThingManager.</span>
<span class="k">struct</span> <span class="n">ThingManager</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">K</span><span class="p">:</span> <span class="nb">Send</span> <span class="o">+</span> <span class="nb">Sync</span> <span class="o">+</span> <span class="nb">Default</span> <span class="o">+</span> <span class="k">'static</span><span class="p">,</span>
    <span class="n">V</span><span class="p">:</span> <span class="nb">Send</span> <span class="o">+</span> <span class="nb">Sync</span> <span class="o">+</span> <span class="nb">Default</span> <span class="o">+</span> <span class="k">'static</span><span class="p">,</span>
<span class="p">{</span>
    <span class="n">wrapped_thing</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Let‚Äôs say that we want some more flexibility in our syntax and will allow the omission of the
<code class="language-plaintext highlighter-rouge">where</code> clause and we will generate it ourselves, based on the generic type arguments that are
passed to <code class="language-plaintext highlighter-rouge">ThingManager</code>, in other words <code class="language-plaintext highlighter-rouge">&lt;K, V&gt;</code>. So the syntax will now look like this.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">fn_macro_custom_syntax!</span> <span class="p">{</span>
  <span class="n">ThingManager</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span>

<span class="k">for</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And we want to generate the following code. Notice that the <code class="language-plaintext highlighter-rouge">where</code> clause is generated
auto-magically ü™Ñ.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Generated manager ThingManager.</span>
<span class="k">struct</span> <span class="n">ThingManager</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">K</span><span class="p">:</span> <span class="nb">Send</span> <span class="o">+</span> <span class="nb">Sync</span> <span class="o">+</span> <span class="k">'static</span><span class="p">,</span>
    <span class="n">V</span><span class="p">:</span> <span class="nb">Send</span> <span class="o">+</span> <span class="nb">Sync</span> <span class="o">+</span> <span class="k">'static</span><span class="p">,</span>
<span class="p">{</span>
    <span class="n">wrapped_thing</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>
      <h3 id="implementing-the-syntax-parser">
        
        
          Implementing the syntax parser <a href="#implementing-the-syntax-parser">#</a>
        
        
      </h3>
    

<p>So how would we implement this macro? The first thing is to create a custom parser for the syntax.
There are 2 main things we have to do:</p>

<ol>
  <li>Create a <code class="language-plaintext highlighter-rouge">struct</code> that holds all the pertinent information from parsing our syntax, which will
need to generate the actual code.</li>
  <li>Create a <code class="language-plaintext highlighter-rouge">Parse</code> trait implementation for this <code class="language-plaintext highlighter-rouge">struct</code> that will take care of parsing all the
tokens that are provided in the <code class="language-plaintext highlighter-rouge">ParseStream</code>.</li>
</ol>

<p>Here‚Äôs the code that does these things. One thing to note is that the <code class="language-plaintext highlighter-rouge">where</code> clause is optional. If
one isn‚Äôt provided, then one will be generated automatically for each of the generic types that are
provided to <code class="language-plaintext highlighter-rouge">ThingManager</code>. This is assuming generic type arguments are passed in with
<code class="language-plaintext highlighter-rouge">ThingManager</code>. If they aren‚Äôt then no <code class="language-plaintext highlighter-rouge">where</code> clause will be generated.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Example of syntax to parse:</span>
<span class="cd">/// ```no_run</span>
<span class="cd">/// fn_macro_custom_syntax! {</span>
<span class="cd">///   ‚ï≠‚îÄL1‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>
<span class="cd">///   ‚îÇ     manager_ty</span>
<span class="cd">///   ‚îÇ     ‚ñæ‚ñæ‚ñæ‚ñæ‚ñæ‚ñæ‚ñæ‚ñæ‚ñæ‚ñæ‚ñæ‚ñæ‚ñæ‚ñæ‚ñæ‚ñæ‚ñæ‚ñæ</span>
<span class="cd">///   named ThingManager&lt;K, V&gt;</span>
<span class="cd">///   ‚îÇ     ‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥ ‚ñ¥‚ñ¥‚ñ¥‚ñ¥</span>
<span class="cd">///   ‚îÇ     ‚îÇ            manager_ty_generic_args</span>
<span class="cd">///   ‚îÇ     manager_name_ident</span>
<span class="cd">///   ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>
<span class="cd">///   ‚ï≠‚îÄL2?‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>
<span class="cd">///   where K: Send + Sync + 'static, V: Send + Sync + 'static</span>
<span class="cd">///   ‚îÇ     ‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥</span>
<span class="cd">///   ‚îÇ     where_clause</span>
<span class="cd">///   ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>
<span class="cd">///   ‚ï≠‚îÄL3‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>
<span class="cd">///   of_type std::collections::HashMap&lt;K, V&gt;</span>
<span class="cd">///   ‚îÇ       ‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥‚ñ¥</span>
<span class="cd">///   ‚îÇ       thing_ty</span>
<span class="cd">///   ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>
<span class="cd">/// }</span>
<span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="n">ManagerOfThingInfo</span> <span class="p">{</span>
  <span class="n">manager_name_ident</span><span class="p">:</span> <span class="n">Ident</span><span class="p">,</span>
  <span class="n">manager_ty</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span>
  <span class="n">manager_ty_generic_args</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Punctuated</span><span class="o">&lt;</span><span class="n">GenericArgument</span><span class="p">,</span> <span class="n">Comma</span><span class="o">&gt;&gt;</span><span class="p">,</span>
  <span class="n">where_clause</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">WhereClause</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">thing_ty</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span>
<span class="p">}</span>

<span class="cd">/// [Parse docs](https://docs.rs/syn/latest/syn/parse/index.html)</span>
<span class="k">impl</span> <span class="n">Parse</span> <span class="k">for</span> <span class="n">ManagerOfThingInfo</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">parse</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="n">ParseStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// üëÄ Manager Type, eg: `ThingManager&lt;K,V&gt;`.</span>
    <span class="k">let</span> <span class="n">manager_ty</span><span class="p">:</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">input</span><span class="nf">.parse</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">manager_ty_generic_args</span> <span class="o">=</span> <span class="k">match</span> <span class="n">manager_ty</span><span class="nf">.has_angle_bracketed_generic_args</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">true</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span>
        <span class="n">manager_ty</span>
          <span class="nf">.get_angle_bracketed_generic_args_result</span><span class="p">()</span>
          <span class="nf">.unwrap</span><span class="p">(),</span>
      <span class="p">),</span>
      <span class="k">false</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="c1">// üëÄ Optional where clause,</span>
    <span class="c1">// eg: `where K: Send+Sync+'static, V: Send+Sync+'static`.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">where_clause</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">WhereClause</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>
    <span class="k">if</span> <span class="n">input</span><span class="nf">.peek</span><span class="p">(</span><span class="nd">Token!</span><span class="p">[</span><span class="k">where</span><span class="p">])</span> <span class="p">{</span>
      <span class="n">where_clause</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">input</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="n">WhereClause</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">if</span> <span class="n">manager_ty</span><span class="nf">.has_angle_bracketed_generic_args</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">ident_vec</span> <span class="o">=</span> <span class="n">manager_ty</span>
          <span class="nf">.get_angle_bracketed_generic_args_idents_result</span><span class="p">()</span>
          <span class="nf">.unwrap</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">my_ts</span> <span class="o">=</span> <span class="nd">quote!</span> <span class="p">{</span>
          <span class="k">where</span> #<span class="p">(</span>#<span class="n">ident_vec</span><span class="p">:</span> <span class="nb">Send</span> <span class="o">+</span> <span class="nb">Sync</span> <span class="o">+</span> <span class="k">'static</span><span class="p">),</span><span class="o">*</span>
        <span class="p">}</span>
        <span class="nf">.into</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">my_where_clause</span><span class="p">:</span> <span class="n">WhereClause</span> <span class="o">=</span> <span class="nn">syn</span><span class="p">::</span><span class="nf">parse</span><span class="p">(</span><span class="n">my_ts</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="n">where_clause</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">my_where_clause</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// üëÄ for keyword.</span>
    <span class="n">input</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nd">Token!</span><span class="p">[</span><span class="k">for</span><span class="p">]</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// üëÄ Thing Type, eg: `std::collections::HashMap&lt;K, V&gt;`.</span>
    <span class="k">let</span> <span class="n">thing_ty</span><span class="p">:</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">input</span><span class="nf">.parse</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">manager_name_ident</span> <span class="o">=</span> <span class="k">if</span> <span class="n">manager_ty</span><span class="nf">.has_ident</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">manager_ty</span><span class="nf">.get_ident</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nd">panic!</span><span class="p">(</span><span class="s">"Expected Type::Path::TypePath.segments to have an Ident"</span><span class="p">)</span>
    <span class="p">};</span>

    <span class="nf">Ok</span><span class="p">(</span><span class="n">ManagerOfThingInfo</span> <span class="p">{</span>
      <span class="n">manager_ty_generic_args</span><span class="p">,</span>
      <span class="n">manager_name_ident</span><span class="p">,</span>
      <span class="n">manager_ty</span><span class="p">,</span>
      <span class="n">thing_ty</span><span class="p">,</span>
      <span class="n">where_clause</span><span class="p">,</span>
    <span class="p">})</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
      <h3 id="implementing-the-code-generator">
        
        
          Implementing the code generator <a href="#implementing-the-code-generator">#</a>
        
        
      </h3>
    

<p>In this example almost all the work goes into parsing the custom syntax. The code generator we are
going to implement is trivial. Here‚Äôs what it looks like.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">fn_proc_macro_impl</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">)</span> <span class="k">-&gt;</span><span class="p">:</span><span class="n">TokenStream</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">manager_of_thing_info</span> <span class="o">=</span>
    <span class="nd">parse_macro_input!</span><span class="p">(</span><span class="n">input</span> <span class="k">as</span> <span class="n">ManagerOfThingInfo</span><span class="p">);</span>

  <span class="k">let</span> <span class="n">ManagerOfThingInfo</span> <span class="p">{</span>
    <span class="n">manager_name_ident</span><span class="p">,</span>
    <span class="n">manager_ty</span><span class="p">,</span>
    <span class="n">thing_ty</span><span class="p">,</span>
    <span class="n">manager_ty_generic_args</span><span class="p">,</span>
    <span class="n">where_clause</span><span class="p">,</span>
  <span class="p">}</span> <span class="o">=</span> <span class="n">manager_of_thing_info</span><span class="p">;</span>

  <span class="k">let</span> <span class="n">doc_struct_str</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span>
    <span class="s">" Generated manager {}."</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">manager_name_ident</span><span class="p">,</span>
  <span class="p">);</span>

  <span class="nd">quote!</span> <span class="p">{</span>
    <span class="nd">#[doc</span> <span class="nd">=</span> <span class="err">#</span><span class="nd">doc_struct_str]</span>
    <span class="k">struct</span> #<span class="n">manager_ty</span> #<span class="n">where_clause</span> <span class="p">{</span>
      <span class="n">wrapped_thing</span><span class="p">:</span> #<span class="n">thing_ty</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nf">.into</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>üìú You can find the source code for this example
<a href="https://github.com/nazmulidris/rust_scratch/blob/main/macros/my_proc_macros_lib/src/custom_syntax.rs">here</a>
in its repo.</p>
</blockquote>

<ul>
  <li>We can watch macro expansion by running this script:
<code class="language-plaintext highlighter-rouge">./cargo-watch-macro-expand-one-test.fish test_fn_macro_custom_syntax</code></li>
  <li>We can watch test output by running this script:
<code class="language-plaintext highlighter-rouge">./cargo-watch-one-test.fish test_fn_macro_custom_syntax</code></li>
</ul>
      <h2 id="eg-3---derive-macro-that-adds-a-method-to-a-struct">
        
        
          Eg 3 - Derive macro that adds a method to a struct <a href="#eg-3---derive-macro-that-adds-a-method-to-a-struct">#</a>
        
        
      </h2>
    

<p>We are going to come up w/ a made-up derive macro called <code class="language-plaintext highlighter-rouge">Describe</code> just for our pedagogical
purposes.</p>

<ol>
  <li>This derive macro will add a method to an annotated struct, enum, or union called <code class="language-plaintext highlighter-rouge">Describe</code>
which simply returns a <code class="language-plaintext highlighter-rouge">String</code> that contains the names of the fields in the struct.</li>
  <li>We will then extend this derive macro to handle generics.</li>
</ol>
      <h3 id="test-for-expected-output">
        
        
          Test for expected output <a href="#test-for-expected-output">#</a>
        
        
      </h3>
    

<p>Here are some simple cases that we should be able to handle in our initial implementation.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">my_proc_macros_lib</span><span class="p">::</span><span class="n">Describe</span><span class="p">;</span>

<span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">test_proc_macro</span><span class="p">()</span> <span class="p">{</span>
  <span class="nd">#[derive(Describe)]</span>
  <span class="k">struct</span> <span class="n">MyStruct</span> <span class="p">{</span>
    <span class="n">my_string</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">my_enum</span><span class="p">:</span> <span class="n">MyEnum</span><span class="p">,</span>
    <span class="n">my_number</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
  <span class="p">}</span>

  <span class="nd">#[derive(Describe)]</span>
  <span class="k">enum</span> <span class="n">MyEnum</span> <span class="p">{</span>
    <span class="n">MyVariant1</span><span class="p">,</span>
  <span class="p">}</span>

  <span class="k">let</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">MyStruct</span> <span class="p">{</span>
    <span class="n">my_string</span><span class="p">:</span> <span class="s">"Hello"</span><span class="nf">.to_string</span><span class="p">(),</span>
    <span class="n">my_enum</span><span class="p">:</span> <span class="nn">MyEnum</span><span class="p">::</span><span class="n">MyVariant1</span><span class="p">,</span>
    <span class="n">my_number</span><span class="p">:</span> <span class="mi">42</span><span class="p">,</span>
  <span class="p">};</span>
  <span class="k">let</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">foo</span><span class="nf">.describe</span><span class="p">();</span>
  <span class="nd">assert_eq!</span><span class="p">(</span>
    <span class="n">foo</span><span class="p">,</span>
    <span class="s">"MyStruct is a struct with these named fields: my_string, my_enum, my_number"</span>
  <span class="p">);</span>
<span class="p">}</span><span class="n">s</span>
</code></pre></div></div>

<blockquote>
  <p>‚ö° To run this test from the
<a href="https://github.com/nazmulidris/rust_scratch/blob/main/macros/tests/test_derive_macro_describe.rs">repo</a>,
in watch mode you can execute the following script:
<code class="language-plaintext highlighter-rouge">./cargo-watch-one-test.fish test_derive_macro_describe</code>.</p>
</blockquote>
      <h3 id="watch-macro-expansion">
        
        
          Watch macro expansion <a href="#watch-macro-expansion">#</a>
        
        
      </h3>
    

<p>As we are developing this macro it is really useful not only to have the tests running (in watch
mode) but also have the macro expansion running in watch mode.</p>

<blockquote>
  <p>‚ö° To run the macro expansion related to this test from the
<a href="https://github.com/nazmulidris/rust_scratch/blob/main/macros/tests/test_derive_macro_describe.rs">repo</a>,
in watch mode you can execute the following script:
<code class="language-plaintext highlighter-rouge">./cargo-watch-macro-expand-one-test.fish test_derive_macro_describe</code>.</p>
</blockquote>
      <h3 id="naive-implementation">
        
        
          Naive implementation <a href="#naive-implementation">#</a>
        
        
      </h3>
    

<p>Let‚Äôs implement this derive macro in a naive way. We won‚Äôt handle generics, that will happen
<a href="#better-implementation-that-handles-generics">later</a>.</p>

<p>We have to define a function in <code class="language-plaintext highlighter-rouge">lib.rs</code> which will use the function that we will write here.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="k">crate</span> <span class="n">proc_macro</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">proc_macro</span><span class="p">::</span><span class="n">TokenStream</span><span class="p">;</span>

<span class="k">mod</span> <span class="n">describe</span><span class="p">;</span>

<span class="nd">#[proc_macro_derive(Describe)]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">derive_macro_describe</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TokenStream</span> <span class="p">{</span>
  <span class="nn">describe</span><span class="p">::</span><span class="nf">derive_proc_macro_impl</span><span class="p">(</span><span class="n">input</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now to create the <code class="language-plaintext highlighter-rouge">describe.rs</code> file which will have the <code class="language-plaintext highlighter-rouge">derive_proc_macro_impl</code> function. This
macro has to to be able to do the following things:</p>

<ul>
  <li>For a <code class="language-plaintext highlighter-rouge">struct</code> or <code class="language-plaintext highlighter-rouge">enum</code> annotated with <code class="language-plaintext highlighter-rouge">#[derive(Describe)]</code> it will generate a method called
<code class="language-plaintext highlighter-rouge">describe</code> which will return a <code class="language-plaintext highlighter-rouge">String</code> containing the names of the fields (named and unnamed) in
the struct or enum.</li>
  <li>For a <code class="language-plaintext highlighter-rouge">union</code> annotated with <code class="language-plaintext highlighter-rouge">#[derive(Describe)]</code> it will generate a method called <code class="language-plaintext highlighter-rouge">describe</code>
which will return a <code class="language-plaintext highlighter-rouge">String</code> containing the names of all the named fields in the union.</li>
</ul>

<p>Here‚Äôs what we have so far.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">derive_proc_macro_impl</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TokenStream</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">DeriveInput</span> <span class="p">{</span>
    <span class="n">ident</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="o">..</span>
  <span class="p">}</span> <span class="o">=</span> <span class="nd">parse_macro_input!</span><span class="p">(</span><span class="n">input</span> <span class="k">as</span> <span class="n">DeriveInput</span><span class="p">);</span>

  <span class="k">let</span> <span class="n">description_str</span> <span class="o">=</span> <span class="k">match</span> <span class="n">data</span> <span class="p">{</span>
    <span class="nf">Struct</span><span class="p">(</span><span class="n">my_struct</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">gen_description_str_for_struct</span><span class="p">(</span><span class="n">my_struct</span><span class="p">),</span>
    <span class="nf">Enum</span><span class="p">(</span><span class="n">my_enum</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">gen_description_str_for_enum</span><span class="p">(</span><span class="n">my_enum</span><span class="p">),</span>
    <span class="nf">Union</span><span class="p">(</span><span class="n">my_union</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">gen_description_str_for_union</span><span class="p">(</span><span class="n">my_union</span><span class="p">),</span>
  <span class="p">};</span>

  <span class="nd">quote!</span> <span class="p">{</span> <span class="cm">/* todo */</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here‚Äôs what the implementation of the <code class="language-plaintext highlighter-rouge">gen_description_str_for_struct</code> function looks like.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">gen_description_str_for_struct</span><span class="p">(</span><span class="n">my_struct</span><span class="p">:</span> <span class="n">DataStruct</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
  <span class="k">match</span> <span class="n">my_struct</span><span class="py">.fields</span> <span class="p">{</span>
    <span class="nf">Named</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">handle_named_fields</span><span class="p">(</span><span class="n">fields</span><span class="p">),</span>
    <span class="nf">Unnamed</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">handle_unnamed_fields</span><span class="p">(</span><span class="n">fields</span><span class="p">),</span>
    <span class="n">Unit</span> <span class="k">=&gt;</span> <span class="nf">handle_unit</span><span class="p">(),</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">handle_named_fields</span><span class="p">(</span><span class="n">fields</span><span class="p">:</span> <span class="n">FieldsNamed</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">my_named_field_idents</span> <span class="o">=</span> <span class="n">fields</span><span class="py">.named</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">it</span><span class="p">|</span> <span class="o">&amp;</span><span class="n">it</span><span class="py">.ident</span><span class="p">);</span>
  <span class="nd">format!</span><span class="p">(</span>
    <span class="s">"a struct with these named fields: {}"</span><span class="p">,</span>
    <span class="nd">quote!</span> <span class="p">{</span>#<span class="p">(</span>#<span class="n">my_named_field_idents</span><span class="p">),</span> <span class="o">*</span><span class="p">}</span>
  <span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">handle_unnamed_fields</span><span class="p">(</span><span class="n">fields</span><span class="p">:</span> <span class="n">FieldsUnnamed</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">my_unnamed_fields_count</span> <span class="o">=</span> <span class="n">fields</span><span class="py">.unnamed</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.count</span><span class="p">();</span>
  <span class="nd">format!</span><span class="p">(</span><span class="s">"a struct with {} unnamed fields"</span><span class="p">,</span> <span class="n">my_unnamed_fields_count</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">handle_unit</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
  <span class="nd">format!</span><span class="p">(</span><span class="s">"a unit struct"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And finally, here are the remainder of the functions.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">gen_description_str_for_enum</span><span class="p">(</span><span class="n">my_enum</span><span class="p">:</span> <span class="n">DataEnum</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">my_variant_idents</span> <span class="o">=</span> <span class="n">my_enum</span><span class="py">.variants</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">it</span><span class="p">|</span> <span class="o">&amp;</span><span class="n">it</span><span class="py">.ident</span><span class="p">);</span>
  <span class="nd">format!</span><span class="p">(</span>
    <span class="s">"an enum with these variants: {}"</span><span class="p">,</span>
    <span class="nd">quote!</span> <span class="p">{</span>#<span class="p">(</span>#<span class="n">my_variant_idents</span><span class="p">),</span><span class="o">*</span><span class="p">}</span>
  <span class="p">)</span>

<span class="k">fn</span> <span class="nf">gen_description_str_for_union</span><span class="p">(</span><span class="n">my_union</span><span class="p">:</span> <span class="n">DataUnion</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
  <span class="nf">handle_named_fields</span><span class="p">(</span><span class="n">my_union</span><span class="py">.fields</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We actually haven‚Äôt generated a token stream yet. We will do that in the next step using <code class="language-plaintext highlighter-rouge">quote!</code>
macro.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">quote!</span> <span class="p">{</span>
  <span class="k">impl</span> #<span class="n">generics</span> #<span class="n">ident</span> #<span class="n">generics</span> #<span class="n">where_clause</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">describe</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
      <span class="k">let</span> <span class="k">mut</span> <span class="n">string</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="nd">stringify!</span><span class="p">(</span>#<span class="n">ident</span><span class="p">));</span>
      <span class="n">string</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">" is "</span><span class="p">);</span>
      <span class="n">string</span><span class="nf">.push_str</span><span class="p">(</span>#<span class="n">description_str</span><span class="p">);</span>
      <span class="n">string</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="nf">.into</span><span class="p">()</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">quote!</code> macro is incredibly powerful and it has a lot of smarts built into it which we will see
when we implement generics support next.</p>
      <h3 id="better-implementation-that-handles-generics">
        
        
          Better implementation that handles generics <a href="#better-implementation-that-handles-generics">#</a>
        
        
      </h3>
    

<p>Here‚Äôs an example of what a simple <code class="language-plaintext highlighter-rouge">Generics</code> object looks like when generated from
<code class="language-plaintext highlighter-rouge">struct Point&lt;T&gt; { ... }</code>.</p>

<ol>
  <li>The <code class="language-plaintext highlighter-rouge">Generics.params[0]</code> is a <code class="language-plaintext highlighter-rouge">TypeParam</code>, which is our <code class="language-plaintext highlighter-rouge">T</code>.</li>
  <li>It contains a an <code class="language-plaintext highlighter-rouge">ident</code> which is the <code class="language-plaintext highlighter-rouge">T</code> identifier in our <code class="language-plaintext highlighter-rouge">struct Point&lt;T&gt; { ... }</code>.</li>
</ol>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Generics</span> <span class="p">{</span>
    <span class="n">lt_token</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span>
        <span class="n">Lt</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="n">params</span><span class="p">:</span> <span class="p">[</span>
        <span class="nf">Type</span><span class="p">(</span>
            <span class="n">TypeParam</span> <span class="p">{</span>
                <span class="n">attrs</span><span class="p">:</span> <span class="p">[],</span>
                <span class="n">ident</span><span class="p">:</span> <span class="n">Ident</span> <span class="p">{</span>
                    <span class="n">ident</span><span class="p">:</span> <span class="s">"T"</span><span class="p">,</span>
                    <span class="n">span</span><span class="p">:</span> <span class="err">#</span><span class="mi">0</span> <span class="nf">bytes</span><span class="p">(</span><span class="mi">706</span><span class="o">..</span><span class="mi">707</span><span class="p">),</span>
                <span class="p">},</span>
                <span class="n">colon_token</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
                <span class="n">bounds</span><span class="p">:</span> <span class="p">[],</span>
                <span class="n">eq_token</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
                <span class="n">default</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">),</span>
    <span class="p">],</span>
    <span class="n">gt_token</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span>
        <span class="n">Gt</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="n">where_clause</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here‚Äôs a function that we can use to parse this <code class="language-plaintext highlighter-rouge">Generics</code> object.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">parse_generics</span><span class="p">(</span><span class="n">generics</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Generics</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Ident</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">generic_param</span><span class="p">)</span> <span class="o">=</span> <span class="n">generics</span><span class="py">.params</span><span class="nf">.first</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// https://docs.rs/syn/latest/syn/enum.GenericParam.html</span>
    <span class="k">match</span> <span class="n">generic_param</span> <span class="p">{</span>
      <span class="nn">syn</span><span class="p">::</span><span class="nn">GenericParam</span><span class="p">::</span><span class="nf">Type</span><span class="p">(</span><span class="k">ref</span> <span class="n">param</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="n">param</span><span class="py">.ident</span><span class="nf">.clone</span><span class="p">()),</span>
      <span class="nn">syn</span><span class="p">::</span><span class="nn">GenericParam</span><span class="p">::</span><span class="nf">Lifetime</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">unimplemented!</span><span class="p">(),</span>
      <span class="nn">syn</span><span class="p">::</span><span class="nn">GenericParam</span><span class="p">::</span><span class="nf">Const</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">unimplemented!</span><span class="p">(),</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nb">None</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And then we could use this in our procedural macro, like so:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">parsed_generics</span> <span class="o">=</span> <span class="nf">parse_generics</span><span class="p">(</span><span class="o">&amp;</span><span class="n">generics</span><span class="p">);</span>
<span class="k">match</span> <span class="n">parsed_generics</span> <span class="p">{</span>
  <span class="nf">Some</span><span class="p">(</span><span class="k">ref</span> <span class="n">_generic_ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
    <span class="nd">quote!</span> <span class="p">{</span>
      <span class="k">impl</span> <span class="o">&lt;</span>#<span class="n">parsed_generics</span><span class="o">&gt;</span> #<span class="n">ident</span> <span class="o">&lt;</span>#<span class="n">parsed_generics</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">describe</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
          <span class="k">let</span> <span class="k">mut</span> <span class="n">string</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="nd">stringify!</span><span class="p">(</span>#<span class="n">ident</span><span class="p">));</span>
          <span class="n">string</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">" is "</span><span class="p">);</span>
          <span class="n">string</span><span class="nf">.push_str</span><span class="p">(</span>#<span class="n">description</span><span class="p">);</span>
          <span class="n">string</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="nf">.into</span><span class="p">()</span> <span class="c1">// Convert from proc_macro2::TokenStream to TokenStream.</span>
  <span class="p">}</span>
  <span class="nb">None</span> <span class="k">=&gt;</span> <span class="p">{</span>
    <span class="nd">quote!</span> <span class="p">{</span>
      <span class="k">impl</span> #<span class="n">ident</span>  <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">describe</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
          <span class="k">let</span> <span class="k">mut</span> <span class="n">string</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="nd">stringify!</span><span class="p">(</span>#<span class="n">ident</span><span class="p">));</span>
          <span class="n">string</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">" is "</span><span class="p">);</span>
          <span class="n">string</span><span class="nf">.push_str</span><span class="p">(</span>#<span class="n">description</span><span class="p">);</span>
          <span class="n">string</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="nf">.into</span><span class="p">()</span> <span class="c1">// Convert from proc_macro2::TokenStream to TokenStream.</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This might provide some insight into how the <code class="language-plaintext highlighter-rouge">Generics</code> object itself is structured, but there is no
need to do any of this, since <code class="language-plaintext highlighter-rouge">quote!()</code> is awesome ü§Ø.</p>
      <h3 id="using-quote">
        
        
          Using quote! <a href="#using-quote">#</a>
        
        
      </h3>
    

<p>Here‚Äôs a mental model for using <code class="language-plaintext highlighter-rouge">quote!()</code>:</p>

<ol>
  <li>If you don‚Äôt include the ‚Äúthing‚Äù that you want to see in generated code, then it will be left
out.</li>
  <li>Conversely, if you want to see it in the generated code, then include it explicitly!</li>
</ol>

<p>So, to handle generics, where you can have multiple types and where clauses, here‚Äôs the simple code
üéâ.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">derive_proc_macro_impl</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TokenStream</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">DeriveInput</span> <span class="p">{</span>
    <span class="n">ident</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">generics</span><span class="p">,</span>
    <span class="o">..</span>
  <span class="p">}</span> <span class="o">=</span> <span class="nd">parse_macro_input!</span><span class="p">(</span><span class="n">input</span> <span class="k">as</span> <span class="n">DeriveInput</span><span class="p">);</span>

  <span class="k">let</span> <span class="n">where_clause</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">generics</span><span class="py">.where_clause</span><span class="p">;</span>

  <span class="k">let</span> <span class="n">description_str</span> <span class="o">=</span> <span class="k">match</span> <span class="n">data</span> <span class="p">{</span>
    <span class="nf">Struct</span><span class="p">(</span><span class="n">my_struct</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">gen_description_str_for_struct</span><span class="p">(</span><span class="n">my_struct</span><span class="p">),</span>
    <span class="nf">Enum</span><span class="p">(</span><span class="n">my_enum</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">gen_description_str_for_enum</span><span class="p">(</span><span class="n">my_enum</span><span class="p">),</span>
    <span class="nf">Union</span><span class="p">(</span><span class="n">my_union</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">gen_description_str_for_union</span><span class="p">(</span><span class="n">my_union</span><span class="p">),</span>
  <span class="p">};</span>

  <span class="nd">quote!</span> <span class="p">{</span>
    <span class="k">impl</span> #<span class="n">generics</span> #<span class="n">ident</span> #<span class="n">generics</span> #<span class="n">where_clause</span> <span class="p">{</span>
      <span class="k">fn</span> <span class="nf">describe</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">string</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="nd">stringify!</span><span class="p">(</span>#<span class="n">ident</span><span class="p">));</span>
        <span class="n">string</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">" is "</span><span class="p">);</span>
        <span class="n">string</span><span class="nf">.push_str</span><span class="p">(</span>#<span class="n">description_str</span><span class="p">);</span>
        <span class="n">string</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nf">.into</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>üìú Here‚Äôs the source code for <code class="language-plaintext highlighter-rouge">describe.rs</code> from its
<a href="https://github.com/nazmulidris/rust_scratch/blob/main/macros/my_proc_macros_lib/src/describe.rs">repo</a>.</p>
</blockquote>

<p>Here are some tips and tricks for using <code class="language-plaintext highlighter-rouge">quote!()</code>:</p>

<ol>
  <li>
    <p>Sometimes it is easier to start w/ a <code class="language-plaintext highlighter-rouge">String</code> or <code class="language-plaintext highlighter-rouge">Vec&lt;String&gt;</code> (which you can <code class="language-plaintext highlighter-rouge">join()</code> into a
<code class="language-plaintext highlighter-rouge">String</code>), then parse that into a <code class="language-plaintext highlighter-rouge">TokenStream</code> using <code class="language-plaintext highlighter-rouge">syn::parse_str()</code>. Then pass that to
<code class="language-plaintext highlighter-rouge">quote!()</code>. And example is if you wanted to add an arbitrary number of trait bounds to an
existing <code class="language-plaintext highlighter-rouge">where</code> clause. It is just easier to manipulate the new trait bounds as a <code class="language-plaintext highlighter-rouge">String</code>,
parse it into a <code class="language-plaintext highlighter-rouge">TokenStream</code>, and then use <code class="language-plaintext highlighter-rouge">quote!()</code> to add that to the existing <code class="language-plaintext highlighter-rouge">where</code>
clause. Here‚Äôs an example from
<a href="https://github.com/nazmulidris/rust_scratch/blob/main/macros/my_proc_macros_lib/src/builder.rs#L169"><code class="language-plaintext highlighter-rouge">builder.rs</code></a>.</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">traits</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="s">"std::default::Default"</span><span class="p">,</span> <span class="s">"std::fmt::Debug"</span><span class="p">];</span>
<span class="nn">syn</span><span class="p">::</span><span class="nn">parse_str</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">syn</span><span class="p">::</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">traits</span><span class="nf">.join</span><span class="p">(</span><span class="s">" + "</span><span class="p">))</span><span class="nf">.unwrap</span><span class="p">();</span>
</code></pre></div>    </div>
  </li>
  <li>You can also use <a href="https://docs.rs/syn/latest/syn/macro.parse_quote.html"><code class="language-plaintext highlighter-rouge">syn::parse_quote!()</code></a>
to get a <code class="language-plaintext highlighter-rouge">TokenStream</code> from a <code class="language-plaintext highlighter-rouge">quote!()</code> expression, if it is just easier to generate a
<code class="language-plaintext highlighter-rouge">quote!()</code> expression instead of using <code class="language-plaintext highlighter-rouge">String</code>, etc.</li>
  <li>Repeating patterns in <code class="language-plaintext highlighter-rouge">quote!()</code> can be tricky to reason about. The best way to get a feel for
how it works is to try various things and as soon as you run into some road blocks, think about
generating <code class="language-plaintext highlighter-rouge">TokenStream</code>s manually, and then passing them to <code class="language-plaintext highlighter-rouge">quote!()</code>.</li>
</ol>
      <h2 id="eg-4---derive-macro-that-generates-a-builder">
        
        
          Eg 4 - Derive macro that generates a builder <a href="#eg-4---derive-macro-that-generates-a-builder">#</a>
        
        
      </h2>
    

<p>Now that we have seen a relatively simple derive procedural macro, let‚Äôs look at a more complex one
that implements the builder pattern and supports generics. There are two things this macro has to
do:</p>

<ol>
  <li>Generate the <code class="language-plaintext highlighter-rouge">&lt;Foo&gt;Builder</code> struct that simply copies all the fields of the annotated struct.</li>
  <li>Generate the impl block for the <code class="language-plaintext highlighter-rouge">&lt;Foo&gt;Builder</code> struct. It needs the following:
    <ol>
      <li>Setter methods for each named field of the <code class="language-plaintext highlighter-rouge">&lt;Foo&gt;</code> struct.</li>
      <li>A <code class="language-plaintext highlighter-rouge">new()</code> method that returns a <code class="language-plaintext highlighter-rouge">&lt;Foo&gt;Builder</code> struct.</li>
      <li>A <code class="language-plaintext highlighter-rouge">build()</code> method that returns a <code class="language-plaintext highlighter-rouge">&lt;Foo&gt;</code> struct.</li>
    </ol>
  </li>
</ol>

<blockquote>
  <p>üìú You can get the source code for this example from its repo
<a href="https://github.com/nazmulidris/rust_scratch/blob/main/macros/my_proc_macros_lib/src/builder.rs">here</a>.
And you can get the source for the test
<a href="https://github.com/nazmulidris/rust_scratch/blob/main/macros/tests/test_derive_macro_builder.rs">here</a>.</p>
</blockquote>
      <h3 id="stub-out-the-implementation">
        
        
          Stub out the implementation <a href="#stub-out-the-implementation">#</a>
        
        
      </h3>
    

<p>We need to make an entry in <code class="language-plaintext highlighter-rouge">lib.rs</code> for it, like so:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[proc_macro_derive(Builder)]</span>
<span class="k">pub</span> <span class="k">fn</span>
<span class="nf">derive_macro_builder</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TokenStream</span> <span class="p">{</span>
  <span class="nn">builder</span><span class="p">::</span><span class="nf">derive_proc_macro_impl</span><span class="p">(</span><span class="n">input</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then we need to make a <code class="language-plaintext highlighter-rouge">builder.rs</code> file which contains the implementation of the derive macro.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">derive_proc_macro_impl</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="nn">proc_macro</span><span class="p">::</span><span class="n">TokenStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">proc_macro</span><span class="p">::</span><span class="n">TokenStream</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">DeriveInput</span> <span class="p">{</span>
    <span class="n">ident</span><span class="p">:</span> <span class="n">struct_name_ident</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">generics</span><span class="p">,</span>
    <span class="o">..</span>
  <span class="p">}:</span> <span class="n">DeriveInput</span> <span class="o">=</span> <span class="nd">parse_macro_input!</span><span class="p">(</span><span class="n">input</span> <span class="k">as</span> <span class="n">DeriveInput</span><span class="p">);</span>

  <span class="k">let</span> <span class="n">required_trait_bounds</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="s">"std::default::Default"</span><span class="p">,</span> <span class="s">"std::fmt::Debug"</span><span class="p">];</span>

  <span class="c1">// Only generate code for struct.</span>
  <span class="k">if</span> <span class="n">data</span><span class="nf">.is_struct</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">with_data_struct_make_ts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">|</span><span class="n">data_struct</span><span class="p">|</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">builder_name_ident</span> <span class="o">=</span> <span class="n">struct_name_ident</span><span class="nf">.from_string</span><span class="p">(</span><span class="s">"{}Builder"</span><span class="p">);</span>

      <span class="k">let</span> <span class="n">gen_props_setter_fns_ts</span> <span class="o">=</span>
        <span class="nf">transform_named_fields_into_setter_fns_ts</span><span class="p">(</span><span class="n">data_struct</span><span class="p">);</span>

      <span class="k">let</span> <span class="n">gen_props_ts</span> <span class="o">=</span> <span class="nf">transform_named_fields_to_props_ts</span><span class="p">(</span><span class="n">data_struct</span><span class="p">);</span>

      <span class="k">let</span> <span class="n">doc_struct_str</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span>
        <span class="s">" Implements the [builder pattern] for [`{}`].</span><span class="se">\n</span><span class="s"> [builder pattern]: {}"</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">struct_name_ident</span><span class="p">,</span> <span class="n">BUILDER_DOC_URL</span>
      <span class="p">);</span>

      <span class="k">let</span> <span class="n">gen_props_with_defaults_ts</span> <span class="o">=</span>
        <span class="nf">transform_named_fields_to_props_with_defaults_ts</span><span class="p">(</span><span class="n">data_struct</span><span class="p">);</span>

      <span class="k">let</span> <span class="n">new_or_modified_where_clause_ts</span> <span class="o">=</span>
        <span class="k">if</span> <span class="nf">does_where_clause_exist</span><span class="p">(</span><span class="o">&amp;</span><span class="n">generics</span><span class="py">.where_clause</span><span class="p">)</span> <span class="p">{</span>
          <span class="nf">add_trait_bounds_to_existing_where_clause_ts</span><span class="p">(</span>
            <span class="o">&amp;</span><span class="n">generics</span><span class="py">.where_clause</span><span class="p">,</span>
            <span class="o">&amp;</span><span class="n">required_trait_bounds</span><span class="p">,</span>
          <span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="nf">make_new_where_clause_with_default_trait_bounds_for_named_fields</span><span class="p">(</span><span class="n">data_struct</span><span class="p">)</span>
        <span class="p">};</span>

      <span class="k">let</span> <span class="n">build_set_named_fields_ts</span> <span class="o">=</span> <span class="nf">build_fn_set_named_fields_ts</span><span class="p">(</span><span class="n">data_struct</span><span class="p">);</span>

      <span class="nd">quote!</span> <span class="p">{</span>
        <span class="nd">#[doc</span> <span class="nd">=</span> <span class="err">#</span><span class="nd">doc_struct_str]</span>
        <span class="k">impl</span> #<span class="n">generics</span> #<span class="n">builder_name_ident</span> #<span class="n">generics</span> #<span class="n">new_or_modified_where_clause_ts</span> <span class="p">{</span>
          <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
            <span class="k">Self</span> <span class="p">{</span>
              #<span class="n">gen_props_with_defaults_ts</span>
            <span class="p">}</span>
          <span class="p">}</span>

          <span class="k">pub</span> <span class="k">fn</span> <span class="nf">build</span><span class="p">(</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> #<span class="n">struct_name_ident</span> #<span class="n">generics</span> <span class="p">{</span>
            #<span class="n">struct_name_ident</span> <span class="p">{</span>
              #<span class="n">build_set_named_fields_ts</span>
            <span class="p">}</span>
          <span class="p">}</span>

          #<span class="n">gen_props_setter_fns_ts</span>
        <span class="p">}</span>

        <span class="k">struct</span> #<span class="n">builder_name_ident</span> #<span class="n">generics</span> #<span class="n">new_or_modified_where_clause_ts</span> <span class="p">{</span>
          #<span class="n">gen_props_ts</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">})</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nd">quote!</span> <span class="p">{}</span>
  <span class="p">}</span>
  <span class="nf">.into</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>
      <h3 id="testing-the-macro">
        
        
          Testing the macro <a href="#testing-the-macro">#</a>
        
        
      </h3>
    

<p>Here‚Äôs the test for the derive macro, <code class="language-plaintext highlighter-rouge">test_derive_macro_builder.rs</code>. They have to cover all the
different kinds of structs that we might encounter, some that have generics, some that don‚Äôt.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">test_proc_macro_struct_and_enum</span><span class="p">()</span> <span class="p">{</span>
  <span class="nd">#[derive(Builder)]</span>
  <span class="k">struct</span> <span class="n">MyStruct</span> <span class="p">{</span>
    <span class="n">my_string</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">my_enum</span><span class="p">:</span> <span class="n">MyEnum</span><span class="p">,</span>
    <span class="n">my_number</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
  <span class="p">}</span>

  <span class="k">enum</span> <span class="n">MyEnum</span> <span class="p">{</span>
    <span class="n">MyVariant1</span><span class="p">,</span>
  <span class="p">}</span>

  <span class="k">impl</span> <span class="nb">Default</span> <span class="k">for</span> <span class="n">MyEnum</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">default</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span> <span class="nn">MyEnum</span><span class="p">::</span><span class="n">MyVariant1</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">test_proc_macro_no_where_clause</span><span class="p">()</span> <span class="p">{</span>
  <span class="nd">#[derive(Builder)]</span>
  <span class="k">struct</span> <span class="n">Point</span><span class="o">&lt;</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">Y</span><span class="p">,</span>
  <span class="p">}</span>

  <span class="k">let</span> <span class="n">my_pt</span><span class="p">:</span> <span class="n">Point</span><span class="o">&lt;</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">i32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">PointBuilder</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span>
    <span class="nf">.set_x</span><span class="p">(</span><span class="mi">1</span> <span class="k">as</span> <span class="nb">i32</span><span class="p">)</span>
    <span class="nf">.set_y</span><span class="p">(</span><span class="mi">2</span> <span class="k">as</span> <span class="nb">i32</span><span class="p">)</span>
    <span class="nf">.build</span><span class="p">();</span>

  <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">my_pt</span><span class="py">.x</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">my_pt</span><span class="py">.y</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">test_proc_macro_generics</span><span class="p">()</span> <span class="p">{</span>
  <span class="nd">#[derive(Builder)]</span>
  <span class="k">struct</span> <span class="n">Point</span><span class="o">&lt;</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="o">&gt;</span>
  <span class="k">where</span>
    <span class="n">X</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span>
    <span class="n">Y</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span>
  <span class="p">{</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">Y</span><span class="p">,</span>
  <span class="p">}</span>

  <span class="k">let</span> <span class="n">my_pt</span><span class="p">:</span> <span class="n">Point</span><span class="o">&lt;</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">i32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">PointBuilder</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span>
    <span class="nf">.set_x</span><span class="p">(</span><span class="mi">1</span> <span class="k">as</span> <span class="nb">i32</span><span class="p">)</span>
    <span class="nf">.set_y</span><span class="p">(</span><span class="mi">2</span> <span class="k">as</span> <span class="nb">i32</span><span class="p">)</span>
    <span class="nf">.build</span><span class="p">();</span>

  <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">my_pt</span><span class="py">.x</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">my_pt</span><span class="py">.y</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
      <h3 id="implementation-details">
        
        
          Implementation details <a href="#implementation-details">#</a>
        
        
      </h3>
    

<p>Now that we have the skeleton of the entire thing, let‚Äôs look at some details of how this is
implemented. It‚Äôs worth taking a closer look at the
<a href="https://github.com/nazmulidris/rust_scratch/blob/main/macros/my_proc_macros_lib/src/utils/mod.rs#"><code class="language-plaintext highlighter-rouge">utils</code> module</a>,
since these contain re-usable functions that are leveraged to construct the final macro.</p>

<p>One pattern used here is extending some syn and proc_macro2 types with a new method.</p>

<ol>
  <li>The <code class="language-plaintext highlighter-rouge">syn::Data</code> type is extended w/ a method <code class="language-plaintext highlighter-rouge">is_struct</code> that can be used to check whether it
contains a <code class="language-plaintext highlighter-rouge">struct</code> or not.</li>
  <li><code class="language-plaintext highlighter-rouge">proc_macro2::Ident</code> type is extended w/ a method <code class="language-plaintext highlighter-rouge">from_string</code> that can be used to create a
<code class="language-plaintext highlighter-rouge">proc_macro2::Ident</code> from a string.</li>
</ol>

<p>And there are some nice functions in <code class="language-plaintext highlighter-rouge">syn_parser_helpers.rs</code> that make it easier for us to create
lambdas that operate on named fields in the struct. We can use these to easily create a
<code class="language-plaintext highlighter-rouge">proc_macro2::TokenStream</code> that will do various things like:</p>

<ol>
  <li>Create a props for the <code class="language-plaintext highlighter-rouge">&lt;Foo&gt;Builder</code> <code class="language-plaintext highlighter-rouge">struct</code>.</li>
  <li>Generate setter functions for the impl block of the <code class="language-plaintext highlighter-rouge">&lt;Foo&gt;Builder</code> <code class="language-plaintext highlighter-rouge">struct</code>.</li>
  <li>Generate <code class="language-plaintext highlighter-rouge">where</code> clauses that add trait bounds to the existing or new <code class="language-plaintext highlighter-rouge">where</code> clause.</li>
</ol>

<p>Please review the sources in detail to get a better understanding of how this is implemented. One of
the interesting things that this builder macro does is that it adds trait bounds to the existing
<code class="language-plaintext highlighter-rouge">where</code> clause. This is done to make sure that the <code class="language-plaintext highlighter-rouge">&lt;Foo&gt;Builder</code> <code class="language-plaintext highlighter-rouge">struct</code> implements the <code class="language-plaintext highlighter-rouge">Default</code>
trait for the <code class="language-plaintext highlighter-rouge">Foo</code> struct. It also adds a trait bound for <code class="language-plaintext highlighter-rouge">Debug</code>. Here‚Äôs a snippet of that.</p>

<blockquote>
  <p>üîÆ There is no need to handle properties or fields that have <code class="language-plaintext highlighter-rouge">Option</code> type. Creating the
requirement that the <code class="language-plaintext highlighter-rouge">&lt;Foo&gt;Builder</code> <code class="language-plaintext highlighter-rouge">struct</code> implements <code class="language-plaintext highlighter-rouge">Default</code> for the <code class="language-plaintext highlighter-rouge">Foo</code> struct ensures
that if a field has an <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code> type, then the default will be <code class="language-plaintext highlighter-rouge">None</code>. In other words, if you
don‚Äôt specify a value for an <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code> field type then the default will be <code class="language-plaintext highlighter-rouge">None</code>!.</p>
</blockquote>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">required_trait_bounds</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="s">"std::default::Default"</span><span class="p">,</span> <span class="s">"std::fmt::Debug"</span><span class="p">];</span>

<span class="k">fn</span> <span class="nf">add_trait_bounds_to_existing_where_clause_ts</span><span class="p">(</span>
  <span class="n">where_clause</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nn">syn</span><span class="p">::</span><span class="n">WhereClause</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">traits</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">proc_macro2</span><span class="p">::</span><span class="n">TokenStream</span> <span class="p">{</span>
  <span class="c1">// Must parse the `traits.join("+")` string into a [syn::Type].</span>
  <span class="k">let</span> <span class="n">joined_traits</span><span class="p">:</span> <span class="nn">syn</span><span class="p">::</span><span class="n">Type</span> <span class="o">=</span>
    <span class="nn">syn</span><span class="p">::</span><span class="nn">parse_str</span><span class="p">::</span><span class="o">&lt;</span><span class="nn">syn</span><span class="p">::</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">traits</span><span class="nf">.join</span><span class="p">(</span><span class="s">" + "</span><span class="p">))</span><span class="nf">.unwrap</span><span class="p">();</span>

  <span class="k">let</span> <span class="n">where_clause_ts</span> <span class="o">=</span> <span class="k">match</span> <span class="n">where_clause</span> <span class="p">{</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">where_clause</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
      <span class="k">let</span> <span class="n">where_predicate_punctuated_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">where_clause</span><span class="py">.predicates</span><span class="p">;</span>

      <span class="k">let</span> <span class="n">modified_where_predicates_ts</span> <span class="o">=</span> <span class="n">where_predicate_punctuated_list</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(</span>
          <span class="p">|</span><span class="n">where_predicate</span><span class="p">|</span> <span class="k">match</span> <span class="n">where_predicate</span> <span class="p">{</span>
            <span class="nn">syn</span><span class="p">::</span><span class="nn">WherePredicate</span><span class="p">::</span><span class="nf">Type</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
              <span class="nd">quote!</span> <span class="p">{</span> #<span class="n">where_predicate</span> <span class="o">+</span> #<span class="n">joined_traits</span> <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">quote!</span> <span class="p">{},</span>
          <span class="p">},</span>
        <span class="p">)</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>

      <span class="nd">quote!</span> <span class="p">{</span> <span class="k">where</span> #<span class="p">(</span>#<span class="n">modified_where_predicates_ts</span><span class="p">),</span><span class="o">*</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="nb">None</span> <span class="k">=&gt;</span> <span class="p">{</span>
      <span class="nd">quote!</span> <span class="p">{}</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="k">return</span> <span class="n">where_clause_ts</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>üëÄ Here are the scripts you can run to watch the macro expansion and test results as you make
changes.</p>

  <ul>
    <li>We can watch this test run using this script:
<code class="language-plaintext highlighter-rouge">./cargo-watch-one-test.fish test_derive_macro_builder</code></li>
    <li>We can watch the macros generated by this test expanded using this script:
<code class="language-plaintext highlighter-rouge">./cargo-watch-macro-expand-one-test.fish test_derive_macro_builder</code></li>
  </ul>
</blockquote>
      <h2 id="eg-5---attribute-macro-that-adds-logging-to-a-function">
        
        
          Eg 5 - Attribute macro that adds logging to a function <a href="#eg-5---attribute-macro-that-adds-logging-to-a-function">#</a>
        
        
      </h2>
    

<p><a href="https://doc.rust-lang.org/reference/procedural-macros.html#attribute-macros">Attribute procedural macros</a>
are very similar to derive procedural macros, with a few key differences.</p>

<ol>
  <li>Instead of just <code class="language-plaintext highlighter-rouge">enum</code> and <code class="language-plaintext highlighter-rouge">struct</code> an attribute procedural macro can be used to annotate any
<a href="https://doc.rust-lang.org/reference/items.html"><code class="language-plaintext highlighter-rouge">Item</code></a>. For example, functions, traits, impl
blocks, etc.</li>
  <li>Unlike a derive macro, attribute macros will replace the entire item that is annotated. Derive
macros can only add code below the annotated <code class="language-plaintext highlighter-rouge">struct</code> or <code class="language-plaintext highlighter-rouge">enum</code>.</li>
  <li>There‚Äôs an extra input argument that attribute macros get passed which holds the arguments used
to annotate the item. This is optional. These attributes can take 3 forms as defined in the
<code class="language-plaintext highlighter-rouge">syn::Meta</code> enum, which can be matched as follows:
    <ol>
      <li><code class="language-plaintext highlighter-rouge">Path(path)</code> -&gt; <code class="language-plaintext highlighter-rouge">path: syn::Path</code> is a meta path is like the <code class="language-plaintext highlighter-rouge">test</code> in <code class="language-plaintext highlighter-rouge">#[test]</code>.</li>
      <li><code class="language-plaintext highlighter-rouge">List(meta_list)</code> -&gt; <code class="language-plaintext highlighter-rouge">meta_list: syn::MetaList</code> is a structured list within an attribute, like
<code class="language-plaintext highlighter-rouge">derive(Copy, Clone)</code>.</li>
      <li><code class="language-plaintext highlighter-rouge">NameValue(meta_name_value)</code> -&gt; <code class="language-plaintext highlighter-rouge">meta_name_value: syn::MetaNameValue</code> is name-value pair
within an attribute, like <code class="language-plaintext highlighter-rouge">feature = "nightly"</code>.</li>
    </ol>
  </li>
</ol>

<p>We aren‚Äôt sure yet what the attributes for this macro might look like. Here are two variants that we
might try out. So let‚Äôs just make 2 macros.</p>

<ol>
  <li>
    <p>Variant 1 - passing an argument that looks like a key value pair to the macro. This is the
<code class="language-plaintext highlighter-rouge">NameValue</code> variant of the <code class="language-plaintext highlighter-rouge">syn::Meta</code> enum.</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[attrib_macro_logger_1(key</span> <span class="nd">=</span> <span class="s">"value"</span><span class="nd">)]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">some_annotated_function</span><span class="p">()</span> <span class="p">{</span>
    <span class="cm">/* ... */</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Variant 2 - passing an argument that looks like a list of identifiers to the macro. This is not
any of the variants of <code class="language-plaintext highlighter-rouge">syn::Meta</code> enum and is a something custom. However it is very similar to
the <code class="language-plaintext highlighter-rouge">List</code> variant of <code class="language-plaintext highlighter-rouge">syn::Meta</code> enum.</p>

    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[attrib_macro_logger_2(a,</span> <span class="nd">b,</span> <span class="nd">c)]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">some_annotated_function</span><span class="p">()</span> <span class="p">{</span>
    <span class="cm">/* ... */</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ol>
      <h3 id="create-entry-in-librs">
        
        
          Create entry in lib.rs <a href="#create-entry-in-librs">#</a>
        
        
      </h3>
    

<p>Let‚Äôs start by creating an entry in <code class="language-plaintext highlighter-rouge">lib.rs</code> for these attribute macros.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[proc_macro_attribute]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">attrib_macro_logger_1</span><span class="p">(</span>
  <span class="n">args</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">,</span>
  <span class="n">item</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TokenStream</span> <span class="p">{</span>
  <span class="nn">logger</span><span class="p">::</span><span class="nf">attrib_proc_macro_impl</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
<span class="p">}</span>

<span class="nd">#[proc_macro_attribute]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">attrib_macro_logger_2</span><span class="p">(</span>
  <span class="n">args</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">,</span>
  <span class="n">item</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TokenStream</span> <span class="p">{</span>
  <span class="nn">logger</span><span class="p">::</span><span class="nf">attrib_proc_macro_impl</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now let‚Äôs write the implementations of the attribute macros, named <code class="language-plaintext highlighter-rouge">logger.rs</code>. As you can see in
addition to the <code class="language-plaintext highlighter-rouge">item</code> parameter, we have an extra parameter <code class="language-plaintext highlighter-rouge">args</code> that holds the arguments that
were passed into this attribute macro.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">quote</span><span class="p">::</span><span class="n">quote</span><span class="p">;</span>

<span class="cd">/// The args take a key value pair like `#[attrib_macro_logger(key = "value")]`.</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">attrib_proc_macro_impl_1</span><span class="p">(</span>
  <span class="n">args</span><span class="p">:</span> <span class="nn">proc_macro</span><span class="p">::</span><span class="n">TokenStream</span><span class="p">,</span>
  <span class="n">item</span><span class="p">:</span> <span class="nn">proc_macro</span><span class="p">::</span><span class="n">TokenStream</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">proc_macro</span><span class="p">::</span><span class="n">TokenStream</span> <span class="p">{</span>
  <span class="nd">quote!</span> <span class="p">{}</span><span class="nf">.into</span><span class="p">()</span>
<span class="p">}</span>

<span class="cd">/// The args take a set of identifiers like `#[attrib_macro_logger(a, b, c)]`.</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">attrib_proc_macro_impl_2</span><span class="p">(</span>
  <span class="n">args</span><span class="p">:</span> <span class="nn">proc_macro</span><span class="p">::</span><span class="n">TokenStream</span><span class="p">,</span>
  <span class="n">item</span><span class="p">:</span> <span class="nn">proc_macro</span><span class="p">::</span><span class="n">TokenStream</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">proc_macro</span><span class="p">::</span><span class="n">TokenStream</span> <span class="p">{</span>
  <span class="nd">quote!</span> <span class="p">{}</span><span class="nf">.into</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>üìú You can get the source code for this example in its repo
<a href="https://github.com/nazmulidris/rust_scratch/blob/main/macros/my_proc_macros_lib/src/logger.rs">here</a>.</p>

  <p>üëÄ Watch macro expansion</p>

  <p>To watch for changes run this script:
<code class="language-plaintext highlighter-rouge">./cargo-watch-macro-expand-one-test.fish test_attribute_macro_logger</code></p>

  <p>üëÄ Watch test output</p>

  <p>To watch for test output run this script:
<code class="language-plaintext highlighter-rouge">./cargo-watch-one-test.fish test_attribute_macro_logger</code></p>
</blockquote>
      <h3 id="how-to-parse-item">
        
        
          How to parse item? <a href="#how-to-parse-item">#</a>
        
        
      </h3>
    

<p>How do we parse the <code class="language-plaintext highlighter-rouge">item</code> parameter? We can use <code class="language-plaintext highlighter-rouge">syn::ItemFn</code> and <code class="language-plaintext highlighter-rouge">parse_macro_input!()</code> to parse
it into something usable. Here‚Äôs an example.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[proc_macro_attribute]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">attrib_proc_macro_impl_1</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TokenStream</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">item</span> <span class="o">=</span> <span class="nd">parse_macro_input!</span><span class="p">(</span><span class="n">item</span> <span class="k">as</span> <span class="n">ItemFn</span><span class="p">);</span>
    <span class="nd">quote!</span> <span class="p">{}</span><span class="nf">.into</span><span class="p">()</span>
<span class="p">}</span>

<span class="nd">#[proc_macro_attribute]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">attrib_proc_macro_impl_2</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TokenStream</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">item</span> <span class="o">=</span> <span class="nd">parse_macro_input!</span><span class="p">(</span><span class="n">item</span> <span class="k">as</span> <span class="n">ItemFn</span><span class="p">);</span>
    <span class="nd">quote!</span> <span class="p">{}</span><span class="nf">.into</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>
      <h3 id="how-to-parse-args-containing-attributes-for-variant-1">
        
        
          How to parse args containing attributes for variant 1? <a href="#how-to-parse-args-containing-attributes-for-variant-1">#</a>
        
        
      </h3>
    

<p>How do we parse <code class="language-plaintext highlighter-rouge">args</code> parameter into something we can use? We can use
<a href="https://docs.rs/syn/latest/syn/type.AttributeArgs.html"><code class="language-plaintext highlighter-rouge">syn::AttributeArgs</code></a> along w/
<code class="language-plaintext highlighter-rouge">parse_macro_input!()</code> to parse it into something usable.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[proc_macro_attribute]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">attrib_proc_macro_impl_1</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TokenStream</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">args</span> <span class="o">=</span> <span class="nd">parse_macro_input!</span><span class="p">(</span><span class="n">args</span> <span class="k">as</span> <span class="n">AttributeArgs</span><span class="p">);</span>
  <span class="k">let</span> <span class="n">item</span> <span class="o">=</span> <span class="nd">parse_macro_input!</span><span class="p">(</span><span class="n">item</span> <span class="k">as</span> <span class="n">ItemFn</span><span class="p">);</span>
  <span class="nd">quote!</span> <span class="p">{}</span><span class="nf">.into</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here‚Äôs a snippet of how we might use this attribute macro.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[attrib_macro_logger_1(key</span> <span class="nd">=</span> <span class="s">"value"</span><span class="nd">)]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">some_annotated_function</span><span class="p">()</span> <span class="p">{</span>
  <span class="cm">/* ... */</span>
<span class="p">}</span>
</code></pre></div></div>

<p>What we really want out of the
<a href="https://docs.rs/syn/latest/syn/type.AttributeArgs.html"><code class="language-plaintext highlighter-rouge">AttributeArgs</code></a> is the key and value pair.
We will write an extension trait to parse the key and value pair. And this is how we can use it.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">attrib_proc_macro_impl_1</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="n">TokenStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TokenStream</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">args</span> <span class="o">=</span> <span class="nd">parse_macro_input!</span><span class="p">(</span><span class="n">args</span> <span class="k">as</span> <span class="n">AttributeArgs</span><span class="p">);</span>
  <span class="c1">// Parse args (which contain key &amp; value).</span>
  <span class="k">let</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="n">args</span><span class="nf">.get_key_value_pair</span><span class="p">();</span>
  <span class="nd">println!</span><span class="p">(</span>
    <span class="s">"key: {}, value: {}"</span><span class="p">,</span>
    <span class="nf">style_prompt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">),</span>
    <span class="nf">style_prompt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">),</span>
  <span class="p">);</span>
  <span class="o">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>You can get the implementation of the extension traits in the links below.</p>

<ol>
  <li><a href="https://github.com/nazmulidris/rust_scratch/blob/main/macros/my_proc_macros_lib/src/utils/attribute_args_ext.rs"><code class="language-plaintext highlighter-rouge">AttributeArgsExt</code></a></li>
  <li><a href="https://github.com/nazmulidris/rust_scratch/blob/main/macros/my_proc_macros_lib/src/utils/meta_ext.rs"><code class="language-plaintext highlighter-rouge">MetaExt</code></a></li>
  <li><a href="https://github.com/nazmulidris/rust_scratch/blob/main/macros/my_proc_macros_lib/src/utils/nested_meta_ext.rs"><code class="language-plaintext highlighter-rouge">NestedMetaExt</code></a></li>
</ol>

<p>These traits are implemented on the types that are provided by syn and all work in a similar
fashion. They all look for specific patterns and panic if they‚Äôre not found. This is the desired
behavior because we want the compiler to give error messages when the it can‚Äôt generate code for the
macro.</p>

<p>And finally we have the complete macro.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">attrib_proc_macro_impl_1</span><span class="p">(</span>
  <span class="n">args</span><span class="p">:</span> <span class="nn">proc_macro</span><span class="p">::</span><span class="n">TokenStream</span><span class="p">,</span>
  <span class="n">item</span><span class="p">:</span> <span class="nn">proc_macro</span><span class="p">::</span><span class="n">TokenStream</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">proc_macro</span><span class="p">::</span><span class="n">TokenStream</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">args</span> <span class="o">=</span> <span class="nd">parse_macro_input!</span><span class="p">(</span><span class="n">args</span> <span class="k">as</span> <span class="n">AttributeArgs</span><span class="p">);</span>
  <span class="k">let</span> <span class="n">item</span> <span class="o">=</span> <span class="nd">parse_macro_input!</span><span class="p">(</span><span class="n">item</span> <span class="k">as</span> <span class="n">ItemFn</span><span class="p">);</span>

  <span class="c1">// Parse args (which contain key &amp; value).</span>
  <span class="k">let</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="n">args</span><span class="nf">.get_key_value_pair</span><span class="p">();</span>
  <span class="nd">println!</span><span class="p">(</span>
    <span class="s">"key: {}, value: {}"</span><span class="p">,</span>
    <span class="nf">style_prompt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">),</span>
    <span class="nf">style_prompt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">),</span>
  <span class="p">);</span>

  <span class="k">let</span> <span class="n">fn_ident</span> <span class="o">=</span> <span class="n">item</span><span class="py">.sig.ident</span><span class="nf">.from_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>

  <span class="nd">quote!</span> <span class="p">{</span>
    <span class="k">fn</span> #<span class="nf">fn_ident</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="nb">str</span> <span class="p">{</span>
      #<span class="n">value</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nf">.into</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When we use the macro like so:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[attrib_macro_logger_1(key</span> <span class="nd">=</span> <span class="s">"value"</span><span class="nd">)]</span>
<span class="k">fn</span> <span class="nf">this_fn_will_be_consumed_and_replaced</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span> <span class="mi">42</span> <span class="p">}</span>
</code></pre></div></div>

<p>Here‚Äôs the code that is generated:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">key</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="nb">str</span> <span class="p">{</span>
  <span class="s">"value"</span>
<span class="p">}</span>
</code></pre></div></div>
      <h3 id="how-to-parse-args-containing-set-of-identifiers-for-variant-2">
        
        
          How to parse args containing set of identifiers for variant 2? <a href="#how-to-parse-args-containing-set-of-identifiers-for-variant-2">#</a>
        
        
      </h3>
    

<p>We can also provide our own custom implementation of the <code class="language-plaintext highlighter-rouge">Parse</code> trait if we want to. Here‚Äôs an
example of this based on syn‚Äôs
<a href="https://github.com/dtolnay/syn/blob/master/examples/trace-var/trace-var/src/lib.rs"><code class="language-plaintext highlighter-rouge">trace-var</code></a>
example.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashSet</span> <span class="k">as</span> <span class="n">Set</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">syn</span><span class="p">::{</span><span class="n">parse_macro_input</span><span class="p">,</span> <span class="n">Token</span><span class="p">,</span> <span class="n">Ident</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">syn</span><span class="p">::</span><span class="nn">parse</span><span class="p">::{</span><span class="n">Parse</span><span class="p">,</span> <span class="n">ParseStream</span><span class="p">,</span> <span class="nb">Result</span><span class="p">};</span>

<span class="cd">/// Parses a list of variable names separated by `+`.</span>
<span class="cd">///</span>
<span class="cd">///     a + b + c</span>
<span class="cd">///</span>
<span class="cd">/// This is how the compiler passes in arguments to our attribute -- it is</span>
<span class="cd">/// everything inside the delimiters after the attribute name.</span>
<span class="cd">///</span>
<span class="cd">///     #[attrib_macro_logger(a+ b+ c)]</span>
<span class="cd">///                           ^^^^^^^</span>
<span class="k">struct</span> <span class="n">ArgsHoldingIdents</span> <span class="p">{</span>
  <span class="n">idents</span><span class="p">:</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">Ident</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Parse</span> <span class="k">for</span> <span class="n">ArgsHoldingIdents</span> <span class="p">{</span>
  <span class="k">fn</span> <span class="nf">parse</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">ParseStream</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">vars</span> <span class="o">=</span> <span class="nn">Punctuated</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Ident</span><span class="p">,</span> <span class="nd">Token!</span><span class="p">[</span><span class="o">+</span><span class="p">]</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">parse_terminated</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">ArgsHoldingIdents</span> <span class="p">{</span>
      <span class="n">idents</span><span class="p">:</span> <span class="n">vars</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.collect</span><span class="p">(),</span>
    <span class="p">})</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>The <code class="language-plaintext highlighter-rouge">parse()</code> function receives a <code class="language-plaintext highlighter-rouge">ParseStream</code> and returns a <code class="language-plaintext highlighter-rouge">Result</code>. In this case:
    <ol>
      <li><code class="language-plaintext highlighter-rouge">args::ParseStream</code> is the <code class="language-plaintext highlighter-rouge">TokenStream</code> of the optional arguments that are passed into the
attribute macro. In other words <code class="language-plaintext highlighter-rouge">(a+ b+ c)</code>.</li>
      <li><code class="language-plaintext highlighter-rouge">Result</code> holds the struct <code class="language-plaintext highlighter-rouge">ArgsHoldingIdents</code>. In other words a <code class="language-plaintext highlighter-rouge">Set</code> of <code class="language-plaintext highlighter-rouge">Ident</code> containing
<code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, <code class="language-plaintext highlighter-rouge">c</code>.</li>
    </ol>
  </li>
  <li>The actual work is done by
<a href="https://docs.rs/syn/latest/syn/punctuated/struct.Punctuated.html#method.parse_terminated"><code class="language-plaintext highlighter-rouge">Punctuated::parse_terminated()</code></a>
function. There are a few of these helper functions provided by syn.</li>
  <li><code class="language-plaintext highlighter-rouge">parse_terminated()</code> parses a bunch of <code class="language-plaintext highlighter-rouge">T</code> separated by <code class="language-plaintext highlighter-rouge">P</code> and it has to be told two things:
    <ol>
      <li><em>What type <code class="language-plaintext highlighter-rouge">T</code> it is parsing?</em> In this case, <code class="language-plaintext highlighter-rouge">Ident</code>.</li>
      <li><em>What the separator <code class="language-plaintext highlighter-rouge">P</code>?</em> In this case,
<a href="https://docs.rs/syn/latest/syn/macro.Token.html"><code class="language-plaintext highlighter-rouge">Token![+]</code></a> which is the Rust
representation of the <code class="language-plaintext highlighter-rouge">+</code> token (provided by the <code class="language-plaintext highlighter-rouge">Token!</code> macro).</li>
      <li>We provide it w/ this information using the turbofish syntax: <code class="language-plaintext highlighter-rouge">::&lt;Ident, Token![+]&gt;::</code>.</li>
    </ol>
  </li>
  <li>Finally after the <code class="language-plaintext highlighter-rouge">ParseStream</code> is parsed, it returns an iterator, which must be used to generate
the result. We simply iterate over the iterator and collect the <code class="language-plaintext highlighter-rouge">Ident</code>s and move them into an
instance of a new struct <code class="language-plaintext highlighter-rouge">ArgsHoldingIdents</code> and return that wrapped in a <code class="language-plaintext highlighter-rouge">Result::Ok</code>.</li>
</ol>

<p>And we might implement the macro like this:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// The args take a set of identifiers like `#[attrib_macro_logger(a, b, c)]`.</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">attrib_proc_macro_impl_2</span><span class="p">(</span>
  <span class="n">args</span><span class="p">:</span> <span class="nn">proc_macro</span><span class="p">::</span><span class="n">TokenStream</span><span class="p">,</span>
  <span class="n">item</span><span class="p">:</span> <span class="nn">proc_macro</span><span class="p">::</span><span class="n">TokenStream</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">proc_macro</span><span class="p">::</span><span class="n">TokenStream</span> <span class="p">{</span>
  <span class="k">let</span> <span class="n">args</span> <span class="o">=</span> <span class="nd">parse_macro_input!</span><span class="p">(</span><span class="n">args</span> <span class="k">as</span> <span class="n">ArgsHoldingIdents</span><span class="p">);</span>
  <span class="k">let</span> <span class="n">item</span> <span class="o">=</span> <span class="nd">parse_macro_input!</span><span class="p">(</span><span class="n">item</span> <span class="k">as</span> <span class="n">ItemFn</span><span class="p">);</span>

  <span class="k">let</span> <span class="n">fn_name_ident</span> <span class="o">=</span> <span class="n">item</span><span class="py">.sig.ident</span><span class="p">;</span>

  <span class="k">let</span> <span class="n">args_to_string</span> <span class="o">=</span> <span class="n">args</span>
    <span class="py">.idents</span>
    <span class="nf">.iter</span><span class="p">()</span>
    <span class="nf">.map</span><span class="p">(|</span><span class="n">ident</span><span class="p">|</span> <span class="n">ident</span><span class="nf">.to_string</span><span class="p">())</span>
    <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span>
    <span class="nf">.join</span><span class="p">(</span><span class="s">", "</span><span class="p">);</span>

  <span class="nd">quote!</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> #<span class="nf">fn_name_ident</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="nb">str</span> <span class="p">{</span> #<span class="n">args_to_string</span> <span class="p">}</span>
  <span class="p">}</span>
  <span class="nf">.into</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And use it like so:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[attrib_macro_logger_2(a</span> <span class="err">+</span> <span class="nd">b</span> <span class="err">+</span> <span class="nd">c)]</span>
<span class="k">fn</span> <span class="nf">foo</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span> <span class="mi">42</span> <span class="p">}</span>
</code></pre></div></div>

<p>This generates the following code (very minor note - the ordering of the output is actually not
stable):</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">foo</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="nb">str</span> <span class="p">{</span>
  <span class="s">"c, a, b"</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>üìú You can find another example of a attribute procedural macro from the syn docs called
<a href="https://github.com/dtolnay/syn/tree/master/examples/trace-var"><code class="language-plaintext highlighter-rouge">trace-var</code></a>.</p>
</blockquote>
      <h2 id="learning-resources">
        
        
          Learning resources <a href="#learning-resources">#</a>
        
        
      </h2>
    

<ul>
  <li>Overview
    <ul>
      <li><a href="https://youtu.be/g4SYTOc8fL0">Excellent overview video</a></li>
    </ul>
  </li>
  <li>Books / articles
    <ul>
      <li><a href="https://doc.rust-lang.org/reference/procedural-macros.html#function-like-procedural-macros">Macro how to</a></li>
      <li><a href="https://doc.rust-lang.org/book/ch19-06-macros.html#procedural-macros-for-generating-code-from-attributes">Macro how to</a></li>
    </ul>
  </li>
  <li>Workshop
    <ul>
      <li><a href="https://github.com/dtolnay/proc-macro-workshop/blob/master/README.md">Proc macro workshop</a></li>
      <li><a href="https://github.com/jonhoo/proc-macro-workshop">Proc macro workshop solutions</a></li>
    </ul>
  </li>
  <li>Technical guides to getting things working
    <ul>
      <li><a href="https://dev.to/dandyvica/rust-procedural-macros-step-by-step-tutorial-36n8">Tutorial - Add lib crate for macros</a></li>
      <li><a href="https://users.rust-lang.org/t/how-to-import-procedural-macros-that-is-not-in-lib-rs/58323/9"><code class="language-plaintext highlighter-rouge">lib.rs</code> restriction</a></li>
      <li><a href="https://docs.rs/quote">Quote</a></li>
      <li><a href="https://docs.rs/syn">Syn</a></li>
    </ul>
  </li>
  <li>Procedural macros workshop
    <ul>
      <li><a href="https://github.com/dtolnay/proc-macro-workshop/blob/master/README.md#derive-macro-derivebuilder">Workshop derive builder problem</a></li>
      <li><a href="https://github.com/dtolnay/proc-macro-workshop/blob/master/builder/tests/01-parse.rs">Solution hints for builder problem</a></li>
    </ul>
  </li>
  <li>Source code examples
    <ol>
      <li>You can find ‚Äúreal world‚Äù examples of both declarative and procedural macros in the
  <code class="language-plaintext highlighter-rouge">r3bl-open-core</code> <a href="https://github.com/r3bl-org/r3bl-open-core">repo</a>.
        <ul>
          <li><a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/macro">proc macros</a></li>
          <li><a href="https://github.com/r3bl-org/r3bl-open-core-archive/tree/main/macro">proc macros</a></li>
          <li><a href="https://github.com/r3bl-org/r3bl-open-core/search?q=macro_rules">decl macros</a></li>
        </ul>
      </li>
      <li>You can find all the pedagogical examples of macros shown in this article in this
  <a href="https://github.com/nazmulidris/rust_scratch/blob/main/macros/">repo</a>.</li>
    </ol>
  </li>
</ul>
      <h2 id="build-with-naz-video-series-on-developerlifecom-youtube-channel">
        
        
          Build with Naz video series on developerlife.com YouTube channel <a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">#</a>
        
        
      </h2>
    

<blockquote>
  <p>If you have comments and feedback on this content, or would like to request new content
(articles &amp; videos) on developerlife.com, please join our <a href="https://discord.gg/8M2ePAevaMi">discord
server</a>.</p>
</blockquote>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a></li>
  <li>Playlists
    <ul>
      <li><a href="https://www.youtube.com/watch?v=bolScvh4x7I&amp;list=PLofhE49PEwmw3MKOU1Kn3xbP4FRQR4Mb3">Build with Naz, Linux TTY, process, signals, commands in async Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmza94sS7UmJnN9gSCHTVTfz">Build with Naz, fundamental effective Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmwO69E7eiQ-ewnMME8ydgQ5">Build with Naz, effective async Rust and tokio</a></li>
      <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
    </ul>
  </li>
</ul>

        <!--
    Display all the categories for this page
    More info:
    - Tutorial - http://tinyurl.com/yc6fq6zx
    - Liquid language reference - http://tinyurl.com/y8s4qpwo
-->
<div class="categories-block">
    
    
    <span class="category">
            <a href="/category/MP">
                #mp</a>
        </span>
    
    <span class="category">
            <a href="/category/Rust">
                #rust</a>
        </span>
    
</div>

        
<blockquote>

  üëÄ Watch Rust ü¶Ä live coding videos on our <a
  href="https://www.youtube.com/@developerlifecom">YouTube Channel</a>.

  <br/>
  <br/>

  <!-- video on rust polymorphism (no playlist) -->
  <iframe
      src="https://www.youtube.com/embed/kYTgGtJjSro?si=XmW-_CAvCfB5e269"
      title="YouTube video player" frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
      referrerpolicy="strict-origin-when-cross-origin"
      allowfullscreen
      >
  </iframe>

  <br/>
  <br/>

  üì¶ Install our useful Rust command line apps using <code>cargo install r3bl-cmdr</code>
  (they are from the <a href="https://github.com/r3bl-org/r3bl-open-core">r3bl-open-core</a>
  project):
  <ul>
    <li>üê±<code>giti</code>: run interactive git commands with confidence in your terminal</li>
    <li>ü¶ú<code>edi</code>: edit Markdown with style in your terminal</li>
  </ul>

  <p>
  <kbd>giti in action</kbd>
  <video width="100%" controls>
    <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/262f59d1-a95c-4af3-accf-c3d6cac6e586" type="video/mp4"/>
  </video>
  </p>

  <p>
  <kbd>edi in action</kbd>
  <video width="100%" controls>
    <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/f2c4b07d-b5a2-4f41-af7a-06d1b6660c41" type="video/mp4"/>
  </video>
  </p>

  </blockquote>

        <!--
    Display related posts (by category)
    More info:
    - Tutorial - http://tinyurl.com/j5tevq7
    - Liquid language reference - http://tinyurl.com/y9ru5msq
-->
<div class="related-post-block">

    <h3>Related Posts</h3>

    <!-- Get all the related posts into the string `postsString`-->
    
    
    

    <!--
        At this point `postsString` string might look like:
        Post 3|Post 1|Post 3|Post 2|Post 1|Post 3|Post 2|
    -->

    <!-- Remove all the dupes from the `postsString` string, and split it into an array -->
    

    <ul>
        
            
                
                <li>
                    <a class="post-list" href="/2022/08/04/rust-dsl-part-1/">
                        Create a simple DSL for CSS like syntax for TUIs
                    </a>
                </li>
            
        
            
        
            
                
                <li>
                    <a class="post-list" href="/2021/03/13/ij-idea-plugin-advanced/">
                        Advanced guide to creating IntelliJ IDEA plugins
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2020/07/11/annotation-processing-kotlin-android/">
                        Annotation Processing in Kotlin and Android
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2020/04/05/kotlin-dsl-intro/">
                        Kotlin DSL Introduction
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/11/28/rust-tls-rustls/">
                        Build with Naz : TLS (Transport Layer Security) in Rust with tokio, rustls, CFSSL
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/11/28/rust-sqlite-diesel/">
                        Build with Naz : Diesel ORM, SQLite, and Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/09/02/rust-lifetimes/">
                        Build with Naz : Rust lifetimes
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/08/20/tty-linux-async-rust/">
                        Build with Naz : Explore Linux TTY, process, signals w/ Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/07/16/pin-box-dynamic-duo/">
                        Build with Naz : Box and Pin exploration in Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/07/10/rust-async-cancellation-safety-tokio/">
                        Build with Naz : Rust async in practice tokio::select!, actor pattern &amp; cancel safety
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/07/08/ubuntu24/">
                        Build with Naz : Ubuntu 24.04 setup and config for dev productivity
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/06/28/md-parser-rust-from-r3bl-tui/">
                        Build with Naz : Markdown parser in Rust and nom from r3bl_tui
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/06/10/rust-miette-error-handling/">
                        Build with Naz : Rust error handling with miette
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/05/28/typestate-pattern-rust/">
                        Build with Naz : Rust typestate pattern
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/05/25/tokio-uring-exploration-rust/">
                        Build with Naz : Linux io_uring and tokio-uring exploration with Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/05/19/effective-async-rust/">
                        Build with Naz : Rust async, non-blocking, concurrent, parallel, event loops, graceful shutdown
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/05/15/tokio-tracing-otel-rust/">
                        Build with Naz : tokio tracing &amp; OTel and how to use it in Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/04/28/rust-polymorphism-dyn-impl-trait-objects-for-testing-and-extensibiity/">
                        Build with Naz : Rust Polymorphism, dyn, impl, using existing traits, trait objects for testing and extensibility
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/04/21/build-async-interactive-cli-apps-in-rust/">
                        Build with Naz : Build interactive and non blocking CLI apps with ease in Rust using r3bl_terminal_async
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/01/13/write-simple-netcat-in-rust/">
                        Write a simple netcat client and server in Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/01/13/write-simple-chat-server-in-rust/">
                        Write a simple TCP chat server in Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2023/09/17/tuify-clap/">
                        tuify your clap CLI apps and make them more interactive
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2023/08/28/justfile/">
                        Use just to manage project specific commands
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2023/02/20/guide-to-nom-parsing/">
                        Build with Naz : Comprehensive guide to nom parsing
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2022/03/12/rust-redux/">
                        Write a Redux library in Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2022/03/12/rust-tokio/">
                        Write code using async/await in Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2022/03/02/rust-grep-cli-app/">
                        Build a grep CLI app in Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2022/02/24/rust-non-binary-tree/">
                        Build a non-binary tree that is thread safe using Rust
                    </a>
                </li>
            
        
    </ul>

</div>

        <a class="u-url" href="/2022/03/30/rust-proc-macro/" hidden></a>
    </div></article>
</div>
      </main><div>
  <section class="sidebar">
    <!-- video on intro to testing (with playlist) -->
    <!-- <iframe
      src="https://www.youtube.com/embed/videoseries?si=7gmhXY5DVYJG7OdU&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
      referrerpolicy="strict-origin-when-cross-origin"
      allowfullscreen
    >
    </iframe> -->

    <!-- rust async readline and spinner & playlist -->
    <!-- <iframe
      src="https://www.youtube.com/embed/videoseries?si=i37Ei9nCfvslOoaI&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
      referrerpolicy="strict-origin-when-cross-origin"
      allowfullscreen
    >
    </iframe> -->

    <!-- effective async rust & playlist -->
    <h2 class="star-us-github-heading">
      Subscribe to our
      <a href="https://www.youtube.com/@developerlifecom">YT Channel</a
      ><span class="heading-emoji"> ü¶Ä</span>
    </h2>

    <iframe
    src="https://www.youtube.com/embed/qvIt8MF-pCM?si=S40pbhnvVDAohj-6"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
      referrerpolicy="strict-origin-when-cross-origin"
      allowfullscreen>
    </iframe>

    <hr />

    <h2 class="star-us-github-heading">
      <a href="https://r3bl.com#services">Need help with code?</a>
      <span class="heading-emoji"> üíº</span>
    </h2>

    <hr />

    <h2 class="star-us-github-heading">
      Use our crates & apps<span class="heading-emoji"> üì¶</span>
    </h2>

    <ul class="sidebar-ul">
      <li class="app-container">
        <a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/cmdr" target="_blank">
          <img class="star-icon-img" src="/assets/r3bl-apps.svg" />
          <div class="sidebar-list-item">
            <p class="p-tag">INSTALL & USE OUR APPS (giti, edi)</p>
            <h3 class="sidebar-h3"><code>r3bl-cmdr</code></h3>
          </div>
        </a>
      </li>
      <li class="app-container">
        <a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/tui" target="_blank">
          <img class="star-icon-img" src="/assets/crate.png" />
          <div class="sidebar-list-item">
            <p class="p-tag">R3BL TUI LIB</p>
            <h3 class="sidebar-h3"><code>r3bl_tui</code></h3>
          </div>
        </a>
      </li>
      <li class="app-container">
        <a href="https://chromewebstore.google.com/detail/r3bl-shortlink/ffhfkgcfbjoadmhdmdcmigopbfkddial?hl=en-US&gl=US" target="_blank">
          <img class="star-icon-img" src="/assets/r3bl-shortlink.svg" />
          <div class="sidebar-list-item">
            <p class="p-tag">SHORTLINK browser extension</p>
            <h3 class="sidebar-h3"><code>shortlink</code></h3>
          </div>
        </a>
      </li>
      <!-- <li class="app-container">
        <a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/tuify" target="_blank">
          <img class="star-icon-img" src="/assets/crate.png" />
          <div class="sidebar-list-item">
            <p class="p-tag">R3BL TUIFY LIB</p>
            <h3 class="sidebar-h3"><code>r3bl_tuify</code></h3>
          </div>
        </a>
      </li>
      <li class="app-container">
        <a
          href="https://github.com/r3bl-org/r3bl-open-core/tree/main/terminal_async"
          target="_blank"
        >
          <img class="star-icon-img" src="/assets/crate.png" />
          <div class="sidebar-list-item">
            <p class="p-tag">R3BL TERMINAL ASYNC LIB</p>
            <h3 class="sidebar-h3"><code>r3bl_terminal_async</code></h3>
          </div>
        </a>
      </li> -->
    </ul>

    <hr />

    <h2 class="star-us-github-heading">
      To provide feedback & comments, join our <a href="https://discord.gg/PhuF4qFpcA">Discord</a>
      <span class="heading-emoji"> üí¨</span>
    </h2>

  </section>
</div>
</div><footer class="site-footer h-card">

    <div class="wrapper">

        <div class="footer-col-wrapper">

            <div class="footer-col"><!-- <p>
    developerlife.com site was started in Nov 1998 with coverage for
    topics related to Java, XML, and web and desktop technologies.
    Today it covers Kotlin, TypeScript, Node.js, React, Android, JDK,
    Web, Cloud technologies, User Experience Engineering (UXE)
    and design topics. ¬© Nazmul Idris 1996-2025. All rights reserved.
</p> -->
<div>
  <p class="footer-p">
    developerlife.com site was started in Nov 1998 by <a
    href="https://developerlife.com/about-me/">Nazmul Idris</a>, with coverage for topics
    related to Java, XML, and web and desktop technologies. Today it covers Rust, TUI,
    CLI, Kotlin, TypeScript, Node.js, React, Android, JDK, Web, Cloud technologies, User
    Experience Engineering (UXE) and design topics. ¬© Nazmul Idris 1996-2025. All rights
    reserved.
  </p>

  <!--
  <div class="footer-container">

    <kbd>
      <a class="footer-elem-2" href="https://r3bl.com#services" target="_blank">Need help with code?</a>
    </kbd>

    <kbd>
      <a class="footer-elem-1" href="/subscribe.html" target="_blank"
        >Newsletter</a
      >
    </kbd>

  </div>
  -->
</div>
</div>

        </div>

    </div>

</footer>
<script>
//open external links in a new window
function external_new_window() {
    for(var c = document.getElementsByTagName("a"), a = 0;a < c.length;a++) {
    var b = c[a];
    b.getAttribute("href") && b.hostname !== location.hostname && (b.target = "_blank")
    }
}
//open PDF links in a new window
function pdf_new_window ()
{
    if (!document.getElementsByTagName) return false;
    var links = document.getElementsByTagName("a");
    for (var eleLink=0; eleLink < links.length; eleLink ++) {
    if ((links[eleLink].href.indexOf('.pdf') !== -1)||(links[eleLink].href.indexOf('.doc') !== -1)||(links[eleLink].href.indexOf('.docx') !== -1)) {
        links[eleLink].onclick =
        function() {
            window.open(this.href);
            return false;
        }
    }
    }
} 
pdf_new_window()
external_new_window();
</script></body>
</html>
