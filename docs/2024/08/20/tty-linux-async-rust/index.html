<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" /><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Build with Naz : Explore Linux TTY, process, signals w/ Rust | developerlife.com</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Build with Naz : Explore Linux TTY, process, signals w/ Rust" />
<meta name="author" content="Nazmul Idris" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This article, along with related videos and the repository, explores Linux TTY, shells, processes, sessions, jobs, PTYs, signals, and more using Rust. It explains /dev/tty and describes how terminal libraries like crossterm and termion build on top of stdio and /dev/tty. The article provides examples of using Rust to send and receive POSIX signals, communicate with processes via IPC, and spawn processes. Additionally, it includes examples of using PTY in Linux and controlling external commands (such as binaries like bash) using asynchronous Rust." />
<meta property="og:description" content="This article, along with related videos and the repository, explores Linux TTY, shells, processes, sessions, jobs, PTYs, signals, and more using Rust. It explains /dev/tty and describes how terminal libraries like crossterm and termion build on top of stdio and /dev/tty. The article provides examples of using Rust to send and receive POSIX signals, communicate with processes via IPC, and spawn processes. Additionally, it includes examples of using PTY in Linux and controlling external commands (such as binaries like bash) using asynchronous Rust." />
<link rel="canonical" href="http://developerlife.com/2024/08/20/tty-linux-async-rust/" />
<meta property="og:url" content="http://developerlife.com/2024/08/20/tty-linux-async-rust/" />
<meta property="og:site_name" content="developerlife.com" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-08-20T10:00:00-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Build with Naz : Explore Linux TTY, process, signals w/ Rust" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Nazmul Idris"},"dateModified":"2024-08-20T10:00:00-05:00","datePublished":"2024-08-20T10:00:00-05:00","description":"This article, along with related videos and the repository, explores Linux TTY, shells, processes, sessions, jobs, PTYs, signals, and more using Rust. It explains /dev/tty and describes how terminal libraries like crossterm and termion build on top of stdio and /dev/tty. The article provides examples of using Rust to send and receive POSIX signals, communicate with processes via IPC, and spawn processes. Additionally, it includes examples of using PTY in Linux and controlling external commands (such as binaries like bash) using asynchronous Rust.","headline":"Build with Naz : Explore Linux TTY, process, signals w/ Rust","mainEntityOfPage":{"@type":"WebPage","@id":"http://developerlife.com/2024/08/20/tty-linux-async-rust/"},"url":"http://developerlife.com/2024/08/20/tty-linux-async-rust/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css" />

  <!-- Add favicon -->
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />

  <!-- Add fontawesome (only for bio.html page) -->
  <link
    rel="stylesheet"
    href="https://use.fontawesome.com/releases/v5.2.0/css/all.css"
    integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ"
    crossorigin="anonymous"
  /><link type="application/atom+xml" rel="alternate" href="http://developerlife.com/feed.xml" title="developerlife.com" /><!-- https://developers.google.com/analytics/devguides/collection/gtagjs -->
<script async
        src="https://www.googletagmanager.com/gtag/js?id=G-NQY9ECC58H"></script>
<script>
  window.dataLayer = window.dataLayer || []

  function gtag() {
    window.dataLayer.push(arguments)
  }

  gtag("js", new Date())
  gtag("config", "G-NQY9ECC58H")
</script>
</head>
<body><!-- https://github.com/mermaid-js/mermaid/blob/develop/docs/n00b-gettingStarted.md -->
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>

<script>
  // https://mermaid-js.github.io/mermaid/#/theming
  mermaid.initialize({
    startOnLoad: true,
    theme: "dark",
    themeVariables: {
      fontFamily: "Fira Code",
      fontSize: "0.95rem",
      darkMode: true,
      primaryColor: "#2f9ece",
      mainBkg: "#303439",
    },
  })
</script>
<header class="site-header" role="banner">

    <div class="wrapper header-wrapper"><div class="logo-container">
        <div class="logo-image">
          <a class="site-title"
             rel="author"
             href="/">
              <!-- This is the logo image placeholder. -->
                <picture>
                  <source srcset="/assets/dl-logo-icon-dark.svg" media="(max-width: 600px)"/>
                  <img  src="/assets/dl-logo-icon-and-text-dark.svg" />
                </picture>
          </a>
        </div>
      </div><nav class="site-nav">
            <input type="checkbox" id="nav-trigger" class="nav-trigger"/>
            <label for="nav-trigger">
          <span class="menu-icon">
              <svg class="svg-icon">
              <use xlink:href="/assets/minima-social-icons.svg#menu">
              </use>
            </svg>
          </span>
            </label>

            <div class="trigger"><!--
    Iterate over all the pages in the site, where page_cursor holds the current
    page for each pass of the for loop.
    Note that page is the currently loaded page itself.
--><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Android/"> Android </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/CC/"> Concurrency </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/CLI/"> CLI </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/CS/"> CS </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/DB/"> Database </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/DI/"> DI </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/FE/"> Frontend </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Hardware/"> Hardware </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/IJ/"> IntelliJ </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/KT/"> Kotlin </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Linux/"> Linux </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/MP/"> MP </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Misc/"> Misc </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Node/"> Node </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Productivity/"> Productivity </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/RN/"> React-Native </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/React/"> React </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Rust/"> Rust </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Server/"> Server </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/State/"> State-Management </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Stories/"> Stories </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/TDD/"> Testing </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/TS/"> TypeScript </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/TUI/"> TUI </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Web/"> Web </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/about-me/"> Nazmul Idris </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/about-site/"> About Us </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/authors/"> Authors </a></div>
        </nav></div>
</header>

<!-- Debug to show the value of page.title and page.category variables -->
<!--<pre>page_cursor.exclude = nil</pre>-->
<!--<pre>page.exclude = nil</pre>-->
<!--<pre>page.title = &quot;Build with Naz : Explore Linux TTY, process, signals w/ Rust&quot;</pre>-->
<!--<pre>page.category = nil</pre>-->
<!--<pre>page.title (json) = Build with Naz : Explore Linux TTY, process, signals w/ Rust</pre>-->
<!--<pre>page.category (json) = </pre>-->
<div class="page-and-sidebar-wrapper">
      <main class="page-content" aria-label="Content">
        <div class="wrapper"><article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting"><header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Build with Naz : Explore Linux TTY, process, signals w/ Rust</h1>

    <!-- Create all the variables needed for this page (and all the includes) -->
    

    <div class="post-meta">
        <p>
            <!-- Date -->Aug 20, 2024

            <!--Author-->
            âˆ™ <a href="/about-me">Nazmul Idris</a>

            <!-- One line social blurb --><ul class="contact-list">
    <li class="p-name">Hi, I'm
            <a href="/about-me">Nazmul</a>,
            an ex-Googler, <a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/tui" target="_blank">r3bl_tui maintainer</a>, SWE, entrepreneur, designer, leader,
            TaiChi-er, racer, storyteller.
            <!-- This is fontawesome icon -->
            I <i class="fas fa-heart"></i>
            leadership, authenticity, play, hope,
            <i class="fas fa-code"></i>,
            <i class="fas fa-terminal"></i>, &
            <i class="fas fa-coffee"></i>,
            ğŸ˜ƒ.</li>
</ul>
</p>
    </div><div class="social-media-container">
  <!-- <iframe
    src="https://github.com/sponsors/nazmulidris/button"
    title="Sponsor nazmulidris"
    height="35"
    width="116"
    style="border: 0; padding-right: 6px"
  ></iframe> -->

  <p class="social-media-item">
    <a
      href="mailto:hello@r3bl.com"
      target="_blank"
      title="Email us at hello@r3bl.com"
    >
      <svg class="svg-icon">
        <use xlink:href="/assets/minima-social-icons.svg#email"></use>
      </svg>
    </a>
  </p>

  <p class="social-media-item">
    <a href="https://r3bl.com/#services" target="_blank" title="Need help with code?">
      <img class="svg-icon" src="https://r3bl.com/images/logo.svg" alt="R3BL Logo">
    </a>
  </p><p class="social-media-item">
    <a
      href="https://www.youtube.com/channel/UCMcsxfCwzwDevc3NRqFgfEg"
      target="_blank"
      title="developerlife.com YouTube channel"
    >
      <svg class="svg-icon">
        <use xlink:href="/assets/minima-social-icons.svg#youtube"></use>
      </svg>
    </a>
  </p><p class="social-media-item">
    <a
      href="https://www.linkedin.com/in/nazmulidris"
      target="_blank"
      title="Nazmul Idris LinkedIn profile"
    >
      <svg class="svg-icon">
        <use xlink:href="/assets/minima-social-icons.svg#linkedin"></use>
      </svg>
    </a>
  </p><p class="social-media-item">
    <a
      href="https://www.github.com/nazmulidris" target="_blank" title="Nazmul Idris github profile">
      <svg class="svg-icon">
        <use xlink:href="/assets/minima-social-icons.svg#github"></use>
      </svg>
    </a>
  </p><p class="social-media-item">
    <a href="/feed.xml" target="_blank" title="RSS feed">
      <svg class="svg-icon">
        <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
      </svg>
    </a>
  </p></div>
</header>
<div class="post-content e-content" itemprop="articleBody">
        <!-- If a page has a hero-image defined in it, then show it here -->


        <p><img class="post-hero-image" src="/assets/linux-tty-proc-async-rust.svg" /></p>

<!-- TOC -->

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#prerequisite">Prerequisite</a></li>
  <li><a href="#github-repo-for-this-article">GitHub repo for this article</a></li>
  <li><a href="#related-youtube-videos-for-this-article">Related YouTube videos for this article</a>
    <ul>
      <li><a href="#part-1--3--background-info">Part 1 / 3 : background info</a></li>
      <li><a href="#part-2--3--examples-of-send--recieve-signals-proc-spawn-and-ipc">Part 2 / 3 : examples of send &amp; recieve signals, proc spawn, and IPC</a></li>
      <li><a href="#part-3--3--run-tokioprocesscommand-in-async-rust">Part 3 / 3 : run tokio::process::Command in async Rust</a></li>
    </ul>
  </li>
  <li><a href="#limitations-of-using-tty-in-linux-and-why-we-like-userland-terminal-emulators-pty">Limitations of using TTY in Linux, and why we like userland terminal emulators PTY</a>
    <ul>
      <li><a href="#kernel-tty-">Kernel TTY ğŸ‘ğŸ½</a></li>
      <li><a href="#userland-pty-">Userland PTY ğŸ‘ğŸ½</a></li>
    </ul>
  </li>
  <li><a href="#examples-of-using-pty-in-linux">Examples of using PTY in Linux</a>
    <ul>
      <li><a href="#using-redirection-to-write-to-another-pty-run-command-in-left-terminal-see-output-in-right-terminal">Using redirection to write to another PTY run command in left terminal, see output in right terminal</a></li>
      <li><a href="#using-redirection-to-read-from-another-pty-type-in-left-terminal-see-it-in-right-terminal">Using redirection to read from another PTY type in left terminal, see it in right terminal</a></li>
      <li><a href="#breaking-things-in-raw-mode">Breaking things in raw mode.</a></li>
    </ul>
  </li>
  <li><a href="#shells-processes-sessions-jobs-ptys-signals">Shells, processes, sessions, jobs, PTYs, signals</a>
    <ul>
      <li><a href="#background-information-knowledgebase">Background information knowledgebase</a>
        <ul>
          <li><a href="#file-descriptors-and-processes-ulimit-stdin-stdout-stderr-pipes">File descriptors and processes, ulimit, stdin, stdout, stderr, pipes</a></li>
          <li><a href="#unix-shells-that-run-in-terminals-to-execute-built-in-and-program-commands">Unix shells that run in terminals to execute built-in and program commands</a>
            <ul>
              <li><a href="#what-is-the-relationship-between-linux-shells-subshells-and-fork-exec-and-wait-patterns">What is the relationship between linux shells, subshells, and fork, exec, and wait patterns?</a></li>
              <li><a href="#does-exec-change-the-current-working-directory-or-affect-environment-variables-in-the-parent">Does exec change the current working directory or affect environment variables in the parent?</a></li>
              <li><a href="#then-how-does-the-cd-command-change-the-current-working-directory-of-a-shell">Then how does the cd command change the current working directory of a shell?</a></li>
              <li><a href="#how-do-subshells-work-in-the-case-where-i-dont-the-shells-environment-to-be-affected-at-all">How do subshells work, in the case where I donâ€™t the shellâ€™s environment to be affected at all?</a></li>
              <li><a href="#deep-dive-of-all-this-information-in-video-format">Deep dive of all this information in video format</a></li>
            </ul>
          </li>
          <li><a href="#processes-sessions-jobs-ptys-signals-using-c">Processes, sessions, jobs, PTYs, signals using C</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#what-is-devtty">What is /dev/tty?</a>
    <ul>
      <li><a href="#how-is-crossterm-built-on-top-of-stdio-pty-etc">How is crossterm built on top of stdio, PTY, etc?</a></li>
      <li><a href="#how-is-termion-built-on-top-of-stdio-pty-etc">How is termion built on top of stdio, PTY, etc?</a></li>
    </ul>
  </li>
  <li><a href="#list-of-signals">List of signals</a></li>
  <li><a href="#-sending-and-receiving-signals-in-rust">ğŸ¦€ Sending and receiving signals in Rust</a>
    <ul>
      <li><a href="#example-using-tokio-to-receive-signals">Example using tokio to receive signals</a></li>
      <li><a href="#example-using-signal-hook-and-signal-hook-tokio">Example using signal-hook and signal-hook-tokio</a></li>
    </ul>
  </li>
  <li><a href="#-process-spawning-in-rust">ğŸ¦€ Process spawning in Rust</a>
    <ul>
      <li><a href="#example-using-procspawn-to-spawn-processes">Example using procspawn to spawn processes</a></li>
      <li><a href="#example-using-procspawn-to-spawn-processes-w-ipc-channel">Example using procspawn to spawn processes w/ ipc-channel</a></li>
    </ul>
  </li>
  <li><a href="#-run-tokioprocesscommand-in-async-rust">ğŸ¦€ Run tokio:process::Command in async Rust</a>
    <ul>
      <li><a href="#example-running-echo-process-programmatically">Example running echo process programmatically</a></li>
      <li><a href="#example-piping-input-to-cat-process-programmatically">Example piping input to cat process programmatically</a></li>
      <li><a href="#example-programmatically-providing-input-into-stdin-and-getting-output-from-stdout-of-a-process">Example programmatically providing input into stdin and getting output from stdout of a process</a></li>
      <li><a href="#example-programmatically-piping-the-output-of-one-process-into-another">Example programmatically piping the output of one process into another</a></li>
      <li><a href="#example-using-r3bl_terminal_async-to-send-commands-to-a-long-running-bash-child-process">Example using r3bl_terminal_async to send commands to a long running bash child process</a></li>
    </ul>
  </li>
  <li><a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</a></li>
</ul>

<!-- /TOC -->
      <h2 id="introduction">
        
        
          Introduction <a href="#introduction">#</a>
        
        
      </h2>
    
<p><a id="markdown-introduction" name="introduction"></a></p>

<p>This article, along with related videos and the repository, explores Linux TTY, shells,
processes, sessions, jobs, PTYs, signals, and more using Rust. It explains <code class="language-plaintext highlighter-rouge">/dev/tty</code> and
describes how terminal libraries like <code class="language-plaintext highlighter-rouge">crossterm</code> and <code class="language-plaintext highlighter-rouge">termion</code> build on top of <code class="language-plaintext highlighter-rouge">stdio</code>
and <code class="language-plaintext highlighter-rouge">/dev/tty</code>. The article provides examples of using Rust to send and receive POSIX
signals, communicate with processes via IPC, and spawn processes. Additionally, it
includes examples of using PTY in Linux and controlling external commands (such as
binaries like <code class="language-plaintext highlighter-rouge">bash</code>) using asynchronous Rust.</p>
      <h2 id="prerequisite">
        
        
          Prerequisite <a href="#prerequisite">#</a>
        
        
      </h2>
    
<p><a id="markdown-prerequisite" name="prerequisite"></a></p>

<p>Read all about TTY history and implementation in Linux
<a href="https://www.linusakesson.net/programming/tty/">here</a> before reading this repo and doing
the exercises here. There is so much background history and information in this article
that is a prerequisite to understanding anything in this repo.</p>

<p>This is a great <a href="https://youtu.be/juGNPLdjLH4?si=0gg4ZPbPbnL2_rQx">YouTube video</a> that
explains the fundamentals of the Linux kernel and device drivers, and how <code class="language-plaintext highlighter-rouge">char</code> device
drivers work. TTYs are <code class="language-plaintext highlighter-rouge">char</code> devices.</p>
      <h2 id="github-repo-for-this-article">
        
        
          GitHub repo for this article <a href="#github-repo-for-this-article">#</a>
        
        
      </h2>
    
<p><a id="markdown-github-repo-for-this-article" name="github-repo-for-this-article"></a></p>

<p>Hereâ€™s the <a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/README.md#list-of-signals"><code class="language-plaintext highlighter-rouge">tty</code>
repo</a>
containing the source code for this article and the videos.</p>
      <h2 id="related-youtube-videos-for-this-article">
        
        
          Related YouTube videos for this article <a href="#related-youtube-videos-for-this-article">#</a>
        
        
      </h2>
    
<p><a id="markdown-related-youtube-videos-for-this-article" name="related-youtube-videos-for-this-article"></a></p>

<p>This article is a companion to the following YouTube videos. If you like to learn via
video, please watch the companion videos on the <a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube
channel</a>. Please
<a href="https://www.youtube.com/@developerlifecom?sub_confirmation=1">subscribe</a> to the channel.</p>

<blockquote>
  <p>â¯ï¸ Hereâ€™s the <a href="https://www.youtube.com/watch?v=bolScvh4x7I&amp;list=PLofhE49PEwmw3MKOU1Kn3xbP4FRQR4Mb3">TTY
playlist</a>
containing all these videos.</p>
</blockquote>
      <h3 id="part-1--3--background-info">
        
        
          Part 1 / 3 : background info <a href="#part-1--3--background-info">#</a>
        
        
      </h3>
    
<p><a id="markdown-part-1-%2F-3-%3A-background-info" name="part-1-%2F-3-%3A-background-info"></a></p>

<!-- video tty-1 -->
<iframe src="https://www.youtube.com/embed/bolScvh4x7I?si=9Cm95eajpdEym0zX" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<p><br /></p>
      <h3 id="part-2--3--examples-of-send--recieve-signals-proc-spawn-and-ipc">
        
        
          Part 2 / 3 : examples of send &amp; recieve signals, proc spawn, and IPC <a href="#part-2--3--examples-of-send--recieve-signals-proc-spawn-and-ipc">#</a>
        
        
      </h3>
    
<p><a id="markdown-part-2-%2F-3-%3A-examples-of-send-%26-recieve-signals%2C-proc-spawn%2C-and-ipc" name="part-2-%2F-3-%3A-examples-of-send-%26-recieve-signals%2C-proc-spawn%2C-and-ipc"></a></p>

<!-- video tty-2 -->
<iframe src="https://www.youtube.com/embed/58_9yjLI4WA?si=-CZA8vZGnVTJ5ILD" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<p><br /></p>
      <h3 id="part-3--3--run-tokioprocesscommand-in-async-rust">
        
        
          Part 3 / 3 : run tokio::process::Command in async Rust <a href="#part-3--3--run-tokioprocesscommand-in-async-rust">#</a>
        
        
      </h3>
    
<p><a id="markdown-part-3-%2F-3-%3A-run-tokio%3A%3Aprocess%3A%3Acommand-in-async-rust" name="part-3-%2F-3-%3A-run-tokio%3A%3Aprocess%3A%3Acommand-in-async-rust"></a></p>

<!-- video tty-3 -->
<iframe src="https://www.youtube.com/embed/8JeL1sGozO4?si=9i1-booV0MoQXRGg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>

<p><br /></p>
      <h2 id="limitations-of-using-tty-in-linux-and-why-we-like-userland-terminal-emulators-pty">
        
        
          Limitations of using TTY in Linux, and why we like userland terminal emulators (PTY) <a href="#limitations-of-using-tty-in-linux-and-why-we-like-userland-terminal-emulators-pty">#</a>
        
        
      </h2>
    
<p><a id="markdown-limitations-of-using-tty-in-linux%2C-and-why-we-like-userland-terminal-emulators-pty" name="limitations-of-using-tty-in-linux%2C-and-why-we-like-userland-terminal-emulators-pty"></a></p>
      <h3 id="kernel-tty-">
        
        
          Kernel TTY ğŸ‘ğŸ½ <a href="#kernel-tty-">#</a>
        
        
      </h3>
    
<p><a id="markdown-kernel-tty-%F0%9F%91%8E%F0%9F%8F%BD" name="kernel-tty-%F0%9F%91%8E%F0%9F%8F%BD"></a></p>

<p>To switch to TTYs in Linux, press:</p>

<ul>
  <li><kbd>Ctrl + Alt + F3</kbd> to <kbd>Ctrl + Alt + F4</kbd>. To access two TTYs, one on <kbd>F3</kbd>
and the other on <kbd>F4</kbd>.</li>
  <li>To switch back to the TTY in which the GUI is running, press <kbd>Ctrl + Alt + F2</kbd>.</li>
</ul>

<p>In the Linux kernel, the TTY driver and line discipline provide basic line editing (and the
implementation of <code class="language-plaintext highlighter-rouge">cooked</code> or <code class="language-plaintext highlighter-rouge">raw</code> mode), and there is no
<a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter"><code class="language-plaintext highlighter-rouge">UART</code></a> or physical
terminal involved. Instead, a video terminal (a complex state machine including a frame buffer of
characters and graphical character attributes) is emulated in software, and
<a href="https://www.youtube.com/watch?v=aAuw2EVCBBg">[video] rendered to a VGA display</a>.</p>

<blockquote>
  <p>So if you run <code class="language-plaintext highlighter-rouge">edi</code> in a TTY, you will see that the font rendering and colors are different than
in a GUI terminal emulator. However it still runs.</p>
</blockquote>
      <h3 id="userland-pty-">
        
        
          Userland PTY ğŸ‘ğŸ½ <a href="#userland-pty-">#</a>
        
        
      </h3>
    
<p><a id="markdown-userland-pty-%F0%9F%91%8D%F0%9F%8F%BD" name="userland-pty-%F0%9F%91%8D%F0%9F%8F%BD"></a></p>

<p>The (kernel TTY) console subsystem is somewhat rigid. Things get more flexible (and abstract) if we
move the terminal emulation into userland. This is how <code class="language-plaintext highlighter-rouge">xterm</code> and its clones work. To facilitate
moving the terminal emulation into userland, while still keeping the TTY subsystem (session
management and line discipline) intact, the pseudo terminal or PTY was invented. And as you may have
guessed, things get even more complicated when you start running pseudo terminals inside pseudo
terminals, aka <code class="language-plaintext highlighter-rouge">screen</code> or <code class="language-plaintext highlighter-rouge">ssh</code>.</p>

<blockquote>
  <p>The primary use case for r3bl code is to run in this terminal emulator environment in userland and
not the TTY environment supplied by the Linux kernel itself.</p>
</blockquote>
      <h2 id="examples-of-using-pty-in-linux">
        
        
          Examples of using PTY in Linux <a href="#examples-of-using-pty-in-linux">#</a>
        
        
      </h2>
    
<p><a id="markdown-examples-of-using-pty-in-linux" name="examples-of-using-pty-in-linux"></a></p>

<p>Each terminal in Linux is associated with a PTY (pseudo terminal). This is the device provided by
each terminal emulator program instance (aka process) that is currently running on the system. Use
the following command to get a list of all PTYs on the system.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ls</span> /dev/pts
</code></pre></div></div>

<p>Hereâ€™s sample output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>crw--w---- nazmul tty  0 B Wed Jul 17 11:36:35 2024 î˜ 0
crw--w---- nazmul tty  0 B Wed Jul 17 11:38:32 2024 î˜ 1
crw--w---- nazmul tty  0 B Wed Jul 17 11:38:06 2024 î˜ 10
crw--w---- nazmul tty  0 B Wed Jul 17 11:23:20 2024 î˜ 11
crw--w---- nazmul tty  0 B Sun Jul 14 16:19:36 2024 î˜ 2
crw--w---- nazmul tty  0 B Mon Jul 15 13:22:48 2024 î˜ 3
crw--w---- nazmul tty  0 B Tue Jul 16 09:58:08 2024 î˜ 4
crw--w---- nazmul tty  0 B Wed Jul 17 10:34:48 2024 î˜ 5
crw--w---- nazmul tty  0 B Wed Jul 17 11:30:32 2024 î˜ 7
crw--w---- nazmul tty  0 B Wed Jul 17 11:36:36 2024 î˜ 8
crw--w---- nazmul tty  0 B Wed Jul 17 11:30:48 2024 î˜ 9
c--------- root   root 0 B Sat Jul 13 18:23:41 2024 î˜ ptmx
</code></pre></div></div>

<p>So which PTY is associated with the currently open terminal? Run the following command to get the
TTY number of the currently open terminal.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">set </span>my_tty_id <span class="o">(</span><span class="nb">tty</span><span class="o">)</span>
<span class="nb">echo</span> <span class="nv">$my_tty_id</span>
</code></pre></div></div>

<p>It will output something like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/dev/pts/1
</code></pre></div></div>

<p>Each <code class="language-plaintext highlighter-rouge">/dev/pts/*</code> is a file. And you can read / write / redirect to these files just like any other
file.</p>

<p>For the following examples, letâ€™s assume that you have 2 terminal emulator app windows open. One on
the left, and another one on the right.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                â”‚  â”‚                                â”‚
â”‚    LEFT TERMINAL               â”‚  â”‚    RIGHT TERMINAL              â”‚
â”‚    /dev/pts/1                  â”‚  â”‚    /dev/pts/2                  â”‚
â”‚                                â”‚  â”‚                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre></div></div>
      <h3 id="using-redirection-to-write-to-another-pty-run-command-in-left-terminal-see-output-in-right-terminal">
        
        
          Using redirection to write to another PTY (run command in left terminal, see output in right terminal) <a href="#using-redirection-to-write-to-another-pty-run-command-in-left-terminal-see-output-in-right-terminal">#</a>
        
        
      </h3>
    
<p><a id="markdown-using-redirection-to-write-to-another-pty-run-command-in-left-terminal%2C-see-output-in-right-terminal" name="using-redirection-to-write-to-another-pty-run-command-in-left-terminal%2C-see-output-in-right-terminal"></a></p>

<p>Letâ€™s say you have 2 terminals open, and one has the PTY number <code class="language-plaintext highlighter-rouge">/dev/pts/1</code> (on the left) and the
other has the TTY number <code class="language-plaintext highlighter-rouge">/dev/pts/2</code> (on the right).</p>

<p>From the left PTY <code class="language-plaintext highlighter-rouge">/dev/pts/1</code>, you can write to the right PTY <code class="language-plaintext highlighter-rouge">/dev/pts/2</code> using the following
command, and you will see â€œHello, World!â€ in the right PTY.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Run this in left terminal /dev/pts/1</span>
<span class="nb">echo</span> <span class="s2">"Hello, World!"</span> <span class="o">&gt;</span> /dev/pts/2 <span class="c"># You will see this in the right terminal /dev/pts/2</span>
</code></pre></div></div>
      <h3 id="using-redirection-to-read-from-another-pty-type-in-left-terminal-see-it-in-right-terminal">
        
        
          Using redirection to read from another PTY (type in left terminal, see it in right terminal) <a href="#using-redirection-to-read-from-another-pty-type-in-left-terminal-see-it-in-right-terminal">#</a>
        
        
      </h3>
    
<p><a id="markdown-using-redirection-to-read-from-another-pty-type-in-left-terminal%2C-see-it-in-right-terminal" name="using-redirection-to-read-from-another-pty-type-in-left-terminal%2C-see-it-in-right-terminal"></a></p>

<p>From the right PTY <code class="language-plaintext highlighter-rouge">/dev/pts/2</code> you can read input from the left PTY <code class="language-plaintext highlighter-rouge">/dev/pts/1</code> using the
following command.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Run this in right terminal /dev/pts/2</span>
<span class="nb">cat</span> /dev/pts/1
</code></pre></div></div>

<p>Type the following in the left PTY.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Run this in left terminal /dev/pts/1</span>
abcdefgh
</code></pre></div></div>

<p>You will see the following output in the right PTY: <code class="language-plaintext highlighter-rouge">abcdefgh</code>.</p>
      <h3 id="breaking-things-in-raw-mode">
        
        
          Breaking things in raw mode. <a href="#breaking-things-in-raw-mode">#</a>
        
        
      </h3>
    
<p><a id="markdown-breaking-things-in-raw-mode." name="breaking-things-in-raw-mode."></a></p>

<p>On the <strong>right</strong> terminal, run the following commands.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vi &amp;
<span class="nb">jobs</span>
</code></pre></div></div>

<p>Here you will see the job number of the <code class="language-plaintext highlighter-rouge">vi</code> process. And you will see that it is in the background.</p>

<p>If you run <code class="language-plaintext highlighter-rouge">ps l</code> you will see the states of all the processes that are running. If you run <code class="language-plaintext highlighter-rouge">ps -l</code>
you will this information on just the processes spawned in the right terminal. For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 S  1000  540327  540177  0  80   0 - 62854 futex_ pts/8    00:00:01 fish
0 T  1000  554675  540327  0  80   0 -  3023 do_sig pts/8    00:00:00 vi
4 R  1000  554850  540327  0  80   0 -  3478 -      pts/8    00:00:00 ps
</code></pre></div></div>

<p>Now if you bring <code class="language-plaintext highlighter-rouge">vi</code> to the foreground by running <code class="language-plaintext highlighter-rouge">fg</code>. The <code class="language-plaintext highlighter-rouge">vi</code> process is now in raw mode, and
the shell is no longer interpreting the input. It wonâ€™t know what to do with input that comes in
over <code class="language-plaintext highlighter-rouge">stdin</code>.</p>

<p>Run <code class="language-plaintext highlighter-rouge">echo "foo" &gt; /dev/pts/2</code> in the <strong>left</strong> terminal, you will see that the <code class="language-plaintext highlighter-rouge">vi</code> process gets
messed up, since it doesnâ€™t really interpret that input (as itâ€™s reading directly from keyboard and
mouse). However, the shell will send that output to <code class="language-plaintext highlighter-rouge">vi</code> and itâ€™s UI will be messed up. The same
thing happens if you use <code class="language-plaintext highlighter-rouge">micro</code> or <code class="language-plaintext highlighter-rouge">nano</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    LEFT TERMINAL               â”‚  â”‚    RIGHT TERMINAL              â”‚
â”‚    /dev/pts/1                  â”‚  â”‚    /dev/pts/2                  â”‚
â”‚                                â”‚  â”‚                                â”‚
â”‚                                â”‚  â”‚  &gt; vi &amp;                        â”‚
â”‚                                â”‚  â”‚  &gt; jobs                        â”‚
â”‚                                â”‚  â”‚  &gt; fg                          â”‚
â”‚  &gt; echo "foo" &gt; /dev/pts/2     â”‚  â”‚  &gt; # vi is messed up           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre></div></div>

<p>To terminate the <code class="language-plaintext highlighter-rouge">vi</code> process (or many of them), run <code class="language-plaintext highlighter-rouge">killall -9 vi</code>. That sends the <code class="language-plaintext highlighter-rouge">SIGKILL</code>
signal to all the <code class="language-plaintext highlighter-rouge">vi</code> processes.</p>
      <h2 id="shells-processes-sessions-jobs-ptys-signals">
        
        
          Shells, processes, sessions, jobs, PTYs, signals <a href="#shells-processes-sessions-jobs-ptys-signals">#</a>
        
        
      </h2>
    
<p><a id="markdown-shells%2C-processes%2C-sessions%2C-jobs%2C-ptys%2C-signals" name="shells%2C-processes%2C-sessions%2C-jobs%2C-ptys%2C-signals"></a></p>

<p>Letâ€™s say in a new terminal emulator program <code class="language-plaintext highlighter-rouge">xterm</code>, and then you run the following commands in
<code class="language-plaintext highlighter-rouge">fish</code>:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> &amp;
<span class="nb">ls</span> | <span class="nb">sort</span>
</code></pre></div></div>

<p>What happens here? What sessions and jobs are created? What about the pipe?</p>

<p>There are 4 jobs:</p>

<ol>
  <li>The job that runs <code class="language-plaintext highlighter-rouge">xterm</code> itself.</li>
</ol>

<ul>
  <li>This does not have any <code class="language-plaintext highlighter-rouge">stdin</code>, <code class="language-plaintext highlighter-rouge">stdout</code>, <code class="language-plaintext highlighter-rouge">stderr</code> <code class="language-plaintext highlighter-rouge">fd</code>s associated with it.</li>
  <li>This does not have a PTY associated with it.</li>
</ul>

<ol>
  <li>The job that runs <code class="language-plaintext highlighter-rouge">bash</code> itself.</li>
</ol>

<ul>
  <li>This has <code class="language-plaintext highlighter-rouge">stdin</code>, <code class="language-plaintext highlighter-rouge">stdout</code>, <code class="language-plaintext highlighter-rouge">stderr</code> (from <code class="language-plaintext highlighter-rouge">xterm</code>), lets say, <code class="language-plaintext highlighter-rouge">/dev/pts/0</code>.</li>
  <li>This has a PTY associated with it, lets say, <code class="language-plaintext highlighter-rouge">/dev/pts/0</code>.</li>
</ul>

<ol>
  <li>The job that runs <code class="language-plaintext highlighter-rouge">cat</code> in the background.</li>
</ol>

<ul>
  <li>This has <code class="language-plaintext highlighter-rouge">stdin</code>, <code class="language-plaintext highlighter-rouge">stdout</code>, <code class="language-plaintext highlighter-rouge">stderr</code> (from <code class="language-plaintext highlighter-rouge">xterm</code>), <code class="language-plaintext highlighter-rouge">/dev/pts/0</code>.</li>
  <li>This has a PTY associated with it, <code class="language-plaintext highlighter-rouge">/dev/pts/0</code>.</li>
</ul>

<ol>
  <li>The job that runs <code class="language-plaintext highlighter-rouge">ls | sort</code> pipeline. This job has 2 processes inside of it which are spawned
in parallel due to the pipe: 4.1. The process that runs <code class="language-plaintext highlighter-rouge">ls</code>.
    <ul>
      <li>This has <code class="language-plaintext highlighter-rouge">stdin</code>, <code class="language-plaintext highlighter-rouge">stderr</code> (from <code class="language-plaintext highlighter-rouge">xterm</code>), <code class="language-plaintext highlighter-rouge">/dev/pts/0</code>.</li>
      <li>Due to the pipe <code class="language-plaintext highlighter-rouge">stdout</code> is set to <code class="language-plaintext highlighter-rouge">pipe0</code>.</li>
      <li>This has a PTY associated with it, <code class="language-plaintext highlighter-rouge">/dev/pts/0</code>. 4.2. The process that runs <code class="language-plaintext highlighter-rouge">sort</code>.</li>
      <li>This has <code class="language-plaintext highlighter-rouge">stdout</code>, <code class="language-plaintext highlighter-rouge">stderr</code> (from <code class="language-plaintext highlighter-rouge">xterm</code>), <code class="language-plaintext highlighter-rouge">/dev/pts/0</code>.</li>
      <li>Due to the pipe, this has <code class="language-plaintext highlighter-rouge">stdin</code> set to <code class="language-plaintext highlighter-rouge">pipe0</code>.</li>
      <li>This has a PTY associated with it, <code class="language-plaintext highlighter-rouge">/dev/pts/0</code>.</li>
    </ul>
  </li>
</ol>

<p>The basic idea is that every pipeline is a job, because every process in a pipeline should be
manipulated (stopped, resumed, killed) simultaneously. Thatâ€™s why <code class="language-plaintext highlighter-rouge">kill</code> allows you to send signals
to entire process groups. By default, <code class="language-plaintext highlighter-rouge">fork</code> places a newly created child process in the same
process group as its parent, so that e.g. a <kbd>^C</kbd> from the keyboard will affect both parent
and child. But the shell, as part of its session leader duties, creates a new process group every
time it launches a pipeline.</p>

<p>The TTY driver keeps track of the foreground process group id, but only in a passive way. The
session leader has to update this information explicitly when necessary. Similarly, the TTY driver
keeps track of the size of the connected terminal, but this information has to be updated
explicitly, by the terminal emulator or even by the user.</p>

<p>Several processes have <code class="language-plaintext highlighter-rouge">/dev/pts/0</code> attached to their standard input. With these constrains:</p>

<ol>
  <li>Only the foreground job (the <code class="language-plaintext highlighter-rouge">ls | sort</code> pipeline) will receive input from the TTY.</li>
  <li>Likewise, only the foreground job will be allowed to write to the TTY device (in the default
configuration).</li>
  <li>If the <code class="language-plaintext highlighter-rouge">cat</code> process were to attempt to write to the TTY, the kernel would suspend it using a
signal.</li>
</ol>
      <h3 id="background-information-knowledgebase">
        
        
          Background information (knowledgebase) <a href="#background-information-knowledgebase">#</a>
        
        
      </h3>
    
<p><a id="markdown-background-information-knowledgebase" name="background-information-knowledgebase"></a></p>

<p>The following sections are a deep live of the Linux kernel and how it works with processes, file
descriptors, shells, and PTYs.</p>
      <h4 id="file-descriptors-and-processes-ulimit-stdin-stdout-stderr-pipes">
        
        
          File descriptors and processes, ulimit, stdin, stdout, stderr, pipes <a href="#file-descriptors-and-processes-ulimit-stdin-stdout-stderr-pipes">#</a>
        
        
      </h4>
    
<p><a id="markdown-file-descriptors-and-processes%2C-ulimit%2C-stdin%2C-stdout%2C-stderr%2C-pipes" name="file-descriptors-and-processes%2C-ulimit%2C-stdin%2C-stdout%2C-stderr%2C-pipes"></a></p>

<p>Hereâ€™s a
<a href="https://youtu.be/rW_NV6rf0rM?si=wcEkGPXnXzKeBn_G">[video] Whatâ€™s behind a file descriptor in Linux? Also, i/o redirection with <code class="language-plaintext highlighter-rouge">dup2</code>.</a>
that goes into file descriptors, pipes, and process forking in Linux.</p>
      <h4 id="unix-shells-that-run-in-terminals-to-execute-built-in-and-program-commands">
        
        
          Unix shells (that run in terminals to execute built-in and program commands) <a href="#unix-shells-that-run-in-terminals-to-execute-built-in-and-program-commands">#</a>
        
        
      </h4>
    
<p><a id="markdown-unix-shells-that-run-in-terminals-to-execute-built-in-and-program-commands" name="unix-shells-that-run-in-terminals-to-execute-built-in-and-program-commands"></a></p>
      <h5 id="what-is-the-relationship-between-linux-shells-subshells-and-fork-exec-and-wait-patterns">
        
        
          What is the relationship between linux shells, subshells, and fork, exec, and wait patterns? <a href="#what-is-the-relationship-between-linux-shells-subshells-and-fork-exec-and-wait-patterns">#</a>
        
        
      </h5>
    
<p><a id="markdown-what-is-the-relationship-between-linux-shells%2C-subshells%2C-and-fork%2C-exec%2C-and-wait-patterns%3F" name="what-is-the-relationship-between-linux-shells%2C-subshells%2C-and-fork%2C-exec%2C-and-wait-patterns%3F"></a></p>

<p>In Linux, shells, subshells, and the fork-exec-wait pattern are interconnected concepts that play a
crucial role in process management and execution. Hereâ€™s how they relate to each other:</p>

<ol>
  <li>
    <p><strong>Shells</strong>: A shell is a command-line interpreter that allows users to interact with the
operating system. Shells provide a way for users to run commands, launch programs, and manage
processes. Examples of popular shells in Linux include Bash, Zsh, and Fish.</p>
  </li>
  <li>
    <p><strong>Fork-Exec-Wait Pattern</strong>: This pattern is commonly used in shell scripting to spawn new
processes and manage their execution. By forking a new process, executing a different program in
the child process, and then waiting for the child process to finish, the shell can run multiple
commands concurrently and coordinate their execution. If the parent does not wait for the child
process to finish, the child is a zombie process.</p>

    <ul>
      <li><strong>Fork</strong>: When a process wants to execute a new program, it creates a copy of itself using the
<code class="language-plaintext highlighter-rouge">fork()</code> system call. This creates a new process (child process) that is an exact copy of the
original process (parent process) at the time of the <code class="language-plaintext highlighter-rouge">fork()</code> call. It needs to do this since
<code class="language-plaintext highlighter-rouge">exec()</code>, which is called next, will swap the program binaries of the process which calls it!
If it doesnâ€™t spawn a child, then the parent will cease to exist in memory after <code class="language-plaintext highlighter-rouge">exec()</code> is
called.</li>
      <li><strong>Exec</strong>: After forking, the child process uses the <code class="language-plaintext highlighter-rouge">exec()</code> system call to replace its memory
space with a new program. This allows the child process to run a different program than the
parent process. The <code class="language-plaintext highlighter-rouge">exec()</code> system call loads the new program into the child processâ€™s memory
and starts its execution.</li>
      <li><strong>Wait</strong>: After forking and executing a new program, the parent process may need to wait for
the child process to finish its execution. The parent process can use the <code class="language-plaintext highlighter-rouge">wait()</code> system call
to wait for the child process to terminate. This ensures that the parent process does not
continue its execution until the child process has completed its task.</li>
    </ul>
  </li>
  <li>
    <p><strong>Subshells</strong>: A subshell is a separate instance of the shell that is spawned to execute a
command or a group of commands. Subshells are created within the parent shell and can be used to
run commands in a separate environment without affecting the parent shell.</p>
  </li>
</ol>

<blockquote>
  <p>You can learn more about each of these system calls on your Linux machine simply by running
<code class="language-plaintext highlighter-rouge">bash -c "man fork"</code>, <code class="language-plaintext highlighter-rouge">bash -c "man exec"</code>, and <code class="language-plaintext highlighter-rouge">bash -c "man wait"</code>. The <code class="language-plaintext highlighter-rouge">bash -c</code> is needed only
if youâ€™re running some other shell like <code class="language-plaintext highlighter-rouge">fish</code> and not <code class="language-plaintext highlighter-rouge">bash</code>.</p>
</blockquote>

<p>The relationship between these concepts is as follows:</p>

<ul>
  <li>A shell process (the parent) creates a clone of their â€œselfâ€ process using <code class="language-plaintext highlighter-rouge">fork()</code>, called a
child process. And then they use <code class="language-plaintext highlighter-rouge">exec()</code> to replace the memory space of the child process with a
new program. Then the parent process waits for the child process to finish.</li>
  <li>The fork-exec-wait pattern is a common technique used in shells and subshells to spawn new
processes, execute programs, and coordinate their execution.</li>
  <li>Shells can create subshells to run commands in a separate environment. For example if you want to
run <code class="language-plaintext highlighter-rouge">cd</code> (which is a shell built-in command and not a external â€œprogramâ€ command) and you donâ€™t
want this to affect the parent shell, you can run it in a subshell.</li>
</ul>

<p>Overall, these concepts work together to facilitate process management, execution, and command
interpretation in a Linux environment.</p>
      <h5 id="does-exec-change-the-current-working-directory-or-affect-environment-variables-in-the-parent">
        
        
          Does exec() change the current working directory or affect environment variables in the parent? <a href="#does-exec-change-the-current-working-directory-or-affect-environment-variables-in-the-parent">#</a>
        
        
      </h5>
    
<p><a id="markdown-does-exec-change-the-current-working-directory-or-affect-environment-variables-in-the-parent%3F" name="does-exec-change-the-current-working-directory-or-affect-environment-variables-in-the-parent%3F"></a></p>

<p>Running <code class="language-plaintext highlighter-rouge">exec()</code> on the child process does not change the current working directory of the parent
process.</p>

<p>When a process calls the <code class="language-plaintext highlighter-rouge">exec()</code> system call in Linux, it replaces its current image with a new
program. The <code class="language-plaintext highlighter-rouge">exec()</code> system call loads a new program into the processâ€™s memory space and starts its
execution.</p>

<p>Hereâ€™s how <code class="language-plaintext highlighter-rouge">exec()</code> affects the current working directory and environment variables:</p>

<ol>
  <li>
    <p><strong>Current Working Directory</strong>: When a child process calls <code class="language-plaintext highlighter-rouge">exec()</code>, the current working directory
of the parent process remains unchanged. The new program loaded by <code class="language-plaintext highlighter-rouge">exec()</code> will start executing
with the same working directory as the original process. Therefore, the current working directory
of the parent process is not affected by the childâ€™s <code class="language-plaintext highlighter-rouge">exec()</code> call.</p>
  </li>
  <li>
    <p><strong>Environment Variables</strong>: The environment of the new program loaded by <code class="language-plaintext highlighter-rouge">exec()</code> can be set
explicitly by the program itself or inherited from the parent process. If the new program does
not explicitly modify the environment variables, it will inherit the environment variables from
the parent process. Any changes made to environment variables in the child process after the
<code class="language-plaintext highlighter-rouge">exec()</code> call will not affect the environment variables of the parent process.</p>
  </li>
</ol>
      <h5 id="then-how-does-the-cd-command-change-the-current-working-directory-of-a-shell">
        
        
          Then how does the cd command change the current working directory of a shell? <a href="#then-how-does-the-cd-command-change-the-current-working-directory-of-a-shell">#</a>
        
        
      </h5>
    
<p><a id="markdown-then-how-does-the-cd-command-change-the-current-working-directory-of-a-shell%3F" name="then-how-does-the-cd-command-change-the-current-working-directory-of-a-shell%3F"></a></p>

<p>The <code class="language-plaintext highlighter-rouge">cd</code> command is a special command called a â€œshell built-inâ€ command; there are about ~70 of
these. <code class="language-plaintext highlighter-rouge">echo</code>, <code class="language-plaintext highlighter-rouge">source</code> are examples of these â€œbuilt-inâ€ commands. These commands are built into the
shell itself. It is not a â€œexternal executable programâ€ command like <code class="language-plaintext highlighter-rouge">ls</code>. So a shell does not have
to <code class="language-plaintext highlighter-rouge">fork</code> and <code class="language-plaintext highlighter-rouge">exec</code> to run these commands. The shell runs them inside of itâ€™s own â€œparentâ€ process,
which affects â€œselfâ€.</p>

<p>If you think about it, <code class="language-plaintext highlighter-rouge">cd</code> has to be a built-in command since we know that child processes canâ€™t
affect the environment of the parent process, and the current working directory is part of a
processâ€™ environment.</p>

<blockquote>
  <p>Watch this <a href="https://youtu.be/GA2mIUQq48s?si=Sfbpre-MeNXlND_b&amp;t=820">video</a> to get an understanding
of <code class="language-plaintext highlighter-rouge">built-in</code> commands vs <code class="language-plaintext highlighter-rouge">external executable program</code> commands.</p>
</blockquote>

<p>Letâ€™s say you want to <code class="language-plaintext highlighter-rouge">cd</code> into a folder but you donâ€™t want this to affect the parent shell. How do
you do this? This is where subshells come into play. If youâ€™re using <code class="language-plaintext highlighter-rouge">fish</code>, then a subshell is like
running <code class="language-plaintext highlighter-rouge">fish -c</code> with whatever is typed in between <code class="language-plaintext highlighter-rouge">""</code>.</p>
      <h5 id="how-do-subshells-work-in-the-case-where-i-dont-the-shells-environment-to-be-affected-at-all">
        
        
          How do subshells work, in the case where I donâ€™t the shellâ€™s environment to be affected at all? <a href="#how-do-subshells-work-in-the-case-where-i-dont-the-shells-environment-to-be-affected-at-all">#</a>
        
        
      </h5>
    
<p><a id="markdown-how-do-subshells-work%2C-in-the-case-where-i-don%E2%80%99t-the-shell%E2%80%99s-environment-to-be-affected-at-all%3F" name="how-do-subshells-work%2C-in-the-case-where-i-don%E2%80%99t-the-shell%E2%80%99s-environment-to-be-affected-at-all%3F"></a></p>

<p>In a Linux shell, a subshell is a separate instance of the shell that is spawned to execute a
command or a group of commands. When a user types a command to execute, the shell creates a subshell
to run that command.</p>

<p>Subshells are useful for various purposes, such as:</p>

<ol>
  <li>Running commands in a separate environment without affecting the parent shell.</li>
  <li>Running commands in parallel to improve performance.</li>
  <li>Running commands that need to be isolated from the parent shell.</li>
</ol>

<p>Subshells are typically created using parentheses <code class="language-plaintext highlighter-rouge">()</code> in <code class="language-plaintext highlighter-rouge">fish</code> or the <code class="language-plaintext highlighter-rouge">$(...)</code> syntax in <code class="language-plaintext highlighter-rouge">bash</code>.
For example, when you run a command within parentheses like this:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>command1<span class="p">;</span> command2<span class="o">)</span>
</code></pre></div></div>

<p>The commands <code class="language-plaintext highlighter-rouge">command1</code> and <code class="language-plaintext highlighter-rouge">command2</code> will be executed in a subshell. Once the commands finish
executing, the subshell exits, and the parent shell continues its operation. If you run the <code class="language-plaintext highlighter-rouge">cd ..</code>
command in a subshell, it wonâ€™t change the current working directory of the shell!</p>

<p>Subshells are used to manage sessions and jobs and pipelines. Things like foreground and background
jobs are managed using subshells. And signals are sent to processes using subshells in a pipeline.</p>

<blockquote>
  <p>Watch this <a href="https://youtu.be/N8kT2XRNEAg?si=iiv6i3mO6Lxi8qb1&amp;t=60">video</a> to get an understanding
of subshells, signals, jobs, pipelines, etc.</p>
</blockquote>
      <h5 id="deep-dive-of-all-this-information-in-video-format">
        
        
          Deep dive of all this information in video format <a href="#deep-dive-of-all-this-information-in-video-format">#</a>
        
        
      </h5>
    
<p><a id="markdown-deep-dive-of-all-this-information-in-video-format" name="deep-dive-of-all-this-information-in-video-format"></a></p>

<p>Hereâ€™s a
<a href="https://www.youtube.com/playlist?list=PLFAC320731F539902">[video playlist] Unix terminals and shells</a>
that goes into details about shells, subshells, forking, exec (command), and wait works.</p>
      <h4 id="processes-sessions-jobs-ptys-signals-using-c">
        
        
          Processes, sessions, jobs, PTYs, signals using C <a href="#processes-sessions-jobs-ptys-signals-using-c">#</a>
        
        
      </h4>
    
<p><a id="markdown-processes%2C-sessions%2C-jobs%2C-ptys%2C-signals-using-c" name="processes%2C-sessions%2C-jobs%2C-ptys%2C-signals-using-c"></a></p>

<p>Here are some videos on forking processes, zombies, and signals in C:</p>

<ul>
  <li><a href="https://www.youtube.com/watch?v=ss1-REMJ9GA">[video] Create new process in C w/ <code class="language-plaintext highlighter-rouge">fork()</code></a></li>
  <li><a href="https://www.youtube.com/watch?v=83M5-NPDeWs">[video] Send signals to processes in C w/ <code class="language-plaintext highlighter-rouge">kill()</code>, <code class="language-plaintext highlighter-rouge">signal()</code>, <code class="language-plaintext highlighter-rouge">sigaction()</code></a></li>
  <li><a href="https://www.youtube.com/watch?v=xJ8KenZw2ag">[video] Zombie processes in C</a></li>
  <li><a href="https://www.youtube.com/watch?v=_5SCtRNnf9U">[video] Stop process becoming zombie in C</a></li>
</ul>
      <h2 id="what-is-devtty">
        
        
          What is /dev/tty? <a href="#what-is-devtty">#</a>
        
        
      </h2>
    
<p><a id="markdown-what-is-%2Fdev%2Ftty%3F" name="what-is-%2Fdev%2Ftty%3F"></a></p>

<p><code class="language-plaintext highlighter-rouge">/dev/tty</code> is a special file in Unix-like operating systems that represents the controlling terminal
of the current process. It is a synonym for the controlling terminal device file associated with the
process.</p>

<p>The controlling terminal is the terminal that is currently active and connected to the process,
allowing input and output interactions. It provides a way for processes to interact with the user
through the terminal interface.</p>

<p>The <code class="language-plaintext highlighter-rouge">/dev/tty</code> file can be used to read from or write to the controlling terminal.</p>

<p>In each process, <code class="language-plaintext highlighter-rouge">/dev/tty</code> is a synonym for the controlling terminal associated with the process
group of that process, if any. It is useful for programs or shell procedures that wish to be sure of
writing messages to or reading data from the terminal no matter how output has been redirected. It
can also be used for applications that demand the name of a file for output, when typed output is
desired and it is tiresome to find out what terminal is currently in use.</p>

<ol>
  <li>Definition from
<a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap10.html">IEEE Open Group Base Specifications for POSIX</a>.</li>
  <li>You can see it used in <code class="language-plaintext highlighter-rouge">crossterm</code> crate
<a href="https://github.com/crossterm-rs/crossterm/blob/master/src/terminal/sys/file_descriptor.rs#L143">here</a>.</li>
  <li>Hereâ€™s more info about this on
<a href="https://www.baeldung.com/linux/monitor-keyboard-drivers#devtty">baeldung.com</a>.</li>
</ol>
      <h3 id="how-is-crossterm-built-on-top-of-stdio-pty-etc">
        
        
          How is crossterm built on top of stdio, PTY, etc? <a href="#how-is-crossterm-built-on-top-of-stdio-pty-etc">#</a>
        
        
      </h3>
    
<p><a id="markdown-how-is-crossterm-built-on-top-of-stdio%2C-pty%2C-etc%3F" name="how-is-crossterm-built-on-top-of-stdio%2C-pty%2C-etc%3F"></a></p>

<p>The <a href="https://github.com/crossterm-rs/crossterm"><code class="language-plaintext highlighter-rouge">crossterm</code></a> crate is built on top of Tokioâ€™s
<a href="https://docs.rs/mio/latest/mio/guide/index.html"><code class="language-plaintext highlighter-rouge">mio</code></a> crate, which uses Linux
<a href="https://man7.org/linux/man-pages/man7/epoll.7.html"><code class="language-plaintext highlighter-rouge">epoll</code></a> to work with file descriptors in an
async manner.</p>

<ul>
  <li>Hereâ€™s <a href="https://docs.rs/mio/latest/mio/struct.Poll.html"><code class="language-plaintext highlighter-rouge">mio</code>â€™s <code class="language-plaintext highlighter-rouge">Poll</code></a> using <code class="language-plaintext highlighter-rouge">epoll</code> under the
hood.</li>
  <li>Hereâ€™s an <a href="https://docs.rs/mio/latest/mio/guide/index.html">example</a> of <code class="language-plaintext highlighter-rouge">mio</code> using Linux <code class="language-plaintext highlighter-rouge">epoll</code>
in order to read from a file descriptor in an async manner.</li>
</ul>

<blockquote>
  <p>Linux <code class="language-plaintext highlighter-rouge">epoll</code> is able to work with <code class="language-plaintext highlighter-rouge">stdio</code> file descriptors (ie, <code class="language-plaintext highlighter-rouge">stdin</code>, <code class="language-plaintext highlighter-rouge">stdout</code>, <code class="language-plaintext highlighter-rouge">stderr</code>), as
well as other file descriptors (network and file system). However, for throughput and performance
(by reducing context switching and being efficient with buffers that hold IO data), Linux
<a href="https://en.wikipedia.org/wiki/Io_uring"><code class="language-plaintext highlighter-rouge">io_uring</code></a> might be more suitable.</p>
</blockquote>

<p>Here are some links to learn more about how <code class="language-plaintext highlighter-rouge">crossterm</code> works with <code class="language-plaintext highlighter-rouge">PTY</code>s and <code class="language-plaintext highlighter-rouge">stdio</code>:</p>

<ul>
  <li><a href="https://github.com/crossterm-rs/crossterm/blob/master/src/terminal/sys/file_descriptor.rs#L143">Get a file descriptor for the TTY <code class="language-plaintext highlighter-rouge">tty_fd()</code></a>.
It uses <a href="https://docs.rs/rustix/latest/rustix/stdio/fn.stdin.html"><code class="language-plaintext highlighter-rouge">rustix::stdio::stdin()</code></a> by
default and falls back on <code class="language-plaintext highlighter-rouge">/dev/tty/</code>.</li>
  <li>This <code class="language-plaintext highlighter-rouge">fd</code> is used by
<a href="https://github.com/crossterm-rs/crossterm/blob/master/src/event/source/unix/mio.rs#L35"><code class="language-plaintext highlighter-rouge">UnixInternalEventSource</code></a>
which creates a <code class="language-plaintext highlighter-rouge">mio::Poll</code> object for the <code class="language-plaintext highlighter-rouge">fd</code>. This <code class="language-plaintext highlighter-rouge">Poll</code> object uses <code class="language-plaintext highlighter-rouge">epoll</code> under the hood.
The
<a href="https://github.com/crossterm-rs/crossterm/blob/master/src/event/source/unix/mio.rs#L72"><code class="language-plaintext highlighter-rouge">EventSource</code> trait impl for <code class="language-plaintext highlighter-rouge">UnixInternalEventSource</code></a>
is used to actually
<a href="https://github.com/crossterm-rs/crossterm/blob/master/src/terminal/sys/file_descriptor.rs#L75">read</a>
the bytes from the <code class="language-plaintext highlighter-rouge">fd</code> (using
<a href="https://docs.rs/rustix/latest/rustix/io/fn.read.html"><code class="language-plaintext highlighter-rouge">rustix::io::read()</code></a>).</li>
  <li>Once a <code class="language-plaintext highlighter-rouge">Poll</code> has been created, a
<a href="https://docs.rs/mio/latest/mio/struct.Registry.html"><code class="language-plaintext highlighter-rouge">mio::Poll::registry()</code></a> must be used to
tell the OS to listen for events on the <code class="language-plaintext highlighter-rouge">fd</code>. A
<a href="https://docs.rs/mio/latest/mio/guide/index.html#2-registering-event-source">source and interest must be registered</a>
with the registry next:
    <ul>
      <li>The <code class="language-plaintext highlighter-rouge">fd</code> <a href="https://docs.rs/mio/latest/mio/unix/struct.SourceFd.html">implements</a> the
<a href="https://docs.rs/mio/latest/mio/event/trait.Source.html"><code class="language-plaintext highlighter-rouge">Source</code> trait</a> which
<a href="https://docs.rs/mio/latest/mio/event/trait.Source.html#implementing-eventsource">allows</a> <code class="language-plaintext highlighter-rouge">mio</code>
to listen for events on the <code class="language-plaintext highlighter-rouge">fd</code>.</li>
      <li>An <code class="language-plaintext highlighter-rouge">Interest::READABLE</code> must also be â€œregisteredâ€ with the <code class="language-plaintext highlighter-rouge">registry</code>. For eg, for <code class="language-plaintext highlighter-rouge">stdin</code>, this
tells the OS to listen for input from the keyboard, and wake the <code class="language-plaintext highlighter-rouge">Poll</code> when this is ready.</li>
      <li>A <code class="language-plaintext highlighter-rouge">Token</code> is supplied that can be used when polling for events to see if theyâ€™re available on
the source. This happens in the
<a href="https://docs.rs/mio/latest/mio/guide/index.html#3-creating-the-event-loop"><code class="language-plaintext highlighter-rouge">loop</code></a> that calls
<code class="language-plaintext highlighter-rouge">poll()</code> to fill an <code class="language-plaintext highlighter-rouge">Event</code> buffer. If an event in this buffer matches the <code class="language-plaintext highlighter-rouge">Token</code>, then the
<code class="language-plaintext highlighter-rouge">fd</code> is ready for reading.</li>
    </ul>
  </li>
</ul>

<p>You can see all the steps (outlined above) in action, in the following crates:</p>

<ul>
  <li><a href="https://docs.rs/mio/latest/mio/guide/index.html">Guide in <code class="language-plaintext highlighter-rouge">mio</code> docs</a>.</li>
  <li><a href="https://github.com/crossterm-rs/crossterm/blob/master/src/event/source/unix/mio.rs"><code class="language-plaintext highlighter-rouge">mio.rs</code> file in <code class="language-plaintext highlighter-rouge">crossterm</code></a>.</li>
  <li>This <a href="https://github.com/nazmulidris/crossterm/pull/1">PR</a> in my fork of <code class="language-plaintext highlighter-rouge">crossterm</code> has
<code class="language-plaintext highlighter-rouge">println!</code> traces so you can see how <code class="language-plaintext highlighter-rouge">mio</code> is used under the hood by <code class="language-plaintext highlighter-rouge">crossterm</code> to read from
<code class="language-plaintext highlighter-rouge">stdin</code>.</li>
</ul>
      <h3 id="how-is-termion-built-on-top-of-stdio-pty-etc">
        
        
          How is termion built on top of stdio, PTY, etc? <a href="#how-is-termion-built-on-top-of-stdio-pty-etc">#</a>
        
        
      </h3>
    
<p><a id="markdown-how-is-termion-built-on-top-of-stdio%2C-pty%2C-etc%3F" name="how-is-termion-built-on-top-of-stdio%2C-pty%2C-etc%3F"></a></p>

<p>Hereâ€™s a <a href="https://github.com/nazmulidris/termion/pull/1">PR</a> to explore the examples in <code class="language-plaintext highlighter-rouge">termion</code>
crate. This is a beautifully simple and elegant crate that is much simpler than <code class="language-plaintext highlighter-rouge">crossterm</code>. It
simply uses the standard library and a few other crates to get bytes from <code class="language-plaintext highlighter-rouge">stdin</code> and write bytes to
<code class="language-plaintext highlighter-rouge">stdout</code>. It does not use <code class="language-plaintext highlighter-rouge">mio</code>, and neither does it support <code class="language-plaintext highlighter-rouge">async</code> <code class="language-plaintext highlighter-rouge">EventStream</code>. There is an
â€œasync modeâ€, which simply spawns another thread and uses a channel to send events to the main
thread.</p>
      <h2 id="list-of-signals">
        
        
          List of signals <a href="#list-of-signals">#</a>
        
        
      </h2>
    
<p><a id="markdown-list-of-signals" name="list-of-signals"></a></p>

<p>Here are the reference docs on signals:
<!-- cspell:disable-next-line --></p>
<ul>
  <li><a href="https://en.wikipedia.org/wiki/POSIX">POSIX</a>, pronounced â€œpaw-siksâ€, <a href="https://en.wikipedia.org/wiki/Signal_(IPC)">signals</a></li>
  <li><a href="https://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html">gnu libc termination signals</a></li>
  <li><a href="https://www.gnu.org/software/libc/manual/html_node/Job-Control-Signals.html">gnu libc job control signals</a></li>
</ul>

<p>Here is a list of all the signals that a process might get:
<a href="https://www.linusakesson.net/programming/tty/#signal-madness:~:text=using%20a%20signal.-,Signal%20madness,-Now%20let%27s%20take">signals</a>.</p>

<p>You can also get a list of them using <code class="language-plaintext highlighter-rouge">kill -l</code>. It is different for <code class="language-plaintext highlighter-rouge">fish</code> and <code class="language-plaintext highlighter-rouge">bash</code>. However,
under the hood, the Linux kernel uses the same signal numbers for all shells.</p>

<!-- cSpell:disable -->

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>fish <span class="nt">-c</span> <span class="s2">"kill -l"</span>
HUP INT QUIT ILL TRAP ABRT BUS FPE KILL USR1 SEGV USR2 PIPE ALRM TERM STKFLT
CHLD CONT STOP TSTP TTIN TTOU URG XCPU XFSZ VTALRM PROF WINCH POLL PWR SYS

<span class="sb">```</span>shell
<span class="nv">$ </span>bash <span class="nt">-c</span> <span class="s2">"kill -l"</span>
 1<span class="o">)</span> SIGHUP	 2<span class="o">)</span> SIGINT	 3<span class="o">)</span> SIGQUIT	 4<span class="o">)</span> SIGILL	 5<span class="o">)</span> SIGTRAP
 6<span class="o">)</span> SIGABRT	 7<span class="o">)</span> SIGBUS	 8<span class="o">)</span> SIGFPE	 9<span class="o">)</span> SIGKILL	10<span class="o">)</span> SIGUSR1
11<span class="o">)</span> SIGSEGV	12<span class="o">)</span> SIGUSR2	13<span class="o">)</span> SIGPIPE	14<span class="o">)</span> SIGALRM	15<span class="o">)</span> SIGTERM
16<span class="o">)</span> SIGSTKFLT	17<span class="o">)</span> SIGCHLD	18<span class="o">)</span> SIGCONT	19<span class="o">)</span> SIGSTOP	20<span class="o">)</span> SIGTSTP
21<span class="o">)</span> SIGTTIN	22<span class="o">)</span> SIGTTOU	23<span class="o">)</span> SIGURG	24<span class="o">)</span> SIGXCPU	25<span class="o">)</span> SIGXFSZ
26<span class="o">)</span> SIGVTALRM	27<span class="o">)</span> SIGPROF	28<span class="o">)</span> SIGWINCH	29<span class="o">)</span> SIGIO	30<span class="o">)</span> SIGPWR
31<span class="o">)</span> SIGSYS	34<span class="o">)</span> SIGRTMIN	35<span class="o">)</span> SIGRTMIN+1	36<span class="o">)</span> SIGRTMIN+2	37<span class="o">)</span> SIGRTMIN+3
38<span class="o">)</span> SIGRTMIN+4	39<span class="o">)</span> SIGRTMIN+5	40<span class="o">)</span> SIGRTMIN+6	41<span class="o">)</span> SIGRTMIN+7	42<span class="o">)</span> SIGRTMIN+8
43<span class="o">)</span> SIGRTMIN+9	44<span class="o">)</span> SIGRTMIN+10	45<span class="o">)</span> SIGRTMIN+11	46<span class="o">)</span> SIGRTMIN+12	47<span class="o">)</span> SIGRTMIN+13
48<span class="o">)</span> SIGRTMIN+14	49<span class="o">)</span> SIGRTMIN+15	50<span class="o">)</span> SIGRTMAX-14	51<span class="o">)</span> SIGRTMAX-13	52<span class="o">)</span> SIGRTMAX-12
53<span class="o">)</span> SIGRTMAX-11	54<span class="o">)</span> SIGRTMAX-10	55<span class="o">)</span> SIGRTMAX-9	56<span class="o">)</span> SIGRTMAX-8	57<span class="o">)</span> SIGRTMAX-7
58<span class="o">)</span> SIGRTMAX-6	59<span class="o">)</span> SIGRTMAX-5	60<span class="o">)</span> SIGRTMAX-4	61<span class="o">)</span> SIGRTMAX-3	62<span class="o">)</span> SIGRTMAX-2
63<span class="o">)</span> SIGRTMAX-1	64<span class="o">)</span> SIGRTMAX
</code></pre></div></div>

<!-- cSpell:enable -->

<p>Here are some important ones.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SIGHUP</code></li>
</ol>

<ul>
  <li>Default action: Terminate</li>
  <li>Possible actions: Terminate, Ignore, Function call</li>
  <li><code class="language-plaintext highlighter-rouge">SIGHUP</code> is sent by the UART driver to the entire session when a hangup condition has been
detected. Normally, this will kill all the processes. Some programs, such as <code class="language-plaintext highlighter-rouge">nohup</code> and <code class="language-plaintext highlighter-rouge">screen</code>,
detach from their session (and TTY), so that their child processes wonâ€™t notice a hangup.</li>
</ul>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SIGINT</code></li>
</ol>

<ul>
  <li>Default action: Terminate</li>
  <li>Possible actions: Terminate, Ignore, Function call</li>
  <li><code class="language-plaintext highlighter-rouge">SIGINT</code> is sent by the TTY driver to the current foreground job when the interactive attention
character (typically <kbd>^C</kbd>, which has ASCII code 3) appears in the input stream, unless
this behavior has been turned off. Anybody with access permissions to the TTY device can change
the interactive attention character and toggle this feature; additionally, the session manager
keeps track of the TTY configuration of each job, and updates the TTY whenever there is a job
switch.</li>
</ul>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SIGQUIT</code></li>
</ol>

<ul>
  <li>Default action: Core dump</li>
  <li>Possible actions: Core dump, Ignore, Function call</li>
  <li><code class="language-plaintext highlighter-rouge">SIGQUIT</code> works just like SIGINT, but the quit character is typically <kbd>^\\</kbd> and the
default action is different.</li>
</ul>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SIGPIPE</code></li>
</ol>

<ul>
  <li>Default action: Terminate</li>
  <li>Possible actions: Terminate, Ignore, Function call</li>
  <li>The kernel sends <code class="language-plaintext highlighter-rouge">SIGPIPE</code> to any process which tries to write to a pipe with no readers. This is
useful, because otherwise jobs like <code class="language-plaintext highlighter-rouge">yes | head</code> would never terminate.</li>
</ul>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SIGCHLD</code></li>
</ol>

<ul>
  <li>Default action: Ignore</li>
  <li>Possible actions: Ignore, Function call</li>
  <li>When a process dies or changes state (stop/continue), the kernel sends a <code class="language-plaintext highlighter-rouge">SIGCHLD</code> to its parent
process. The <code class="language-plaintext highlighter-rouge">SIGCHLD</code> signal carries additional information, namely the process id, the user id,
the exit status (or termination signal) of the terminated process and some execution time
statistics. The session leader (shell) keeps track of its jobs using this signal.</li>
</ul>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SIGSTOP</code></li>
</ol>

<ul>
  <li>Default action: Suspend</li>
  <li>Possible actions: Suspend</li>
  <li>This signal will unconditionally suspend the recipient, i.e. its signal action canâ€™t be
reconfigured. Please note, however, that <code class="language-plaintext highlighter-rouge">SIGSTOP</code> isnâ€™t sent by the kernel during job control.
Instead, <kbd>^Z</kbd> typically triggers a <code class="language-plaintext highlighter-rouge">SIGTSTP</code>, which can be intercepted by the
application. The application may then e.g. move the cursor to the bottom of the screen or
otherwise put the terminal in a known state, and subsequently put itself to sleep using <code class="language-plaintext highlighter-rouge">SIGSTOP</code>.</li>
</ul>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SIGCONT</code></li>
</ol>

<ul>
  <li>Default action: Wake up</li>
  <li>Possible actions: Wake up, Wake up + Function call</li>
  <li><code class="language-plaintext highlighter-rouge">SIGCONT</code> will un-suspend a stopped process. It is sent explicitly by the shell when the user
invokes the <code class="language-plaintext highlighter-rouge">fg</code> command. Since <code class="language-plaintext highlighter-rouge">SIGSTOP</code> canâ€™t be intercepted by an application, an unexpected
<code class="language-plaintext highlighter-rouge">SIGCONT</code> signal might indicate that the process was suspended some time ago, and then
un-suspended.</li>
</ul>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SIGTSTP</code></li>
</ol>

<ul>
  <li>Default action: Suspend</li>
  <li>Possible actions: Suspend, Ignore, Function call</li>
  <li><code class="language-plaintext highlighter-rouge">SIGTSTP</code> works just like <code class="language-plaintext highlighter-rouge">SIGINT</code> and <code class="language-plaintext highlighter-rouge">SIGQUIT</code>, but the magic character is typically
<kbd>^Z</kbd> and the default action is to suspend the process.</li>
</ul>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SIGTTIN</code></li>
</ol>

<ul>
  <li>Default action: Suspend</li>
  <li>Possible actions: Suspend, Ignore, Function call</li>
  <li>If a process within a background job tries to read from a TTY device, the TTY sends a <code class="language-plaintext highlighter-rouge">SIGTTIN</code>
signal to the entire job. This will normally suspend the job.</li>
</ul>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SIGTTOU</code></li>
</ol>

<ul>
  <li>Default action: Suspend</li>
  <li>Possible actions: Suspend, Ignore, Function call</li>
  <li>If a process within a background job tries to write to a TTY device, the TTY sends a <code class="language-plaintext highlighter-rouge">SIGTTOU</code>
signal to the entire job. This will normally suspend the job. It is possible to turn off this
feature on a per-TTY basis.</li>
</ul>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SIGWINCH</code></li>
</ol>

<ul>
  <li>Default action: Ignore</li>
  <li>Possible actions: Ignore, Function call</li>
  <li>As mentioned, the TTY device keeps track of the terminal size, but this information needs to be
updated manually. Whenever that happens, the TTY device sends <code class="language-plaintext highlighter-rouge">SIGWINCH</code> to the foreground job.
Well-behaving interactive applications, such as editors, react upon this, fetch the new terminal
size from the TTY device and redraw themselves accordingly.</li>
</ul>
      <h2 id="-sending-and-receiving-signals-in-rust">
        
        
          ğŸ¦€ Sending and receiving signals in Rust <a href="#-sending-and-receiving-signals-in-rust">#</a>
        
        
      </h2>
    
<p><a id="markdown-%F0%9F%A6%80-sending-and-receiving-signals-in-rust" name="%F0%9F%A6%80-sending-and-receiving-signals-in-rust"></a></p>

<table>
  <thead>
    <tr>
      <th>crate</th>
      <th>recv</th>
      <th>send</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="https://docs.rs/tokio/latest/tokio/signal">https://docs.rs/tokio/latest/tokio/signal</a></td>
      <td>ğŸŸ¢</td>
      <td>ğŸ”´</td>
    </tr>
    <tr>
      <td><a href="https://crates.io/crates/ctrlc">https://crates.io/crates/ctrlc</a></td>
      <td>ğŸŸ¢</td>
      <td>ğŸ”´</td>
    </tr>
    <tr>
      <td><a href="https://crates.io/crates/signal-hook">https://crates.io/crates/signal-hook</a></td>
      <td>ğŸŸ¢</td>
      <td>ğŸŸ¢ *</td>
    </tr>
    <tr>
      <td><a href="https://docs.rs/nix/latest/nix/">https://docs.rs/nix/latest/nix/</a></td>
      <td>ğŸŸ¢</td>
      <td>ğŸŸ¢</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>*: Via
<a href="https://docs.rs/signal-hook/latest/signal_hook/low_level/fn.raise.html"><code class="language-plaintext highlighter-rouge">signal_hook::low_level::raise</code></a>.</p>
</blockquote>
      <h4 id="example-using-tokio-to-receive-signals">
        
        
          Example using tokio to receive signals <a href="#example-using-tokio-to-receive-signals">#</a>
        
        
      </h4>
    
<p><a id="markdown-example-using-tokio-to-receive-signals" name="example-using-tokio-to-receive-signals"></a></p>

<p>Please watch the live coding <a href="#related-youtube-videos-for-this-article">videos</a> to get a
deep dive into what each line of code does.</p>

<p>Please clone this <a href="https://github.com/nazmulidris/rust-scratch">repo</a> to your computer to
play w/ the examples in the <a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/README.md"><code class="language-plaintext highlighter-rouge">rust-scratch/tty</code>
crate</a> shown below.</p>

<p><a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/src/receive_signal.rs"><code class="language-plaintext highlighter-rouge">receive_signal.rs</code></a>.
<code class="language-plaintext highlighter-rouge">tokio</code> has limited handling of signals. You can only receive certain signals, not send
them.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">miette</span><span class="p">::</span><span class="n">IntoDiagnostic</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">r3bl_rs_utils_core</span><span class="p">::</span><span class="n">ok</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">signal</span><span class="p">::</span><span class="n">unix</span><span class="p">;</span>

<span class="nd">#[tokio::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">signal</span> <span class="o">=</span> <span class="nn">unix</span><span class="p">::</span><span class="nn">SignalKind</span><span class="p">::</span><span class="nf">window_change</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">stream</span> <span class="o">=</span> <span class="nn">unix</span><span class="p">::</span><span class="nf">signal</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">tick_interval</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">interval</span><span class="p">(</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">500</span><span class="p">));</span>

    <span class="k">let</span> <span class="n">sleep_future</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nd">pin!</span><span class="p">(</span><span class="n">sleep_future</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">pid</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nf">id</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"PID: {}"</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>

    <span class="c1">// Copy child PID to clipboard.</span>
    <span class="c1">// Use `ClipboardProvider` trait.</span>
    <span class="k">use</span> <span class="nn">cli_clipboard</span><span class="p">::</span><span class="n">ClipboardProvider</span> <span class="k">as</span> <span class="n">_</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">ctx</span> <span class="o">=</span> <span class="nn">cli_clipboard</span><span class="p">::</span><span class="nn">ClipboardContext</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span>
        <span class="nf">.map_err</span><span class="p">(|</span><span class="n">e</span><span class="p">|</span> <span class="nn">miette</span><span class="p">::</span><span class="nd">miette!</span><span class="p">(</span>
            <span class="s">"couldn't create clip context: {}"</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
    <span class="n">ctx</span><span class="nf">.set_contents</span><span class="p">(</span><span class="n">pid</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.to_owned</span><span class="p">())</span>
        <span class="nf">.map_err</span><span class="p">(|</span><span class="n">e</span><span class="p">|</span> <span class="nn">miette</span><span class="p">::</span><span class="nd">miette!</span><span class="p">(</span>
            <span class="s">"couldn't set clip contents: {}"</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
    <span class="n">ctx</span><span class="nf">.get_contents</span><span class="p">()</span>
        <span class="nf">.map_err</span><span class="p">(|</span><span class="n">e</span><span class="p">|</span> <span class="nn">miette</span><span class="p">::</span><span class="nd">miette!</span><span class="p">(</span>
            <span class="s">"couldn't get clip contents: {}"</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span> <span class="p">{</span>
            <span class="c1">// Respond to window change signal.</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">stream</span><span class="nf">.recv</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">SIGWINCH received"</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// Sleep for 5 seconds &amp; terminate the program if running.</span>
            <span class="n">_</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">sleep_future</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Slept for 5 seconds"</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// Run at each tick interval.</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">tick_interval</span><span class="nf">.tick</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"Tick"</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="c1">// Respond to ctrl-c signal.</span>
            <span class="n">_</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">signal</span><span class="p">::</span><span class="nf">ctrl_c</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Ctrl-C received"</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">ok!</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here are some notes on the code:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">tokio::signal::ctrl_c</code> is a utility function that creates a future that completes
when <code class="language-plaintext highlighter-rouge">ctrl-c</code> is pressed. There is <strong>NO</strong> need to write a signal stream for this like
so:
    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">signal</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">signal</span><span class="p">::</span><span class="nn">unix</span><span class="p">::</span><span class="nn">SignalKind</span><span class="p">::</span><span class="nf">interrupt</span><span class="p">();</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">stream_sigterm</span> <span class="o">=</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nn">signal</span><span class="p">::</span><span class="nn">unix</span><span class="p">::</span><span class="nf">signal</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
<span class="k">loop</span> <span class="p">{</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span> <span class="p">{</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">stream_sigterm</span><span class="nf">.recv</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">SIGINT received"</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li><code class="language-plaintext highlighter-rouge">tokio::signal::unix::signal</code> is a lower level function that you can use to create a
stream of signals of a given type (e.g., <code class="language-plaintext highlighter-rouge">tokio::signal::unix::SignalKind</code>). Some
examples are:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">tokio::signal::unix::SignalKind::hangup</code></li>
      <li><code class="language-plaintext highlighter-rouge">tokio::signal::unix::SignalKind::interrupt</code></li>
      <li><code class="language-plaintext highlighter-rouge">tokio::signal::unix::SignalKind::pipe</code></li>
    </ul>
  </li>
  <li>There are limitations to what <code class="language-plaintext highlighter-rouge">tokio::signal::unix::SignalKind::from_raw</code> can do:
    <ul>
      <li>For example you canâ€™t just pass in <code class="language-plaintext highlighter-rouge">SIGSTOP</code> ie <code class="language-plaintext highlighter-rouge">19</code> and expect it to work. This
is an <a href="https://docs.rs/signal-hook/latest/signal_hook/#limitations">OS
limitation</a> for both
<code class="language-plaintext highlighter-rouge">SIGKILL</code> or <code class="language-plaintext highlighter-rouge">SIGSTOP</code>.</li>
      <li>Hereâ€™s a list of POSIX signals that are
<a href="https://docs.rs/signal-hook/latest/signal_hook/low_level/fn.register.html#panics"><code class="language-plaintext highlighter-rouge">FORBIDDEN</code></a>
from the <code class="language-plaintext highlighter-rouge">signal_hook</code> crate.</li>
      <li>You can just pass the signal number directly to
<code class="language-plaintext highlighter-rouge">tokio::signal::unix::SignalKind::from_raw</code>.</li>
      <li>However, if youâ€™re doing more sophisticated things you might need to use the
<a href="https://github.com/vorner/signal-hook">signal-hook</a> crate (which not only
supports sending and receiving signals, but also has async adapters for <code class="language-plaintext highlighter-rouge">tokio</code>).</li>
      <li>Here are relevant docs:
        <ul>
          <li><a href="https://docs.rs/tokio/latest/tokio/signal/index.html">tokio::signal</a></li>
          <li><a href="https://docs.rs/tokio/latest/tokio/signal/unix/fn.signal.html">tokio::signal::unix::signal</a></li>
          <li><a href="https://docs.rs/tokio/latest/tokio/signal/unix/struct.SignalKind.html">tokio::signal::unix::SignalKind</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>See it in action:</p>

<ul>
  <li>Run the binary: <code class="language-plaintext highlighter-rouge">cargo run --bin send_receive_signal</code></li>
  <li>Send signals to the process:
    <ul>
      <li>To get a list of all the signals that you can send to a process, you can run the
following command: <code class="language-plaintext highlighter-rouge">kill -L</code></li>
      <li>To send Ctrl+C, aka, <code class="language-plaintext highlighter-rouge">SIGINT</code>, aka <code class="language-plaintext highlighter-rouge">tokio::signal::unix::SignalKind::interrupt</code>, to
the process, you can run the following command: <code class="language-plaintext highlighter-rouge">kill -2 &lt;PID&gt;</code> or <code class="language-plaintext highlighter-rouge">kill -INT &lt;PID&gt;</code></li>
      <li>To send <code class="language-plaintext highlighter-rouge">SIGWINCH</code>, aka <code class="language-plaintext highlighter-rouge">tokio::signal::unix::SignalKind::window_change</code> to the
process, simply change the terminal window size of the terminal that the process is
running in. Or run the following command: <code class="language-plaintext highlighter-rouge">kill -28 &lt;PID&gt;</code> or <code class="language-plaintext highlighter-rouge">kill -WINCH &lt;PID&gt;</code></li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>Other crate choices to receive signals:</p>

  <ul>
    <li><a href="https://crates.io/crates/ctrlc"><code class="language-plaintext highlighter-rouge">ctrlc</code></a></li>
    <li><a href="https://crates.io/crates/signal-hook"><code class="language-plaintext highlighter-rouge">signal-hook</code></a></li>
  </ul>
</blockquote>
      <h4 id="example-using-signal-hook-and-signal-hook-tokio">
        
        
          Example using signal-hook and signal-hook-tokio <a href="#example-using-signal-hook-and-signal-hook-tokio">#</a>
        
        
      </h4>
    
<p><a id="markdown-example-using-signal-hook-and-signal-hook-tokio" name="example-using-signal-hook-and-signal-hook-tokio"></a></p>

<p>Please watch the live coding <a href="#related-youtube-videos-for-this-article">videos</a> to get a
deep dive into what each line of code does.</p>

<p>Please clone this <a href="https://github.com/nazmulidris/rust-scratch">repo</a> to your computer to
play w/ the examples in the <a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/README.md"><code class="language-plaintext highlighter-rouge">rust-scratch/tty</code>
crate</a> shown below.</p>

<p><a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/src/send_and_receive_signal.rs"><code class="language-plaintext highlighter-rouge">send_and_receive_signal.rs</code></a>
allows you to both send and receive signals in a process.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">futures</span><span class="p">::</span><span class="nn">stream</span><span class="p">::</span><span class="n">StreamExt</span> <span class="k">as</span> <span class="n">_</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">miette</span><span class="p">::</span><span class="n">IntoDiagnostic</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">r3bl_rs_utils_core</span><span class="p">::</span><span class="n">ok</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">signal_hook</span><span class="p">::</span><span class="nn">consts</span><span class="p">::</span><span class="nn">signal</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">signal_hook_tokio</span><span class="p">::</span><span class="n">Signals</span><span class="p">;</span>

<span class="nd">#[tokio::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">pid</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nf">id</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"PID: {}"</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>

    <span class="c1">// Broadcast channel to shutdown the process.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">sender_shutdown_channel</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">broadcast</span><span class="p">::</span><span class="nn">channel</span><span class="p">::</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="c1">// Register signal handlers.</span>
    <span class="k">let</span> <span class="n">signals_stream</span><span class="p">:</span> <span class="n">Signals</span> <span class="o">=</span>
        <span class="nn">Signals</span><span class="p">::</span><span class="nf">new</span><span class="p">([</span><span class="n">SIGHUP</span><span class="p">,</span> <span class="n">SIGTERM</span><span class="p">,</span> <span class="n">SIGINT</span><span class="p">,</span> <span class="n">SIGQUIT</span><span class="p">])</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">signals_handle</span> <span class="o">=</span> <span class="n">signals_stream</span><span class="nf">.handle</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">join_handle_monitor_signals_task</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span>
        <span class="nf">handle_signals_task</span><span class="p">(</span>
            <span class="n">signals_stream</span><span class="p">,</span>
            <span class="n">sender_shutdown_channel</span><span class="nf">.clone</span><span class="p">(),</span>
        <span class="p">));</span>

    <span class="nf">run_main_event_loop</span><span class="p">(</span><span class="n">sender_shutdown_channel</span><span class="nf">.clone</span><span class="p">())</span><span class="k">.await</span><span class="p">;</span>

    <span class="c1">// Cleanup tasks after shutdown.</span>
    <span class="n">signals_handle</span><span class="nf">.close</span><span class="p">();</span>
    <span class="n">join_handle_monitor_signals_task</span><span class="k">.await</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="nd">ok!</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">async</span> <span class="k">fn</span> <span class="nf">run_main_event_loop</span><span class="p">(</span>
    <span class="n">sender_shutdown_channel</span><span class="p">:</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">broadcast</span><span class="p">::</span><span class="n">Sender</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span>
    <span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">receiver_shutdown_channel</span> <span class="o">=</span>
        <span class="n">sender_shutdown_channel</span><span class="nf">.subscribe</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">tick_interval</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">interval</span><span class="p">(</span>
        <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">500</span><span class="p">));</span>

    <span class="c1">// Wait for 1 sec &amp; then send SIGTERM signal.</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span>
            <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="k">.await</span><span class="p">;</span>
        <span class="n">_</span> <span class="o">=</span> <span class="nn">signal_hook</span><span class="p">::</span><span class="nn">low_level</span><span class="p">::</span><span class="nf">raise</span><span class="p">(</span><span class="n">SIGTERM</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"ğŸ§¨ Sent SIGTERM signal"</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="k">loop</span> <span class="p">{</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nd">select!</span> <span class="p">{</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">tick_interval</span><span class="nf">.tick</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"Tick"</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">receiver_shutdown_channel</span><span class="nf">.recv</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"Received shutdown signal"</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">async</span> <span class="k">fn</span> <span class="nf">handle_signals_task</span><span class="p">(</span>
    <span class="k">mut</span> <span class="n">signals_stream</span><span class="p">:</span> <span class="n">Signals</span><span class="p">,</span>
    <span class="n">sender_shutdown_channel</span><span class="p">:</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">broadcast</span><span class="p">::</span><span class="n">Sender</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span> <span class="o">=</span> <span class="n">signals_stream</span><span class="nf">.next</span><span class="p">()</span><span class="k">.await</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">signal</span> <span class="p">{</span>
            <span class="n">SIGHUP</span> <span class="p">|</span> <span class="n">SIGTERM</span> <span class="p">|</span> <span class="n">SIGINT</span> <span class="p">|</span> <span class="n">SIGQUIT</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"ğŸ“¥ Received signal: {:?}"</span><span class="p">,</span> <span class="n">signal</span><span class="p">);</span>
                <span class="n">_</span> <span class="o">=</span> <span class="n">sender_shutdown_channel</span><span class="nf">.send</span><span class="p">(());</span>
            <span class="p">}</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">unreachable!</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notes on the code:</p>

<ul>
  <li>Example of how to send and receive Linux (POSIX, Unix) signals in a process
It uses the following crates to make this happen:
    <ul>
      <li><a href="https://docs.rs/signal-hook/">signal-hook</a></li>
      <li><a href="https://docs.rs/signal-hook-tokio/latest/signal_hook_tokio/">signal-hook-tokio</a></li>
    </ul>
  </li>
  <li>Signal handler registration limitations (to receive signals)
POSIX allows signal handlers to be overridden in a process. This is a powerful feature
that can be used to implement a wide variety of functionality.
    <ul>
      <li>However, there are
<a href="https://docs.rs/signal-hook/latest/signal_hook/#limitations">limitations</a> around
overriding signal handlers in a process. For example, POSIX compliant operating
systems will not allow you to override the
<a href="https://docs.rs/signal-hook/latest/signal_hook/consts/signal/constant.SIGKILL.html"><code class="language-plaintext highlighter-rouge">SIGKILL</code></a>
or
<a href="https://docs.rs/signal-hook/latest/signal_hook/consts/signal/constant.SIGSTOP.html"><code class="language-plaintext highlighter-rouge">SIGSTOP</code></a>
signals.</li>
      <li>Hereâ€™s a full list of
<a href="https://docs.rs/signal-hook/latest/signal_hook/low_level/fn.register.html#panics"><code class="language-plaintext highlighter-rouge">FORBIDDEN</code></a>
signals that will <code class="language-plaintext highlighter-rouge">panic</code> the <code class="language-plaintext highlighter-rouge">register</code> function, if used.</li>
    </ul>
  </li>
  <li>The following dependencies need to be added to the <code class="language-plaintext highlighter-rouge">Cargo.toml</code> file for this to work:
    <div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="py">signal-hook</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.3.17"</span> <span class="p">}</span>
<span class="py">signal-hook-tokio</span> <span class="o">=</span> <span class="p">{</span>
    <span class="py">version</span> <span class="p">=</span> <span class="s">"0.3.1"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"futures-v0_3"</span><span class="p">]</span> <span class="p">}</span>
<span class="py">futures</span> <span class="p">=</span> <span class="s">"0.3.30"</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>See it in action:</p>

<ul>
  <li>Run the binary: <code class="language-plaintext highlighter-rouge">cargo run --bin send_and_receive_signal</code></li>
</ul>
      <h2 id="-process-spawning-in-rust">
        
        
          ğŸ¦€ Process spawning in Rust <a href="#-process-spawning-in-rust">#</a>
        
        
      </h2>
    
<p><a id="markdown-%F0%9F%A6%80-process-spawning-in-rust" name="%F0%9F%A6%80-process-spawning-in-rust"></a></p>

<p>Please watch the live coding <a href="#related-youtube-videos-for-this-article">videos</a> to get a
deep dive into what each line of code does.</p>

<p>Please clone this <a href="https://github.com/nazmulidris/rust-scratch">repo</a> to your computer to
play w/ the examples in the <a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/README.md"><code class="language-plaintext highlighter-rouge">rust-scratch/tty</code>
crate</a> shown below.</p>
      <h4 id="example-using-procspawn-to-spawn-processes">
        
        
          Example using procspawn to spawn processes <a href="#example-using-procspawn-to-spawn-processes">#</a>
        
        
      </h4>
    
<p><a id="markdown-example-using-procspawn-to-spawn-processes" name="example-using-procspawn-to-spawn-processes"></a></p>

<p><a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/src/procspawn.rs"><code class="language-plaintext highlighter-rouge">procspawn.rs</code></a>
can be used to spawn child processes in Rust with great flexibility and control.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">miette</span><span class="p">::</span><span class="n">IntoDiagnostic</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">r3bl_rs_utils_core</span><span class="p">::</span><span class="n">ok</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// A spawned process will execute every line of code up to here.</span>
    <span class="nn">procspawn</span><span class="p">::</span><span class="nf">init</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">pid_parent</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nf">id</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">args</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i64</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">sum</span><span class="p">,</span> <span class="n">pid_child</span><span class="p">,</span> <span class="n">pid_child_from_clip</span><span class="p">)</span> <span class="o">=</span> <span class="nf">configure_builder</span><span class="p">()</span>
        <span class="nf">.spawn</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">run_in_child_process</span><span class="p">)</span>
        <span class="nf">.join</span><span class="p">()</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"Parent PID: {}"</span><span class="p">,</span> <span class="n">pid_parent</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"Child PID: {}, sum: {}, pid from clip: {}"</span><span class="p">,</span>
        <span class="n">pid_child</span><span class="p">,</span> <span class="n">sum</span><span class="p">,</span> <span class="n">pid_child_from_clip</span>
    <span class="p">);</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">sum</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">pid_child</span><span class="p">,</span> <span class="n">pid_child_from_clip</span><span class="p">);</span>

    <span class="nd">ok!</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// Create a new builder with stderr &amp; stdout that's null.</span>
<span class="k">fn</span> <span class="nf">configure_builder</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">procspawn</span><span class="p">::</span><span class="n">Builder</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">it</span> <span class="o">=</span> <span class="nn">procspawn</span><span class="p">::</span><span class="nn">Builder</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="n">it</span><span class="nf">.stderr</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">null</span><span class="p">());</span> <span class="c1">// Suppress stderr.</span>
    <span class="n">it</span><span class="nf">.stdout</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">null</span><span class="p">());</span> <span class="c1">// Suppress stdout.</span>
    <span class="n">it</span>
<span class="p">}</span>

<span class="c1">// This function will be executed in a child process.</span>
<span class="k">fn</span> <span class="nf">run_in_child_process</span><span class="p">(</span>
    <span class="cm">/* serde */</span> <span class="n">param</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i64</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">result</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span>
    <span class="cm">/* serde - Ok variant */</span>
    <span class="p">(</span>
        <span class="cm">/* sum */</span> <span class="nb">i64</span><span class="p">,</span>
        <span class="cm">/* pid */</span> <span class="nb">String</span><span class="p">,</span>
        <span class="cm">/* pid from clip */</span> <span class="nb">String</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="cm">/* serde - Err variant */</span>
    <span class="n">ClipboardError</span><span class="p">,</span>
<span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">pid_child</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nf">id</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">param</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.sum</span><span class="p">();</span>

    <span class="c1">// Copy child pid to the clipboard.</span>
    <span class="c1">// Import `ClipboardProvider` trait.</span>
    <span class="k">use</span> <span class="nn">cli_clipboard</span><span class="p">::</span><span class="n">ClipboardProvider</span> <span class="k">as</span> <span class="n">_</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">ctx</span> <span class="o">=</span> <span class="nn">cli_clipboard</span><span class="p">::</span><span class="nn">ClipboardContext</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span>
        <span class="nf">.map_err</span><span class="p">(|</span><span class="n">_</span><span class="p">|</span> <span class="nn">ClipboardError</span><span class="p">::</span><span class="n">ContextUnavailable</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="n">ctx</span><span class="nf">.set_contents</span><span class="p">(</span><span class="n">pid_child</span><span class="nf">.to_string</span><span class="p">()</span><span class="nf">.to_owned</span><span class="p">())</span>
        <span class="nf">.map_err</span><span class="p">(|</span><span class="n">_</span><span class="p">|</span> <span class="nn">ClipboardError</span><span class="p">::</span><span class="n">SetContents</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">pid_child_from_clip</span> <span class="o">=</span> <span class="n">ctx</span>
        <span class="nf">.get_contents</span><span class="p">()</span>
        <span class="nf">.map_err</span><span class="p">(|</span><span class="n">_</span><span class="p">|</span> <span class="nn">ClipboardError</span><span class="p">::</span><span class="n">GetContents</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">((</span><span class="n">sum</span><span class="p">,</span> <span class="n">pid_child</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="n">pid_child_from_clip</span><span class="p">))</span>
<span class="p">}</span>

<span class="nd">#[derive(</span>
    <span class="nd">Debug,</span> <span class="nd">serde::Deserialize,</span> <span class="nd">serde::Serialize,</span> <span class="nd">thiserror::Error</span>
<span class="nd">)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">ClipboardError</span> <span class="p">{</span>
    <span class="nd">#[error(</span><span class="s">"clipboard context unavailable"</span><span class="nd">)]</span>
    <span class="n">ContextUnavailable</span><span class="p">,</span>

    <span class="nd">#[error(</span><span class="s">"could not get clipboard contents"</span><span class="nd">)]</span>
    <span class="n">GetContents</span><span class="p">,</span>

    <span class="nd">#[error(</span><span class="s">"could not set clipboard contents"</span><span class="nd">)]</span>
    <span class="n">SetContents</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notes on the code:</p>

<ul>
  <li>The <a href="https://docs.rs/procspawn/latest/procspawn/"><code class="language-plaintext highlighter-rouge">procspawn</code></a> crate provides the
ability to spawn processes with a function similar to <code class="language-plaintext highlighter-rouge">thread::spawn</code>.</li>
  <li>Unlike <code class="language-plaintext highlighter-rouge">thread::spawn</code> data cannot be passed by the use of closures.</li>
  <li>Instead if must be explicitly passed as serializable object (specifically it must be
<code class="language-plaintext highlighter-rouge">serde</code> serializable). Internally, the data is serialized using
<a href="https://docs.rs/procspawn/latest/procspawn/#bincode-limitations"><code class="language-plaintext highlighter-rouge">bincode</code></a>.</li>
  <li>The return value from the spawned closure also must be serializable and can then be
retrieved from the returned join handle.</li>
  <li>If the spawned function causes a panic it will also be serialized across the process
boundaries.</li>
  <li>Great <a href="https://github.com/mitsuhiko/procspawn/tree/master/examples">examples</a> from the
official docs.</li>
</ul>

<p>See it in action:</p>

<ul>
  <li>Run the binary: <code class="language-plaintext highlighter-rouge">cargo run --bin procspawn</code></li>
</ul>
      <h4 id="example-using-procspawn-to-spawn-processes-w-ipc-channel">
        
        
          Example using procspawn to spawn processes w/ ipc-channel <a href="#example-using-procspawn-to-spawn-processes-w-ipc-channel">#</a>
        
        
      </h4>
    
<p><a id="markdown-example-using-procspawn-to-spawn-processes-w%2F-ipc-channel" name="example-using-procspawn-to-spawn-processes-w%2F-ipc-channel"></a></p>

<p><a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/src/procspawn_ipc_channel.rs"><code class="language-plaintext highlighter-rouge">procspawn_ipc_channel.rs</code></a>
can be used to manage complex IPC communication between parent and child processes.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">miette</span><span class="p">::</span><span class="n">IntoDiagnostic</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">r3bl_rs_utils_core</span><span class="p">::</span><span class="n">ok</span><span class="p">;</span>

<span class="k">type</span> <span class="n">Message</span> <span class="o">=</span> <span class="nb">String</span><span class="p">;</span>

<span class="k">const</span> <span class="n">MSG_1</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="p">;</span>
<span class="k">const</span> <span class="n">MSG_2</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">"World"</span><span class="p">;</span>
<span class="k">const</span> <span class="n">END_MSG</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">"END"</span><span class="p">;</span>
<span class="k">const</span> <span class="n">SHUTDOWN_MSG</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">"SHUTDOWN"</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// A spawned process will execute every line of code up to here.</span>
    <span class="nn">procspawn</span><span class="p">::</span><span class="nf">init</span><span class="p">();</span>

    <span class="c1">// Create a channel to send messages across processes.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">receiver</span><span class="p">)</span> <span class="o">=</span> <span class="nn">ipc_channel</span><span class="p">::</span><span class="nn">ipc</span><span class="p">::</span><span class="nn">channel</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span><span class="p">()</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Spawn a child process that will receive messages from the</span>
    <span class="c1">// parent process.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">join_handle</span> <span class="o">=</span> <span class="nf">configure_builder</span><span class="p">()</span><span class="nf">.spawn</span><span class="p">(</span>
        <span class="cm">/* arg from parent process */</span> <span class="n">receiver</span><span class="p">,</span>
        <span class="cm">/* param to child process; closure runs in child process */</span>
        <span class="n">run_in_child_process</span><span class="p">,</span>
    <span class="p">);</span>

    <span class="nf">parent_send_messages</span><span class="p">(</span><span class="n">sender</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Read the stdout, until EOF, of the child process into `buf`.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">buf</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="c1">// Import `Read` trait for `read_to_string`.</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="n">Read</span> <span class="k">as</span> <span class="n">_</span><span class="p">;</span>
    <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">stdout</span><span class="p">)</span> <span class="o">=</span> <span class="n">join_handle</span><span class="nf">.stdout</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nn">miette</span><span class="p">::</span><span class="nd">bail!</span><span class="p">(</span><span class="s">"Failed to get stdout"</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="k">let</span> <span class="n">bytes_read</span> <span class="o">=</span> <span class="n">stdout</span><span class="nf">.read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">buf</span><span class="p">)</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"Output from child process: {:?}, bytes_read: {}"</span><span class="p">,</span>
        <span class="n">buf</span><span class="p">,</span> <span class="n">bytes_read</span>
    <span class="p">);</span>

    <span class="c1">// Make assertions.</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{MSG_1}</span><span class="se">\n</span><span class="s">{MSG_2}</span><span class="se">\n</span><span class="s">{END_MSG}</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>

    <span class="c1">// Wait for the child process to exit and get its return value.</span>
    <span class="n">join_handle</span><span class="nf">.join</span><span class="p">()</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="nd">ok!</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">parent_send_messages</span><span class="p">(</span>
    <span class="n">sender</span><span class="p">:</span> <span class="nn">ipc_channel</span><span class="p">::</span><span class="nn">ipc</span><span class="p">::</span><span class="n">IpcSender</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="n">sender</span><span class="nf">.send</span><span class="p">(</span><span class="n">MSG_1</span><span class="nf">.to_string</span><span class="p">())</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="n">sender</span><span class="nf">.send</span><span class="p">(</span><span class="n">MSG_2</span><span class="nf">.to_string</span><span class="p">())</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="n">sender</span><span class="nf">.send</span><span class="p">(</span><span class="n">SHUTDOWN_MSG</span><span class="nf">.to_string</span><span class="p">())</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="nd">ok!</span><span class="p">()</span>
<span class="p">}</span>

<span class="cd">/// This function will be executed in the child process. It gets</span>
<span class="cd">/// [Message]s from the parent process and processes them.</span>
<span class="k">fn</span> <span class="nf">run_in_child_process</span><span class="p">(</span>
    <span class="n">receiver</span><span class="p">:</span> <span class="nn">ipc_channel</span><span class="p">::</span><span class="nn">ipc</span><span class="p">::</span><span class="n">IpcReceiver</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="k">let</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">=</span> <span class="n">receiver</span><span class="nf">.recv</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">msg</span> <span class="o">==</span> <span class="n">SHUTDOWN_MSG</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// Print the message to stdout.</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Print `END_MSG` to stdout.</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{END_MSG}"</span><span class="p">);</span>
<span class="p">}</span>

<span class="cd">/// Create a new builder with stdout piped and stderr muted.</span>
<span class="k">fn</span> <span class="nf">configure_builder</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">procspawn</span><span class="p">::</span><span class="n">Builder</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">it</span> <span class="o">=</span> <span class="nn">procspawn</span><span class="p">::</span><span class="nn">Builder</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="n">it</span><span class="nf">.stdout</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">piped</span><span class="p">());</span>
    <span class="n">it</span><span class="nf">.stderr</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">null</span><span class="p">());</span>
    <span class="n">it</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notes on the code:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ipc_channel::ipc::channel</code> is used to send messages across processes via IPC. These
messages must be serializable.</li>
  <li>The parent process sends messages to the child process. This happens over an
ipc_channel sender.</li>
  <li>The child process receives messages from the parent process. This happens over an
ipc_channel receiver. The receiver is passed across process boundaries from
the parent to the child process.</li>
</ul>

<p>See it in action:</p>

<ul>
  <li>Run the binary: <code class="language-plaintext highlighter-rouge">cargo run --bin procspawn_ipc_channel</code></li>
</ul>

<blockquote>
  <p>Hereâ€™s the <a href="https://crates.io/crates/procspawn"><code class="language-plaintext highlighter-rouge">procspawn</code> crate</a> that we can use for this.</p>
</blockquote>
      <h2 id="-run-tokioprocesscommand-in-async-rust">
        
        
          ğŸ¦€ Run tokio:process::Command in async Rust <a href="#-run-tokioprocesscommand-in-async-rust">#</a>
        
        
      </h2>
    
<p><a id="markdown-%F0%9F%A6%80-run-tokio%3Aprocess%3A%3Acommand-in-async-rust" name="%F0%9F%A6%80-run-tokio%3Aprocess%3A%3Acommand-in-async-rust"></a></p>

<p>Please watch the live coding <a href="#related-youtube-videos-for-this-article">videos</a> to get a
deep dive into what each line of code does.</p>

<blockquote>
  <p>In <code class="language-plaintext highlighter-rouge">tokio</code> a good place to start is
<a href="https://docs.rs/tokio/latest/tokio/process/index.html"><code class="language-plaintext highlighter-rouge">tokio::process</code></a> which mimics
the <code class="language-plaintext highlighter-rouge">std::process</code> module.</p>
</blockquote>
      <h3 id="example-running-echo-process-programmatically">
        
        
          Example running echo process programmatically <a href="#example-running-echo-process-programmatically">#</a>
        
        
      </h3>
    
<p><a id="markdown-example-running-echo-process-programmatically" name="example-running-echo-process-programmatically"></a></p>

<p>Please clone this <a href="https://github.com/nazmulidris/rust-scratch">repo</a> to your computer to
play w/ the examples in the <a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/README.md"><code class="language-plaintext highlighter-rouge">rust-scratch/tty</code>
crate</a> shown below.</p>

<p><a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/src/async_command_exec_1.rs"><code class="language-plaintext highlighter-rouge">async_command_exec_1.rs</code></a></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">crossterm</span><span class="p">::</span><span class="nn">style</span><span class="p">::</span><span class="n">Stylize</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">miette</span><span class="p">::</span><span class="n">IntoDiagnostic</span><span class="p">;</span>

<span class="nd">#[tokio::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">run_command_no_capture</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">run_command_capture_output</span><span class="p">()</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="c1">// - Run `echo hello world` and wait for it to complete.</span>
<span class="c1">// - Do not capture the output or provide the input.</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">run_command_no_capture</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"run_command_no_capture"</span><span class="nf">.blue</span><span class="p">());</span>

    <span class="c1">// Without redirection, the output of the command will be</span>
    <span class="c1">// inherited from the process that starts the command. So</span>
    <span class="c1">// if this is running in a terminal, the output will be</span>
    <span class="c1">// printed to the terminal.</span>
    <span class="c1">//</span>
    <span class="c1">// Even though `spawn()` is called this child / command</span>
    <span class="c1">// doesn't make any progress until you call `wait().await`.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">command</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">command</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Command</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"echo"</span><span class="p">);</span>
        <span class="n">command</span>
            <span class="nf">.args</span><span class="p">([</span><span class="s">"hello"</span><span class="p">,</span> <span class="s">"world"</span><span class="p">])</span>
            <span class="nf">.stdin</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">inherit</span><span class="p">())</span>
            <span class="nf">.stdout</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">inherit</span><span class="p">())</span>
            <span class="nf">.stderr</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">inherit</span><span class="p">());</span>
        <span class="n">command</span>
    <span class="p">};</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">child</span> <span class="o">=</span> <span class="n">command</span><span class="nf">.spawn</span><span class="p">()</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Wait for the command to complete. Don't capture the output,</span>
    <span class="c1">// it will go to `stdout` of the process running this program.</span>
    <span class="k">let</span> <span class="n">exit_status</span> <span class="o">=</span> <span class="n">child</span><span class="nf">.wait</span><span class="p">()</span><span class="k">.await</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="n">exit_status</span><span class="nf">.success</span><span class="p">());</span>

    <span class="c1">// Print the exit status of the command.</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"exit status: {}"</span><span class="p">,</span> <span class="n">exit_status</span><span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="c1">// - Run `echo hello world` and wait for it to complete.</span>
<span class="c1">// - Capture its output and do not provide the input.</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">run_command_capture_output</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"run_command_capture_output"</span><span class="nf">.blue</span><span class="p">());</span>

    <span class="c1">// Redirect the output of the command to a pipe `Stdio::piped()`.</span>
    <span class="c1">//</span>
    <span class="c1">// Even though `spawn()` is called this child / command doesn't</span>
    <span class="c1">// make any progress until you call `wait_with_out().await`.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">command</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">command</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Command</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"echo"</span><span class="p">);</span>
        <span class="n">command</span>
            <span class="nf">.args</span><span class="p">([</span><span class="s">"hello"</span><span class="p">,</span> <span class="s">"world"</span><span class="p">])</span>
            <span class="nf">.stdin</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">null</span><span class="p">())</span>
            <span class="nf">.stdout</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">piped</span><span class="p">())</span>
            <span class="nf">.stderr</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">null</span><span class="p">());</span>
        <span class="n">command</span>
    <span class="p">};</span>
    <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="n">command</span><span class="nf">.spawn</span><span class="p">()</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Wait for the command to complete and capture the output.</span>
    <span class="c1">// - Calling `wait()` consumes the child process, so we can't</span>
    <span class="c1">//   call `output.stdout` on it after this.</span>
    <span class="c1">// - That's why we use `wait_with_output()`, which actually</span>
    <span class="c1">//   returns a different type than `wait()`; this is also a</span>
    <span class="c1">//   great use of type state pattern.</span>
    <span class="k">let</span> <span class="n">output</span> <span class="o">=</span> <span class="n">child</span><span class="nf">.wait_with_output</span><span class="p">()</span><span class="k">.await</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="nd">assert!</span><span class="p">(</span><span class="n">output</span><span class="py">.status</span><span class="nf">.success</span><span class="p">());</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">output</span><span class="py">.stdout</span><span class="p">,</span> <span class="s">b"hello world</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notes on the code:</p>

<ul>
  <li>Run a command and wait for it to complete. Do not capture the output or provide the
input.</li>
  <li>Run a command and capture the output. Do not provide the input. This example uses the
<a href="https://docs.rs/tokio/latest/tokio/process/index.html"><code class="language-plaintext highlighter-rouge">tokio::process::Command</code></a>
struct to execute a command asynchronously.</li>
  <li>In both cases, the pattern is the same:
    <ol>
      <li>Create a <code class="language-plaintext highlighter-rouge">tokio::process::Command</code>.</li>
      <li>Configure it with the desired <code class="language-plaintext highlighter-rouge">stdin</code> and <code class="language-plaintext highlighter-rouge">stdout</code>.</li>
      <li>Spawn the command. Note this doesnâ€™t make any progress until you call
<code class="language-plaintext highlighter-rouge">wait().await</code> or <code class="language-plaintext highlighter-rouge">wait_with_output().await</code>.</li>
      <li>Wait for the command to complete with or without output capture.</li>
    </ol>
  </li>
</ul>

<p>See it in action:</p>

<ul>
  <li>Run the binary: <code class="language-plaintext highlighter-rouge">cargo run --bin async_command_exec_1</code></li>
  <li>You should see something like the following in your terminal
    <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hello world
exit status: exit status: 0
</code></pre></div>    </div>
  </li>
</ul>
      <h3 id="example-piping-input-to-cat-process-programmatically">
        
        
          Example piping input to cat process programmatically <a href="#example-piping-input-to-cat-process-programmatically">#</a>
        
        
      </h3>
    
<p><a id="markdown-example-piping-input-to-cat-process-programmatically" name="example-piping-input-to-cat-process-programmatically"></a></p>

<p>Please clone this <a href="https://github.com/nazmulidris/rust-scratch">repo</a> to your computer to
play w/ the examples in the <a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/README.md"><code class="language-plaintext highlighter-rouge">rust-scratch/tty</code>
crate</a> shown below.</p>

<p><a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/src/async_command_exec_2.rs"><code class="language-plaintext highlighter-rouge">async_command_exec_2.rs</code></a></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">crossterm</span><span class="p">::</span><span class="nn">style</span><span class="p">::</span><span class="n">Stylize</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">miette</span><span class="p">::</span><span class="n">IntoDiagnostic</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">r3bl_rs_utils_core</span><span class="p">::</span><span class="n">ok</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="n">Stdio</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">io</span><span class="p">::{</span><span class="n">AsyncBufReadExt</span><span class="p">,</span> <span class="n">BufReader</span><span class="p">};</span>

<span class="cd">/// This variant requires the use of `tokio::spawn` to wait for the</span>
<span class="cd">/// child process to complete.</span>
<span class="nd">#[tokio::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Create a child process that runs `cat`.</span>
    <span class="c1">// - Send the output of `cat` back to this child process.</span>
    <span class="c1">// - This child / command does not make progress until</span>
    <span class="c1">//   `wait().await` is called.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">child</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Command</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"cat"</span><span class="p">)</span>
        <span class="nf">.stdin</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">inherit</span><span class="p">())</span>
        <span class="nf">.stdout</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">piped</span><span class="p">())</span>
        <span class="nf">.stderr</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">inherit</span><span class="p">())</span>
        <span class="nf">.spawn</span><span class="p">()</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Get the stdout of the child process. Do this before the next</span>
    <span class="c1">// step, because the `child` struct is moved into the closure.</span>
    <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">child_stdout</span><span class="p">)</span> <span class="o">=</span> <span class="n">child</span><span class="py">.stdout</span><span class="nf">.take</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nn">miette</span><span class="p">::</span><span class="nd">bail!</span><span class="p">(</span><span class="s">"Failed to capture stdout of child process"</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="c1">// ğŸš€ Ensure the child process is spawned in the runtime, so it</span>
    <span class="c1">// can make progress on its own while we await any output.</span>
    <span class="k">let</span> <span class="n">child_task_join_handle</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">result_exit_status</span> <span class="o">=</span> <span class="n">child</span><span class="nf">.wait</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>
        <span class="nd">println!</span><span class="p">(</span>
            <span class="s">"{}"</span><span class="p">,</span>
            <span class="nd">format!</span><span class="p">(</span>
                <span class="s">"Child process exited with status: {:?}"</span><span class="p">,</span>
                <span class="n">result_exit_status</span>
            <span class="p">)</span><span class="nf">.green</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">});</span>

    <span class="c1">// As long as there is a line to be read from the child process,</span>
    <span class="c1">// print it to the terminal.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">child_stdout_reader</span> <span class="o">=</span> <span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">child_stdout</span><span class="p">)</span><span class="nf">.lines</span><span class="p">();</span>
    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">=</span> <span class="n">child_stdout_reader</span>
        <span class="nf">.next_line</span><span class="p">()</span><span class="k">.await</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span>
    <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"â¯ {}"</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span><span class="nf">.cyan</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="c1">// Wait for the child task to complete.</span>
    <span class="n">child_task_join_handle</span><span class="k">.await</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="nd">ok!</span><span class="p">()</span>
<span class="p">}</span>

<span class="cd">/// This is a simpler version of the `main` function above. It</span>
<span class="cd">/// doesn't need to use `tokio::spawn` to wait for the child</span>
<span class="cd">/// process to complete.</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main_simpler</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Create a child process that runs `cat`.</span>
    <span class="c1">// - Send the output of `cat` back to this child process.</span>
    <span class="c1">// - This child / command does not make progress until</span>
    <span class="c1">//   `wait().await` is called.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">child</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Command</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"cat"</span><span class="p">)</span>
        <span class="nf">.stdin</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">inherit</span><span class="p">())</span>
        <span class="nf">.stdout</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">piped</span><span class="p">())</span>
        <span class="nf">.stderr</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">inherit</span><span class="p">())</span>
        <span class="nf">.spawn</span><span class="p">()</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Get the stdout of the child process. Do this before the next</span>
    <span class="c1">// step, because the `child` struct is moved into the closure.</span>
    <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">child_stdout</span><span class="p">)</span> <span class="o">=</span> <span class="n">child</span><span class="py">.stdout</span><span class="nf">.take</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nn">miette</span><span class="p">::</span><span class="nd">bail!</span><span class="p">(</span><span class="s">"Failed to capture stdout of child process"</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="c1">// As long as there is a line to be read from the child process,</span>
    <span class="c1">// print it to the terminal.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">child_stdout_reader</span> <span class="o">=</span> <span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">child_stdout</span><span class="p">)</span><span class="nf">.lines</span><span class="p">();</span>
    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">=</span> <span class="n">child_stdout_reader</span>
        <span class="nf">.next_line</span><span class="p">()</span><span class="k">.await</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span>
    <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"â¯ {}"</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span><span class="nf">.cyan</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="c1">// Simultaneously waits for the child to exit and collect all</span>
    <span class="c1">// remaining output on the stdout/stderr handles, returning an</span>
    <span class="c1">// Output instance.</span>
    <span class="k">let</span> <span class="n">output</span> <span class="o">=</span> <span class="n">child</span><span class="nf">.wait_with_output</span><span class="p">()</span><span class="k">.await</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"{}"</span><span class="p">,</span>
        <span class="nd">format!</span><span class="p">(</span>
            <span class="s">"Child process exited with status: {:?}"</span><span class="p">,</span> <span class="n">output</span><span class="py">.status</span>
        <span class="p">)</span><span class="nf">.green</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="nd">ok!</span><span class="p">()</span>
<span class="p">}</span>

<span class="cd">/// The nature of this function is different to the 2 above. For eg,</span>
<span class="cd">/// if you run this function in a terminal, you have to terminate</span>
<span class="cd">/// the input using `Ctrl-D` (EOF) if you want to see anything</span>
<span class="cd">/// displayed in the terminal output. In the two variants above,</span>
<span class="cd">/// output is captured in an "interactive" manner, as it comes</span>
<span class="cd">///  in from the stdin.</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main_non_interactive</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Create a child process that runs `cat`.</span>
    <span class="c1">// - Send the output of `cat` back to this child process.</span>
    <span class="c1">// - This child / command does not make progress until</span>
    <span class="c1">// `wait().await` is called.</span>
    <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Command</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"cat"</span><span class="p">)</span>
        <span class="nf">.stdin</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">inherit</span><span class="p">())</span>
        <span class="nf">.stdout</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">piped</span><span class="p">())</span>
        <span class="nf">.stderr</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">inherit</span><span class="p">())</span>
        <span class="nf">.spawn</span><span class="p">()</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Simultaneously waits for the child to exit and collect</span>
    <span class="c1">// all remaining output on the stdout/stderr handles,</span>
    <span class="c1">// returning an Output instance.</span>
    <span class="k">let</span> <span class="n">output</span> <span class="o">=</span> <span class="n">child</span><span class="nf">.wait_with_output</span><span class="p">()</span><span class="k">.await</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"{}"</span><span class="p">,</span>
        <span class="nd">format!</span><span class="p">(</span>
            <span class="s">"Child process exited with status: {:?}"</span><span class="p">,</span> <span class="n">output</span><span class="py">.status</span>
        <span class="p">)</span><span class="nf">.green</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="c1">// Print the output.stdout to terminal.</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_lossy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">output</span><span class="py">.stdout</span><span class="p">));</span>

    <span class="nd">ok!</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notes on the code:</p>

<ul>
  <li>This example uses the
<a href="https://docs.rs/tokio/latest/tokio/process/index.html"><code class="language-plaintext highlighter-rouge">tokio::process::Command</code></a>
struct to execute a command asynchronously, and then pipes the output of this command,
back to itself. Then prints the output one line at a time.</li>
  <li>To run this program, pipe some input (from the shell) into this program.
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"hello world</span><span class="se">\n</span><span class="s2">foo</span><span class="se">\n</span><span class="s2">bar</span><span class="se">\n</span><span class="s2">"</span> <span class="se">\</span>
  | cargo run <span class="nt">--bin</span> async_command_exec_2
</code></pre></div>    </div>
  </li>
  <li>This process will then run <code class="language-plaintext highlighter-rouge">cat</code> and capture the output from <code class="language-plaintext highlighter-rouge">cat</code>.</li>
  <li>It will then print the output from <code class="language-plaintext highlighter-rouge">cat</code> one line at time to the terminal.</li>
  <li>Flow diagram of the program:
    <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Terminal emulator running fish/bash shell
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚&gt; echo -e "foo\nbar\nbaz" | cargo run --bin async_command_exec_2â”‚
â””â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                     â”‚        Pipeline above runs
        â”‚                     â”‚        in parallel
   external                 external
   process                  process
   command (fork &amp; exec)    command (fork &amp; exec)
                              â”‚
                              â”œâ”€â”€â”€â”€â–º create async Command for `cat`
                              â”‚      with stdout = `Stdio::piped()`
                              â”‚      to capture the output of `cmd`
                              â”‚      back into this program
                              â”‚
                              â”œâ”€â”€â”€â”€â–º the stdin for this Command is
                              â”‚      inherited from the current
                              â”‚      process which is provided by
                              â”‚      process the terminal &amp; `pipe`
                              â”‚
                              â”œâ”€â”€â”€â”€â–º `cmd.spawn()` then sets up the
                              â”‚      `cat` process to run with the
                              â”‚      given stdin &amp; stdout and
                              â”‚      returns a `Child` struct
                              â”‚
                              â”œâ”€â”€â”€â”€â–º ğŸš€ instead of waiting
                              â”‚      "normally", we must use
                              â”‚      `tokio::spawn` to call
                              â”‚      `child.wait().await` on the
                              â”‚      child so it can make progress
                              â”‚      while we wait for its output
                              â”‚      below (in the current task)
                              â”‚
                              â””â”€â”€â”€â”€â–º in our current task, we can
                                     now access `stdout` WHILE the
                                     child task is making progress
                                     above
</code></pre></div>    </div>
  </li>
  <li>How to kill child process:
    <ul>
      <li>Note that similar to the behavior to the standard library, and unlike the futures
paradigm of dropping-implies-cancellation, a spawned process will, by default,
continue to execute even after the <code class="language-plaintext highlighter-rouge">tokio::process::Child</code> handle has been dropped.
More info in the
<a href="https://docs.rs/tokio/latest/tokio/process/index.html#caveats">docs</a>. To change this
behavior you can use <code class="language-plaintext highlighter-rouge">tokio::process::Command::kill_on_drop</code> which isnâ€™t really
recommended.</li>
      <li>Instead, to kill a child process, you can do the following:
        <ul>
          <li><code class="language-plaintext highlighter-rouge">tokio::process::Child::kill</code> - This forces the child process to exit.</li>
          <li><code class="language-plaintext highlighter-rouge">tokio::process::Child::wait</code> - This waits for the child process to cleanly exit.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>See it in action:</p>

<ul>
  <li>Run the binary: <code class="language-plaintext highlighter-rouge">echo -e "foo\nbar\nbaz" | cargo run --bin async_command_exec_2</code></li>
  <li>Or run the binary: <code class="language-plaintext highlighter-rouge">cargo run --bin async_command_exec_2</code> and then type some input
into the terminal and then press <code class="language-plaintext highlighter-rouge">Ctrl-D</code> to terminate the input.</li>
</ul>
      <h3 id="example-programmatically-providing-input-into-stdin-and-getting-output-from-stdout-of-a-process">
        
        
          Example programmatically providing input into stdin and getting output from stdout of a process <a href="#example-programmatically-providing-input-into-stdin-and-getting-output-from-stdout-of-a-process">#</a>
        
        
      </h3>
    
<p><a id="markdown-example-programmatically-providing-input-into-stdin-and-getting-output-from-stdout-of-a-process" name="example-programmatically-providing-input-into-stdin-and-getting-output-from-stdout-of-a-process"></a></p>

<p>Please clone this <a href="https://github.com/nazmulidris/rust-scratch">repo</a> to your computer to
play w/ the examples in the <a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/README.md"><code class="language-plaintext highlighter-rouge">rust-scratch/tty</code>
crate</a> shown below.</p>

<p><a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/src/async_command_exec_3.rs"><code class="language-plaintext highlighter-rouge">async_command_exec_3.rs</code></a></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">crossterm</span><span class="p">::</span><span class="nn">style</span><span class="p">::</span><span class="n">Stylize</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">miette</span><span class="p">::</span><span class="n">IntoDiagnostic</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">r3bl_rs_utils_core</span><span class="p">::</span><span class="n">ok</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="n">Stdio</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">tokio</span><span class="p">::{</span>
    <span class="nn">io</span><span class="p">::{</span><span class="n">AsyncBufReadExt</span><span class="p">,</span> <span class="n">AsyncWriteExt</span><span class="p">,</span> <span class="n">BufReader</span><span class="p">},</span>
    <span class="nn">process</span><span class="p">::{</span><span class="n">Child</span><span class="p">,</span> <span class="n">ChildStdin</span><span class="p">,</span> <span class="n">ChildStdout</span><span class="p">},</span>
    <span class="nn">task</span><span class="p">::</span><span class="n">JoinHandle</span><span class="p">,</span>
<span class="p">};</span>

<span class="nd">#[tokio::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Create a child process that runs `cat`.</span>
    <span class="c1">// 1. Send the output of `cat` back to this child process.</span>
    <span class="c1">// 2. Send the input to `cat` from this child process.</span>
    <span class="c1">// 3. This child / command does not make progress until</span>
    <span class="c1">//    `wait().await` is called.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">child</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="nn">Command</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"cat"</span><span class="p">)</span>
        <span class="nf">.stdin</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">piped</span><span class="p">())</span>
        <span class="nf">.stdout</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">piped</span><span class="p">())</span>
        <span class="nf">.stderr</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">null</span><span class="p">())</span>
        <span class="nf">.spawn</span><span class="p">()</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// These are the bytes that will be sent to the `stdin` of the</span>
    <span class="c1">// child process.</span>
    <span class="k">let</span> <span class="n">input</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">[</span><span class="s">"hello"</span><span class="p">,</span> <span class="s">"nadia!"</span><span class="p">];</span>

    <span class="c1">// Get the stdout &amp; stdin of the child process. Do this before</span>
    <span class="c1">// the next step, because the `child` struct is moved into</span>
    <span class="c1">// the closure.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="n">stdin</span><span class="p">):</span> <span class="p">(</span><span class="n">ChildStdout</span><span class="p">,</span> <span class="n">ChildStdin</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">stdout</span><span class="p">)</span> <span class="o">=</span> <span class="n">child</span><span class="py">.stdout</span><span class="nf">.take</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nn">miette</span><span class="p">::</span><span class="nd">bail!</span><span class="p">(</span><span class="s">"Child process did not have a stdout"</span><span class="p">);</span>
        <span class="p">};</span>
        <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">stdin</span><span class="p">)</span> <span class="o">=</span> <span class="n">child</span><span class="py">.stdin</span><span class="nf">.take</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nn">miette</span><span class="p">::</span><span class="nd">bail!</span><span class="p">(</span><span class="s">"Child process did not have a stdin"</span><span class="p">);</span>
        <span class="p">};</span>
        <span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="n">stdin</span><span class="p">)</span>
    <span class="p">};</span>

    <span class="c1">// Spawn tasks to:</span>
    <span class="k">let</span> <span class="n">join_handle_child_task</span> <span class="o">=</span> <span class="nf">spawn_child_process</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">join_handle_provide_input_task</span> <span class="o">=</span>
        <span class="nf">spawn_provide_input</span><span class="p">(</span><span class="n">stdin</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>

    <span class="c1">// Read the output of the child process, on the current thread.</span>
    <span class="n">_</span> <span class="o">=</span> <span class="nf">read_stdout</span><span class="p">(</span><span class="n">stdout</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>

    <span class="c1">// Wait for the child process to complete.</span>
    <span class="n">_</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nd">join!</span><span class="p">(</span>
        <span class="n">join_handle_child_task</span><span class="p">,</span> <span class="n">join_handle_provide_input_task</span><span class="p">);</span>

    <span class="c1">// Make assertions.</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">input</span><span class="nf">.join</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span> <span class="s">"hello</span><span class="se">\n</span><span class="s">nadia!"</span><span class="p">);</span>

    <span class="nd">ok!</span><span class="p">()</span>
<span class="p">}</span>

<span class="cd">/// As long as there is a line to be read from the child process,</span>
<span class="cd">/// print it to the terminal.</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">read_stdout</span><span class="p">(</span><span class="n">stdout</span><span class="p">:</span> <span class="n">ChildStdout</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">output</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">stdout_reader</span> <span class="o">=</span> <span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">stdout</span><span class="p">)</span><span class="nf">.lines</span><span class="p">();</span>
    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">=</span> <span class="n">stdout_reader</span>
        <span class="nf">.next_line</span><span class="p">()</span><span class="k">.await</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span>
    <span class="p">{</span>
        <span class="n">output</span><span class="nf">.push</span><span class="p">(</span><span class="n">line</span><span class="nf">.clone</span><span class="p">());</span>
        <span class="nd">println!</span><span class="p">(</span>
            <span class="s">"ğŸ§µ read_stdout -&gt; {}"</span><span class="p">,</span>
            <span class="nd">format!</span><span class="p">(</span><span class="s">"ğŸ«²  {}"</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span><span class="nf">.cyan</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="nd">ok!</span><span class="p">()</span>
<span class="p">}</span>

<span class="cd">/// ğŸš€ Ensure the child process is spawned in the runtime, so it</span>
<span class="cd">/// can make progress on its own while we await any output.</span>
<span class="k">fn</span> <span class="nf">spawn_child_process</span><span class="p">(</span><span class="k">mut</span> <span class="n">child</span><span class="p">:</span> <span class="n">Child</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">JoinHandle</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">result_exit_status</span> <span class="o">=</span> <span class="n">child</span><span class="nf">.wait</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>
        <span class="nd">println!</span><span class="p">(</span>
            <span class="s">"{}"</span><span class="p">,</span>
            <span class="nd">format!</span><span class="p">(</span>
                <span class="s">"ğŸš€ spawn_child_process -&gt; exit w/ status: {:?}"</span><span class="p">,</span>
                <span class="n">result_exit_status</span>
            <span class="p">)</span>
            <span class="nf">.green</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="cd">/// ğŸš€ Provide input to the child process.</span>
<span class="k">fn</span> <span class="nf">spawn_provide_input</span><span class="p">(</span>
    <span class="k">mut</span> <span class="n">stdin</span><span class="p">:</span> <span class="n">ChildStdin</span><span class="p">,</span> <span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="o">&amp;</span><span class="nb">str</span><span class="p">]</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="n">JoinHandle</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">input</span> <span class="o">=</span> <span class="n">input</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">s</span><span class="p">|</span> <span class="n">s</span><span class="nf">.to_string</span><span class="p">())</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;&gt;</span><span class="p">()</span>
        <span class="nf">.join</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="c1">// Write the input to the `stdin` of the child process.</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">stdin</span><span class="nf">.write_all</span><span class="p">(</span><span class="n">input</span><span class="nf">.as_bytes</span><span class="p">())</span><span class="k">.await</span><span class="p">;</span>

        <span class="c1">// Drop the handle to signal EOF to the child process.</span>
        <span class="nf">drop</span><span class="p">(</span><span class="n">stdin</span><span class="p">);</span>

        <span class="nd">println!</span><span class="p">(</span>
            <span class="s">"{}: {}"</span><span class="p">,</span>
            <span class="s">"ğŸš€ spawn_provide_input -&gt; EOF to child ğŸ«±  stdin"</span>
                <span class="nf">.green</span><span class="p">(),</span>
            <span class="nd">format!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">input</span><span class="p">)</span><span class="nf">.blue</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">})</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notes on the code:</p>

<ul>
  <li>This example is similar to <code class="language-plaintext highlighter-rouge">async_command_exec_2.rs</code>, except that there is no need to
pipe input from the shell into this program. It does the following:
    <ol>
      <li>Programmatically provides data to the <code class="language-plaintext highlighter-rouge">cat</code> command via <code class="language-plaintext highlighter-rouge">stdin</code>.</li>
      <li>Programmatically captures the output of <code class="language-plaintext highlighter-rouge">cat</code> via <code class="language-plaintext highlighter-rouge">stdout</code>.</li>
    </ol>
  </li>
  <li>Flow diagram of the program:
    <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Terminal emulator running fish/bash shell
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ &gt; cargo run --bin async_command_exec_3 â”‚
â””â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”œâ”€â”€â”€â”€â–º create async Command for `cat`
    â”‚      with stdout = `Stdio::piped()` to
    â”‚      capture the output of `cmd`
    â”‚      back into this program
    â”‚
    â”œâ”€â”€â”€â”€â–º set stdin = `Stdio::piped()` to provide
    â”‚      input to the `cat` command asynchronously
    â”‚
    â”œâ”€â”€â”€â”€â–º `cmd.spawn()` then sets up the `cat` process
    â”‚      to run with the given stdin &amp; stdout and
    â”‚      returns a `Child` struct
    â”‚
    â”œâ”€â”€â”€â”€â–º ğŸš€ instead of waiting "normally", we must use
    â”‚      `tokio::spawn` to call `child.wait().await`
    â”‚      on the child so it can make progress while
    â”‚      we wait for its output below (in the current task)
    â”‚
    â”œâ”€â”€â”€â”€â–º ğŸš€ also use `tokio::spawn` to call
    â”‚      `child.stdin.write_all()` to provide input
    â”‚      to the `cat` command
    â”‚
    â””â”€â”€â”€â”€â–º in our current task, we can now access `stdout`
           WHILE the child task is making progress above
</code></pre></div>    </div>
  </li>
  <li>How to kill child process:
    <ul>
      <li>Note that similar to the behavior to the standard library, and unlike the futures
paradigm of dropping-implies-cancellation, a spawned process will, by default,
continue to execute even after the <code class="language-plaintext highlighter-rouge">tokio::process::Child</code> handle has been dropped.
More info in the
<a href="https://docs.rs/tokio/latest/tokio/process/index.html#caveats">docs</a>. To change this
behavior you can use <code class="language-plaintext highlighter-rouge">tokio::process::Command::kill_on_drop</code> which isnâ€™t really
recommended.</li>
      <li>Instead, to kill a child process, you can do the following:
        <ul>
          <li><code class="language-plaintext highlighter-rouge">tokio::process::Child::kill</code> - This forces the child process to exit.</li>
          <li><code class="language-plaintext highlighter-rouge">tokio::process::Child::wait</code> - This waits for the child process to cleanly exit.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>See it in action:</p>

<ul>
  <li>Run the binary: <code class="language-plaintext highlighter-rouge">cargo run --bin async_command_exec_3</code></li>
  <li>It should produce output that looks something like the following:
    <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ğŸš€ spawn_provide_input -&gt; Finished providing input + EOF to child process ğŸ«±  stdin: "hello\nnadia!"
ğŸ§µ read_stdout -&gt; ğŸ«²  hello
ğŸ§µ read_stdout -&gt; ğŸ«²  nadia!
ğŸš€ spawn_child_process -&gt; Child process exited with status: Ok(ExitStatus(unix_wait_status(0)))
</code></pre></div>    </div>
  </li>
</ul>
      <h3 id="example-programmatically-piping-the-output-of-one-process-into-another">
        
        
          Example programmatically piping the output of one process into another <a href="#example-programmatically-piping-the-output-of-one-process-into-another">#</a>
        
        
      </h3>
    
<p><a id="markdown-example-programmatically-piping-the-output-of-one-process-into-another" name="example-programmatically-piping-the-output-of-one-process-into-another"></a></p>

<p>Please clone this <a href="https://github.com/nazmulidris/rust-scratch">repo</a> to your computer to
play w/ the examples in the <a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/README.md"><code class="language-plaintext highlighter-rouge">rust-scratch/tty</code>
crate</a> shown below.</p>

<p><a href="https://github.com/nazmulidris/rust-scratch/blob/main/tty/src/async_command_exec_4.rs"><code class="language-plaintext highlighter-rouge">async_command_exec_4.rs</code></a></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">crossterm</span><span class="p">::</span><span class="nn">style</span><span class="p">::</span><span class="n">Stylize</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">miette</span><span class="p">::</span><span class="n">IntoDiagnostic</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">r3bl_rs_utils_core</span><span class="p">::</span><span class="n">ok</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="n">Stdio</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">tokio</span><span class="p">::{</span><span class="nn">io</span><span class="p">::</span><span class="n">AsyncReadExt</span><span class="p">,</span> <span class="nn">process</span><span class="p">::</span><span class="n">Command</span><span class="p">};</span>

<span class="k">type</span> <span class="n">EchoResult</span> <span class="o">=</span> <span class="p">(</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="n">ChildStdout</span><span class="p">,</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">task</span><span class="p">::</span><span class="n">JoinHandle</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">type</span> <span class="n">TrResult</span> <span class="o">=</span> <span class="p">(</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="n">ChildStdout</span><span class="p">,</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">task</span><span class="p">::</span><span class="n">JoinHandle</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">);</span>

<span class="k">const</span> <span class="n">INPUT</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">"hello world"</span><span class="p">;</span>

<span class="nd">#[tokio::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Spawn the `echo` command &amp; get its `stdout`.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">child_stdout_echo</span><span class="p">,</span> <span class="n">join_handle_echo</span><span class="p">):</span> <span class="n">EchoResult</span> <span class="o">=</span>
        <span class="nf">spawn_child_echo_and_get_stdout</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Spawn the `tr` command &amp; provide the `stdout` of `echo` to</span>
    <span class="c1">// its `stdin`.</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">child_stdout_tr</span><span class="p">,</span> <span class="n">join_handle_tr</span><span class="p">):</span> <span class="n">TrResult</span> <span class="o">=</span>
        <span class="nf">spawn_child_tr_and_provide_stdin</span><span class="p">(</span><span class="n">child_stdout_echo</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Wait for both child processes to complete.</span>
    <span class="n">_</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nd">try_join!</span><span class="p">(</span><span class="n">join_handle_echo</span><span class="p">,</span> <span class="n">join_handle_tr</span><span class="p">);</span>

    <span class="c1">// Read the output of the `tr` command from `child_stdout_tr`.</span>
    <span class="k">let</span> <span class="n">output</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">buf</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
        <span class="nn">tokio</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">child_stdout_tr</span><span class="p">)</span>
            <span class="nf">.read_to_end</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">buf</span><span class="p">)</span>
            <span class="k">.await</span>
            <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
        <span class="n">buf</span>
    <span class="p">};</span>

    <span class="c1">// Make assertions.</span>
    <span class="k">let</span> <span class="n">expected_output</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{INPUT}</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span><span class="nf">.to_uppercase</span><span class="p">();</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">expected_output</span><span class="p">,</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_lossy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">output</span><span class="p">));</span>

    <span class="c1">// Print the output of the `tr` command.</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"{}: {}"</span><span class="p">,</span>
        <span class="s">"output"</span><span class="nf">.blue</span><span class="p">(),</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_lossy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">output</span><span class="p">))</span><span class="nf">.green</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="nd">ok!</span><span class="p">()</span>
<span class="p">}</span>

<span class="cd">/// ğŸš€ Spawn `echo` command &amp; get its `stdout`. We will pipe this</span>
<span class="cd">/// into the `stdin` of `tr`.</span>
<span class="cd">///</span>
<span class="cd">/// Return a tuple of:</span>
<span class="cd">/// 1. `stdout` of `echo`: [tokio::process::ChildStdout].</span>
<span class="cd">/// 2. [tokio::task::JoinHandle] of `echo` [tokio::process::Child]</span>
<span class="cd">///    process, spawned by the [tokio::process::Command] that</span>
<span class="cd">///    starts `echo`.</span>
<span class="k">fn</span> <span class="nf">spawn_child_echo_and_get_stdout</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">EchoResult</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Spawn the child process for `echo`.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">child_echo</span> <span class="o">=</span> <span class="nn">Command</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"echo"</span><span class="p">)</span>
        <span class="nf">.arg</span><span class="p">(</span><span class="n">INPUT</span><span class="p">)</span>
        <span class="nf">.stdout</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">piped</span><span class="p">())</span>
        <span class="nf">.stdin</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">null</span><span class="p">())</span>
        <span class="nf">.stderr</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">null</span><span class="p">())</span>
        <span class="nf">.spawn</span><span class="p">()</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Take the `stdout` of the child process.</span>
    <span class="k">let</span> <span class="n">child_stdout</span> <span class="o">=</span> <span class="n">child_echo</span><span class="py">.stdout</span><span class="nf">.take</span><span class="p">()</span>
        <span class="nf">.ok_or</span><span class="p">(</span><span class="nn">miette</span><span class="p">::</span><span class="nd">miette!</span><span class="p">(</span>
            <span class="s">"Failed to capture stdout of `echo` child process"</span>
        <span class="p">))</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Ensure the child process is spawned in the runtime, so it can</span>
    <span class="c1">// make progress on its own while we await any output.</span>
    <span class="k">let</span> <span class="n">join_handle</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">child_echo</span><span class="nf">.wait</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>
    <span class="p">});</span>

    <span class="c1">// Return the `stdout` of `echo` and the `JoinHandle` of the</span>
    <span class="c1">// `echo` child process.</span>
    <span class="nf">Ok</span><span class="p">((</span><span class="n">child_stdout</span><span class="p">,</span> <span class="n">join_handle</span><span class="p">))</span>
<span class="p">}</span>

<span class="cd">/// ğŸš€ Spawn `tr` command &amp; pass the given</span>
<span class="cd">/// [tokio::process::ChildStdout] to its `stdin`.</span>
<span class="cd">///</span>
<span class="cd">/// Return a tuple of:</span>
<span class="cd">/// 1. `stdout` of `tr`: [tokio::process::ChildStdout].</span>
<span class="cd">/// 2. [tokio::task::JoinHandle] of `tr` [tokio::process::Child]</span>
<span class="cd">///    process, spawned by the [tokio::process::Command] that</span>
<span class="cd">///    starts `tr`.</span>
<span class="k">fn</span> <span class="nf">spawn_child_tr_and_provide_stdin</span><span class="p">(</span>
    <span class="n">stdout_from_other_child</span><span class="p">:</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="n">ChildStdout</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">miette</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">TrResult</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Convert `stdout_from_other_child`: tokio::process::ChildStdout</span>
    <span class="c1">// into tokio::process::ChildStdin, so it can be provided to the</span>
    <span class="c1">// `stdin` of the `tr` command.</span>
    <span class="k">let</span> <span class="n">stdout_from_other_child</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">process</span><span class="p">::</span><span class="n">Stdio</span> <span class="o">=</span>
        <span class="n">stdout_from_other_child</span><span class="nf">.try_into</span><span class="p">()</span><span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Spawn child process.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">child_tr</span> <span class="o">=</span> <span class="nn">Command</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"tr"</span><span class="p">)</span>
        <span class="nf">.arg</span><span class="p">(</span><span class="s">"a-z"</span><span class="p">)</span>
        <span class="nf">.arg</span><span class="p">(</span><span class="s">"A-Z"</span><span class="p">)</span>
        <span class="nf">.stdin</span><span class="p">(</span><span class="n">stdout_from_other_child</span><span class="p">)</span>
        <span class="nf">.stdout</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">piped</span><span class="p">())</span>
        <span class="nf">.stderr</span><span class="p">(</span><span class="nn">Stdio</span><span class="p">::</span><span class="nf">null</span><span class="p">())</span>
        <span class="nf">.spawn</span><span class="p">()</span>
        <span class="nf">.into_diagnostic</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Take the `stdout` of the child process.</span>
    <span class="k">let</span> <span class="n">child_stdout</span> <span class="o">=</span> <span class="n">child_tr</span><span class="py">.stdout</span><span class="nf">.take</span><span class="p">()</span><span class="nf">.ok_or</span><span class="p">(</span><span class="nn">miette</span><span class="p">::</span><span class="nd">miette!</span><span class="p">(</span>
        <span class="s">"Failed to capture stdout of `tr` child process"</span>
    <span class="p">))</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// Ensure the child process is spawned in the runtime, so it can</span>
    <span class="c1">// make progress on its own while we await any output.</span>
    <span class="k">let</span> <span class="n">join_handle</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">child_tr</span><span class="nf">.wait</span><span class="p">()</span><span class="k">.await</span><span class="p">;</span>
    <span class="p">});</span>

    <span class="nf">Ok</span><span class="p">((</span><span class="n">child_stdout</span><span class="p">,</span> <span class="n">join_handle</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notes on the code:</p>

<ul>
  <li>In this example, we will will orchestrate two processes and make a pipe between them
programmatically (we are used to doing this using <code class="language-plaintext highlighter-rouge">|</code> in shells). We will replicate
the following functionality in this program: <code class="language-plaintext highlighter-rouge">echo hello world | tr a-z A-Z</code>.
    <ol>
      <li>Spawn the <code class="language-plaintext highlighter-rouge">echo</code> command, with arg <code class="language-plaintext highlighter-rouge">hello world</code> and get its <code class="language-plaintext highlighter-rouge">stdout</code>.</li>
      <li>Then we will provide this <code class="language-plaintext highlighter-rouge">stdout</code> to the <code class="language-plaintext highlighter-rouge">stdin</code> of the <code class="language-plaintext highlighter-rouge">tr</code> command, with arg
<code class="language-plaintext highlighter-rouge">a-z A-Z</code> and spawn it.</li>
      <li>Finally we join the <code class="language-plaintext highlighter-rouge">echo</code> and <code class="language-plaintext highlighter-rouge">tr</code> child processes and wait for them both to
complete.</li>
    </ol>
  </li>
</ul>

<p>See it in action:</p>

<ul>
  <li>Run the binary: <code class="language-plaintext highlighter-rouge">cargo run --bin async_command_exec_4</code></li>
  <li>You should see output that looks something like the following:
    <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>output: HELLO WORLD
</code></pre></div>    </div>
  </li>
</ul>
      <h3 id="example-using-r3bl_terminal_async-to-send-commands-to-a-long-running-bash-child-process">
        
        
          Example using r3bl_terminal_async to send commands to a long running bash child process <a href="#example-using-r3bl_terminal_async-to-send-commands-to-a-long-running-bash-child-process">#</a>
        
        
      </h3>
    
<p><a id="markdown-example-using-r3bl_terminal_async-to-send-commands-to-a-long-running-bash-child-process" name="example-using-r3bl_terminal_async-to-send-commands-to-a-long-running-bash-child-process"></a></p>

<p>The following example is in the <a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/terminal_async"><code class="language-plaintext highlighter-rouge">r3bl_terminal_async</code>
repo</a>. Please clone that repo to your computer to
play w/ the following example:</p>

<p><a href="https://github.com/r3bl-org/r3bl-open-core/blob/main/terminal_async/examples/shell_async.rs"><code class="language-plaintext highlighter-rouge">shell_async.rs</code></a></p>

<p>You can clone the <a href="https://github.com/r3bl-org/r3bl-open-core"><code class="language-plaintext highlighter-rouge">r3bl-open-core</code></a> repo to your computer
and then run the following command to run the example:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/r3bl-org/r3bl-open-core
<span class="nb">cd </span>r3bl-open-core/terminal_async
cargo run <span class="nt">--example</span> shell_async
</code></pre></div></div>

<p>Type the following commands to have a go at this.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">msg</span><span class="o">=</span><span class="s2">"hello nadia!"</span>
<span class="nb">echo</span> <span class="nv">$msg</span>
</code></pre></div></div>

<p>You should see something like the following.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[1606192] &gt; msg="hello nadia!"
[1606192] &gt; echo $msg
hello nadia!
[1606192] &gt;
</code></pre></div></div>

<p>Clean up any left over processes:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>killall <span class="nt">-9</span> bash shell_async
</code></pre></div></div>
      <h2 id="build-with-naz-video-series-on-developerlifecom-youtube-channel">
        
        
          Build with Naz video series on developerlife.com YouTube channel <a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">#</a>
        
        
      </h2>
    
<p><a id="markdown-build-with-naz-video-series-on-developerlife.com-youtube-channel" name="build-with-naz-video-series-on-developerlife.com-youtube-channel"></a></p>

<p>You can watch a video series on building this crate with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a></li>
  <li>Playlists
    <ul>
      <li><a href="https://www.youtube.com/watch?v=bolScvh4x7I&amp;list=PLofhE49PEwmw3MKOU1Kn3xbP4FRQR4Mb3">Build with Naz, Linux TTY, process, signals, commands in async Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmza94sS7UmJnN9gSCHTVTfz">Build with Naz, fundamental effective Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmwO69E7eiQ-ewnMME8ydgQ5">Build with Naz, effective async Rust and tokio</a></li>
      <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
    </ul>
  </li>
</ul>

        <!--
    Display all the categories for this page
    More info:
    - Tutorial - http://tinyurl.com/yc6fq6zx
    - Liquid language reference - http://tinyurl.com/y8s4qpwo
-->
<div class="categories-block">
    
    
    <span class="category">
            <a href="/category/CLI">
                #cli</a>
        </span>
    
    <span class="category">
            <a href="/category/Rust">
                #rust</a>
        </span>
    
    <span class="category">
            <a href="/category/Server">
                #server</a>
        </span>
    
    <span class="category">
            <a href="/category/TUI">
                #tui</a>
        </span>
    
</div>

        
<blockquote>

  ğŸ‘€ Watch Rust ğŸ¦€ live coding videos on our <a
  href="https://www.youtube.com/@developerlifecom">YouTube Channel</a>.

  <br/>
  <br/>

  <!-- video on rust polymorphism (no playlist) -->
  <iframe
      src="https://www.youtube.com/embed/kYTgGtJjSro?si=XmW-_CAvCfB5e269"
      title="YouTube video player" frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
      referrerpolicy="strict-origin-when-cross-origin"
      allowfullscreen
      >
  </iframe>

  <br/>
  <br/>

  ğŸ“¦ Install our useful Rust command line apps using <code>cargo install r3bl-cmdr</code>
  (they are from the <a href="https://github.com/r3bl-org/r3bl-open-core">r3bl-open-core</a>
  project):
  <ul>
    <li>ğŸ±<code>giti</code>: run interactive git commands with confidence in your terminal</li>
    <li>ğŸ¦œ<code>edi</code>: edit Markdown with style in your terminal</li>
  </ul>

  <p>
  <kbd>giti in action</kbd>
  <video width="100%" controls>
    <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/262f59d1-a95c-4af3-accf-c3d6cac6e586" type="video/mp4"/>
  </video>
  </p>

  <p>
  <kbd>edi in action</kbd>
  <video width="100%" controls>
    <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/f2c4b07d-b5a2-4f41-af7a-06d1b6660c41" type="video/mp4"/>
  </video>
  </p>

  </blockquote>

        <!--
    Display related posts (by category)
    More info:
    - Tutorial - http://tinyurl.com/j5tevq7
    - Liquid language reference - http://tinyurl.com/y9ru5msq
-->
<div class="related-post-block">

    <h3>Related Posts</h3>

    <!-- Get all the related posts into the string `postsString`-->
    
    
    

    <!--
        At this point `postsString` string might look like:
        Post 3|Post 1|Post 3|Post 2|Post 1|Post 3|Post 2|
    -->

    <!-- Remove all the dupes from the `postsString` string, and split it into an array -->
    

    <ul>
        
            
                
                <li>
                    <a class="post-list" href="/2024/11/28/rust-tls-rustls/">
                        Build with Naz : TLS (Transport Layer Security) in Rust with tokio, rustls, CFSSL
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/11/28/rust-sqlite-diesel/">
                        Build with Naz : Diesel ORM, SQLite, and Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/09/02/rust-lifetimes/">
                        Build with Naz : Rust lifetimes
                    </a>
                </li>
            
        
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/07/16/pin-box-dynamic-duo/">
                        Build with Naz : Box and Pin exploration in Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/07/10/rust-async-cancellation-safety-tokio/">
                        Build with Naz : Rust async in practice tokio::select!, actor pattern &amp; cancel safety
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/06/28/md-parser-rust-from-r3bl-tui/">
                        Build with Naz : Markdown parser in Rust and nom from r3bl_tui
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/06/10/rust-miette-error-handling/">
                        Build with Naz : Rust error handling with miette
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/05/28/typestate-pattern-rust/">
                        Build with Naz : Rust typestate pattern
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/05/25/tokio-uring-exploration-rust/">
                        Build with Naz : Linux io_uring and tokio-uring exploration with Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/05/19/effective-async-rust/">
                        Build with Naz : Rust async, non-blocking, concurrent, parallel, event loops, graceful shutdown
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/05/15/tokio-tracing-otel-rust/">
                        Build with Naz : tokio tracing &amp; OTel and how to use it in Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/04/28/rust-polymorphism-dyn-impl-trait-objects-for-testing-and-extensibiity/">
                        Build with Naz : Rust Polymorphism, dyn, impl, using existing traits, trait objects for testing and extensibility
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/04/21/build-async-interactive-cli-apps-in-rust/">
                        Build with Naz : Build interactive and non blocking CLI apps with ease in Rust using r3bl_terminal_async
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/01/13/write-simple-netcat-in-rust/">
                        Write a simple netcat client and server in Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/01/13/write-simple-chat-server-in-rust/">
                        Write a simple TCP chat server in Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2023/09/22/overcome-your-fear-of-merge-conflicts/">
                        How to overcome your fear of git merge conflicts
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2023/09/17/tuify-clap/">
                        tuify your clap CLI apps and make them more interactive
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2023/08/28/justfile/">
                        Use just to manage project specific commands
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2023/02/20/guide-to-nom-parsing/">
                        Build with Naz : Comprehensive guide to nom parsing
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2022/08/04/rust-dsl-part-1/">
                        Create a simple DSL for CSS like syntax for TUIs
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2022/03/12/rust-redux/">
                        Write a Redux library in Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2022/03/12/rust-tokio/">
                        Write code using async/await in Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2022/03/02/rust-grep-cli-app/">
                        Build a grep CLI app in Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2022/02/24/rust-non-binary-tree/">
                        Build a non-binary tree that is thread safe using Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2021/11/25/ink-v3-advanced-ui-components/">
                        Reference handbook for using Ink v3.2.0 components (w/ React, Node.js and TypeScript)
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2021/11/05/ink-v3-advanced/">
                        Advanced guide to Ink v3.2.0 (w/ React, Node.js and TypeScript)
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2021/11/04/introduction-to-ink-v3/">
                        Introduction to Ink v3.2.0 (w/ React, Node.js and TypeScript)
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2025/05/19/rust-mem-latency/">
                        Build with Naz : Rust, Memory performance &amp; latency - locality, access, allocate, cache lines
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/07/08/ubuntu24/">
                        Build with Naz : Ubuntu 24.04 setup and config for dev productivity
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2022/03/30/rust-proc-macro/">
                        Guide to Rust procedural macros
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2021/07/02/nodejs-typescript-handbook/">
                        Node.js (v16.3.0) Handbook using TypeScript (v4.3.4)
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2019/12/02/project-loom-experiment/">
                        Experimenting w/ Fibers in Project Loom preview
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2011/04/13/creating-asynchronous-servlets-with-tomcat-7-servlet-3-0-api/">
                        Creating asynchronous servlets with Tomcat 7 (Servlet 3.0 API)
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2009/03/06/using-json-for-mobile-object-exchange/">
                        Using JSON for mobile object exchange
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2008/04/21/geocoding-tutorial-accessing-google-static-maps-from-java/">
                        Geocoding tutorial - Accessing Google Static Maps from Java
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2007/11/27/what-is-xml-an-introduction/">
                        What is XML? An introduction
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2000/09/20/advanced-threads/">
                        Advanced Threads
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/1998/12/01/xml-and-java-tutorial-part-1/">
                        XML and Java Tutorial, Part 1
                    </a>
                </li>
            
        
    </ul>

</div>

        <a class="u-url" href="/2024/08/20/tty-linux-async-rust/" hidden></a>
    </div></article>
</div>
      </main><div>
  <section class="sidebar">
    <!-- video on intro to testing (with playlist) -->
    <!-- <iframe
      src="https://www.youtube.com/embed/videoseries?si=7gmhXY5DVYJG7OdU&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
      referrerpolicy="strict-origin-when-cross-origin"
      allowfullscreen
    >
    </iframe> -->

    <!-- rust async readline and spinner & playlist -->
    <!-- <iframe
      src="https://www.youtube.com/embed/videoseries?si=i37Ei9nCfvslOoaI&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
      referrerpolicy="strict-origin-when-cross-origin"
      allowfullscreen
    >
    </iframe> -->

    <!-- effective async rust & playlist -->
    <h2 class="star-us-github-heading">
      Subscribe to our
      <a href="https://www.youtube.com/@developerlifecom">YT Channel</a
      ><span class="heading-emoji"> ğŸ¦€</span>
    </h2>

    <iframe
    src="https://www.youtube.com/embed/qvIt8MF-pCM?si=S40pbhnvVDAohj-6"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
      referrerpolicy="strict-origin-when-cross-origin"
      allowfullscreen>
    </iframe>

    <hr />

    <h2 class="star-us-github-heading">
      <a href="https://r3bl.com#services">Need help with code?</a>
      <span class="heading-emoji"> ğŸ’¼</span>
    </h2>

    <hr />

    <h2 class="star-us-github-heading">
      Use our crates & apps<span class="heading-emoji"> ğŸ“¦</span>
    </h2>

    <ul class="sidebar-ul">
      <li class="app-container">
        <a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/cmdr" target="_blank">
          <img class="star-icon-img" src="/assets/r3bl-apps.svg" />
          <div class="sidebar-list-item">
            <p class="p-tag">INSTALL & USE OUR APPS (giti, edi)</p>
            <h3 class="sidebar-h3"><code>r3bl-cmdr</code></h3>
          </div>
        </a>
      </li>
      <li class="app-container">
        <a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/tui" target="_blank">
          <img class="star-icon-img" src="/assets/crate.png" />
          <div class="sidebar-list-item">
            <p class="p-tag">R3BL TUI LIB</p>
            <h3 class="sidebar-h3"><code>r3bl_tui</code></h3>
          </div>
        </a>
      </li>
      <li class="app-container">
        <a href="https://chromewebstore.google.com/detail/r3bl-shortlink/ffhfkgcfbjoadmhdmdcmigopbfkddial?hl=en-US&gl=US" target="_blank">
          <img class="star-icon-img" src="/assets/r3bl-shortlink.svg" />
          <div class="sidebar-list-item">
            <p class="p-tag">SHORTLINK browser extension</p>
            <h3 class="sidebar-h3"><code>shortlink</code></h3>
          </div>
        </a>
      </li>
      <!-- <li class="app-container">
        <a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/tuify" target="_blank">
          <img class="star-icon-img" src="/assets/crate.png" />
          <div class="sidebar-list-item">
            <p class="p-tag">R3BL TUIFY LIB</p>
            <h3 class="sidebar-h3"><code>r3bl_tuify</code></h3>
          </div>
        </a>
      </li>
      <li class="app-container">
        <a
          href="https://github.com/r3bl-org/r3bl-open-core/tree/main/terminal_async"
          target="_blank"
        >
          <img class="star-icon-img" src="/assets/crate.png" />
          <div class="sidebar-list-item">
            <p class="p-tag">R3BL TERMINAL ASYNC LIB</p>
            <h3 class="sidebar-h3"><code>r3bl_terminal_async</code></h3>
          </div>
        </a>
      </li> -->
    </ul>

  </section>
</div>
</div><footer class="site-footer h-card">

    <div class="wrapper">

        <div class="footer-col-wrapper">

            <div class="footer-col"><!-- <p>
    developerlife.com site was started in Nov 1998 with coverage for
    topics related to Java, XML, and web and desktop technologies.
    Today it covers Kotlin, TypeScript, Node.js, React, Android, JDK,
    Web, Cloud technologies, User Experience Engineering (UXE)
    and design topics. Â© Nazmul Idris 1996-2025. All rights reserved.
</p> -->
<div>
  <p class="footer-p">
    developerlife.com site was started in Nov 1998 by <a
    href="https://developerlife.com/about-me/">Nazmul Idris</a>, with coverage for topics
    related to Java, XML, and web and desktop technologies. Today it covers Rust, TUI,
    CLI, Kotlin, TypeScript, Node.js, React, Android, JDK, Web, Cloud technologies, User
    Experience Engineering (UXE) and design topics. Â© Nazmul Idris 1996-2025. All rights
    reserved.
  </p>

  <!--
  <div class="footer-container">

    <kbd>
      <a class="footer-elem-2" href="https://r3bl.com#services" target="_blank">Need help with code?</a>
    </kbd>

    <kbd>
      <a class="footer-elem-1" href="/subscribe.html" target="_blank"
        >Newsletter</a
      >
    </kbd>

  </div>
  -->
</div>
</div>

        </div>

    </div>

</footer>
<script>
//open external links in a new window
function external_new_window() {
    for(var c = document.getElementsByTagName("a"), a = 0;a < c.length;a++) {
    var b = c[a];
    b.getAttribute("href") && b.hostname !== location.hostname && (b.target = "_blank")
    }
}
//open PDF links in a new window
function pdf_new_window ()
{
    if (!document.getElementsByTagName) return false;
    var links = document.getElementsByTagName("a");
    for (var eleLink=0; eleLink < links.length; eleLink ++) {
    if ((links[eleLink].href.indexOf('.pdf') !== -1)||(links[eleLink].href.indexOf('.doc') !== -1)||(links[eleLink].href.indexOf('.docx') !== -1)) {
        links[eleLink].onclick =
        function() {
            window.open(this.href);
            return false;
        }
    }
    }
} 
pdf_new_window()
external_new_window();
</script></body>
</html>
