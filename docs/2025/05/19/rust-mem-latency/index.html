<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" /><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Build with Naz : Rust, Memory performance &amp; latency - locality, access, allocate, cache lines | developerlife.com</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Build with Naz : Rust, Memory performance &amp; latency - locality, access, allocate, cache lines" />
<meta name="author" content="Nazmul Idris" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Moore’s Law, the observation that the number of transistors on a chip doubles roughly every 2 years, ended around 2015–2020. This means CPU bound code that runs slowly will run slowly on future CPUs. The traditional approach of Big-O analysis and algorithmic improvements is no longer accurate, since it only accounts for “op-count” and ignores the cost of memory access. Modern CPUs have many cores, but each core isn’t getting any faster. So using parallelism is another way to get more performance. Let’s explore memory performance and latency in Rust." />
<meta property="og:description" content="Moore’s Law, the observation that the number of transistors on a chip doubles roughly every 2 years, ended around 2015–2020. This means CPU bound code that runs slowly will run slowly on future CPUs. The traditional approach of Big-O analysis and algorithmic improvements is no longer accurate, since it only accounts for “op-count” and ignores the cost of memory access. Modern CPUs have many cores, but each core isn’t getting any faster. So using parallelism is another way to get more performance. Let’s explore memory performance and latency in Rust." />
<link rel="canonical" href="http://developerlife.com/2025/05/19/rust-mem-latency/" />
<meta property="og:url" content="http://developerlife.com/2025/05/19/rust-mem-latency/" />
<meta property="og:site_name" content="developerlife.com" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-05-19T00:00:00-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Build with Naz : Rust, Memory performance &amp; latency - locality, access, allocate, cache lines" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Nazmul Idris"},"dateModified":"2025-05-19T00:00:00-05:00","datePublished":"2025-05-19T00:00:00-05:00","description":"Moore’s Law, the observation that the number of transistors on a chip doubles roughly every 2 years, ended around 2015–2020. This means CPU bound code that runs slowly will run slowly on future CPUs. The traditional approach of Big-O analysis and algorithmic improvements is no longer accurate, since it only accounts for “op-count” and ignores the cost of memory access. Modern CPUs have many cores, but each core isn’t getting any faster. So using parallelism is another way to get more performance. Let’s explore memory performance and latency in Rust.","headline":"Build with Naz : Rust, Memory performance &amp; latency - locality, access, allocate, cache lines","mainEntityOfPage":{"@type":"WebPage","@id":"http://developerlife.com/2025/05/19/rust-mem-latency/"},"url":"http://developerlife.com/2025/05/19/rust-mem-latency/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css" />

  <!-- Add favicon -->
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />

  <!-- Add fontawesome (only for bio.html page) -->
  <link
    rel="stylesheet"
    href="https://use.fontawesome.com/releases/v5.2.0/css/all.css"
    integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ"
    crossorigin="anonymous"
  /><link type="application/atom+xml" rel="alternate" href="http://developerlife.com/feed.xml" title="developerlife.com" /><!-- https://developers.google.com/analytics/devguides/collection/gtagjs -->
<script async
        src="https://www.googletagmanager.com/gtag/js?id=G-NQY9ECC58H"></script>
<script>
  window.dataLayer = window.dataLayer || []

  function gtag() {
    window.dataLayer.push(arguments)
  }

  gtag("js", new Date())
  gtag("config", "G-NQY9ECC58H")
</script>
</head>
<body><!-- https://github.com/mermaid-js/mermaid/blob/develop/docs/n00b-gettingStarted.md -->
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>

<script>
  // https://mermaid-js.github.io/mermaid/#/theming
  mermaid.initialize({
    startOnLoad: true,
    theme: "dark",
    themeVariables: {
      fontFamily: "Fira Code",
      fontSize: "0.95rem",
      darkMode: true,
      primaryColor: "#2f9ece",
      mainBkg: "#303439",
    },
  })
</script>
<header class="site-header" role="banner">

    <div class="wrapper header-wrapper"><div class="logo-container">
        <div class="logo-image">
          <a class="site-title"
             rel="author"
             href="/">
              <!-- This is the logo image placeholder. -->
                <picture>
                  <source srcset="/assets/dl-logo-icon-dark.svg" media="(max-width: 600px)"/>
                  <img  src="/assets/dl-logo-icon-and-text-dark.svg" />
                </picture>
          </a>
        </div>
      </div><nav class="site-nav">
            <input type="checkbox" id="nav-trigger" class="nav-trigger"/>
            <label for="nav-trigger">
          <span class="menu-icon">
              <svg class="svg-icon">
              <use xlink:href="/assets/minima-social-icons.svg#menu">
              </use>
            </svg>
          </span>
            </label>

            <div class="trigger"><!--
    Iterate over all the pages in the site, where page_cursor holds the current
    page for each pass of the for loop.
    Note that page is the currently loaded page itself.
--><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Android/"> Android </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/CC/"> Concurrency </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/CLI/"> CLI </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/CS/"> CS </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/DB/"> Database </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/DI/"> DI </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/FE/"> Frontend </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Hardware/"> Hardware </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/IJ/"> IntelliJ </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/KT/"> Kotlin </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Linux/"> Linux </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/MP/"> MP </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Misc/"> Misc </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Node/"> Node </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Productivity/"> Productivity </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/RN/"> React-Native </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/React/"> React </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Rust/"> Rust </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Server/"> Server </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/State/"> State-Management </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Stories/"> Stories </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/TDD/"> Testing </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/TS/"> TypeScript </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/TUI/"> TUI </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/category/Web/"> Web </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/about-me/"> Nazmul Idris </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/about-site/"> About Us </a><!-- This item is not selected -->
        <!-- Don't list excluded pages --><a class="page-link" href="/authors/"> Authors </a></div>
        </nav></div>
</header>

<!-- Debug to show the value of page.title and page.category variables -->
<!--<pre>page_cursor.exclude = nil</pre>-->
<!--<pre>page.exclude = nil</pre>-->
<!--<pre>page.title = &quot;Build with Naz : Rust, Memory performance &amp; latency - locality, access, allocate, cache lines&quot;</pre>-->
<!--<pre>page.category = nil</pre>-->
<!--<pre>page.title (json) = Build with Naz : Rust, Memory performance & latency - locality, access, allocate, cache lines</pre>-->
<!--<pre>page.category (json) = </pre>-->
<div class="page-and-sidebar-wrapper">
      <main class="page-content" aria-label="Content">
        <div class="wrapper"><article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting"><header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Build with Naz : Rust, Memory performance &amp; latency - locality, access, allocate, cache lines</h1>

    <!-- Create all the variables needed for this page (and all the includes) -->
    

    <div class="post-meta">
        <p>
            <!-- Date -->May 19, 2025

            <!--Author-->
            ∙ <a href="/about-me">Nazmul Idris</a>

            <!-- One line social blurb --><ul class="contact-list">
    <li class="p-name">Hi, I'm
            <a href="/about-me">Nazmul</a>,
            an ex-Googler, <a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/tui" target="_blank">r3bl_tui maintainer</a>, SWE, entrepreneur, designer, leader,
            TaiChi-er, racer, storyteller.
            <!-- This is fontawesome icon -->
            I <i class="fas fa-heart"></i>
            leadership, authenticity, play, hope,
            <i class="fas fa-code"></i>,
            <i class="fas fa-terminal"></i>, &
            <i class="fas fa-coffee"></i>,
            😃.</li>
</ul>
</p>
    </div><div class="social-media-container">
  <!-- <iframe
    src="https://github.com/sponsors/nazmulidris/button"
    title="Sponsor nazmulidris"
    height="35"
    width="116"
    style="border: 0; padding-right: 6px"
  ></iframe> -->

  <p class="social-media-item">
    <a
      href="mailto:hello@r3bl.com"
      target="_blank"
      title="Email us at hello@r3bl.com"
    >
      <svg class="svg-icon">
        <use xlink:href="/assets/minima-social-icons.svg#email"></use>
      </svg>
    </a>
  </p>

  <p class="social-media-item">
    <a href="https://r3bl.com/#services" target="_blank" title="Need help with code?">
      <img class="svg-icon" src="https://r3bl.com/images/logo.svg" alt="R3BL Logo">
    </a>
  </p><p class="social-media-item">
    <a
      href="https://www.youtube.com/channel/UCMcsxfCwzwDevc3NRqFgfEg"
      target="_blank"
      title="developerlife.com YouTube channel"
    >
      <svg class="svg-icon">
        <use xlink:href="/assets/minima-social-icons.svg#youtube"></use>
      </svg>
    </a>
  </p><p class="social-media-item">
    <a
      href="https://www.linkedin.com/in/nazmulidris"
      target="_blank"
      title="Nazmul Idris LinkedIn profile"
    >
      <svg class="svg-icon">
        <use xlink:href="/assets/minima-social-icons.svg#linkedin"></use>
      </svg>
    </a>
  </p><p class="social-media-item">
    <a
      href="https://www.github.com/nazmulidris" target="_blank" title="Nazmul Idris github profile">
      <svg class="svg-icon">
        <use xlink:href="/assets/minima-social-icons.svg#github"></use>
      </svg>
    </a>
  </p><p class="social-media-item">
    <a href="/feed.xml" target="_blank" title="RSS feed">
      <svg class="svg-icon">
        <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
      </svg>
    </a>
  </p></div>
</header>
<div class="post-content e-content" itemprop="articleBody">
        <!-- If a page has a hero-image defined in it, then show it here -->


        <p><img class="post-hero-image" src="/assets/rust-mem-latency-perf.png" /></p>

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

<ul>
  <li><a href="#rest-in-peace-moores-law">Rest In Peace, Moore’s Law</a></li>
  <li><a href="#memory-latency-and-cache-lines">Memory latency and cache lines</a>
    <ul>
      <li><a href="#order-of-magnitude-latency-differences">Order of magnitude latency differences</a></li>
      <li><a href="#cache-line">Cache line</a></li>
    </ul>
  </li>
  <li><a href="#stack-vs-heap">Stack vs heap</a>
    <ul>
      <li><a href="#stack-memory">Stack memory</a></li>
      <li><a href="#heap-memory">Heap memory</a></li>
      <li><a href="#why-stack-access-is-often-faster">Why stack access is often faster</a></li>
      <li><a href="#practical-implications-in-rust-and-linux">Practical implications in Rust and Linux</a></li>
      <li><a href="#stack-size-in-ubuntu-2504">Stack size in Ubuntu 25.04</a></li>
      <li><a href="#allocation-and-drop">Allocation and drop</a></li>
      <li><a href="#heap-memory-example-string-and-string-slice">Heap memory example, String and string slice</a></li>
    </ul>
  </li>
  <li><a href="#memory-alignment">Memory alignment</a></li>
  <li><a href="#global-allocators">Global allocators</a></li>
  <li><a href="#using-arrays-for-stack-or-heap-allocation">Using arrays for stack or heap allocation</a></li>
  <li><a href="#using-smallvec-and-smallstr-crates">Using smallvec and smallstr crates</a>
    <ul>
      <li><a href="#smallvec">smallvec</a></li>
      <li><a href="#smallstr">smallstr</a></li>
    </ul>
  </li>
  <li><a href="#other-code-examples">Other code examples</a></li>
  <li><a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">Build with Naz video series on developerlife.com YouTube channel</a></li>
</ul>

<!-- END doctoc generated TOC please keep comment here to allow auto update -->
      <h2 id="rest-in-peace-moores-law">
        
        
          Rest In Peace, Moore’s Law <a href="#rest-in-peace-moores-law">#</a>
        
        
      </h2>
    

<p>Moore’s Law, the observation that the number of transistors on a chip doubles roughly
every two years, has slowed significantly in recent years. While there’s no official end
date, the it effectively ended around 2015–2020. Modern process nodes (e.g., 7nm, 5nm,
3nm) are much harder and more expensive to shrink further, and improvements now take
longer than two years.</p>

<p>Implications:</p>

<ul>
  <li>This means CPU bound code that runs slowly will run slowly on future CPUs.</li>
  <li>The traditional approach of Big-O analysis and algorithmic improvements is not accurate,
since it only accounts for “op-count” and totally ignores the cost of memory access.</li>
  <li>Modern CPUs have many cores, but each core isn’t getting any faster. So using
parallelism is another way to get more performance.</li>
</ul>

<p>In this article, we will explore many of these topics in Rust, with examples written for
didactic exposition.</p>

<p>Here are some great resources to understand the implication of the end of Moore’s Law on
software performance.</p>

<ul>
  <li><a href="https://youtu.be/m7PVZixO35c">New CPUs don’t speed up old code</a></li>
  <li><a href="https://youtu.be/WwkuAqObplU">Data oriented design (YouTube)</a>
    <ul>
      <li>“Flat” data structures are better for memory locality.</li>
      <li>Pointer jumps are expensive and can slow down access (e.g., a Unicode string that
doesn’t own its data and fetches from another slice is slower due to poor locality).</li>
    </ul>
  </li>
  <li><a href="https://youtu.be/Dhn-JgZaBWo">Memory Latency vs CPU operation (YouTube)</a></li>
  <li><a href="https://youtu.be/pJ-FRRB5E84&amp;t=1831">Memory Allocation Tips (YouTube)</a>
    <ul>
      <li>For <code class="language-plaintext highlighter-rouge">Vec</code> and <code class="language-plaintext highlighter-rouge">String</code>, use <code class="language-plaintext highlighter-rouge">.with_capacity()</code> to pre-allocate memory and reduce
reallocations.</li>
      <li>Consider using these crates for performance improvements:
        <ul>
          <li><a href="https://docs.rs/smallvec/latest/smallvec/struct.SmallVec.html"><code class="language-plaintext highlighter-rouge">smallvec</code></a> (part of
Servo): Store small numbers of elements on the stack.</li>
          <li><a href="https://docs.rs/smallstr/0.3.0/smallstr/"><code class="language-plaintext highlighter-rouge">smallstr</code></a> (based on smallvec): Store
small strings on the stack.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
      <h2 id="memory-latency-and-cache-lines">
        
        
          Memory latency and cache lines <a href="#memory-latency-and-cache-lines">#</a>
        
        
      </h2>
    

<p>The CPU’s cache hierarchy (L1, L2, and often L3) acts as a crucial intermediary, bridging
the massive performance gap between the incredibly fast CPU registers and the much slower
main memory and storage. Cache lines are the fundamental building blocks that enable this
efficient data movement and significantly impact overall system performance.</p>
      <h3 id="order-of-magnitude-latency-differences">
        
        
          Order of magnitude latency differences <a href="#order-of-magnitude-latency-differences">#</a>
        
        
      </h3>
    

<p>The relative latencies look something like this (very approximate) for a machine with
Intel 14th Gen, DDR5-5200, PCIe 4 SSD:</p>

<table>
  <thead>
    <tr>
      <th>Memory Type</th>
      <th>Relative Latency (vs. Register)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Register</td>
      <td>1x</td>
    </tr>
    <tr>
      <td>L1 Cache</td>
      <td>10x - 50x</td>
    </tr>
    <tr>
      <td>L2 Cache</td>
      <td>50x - 200x</td>
    </tr>
    <tr>
      <td>RAM</td>
      <td>500x - 1000x</td>
    </tr>
    <tr>
      <td>GPU HBM/GDDR6</td>
      <td>1,000x - 2,000x</td>
    </tr>
    <tr>
      <td>SSD</td>
      <td>10,000x - 100,000x</td>
    </tr>
    <tr>
      <td>Local Network (LAN)</td>
      <td>100,000x - 1,000,000x</td>
    </tr>
    <tr>
      <td>Internet (Same Region)</td>
      <td>1,000,000x - 10,000,000x</td>
    </tr>
    <tr>
      <td>Internet (Cross-Continental)</td>
      <td>10,000,000x - 100,000,000x</td>
    </tr>
  </tbody>
</table>

<p><img src="/assets/memory_latency.svg" alt="Memory Latency" /></p>

<p>It’s important to understand that these are <em>relative</em> order-of-magnitude estimates and
can vary based on specific workloads, system configurations, and the exact characteristics
of the components. However, they provide a good sense of the performance hierarchy:</p>

<ol>
  <li>
    <p><strong>Fetching Data from a Register:</strong> This is the fastest operation, happening within the
CPU core itself.</p>

    <ul>
      <li><strong>Latency:</strong> Sub-nanosecond (on the order of picoseconds). Let’s consider this as
<strong>~1 unit of time</strong>.</li>
    </ul>
  </li>
  <li>
    <p><strong>Fetching Data from L1 Cache:</strong> The L1 cache is the smallest and closest cache to the
CPU cores.</p>

    <ul>
      <li><strong>Latency:</strong> Around 1-5 nanoseconds. This is still incredibly fast, but noticeably
slower than register access.</li>
      <li><strong>Relative Order of Magnitude:</strong> <strong>~10x - 50x</strong> slower than register access.</li>
    </ul>
  </li>
  <li>
    <p><strong>Fetching Data from L2 Cache:</strong> The L2 cache is larger and slightly further away than
L1.</p>

    <ul>
      <li><strong>Latency:</strong> Around 5-20 nanoseconds.</li>
      <li><strong>Relative Order of Magnitude:</strong> <strong>~50x - 200x</strong> slower than register access.</li>
    </ul>
  </li>
  <li>
    <p><strong>Fetching Data from Main Memory (DDR5-5200):</strong> Accessing RAM is significantly slower
than cache access. DDR5-5200 specifies the data transfer rate, but the actual latency
to fetch data involves factors like CAS latency and command cycles.</p>

    <ul>
      <li><strong>Latency:</strong> Around 50-100 nanoseconds (or even higher depending on the specific
timings and system load).</li>
      <li><strong>Relative Order of Magnitude:</strong> <strong>~500x - 1000x</strong> slower than register access.</li>
    </ul>
  </li>
  <li>
    <p><strong>Fetching Data from SSD (PCIe 4):</strong> Accessing an SSD is orders of magnitude slower
than RAM, although much faster than traditional hard drives. PCIe 4 offers high
bandwidth, but the latency for a random access is still considerable in CPU time
scales.</p>
    <ul>
      <li><strong>Latency:</strong> Tens to hundreds of <em>microseconds</em> (thousands to hundreds of thousands
of nanoseconds). Let’s say around 10-100 microseconds for a typical random read.</li>
      <li><strong>Relative Order of Magnitude:</strong> <strong>~10,000x - 100,000x</strong> slower than register
access.</li>
    </ul>
  </li>
</ol>

<blockquote>
  <table>
    <thead>
      <tr>
        <th>Unit Name</th>
        <th>Symbol</th>
        <th>Value in Seconds</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>second</td>
        <td>s</td>
        <td>1</td>
      </tr>
      <tr>
        <td>millisecond</td>
        <td>ms</td>
        <td>1/1,000 = 10⁻³ s</td>
      </tr>
      <tr>
        <td>microsecond</td>
        <td>μs</td>
        <td>1/1,000,000 = 10⁻⁶ s</td>
      </tr>
      <tr>
        <td>nanosecond</td>
        <td>ns</td>
        <td>1/1,000,000,000 = 10⁻⁹ s</td>
      </tr>
      <tr>
        <td>picosecond</td>
        <td>ps</td>
        <td>1/1,000,000,000,000 = 10⁻¹² s</td>
      </tr>
      <tr>
        <td>femtosecond</td>
        <td>fs</td>
        <td>1/1,000,000,000,000,000 = 10⁻¹⁵ s</td>
      </tr>
    </tbody>
  </table>
</blockquote>
      <h3 id="cache-line">
        
        
          Cache line <a href="#cache-line">#</a>
        
        
      </h3>
    

<p>A <strong>cache line</strong> is the fundamental unit of data transfer between the CPU’s cache
hierarchy and the main memory. On the 14th gen Intel CPUs it is 64 bytes, its primary
function is to enhance performance by fetching and storing data in larger blocks, thereby
reducing the frequency of slower main memory accesses. It is 128 bytes or twice as large
on an Apple M4 chip.</p>

<p>All CPU accesses to RAM are done in cache line units, even if the CPU only needs a single
byte or word (e.g., <code class="language-plaintext highlighter-rouge">usize</code>, or 64 bits / 8 bytes on 14th gen Intel CPU). The cache line
is the fundamental unit of data transfer between RAM and the CPU cache.</p>

<p><strong>How it works:</strong> When the CPU needs to read data, it first checks its caches (L1, L2,
L3):</p>

<ul>
  <li>If the data is not present (<strong>cache miss</strong>), the CPU fetches the data from RAM.</li>
  <li>However, it does not fetch just the specific byte or word requested—it fetches an entire
<strong>cache line</strong> (e.g., 64 bytes on Intel CPUs).</li>
  <li>This cache line is then stored in the cache, and the requested data is delivered to the
CPU. Similarly, when data is written, the corresponding cache line is updated and
eventually written back to main memory.</li>
</ul>

<p><strong>Impact on Memory Latency:</strong> Cache lines significantly influence memory latency:</p>

<ul>
  <li><strong>Spatial Locality:</strong> By fetching a block of contiguous data, cache lines exploit the
tendency of programs to access nearby memory locations, minimizing subsequent memory
accesses.</li>
  <li><strong>Cache Miss Penalty:</strong> While a cache miss incurs a substantial latency penalty to fetch
the entire line, this is often offset by the fact that a larger chunk of potentially
needed data is brought into the cache at once.</li>
  <li><strong>Bandwidth Utilization:</strong> Transferring data in larger cache line units optimizes the
use of the available memory bandwidth compared to numerous small transfers.</li>
</ul>

<p><strong>Example Benefit:</strong> Accessing elements of an array sequentially demonstrates the
advantage. With a 64-byte cache line and 4-byte integers, fetching one integer brings 15
neighboring integers into the cache, likely satisfying future access requests without
needing to go back to main memory.</p>

<p>More information on cache placement policies:</p>

<ul>
  <li><a href="https://en.wikipedia.org/wiki/Cache_placement_policies#Example_3">Wikipedia: CPU Cache placement policies</a></li>
</ul>
      <h2 id="stack-vs-heap">
        
        
          Stack vs heap <a href="#stack-vs-heap">#</a>
        
        
      </h2>
    

<p>Both stack and heap are in main memory (RAM). Their differences are logical rather than
physical.</p>
      <h3 id="stack-memory">
        
        
          Stack memory <a href="#stack-memory">#</a>
        
        
      </h3>
    

<ul>
  <li><strong>Cache friendliness</strong>: Stack memory tends to be more cache-friendly.
    <ul>
      <li>Access patterns are predictable and localized.</li>
      <li>Recent stack frames likely remain in CPU cache.</li>
    </ul>
  </li>
  <li><strong>Locality</strong>: Excellent spatial and temporal locality.
    <ul>
      <li>Data accessed together is stored together.</li>
      <li>Recently accessed data is likely to be accessed again soon.</li>
    </ul>
  </li>
  <li><strong>Allocation cost</strong>: Essentially free (just incrementing/decrementing a stack pointer).</li>
</ul>
      <h3 id="heap-memory">
        
        
          Heap memory <a href="#heap-memory">#</a>
        
        
      </h3>
    

<ul>
  <li><strong>Cache behavior</strong>: Often less cache-friendly.
    <ul>
      <li>Allocations can be scattered throughout memory.</li>
      <li>More likely to cause cache misses.</li>
    </ul>
  </li>
  <li><strong>Locality</strong>: Usually poorer spatial locality.
    <ul>
      <li>Related objects may be far apart in memory.</li>
      <li>More random access patterns.</li>
    </ul>
  </li>
  <li><strong>Allocation cost</strong>: Relatively expensive.
    <ul>
      <li>Requires searching for free blocks.</li>
      <li>May involve complex bookkeeping.</li>
    </ul>
  </li>
</ul>
      <h3 id="why-stack-access-is-often-faster">
        
        
          Why stack access is often faster <a href="#why-stack-access-is-often-faster">#</a>
        
        
      </h3>
    

<ol>
  <li><strong>Predictable access pattern</strong>: The CPU can prefetch stack data more effectively.</li>
  <li><strong>Cache utilization</strong>: Better use of cache lines due to contiguous memory access.</li>
  <li><strong>Allocation overhead</strong>: No complex memory management routines.</li>
</ol>
      <h3 id="practical-implications-in-rust-and-linux">
        
        
          Practical implications in Rust and Linux <a href="#practical-implications-in-rust-and-linux">#</a>
        
        
      </h3>
    

<ul>
  <li>Small, fixed-size values benefit from stack allocation.</li>
  <li>Larger or dynamically-sized values must use heap allocation.</li>
  <li>Cache line considerations might apply more predictably to stack memory.</li>
</ul>

<p>Stack size is important when considering memory access patterns. Stack memory benefits
from:</p>

<ul>
  <li>Better cache locality (growing/shrinking in a linear fashion)</li>
  <li>More predictable access patterns</li>
  <li>Automatic management (no allocation overhead)</li>
</ul>

<p>The fixed size nature of stacks is why recursion can cause stack overflow errors, while
heap allocations (which have their own performance trade-offs) can grow dynamically until
system memory is exhausted.</p>

<p>This is why data-oriented design principles often recommend organizing data for better
cache utilization, regardless of whether it’s on stack or heap.</p>
      <h3 id="stack-size-in-ubuntu-2504">
        
        
          Stack size in Ubuntu 25.04 <a href="#stack-size-in-ubuntu-2504">#</a>
        
        
      </h3>
    

<p>In Ubuntu 25.04 with the latest Linux kernel, the default stack size for:</p>

<ul>
  <li><strong>User threads</strong>: 8 MB (8,388,608 bytes)</li>
  <li><strong>Kernel threads</strong>: ~16 KB (kernel space stack)</li>
</ul>

<p>This is configurable through several mechanisms:</p>

<ol>
  <li>Check current stack size in a terminal with:</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c"># Displays the current stack size limit in KB.</span>
  <span class="nb">ulimit</span> <span class="nt">-s</span>
</code></pre></div></div>

<ol>
  <li>Modify stack size temporarily:</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c"># Set stack size to 8192 KB.</span>
  <span class="nb">ulimit</span> <span class="nt">-s</span> 8192
</code></pre></div></div>

<ol>
  <li>For permanent changes, edit <code class="language-plaintext highlighter-rouge">/etc/security/limits.conf</code>:</li>
</ol>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c"># &lt;domain&gt; &lt;type&gt; &lt;item&gt; &lt;value&gt;
</span>  <span class="c"># - domain: * means all users.
</span>  <span class="c"># - type: soft and hard are the limit types.
</span>  <span class="c"># - item: stack is the resource.
</span>  <span class="c"># - value: The value is in kilobytes (KB).
</span>  * <span class="n">soft</span> <span class="n">stack</span> <span class="m">8192</span>
  * <span class="n">hard</span> <span class="n">stack</span> <span class="m">16384</span>
</code></pre></div></div>
      <h3 id="allocation-and-drop">
        
        
          Allocation and drop <a href="#allocation-and-drop">#</a>
        
        
      </h3>
    

<p>The cost of dropping (deallocating) memory on the heap using Rust’s default allocator
(<code class="language-plaintext highlighter-rouge">std::alloc::System</code>, which typically wraps the underlying OS <code class="language-plaintext highlighter-rouge">malloc</code> / <code class="language-plaintext highlighter-rouge">free</code> provided
by <code class="language-plaintext highlighter-rouge">glibc</code> GNU C Library) is generally much lower than the cost of allocating it, but it
is not free. Here’s an example of the costs involved in allocating and dropping 500KB of
memory on the heap and stack:</p>

<table>
  <thead>
    <tr>
      <th>Operation</th>
      <th>Stack (500 KB)</th>
      <th>Heap (500 KB)</th>
      <th>Relative Difference</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Allocation</td>
      <td>~10–100 ns</td>
      <td>~1–10 μs</td>
      <td>10x–100x slower</td>
    </tr>
    <tr>
      <td>Deallocation</td>
      <td>~10–100 ns</td>
      <td>~1–10 μs</td>
      <td>10x–100x slower</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>Note: 1μs (micro second) = 1,000ns (nano second)</p>
</blockquote>

<p><strong>Heap:</strong></p>

<ul>
  <li><strong>Allocating</strong>: Can be expensive, especially for large or many small allocations, due to
searching for free blocks, updating allocator metadata, and possible fragmentation.</li>
  <li><strong>Dropping/Deallocating</strong>: Usually faster, as it typically just marks the memory as free
and updates allocator metadata. However, the actual cost depends on the allocator’s
implementation and fragmentation state.</li>
</ul>

<p><strong>Stack:</strong></p>

<ul>
  <li><strong>Allocating</strong>: Very cheap (just moves the stack pointer). However, note that filling it
with valid data can be expensive if the data is large.</li>
  <li><strong>Dropping/Deallocating</strong>: Also very cheap (just moves the stack pointer back).</li>
</ul>
      <h3 id="heap-memory-example-string-and-string-slice">
        
        
          Heap memory example, String and string slice <a href="#heap-memory-example-string-and-string-slice">#</a>
        
        
      </h3>
    

<p>Let’s get started with memory layout in Rust using the <code class="language-plaintext highlighter-rouge">String</code> and <code class="language-plaintext highlighter-rouge">&amp;str</code> types. <code class="language-plaintext highlighter-rouge">String</code>
is a heap-allocated, growable string type, while <code class="language-plaintext highlighter-rouge">&amp;str</code> is a string slice that is a view
into owned data somewhere else (like a <code class="language-plaintext highlighter-rouge">String</code>).</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">&amp;str</code> is is comprised of a pointer to the data and a length.</li>
  <li><code class="language-plaintext highlighter-rouge">String</code> is a struct that contains a pointer to the data, a length, and a capacity. And
is a <code class="language-plaintext highlighter-rouge">Vec&lt;u8&gt;</code> under the hood. A <code class="language-plaintext highlighter-rouge">Vec</code> itself is comprised of a pointer to the data, a
length, and a capacity.</li>
</ul>

<p>First add the following dependencies to your project:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo add r3bl_tui
</code></pre></div></div>

<p>Then you can run the following code:</p>

<div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">string_and_vec_tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">r3bl_tui</span><span class="p">::{</span><span class="n">fg_light_yellow_green</span><span class="p">,</span> <span class="n">fg_lizard_green</span><span class="p">};</span>

    <span class="nd">#[serial_test::serial]</span>
    <span class="nd">#[test]</span>
    <span class="cd">/// Demonstrates the memory layout of String, which contains [ptr, len, capacity].</span>
    <span class="k">fn</span> <span class="nf">mem_layout_string</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">fg_lizard_green</span><span class="p">(</span>
            <span class="s">"</span><span class="se">\n</span><span class="s">=== String Memory Layout Example ==="</span>
        <span class="p">)</span><span class="nf">.println</span><span class="p">();</span>

        <span class="c1">// Create a String.</span>
        <span class="c1">// ASCII values for digits:</span>
        <span class="c1">// '0': 48 (0x30), '1': 49 (0x31), '2': 50 (0x32),</span>
        <span class="c1">// '3': 51 (0x33), '4': 52 (0x34), '6': 54 (0x36),</span>
        <span class="c1">// '7': 55 (0x37), '8': 56 (0x38), '9': 57 (0x39)</span>
        <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"0123456789"</span><span class="p">);</span>

        <span class="c1">// We can get these values safely.</span>
        <span class="nf">fg_light_yellow_green</span><span class="p">(</span>
            <span class="s">"</span><span class="se">\n</span><span class="s">Safely accessing String metadata:"</span>
        <span class="p">)</span><span class="nf">.println</span><span class="p">();</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"  ptr: {:p}"</span><span class="p">,</span> <span class="n">s</span><span class="nf">.as_ptr</span><span class="p">());</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"  len: {}"</span><span class="p">,</span> <span class="n">s</span><span class="nf">.len</span><span class="p">());</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"  cap: {}"</span><span class="p">,</span> <span class="n">s</span><span class="nf">.capacity</span><span class="p">());</span>

        <span class="c1">// Unsafely transmute String to Vec of bytes.</span>
        <span class="c1">// This will show the Vec representation which</span>
        <span class="c1">// includes the UTF-8 bytes (identical to ASCII</span>
        <span class="c1">// values for these digits).</span>
        <span class="nf">fg_light_yellow_green</span><span class="p">(</span>
            <span class="s">"</span><span class="se">\n</span><span class="s">Unsafely accessing String as Vec&lt;u8&gt; (hex dump):"</span>
        <span class="p">)</span><span class="nf">.println</span><span class="p">();</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{:x?}"</span><span class="p">,</span> <span class="k">unsafe</span> <span class="p">{</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nn">transmute</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="p">});</span>

        <span class="c1">// Note that transmuting a String to the following</span>
        <span class="c1">// does not work:</span>
        <span class="c1">//</span>
        <span class="c1">// let (ptr, len, cap): (*mut usize, usize, usize) =</span>
        <span class="c1">//   unsafe { std::mem::transmute(s) };</span>
        <span class="c1">//</span>
        <span class="c1">// Both of the following are invalid:</span>
        <span class="c1">// - `(*const u8, usize, usize)`</span>
        <span class="c1">// - `(*mut u8, usize, usize)`</span>
        <span class="p">{</span>
            <span class="nf">fg_light_yellow_green</span><span class="p">(</span>
                <span class="s">"</span><span class="se">\n</span><span class="s">Accessing String with into_raw_parts():"</span>
            <span class="p">)</span><span class="nf">.println</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"0123456789"</span><span class="p">);</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">cap</span><span class="p">)</span> <span class="o">=</span> <span class="n">s</span><span class="nf">.into_raw_parts</span><span class="p">();</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"  ptr: {:p}"</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"  len: {}"</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"  cap: {}"</span><span class="p">,</span> <span class="n">cap</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">#[serial_test::serial]</span>
    <span class="nd">#[test]</span>
    <span class="cd">/// Demonstrates the memory layout of &amp;str, which</span>
    <span class="cd">/// contains [ptr, len].</span>
    <span class="k">fn</span> <span class="nf">mem_layout_str_slice</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">fg_lizard_green</span><span class="p">(</span>
            <span class="s">"</span><span class="se">\n</span><span class="s">=== &amp;str Memory Layout Example 1 ==="</span>
        <span class="p">)</span><span class="nf">.println</span><span class="p">();</span>

        <span class="c1">// Create a string slice</span>
        <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"Hello, world!"</span><span class="p">;</span>

        <span class="c1">// &amp;str is represented as [ptr, len].</span>
        <span class="k">unsafe</span> <span class="p">{</span>
            <span class="c1">// Transmute &amp;str to raw parts.</span>
            <span class="k">let</span> <span class="n">raw_parts</span><span class="p">:</span> <span class="p">(</span><span class="o">*</span><span class="k">const</span> <span class="nb">u8</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">transmute</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

            <span class="nf">fg_light_yellow_green</span><span class="p">(</span>
                <span class="s">"</span><span class="se">\n</span><span class="s">&amp;str memory layout:"</span>
            <span class="p">)</span><span class="nf">.println</span><span class="p">();</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"  ptr: {:p}"</span><span class="p">,</span> <span class="n">raw_parts</span><span class="na">.0</span><span class="p">);</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"  len: {}"</span><span class="p">,</span> <span class="n">raw_parts</span><span class="na">.1</span><span class="p">);</span>

            <span class="c1">// We can also get these values safely</span>
            <span class="nf">fg_light_yellow_green</span><span class="p">(</span>
                <span class="s">"</span><span class="se">\n</span><span class="s">Safely accessing &amp;str metadata:"</span>
            <span class="p">)</span><span class="nf">.println</span><span class="p">();</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"  ptr: {:p}"</span><span class="p">,</span> <span class="n">s</span><span class="nf">.as_ptr</span><span class="p">());</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"  len: {}"</span><span class="p">,</span> <span class="n">s</span><span class="nf">.len</span><span class="p">());</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">#[serial_test::serial]</span>
    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">mem_layout_str_slice_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">fg_lizard_green</span><span class="p">(</span>
            <span class="s">"</span><span class="se">\n</span><span class="s">=== &amp;str Memory Layout Example 2 ==="</span>
        <span class="p">)</span><span class="nf">.println</span><span class="p">();</span>

        <span class="c1">// Demonstrate that &amp;str is just a view into some data.</span>
        <span class="k">let</span> <span class="n">owned</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Hello, world!"</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">slice</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">owned</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">5</span><span class="p">];</span> <span class="c1">// "Hello".</span>

        <span class="c1">// Safe approach to get the pointer and length for slice.</span>
        <span class="k">let</span> <span class="n">slice_ptr</span> <span class="o">=</span> <span class="n">slice</span><span class="nf">.as_ptr</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">slice_len</span> <span class="o">=</span> <span class="n">slice</span><span class="nf">.len</span><span class="p">();</span>

        <span class="c1">// Safe approach to get the pointer and length for owned.</span>
        <span class="k">let</span> <span class="n">owned_ptr</span> <span class="o">=</span> <span class="n">owned</span><span class="nf">.as_ptr</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">owned_len</span> <span class="o">=</span> <span class="n">owned</span><span class="nf">.len</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">owned_capacity</span> <span class="o">=</span> <span class="n">owned</span><span class="nf">.capacity</span><span class="p">();</span>

        <span class="nf">fg_light_yellow_green</span><span class="p">(</span>
            <span class="s">"</span><span class="se">\n</span><span class="s">Comparing owned String and &amp;str slice (safely):"</span>
        <span class="p">)</span><span class="nf">.println</span><span class="p">();</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"  String ptr: {:p}"</span><span class="p">,</span> <span class="n">owned_ptr</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"  &amp;str ptr:   {:p}"</span><span class="p">,</span> <span class="n">slice_ptr</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span>
            <span class="s">"  String points to same memory as slice: {}"</span><span class="p">,</span>
            <span class="n">slice_ptr</span> <span class="o">==</span> <span class="n">owned_ptr</span>
        <span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"  String len: {}, slice len: {}"</span><span class="p">,</span>
            <span class="n">owned_len</span><span class="p">,</span> <span class="n">slice_len</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"  String cap: {}"</span><span class="p">,</span> <span class="n">owned_capacity</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
      <h2 id="memory-alignment">
        
        
          Memory alignment <a href="#memory-alignment">#</a>
        
        
      </h2>
    

<p>Memory alignment refers to arranging data in memory at addresses that are multiples of the
data type’s alignment requirement.</p>

<p>The alignment of a value specifies what addresses are valid to store the value at.</p>

<p>A value of alignment n must only be stored at an address that is a multiple of <code class="language-plaintext highlighter-rouge">n</code>. For
example, a value with an alignment of <code class="language-plaintext highlighter-rouge">2</code> must be stored at an even address, while a value
with an alignment of <code class="language-plaintext highlighter-rouge">1</code> can be stored at any address.</p>

<ul>
  <li>Alignment is measured in bytes, and must be at least <code class="language-plaintext highlighter-rouge">1</code>, and always a power of <code class="language-plaintext highlighter-rouge">2</code>.</li>
  <li>The alignment of a value can be checked with the
<a href="https://doc.rust-lang.org/core/mem/fn.align_of_val.html"><code class="language-plaintext highlighter-rouge">align_of_val</code></a> function.</li>
</ul>

<p>Rust’s type system and compiler automatically handle memory alignment for safety and
performance, but understanding alignment is important when working with FFI, low-level
code, or optimizing data structures.</p>

<p>On a 14th gen Intel CPU (which is a 64-bit x86_64 architecture), the default alignment for
primitive types in Rust is:</p>

<ul>
  <li>8 bytes for types whose size is 8 bytes (e.g., <code class="language-plaintext highlighter-rouge">u64</code>, <code class="language-plaintext highlighter-rouge">f64</code>, <code class="language-plaintext highlighter-rouge">usize</code>, pointers)</li>
  <li>4 bytes for types whose size is 4 bytes (e.g., <code class="language-plaintext highlighter-rouge">u32</code>, <code class="language-plaintext highlighter-rouge">i32</code>, <code class="language-plaintext highlighter-rouge">f32</code>)</li>
  <li>2 bytes for types whose size is 2 bytes (e.g., <code class="language-plaintext highlighter-rouge">u16</code>, <code class="language-plaintext highlighter-rouge">i16</code>)</li>
  <li>1 byte for types whose size is 1 byte (e.g., <code class="language-plaintext highlighter-rouge">u8</code>, <code class="language-plaintext highlighter-rouge">i8</code>)</li>
  <li>The alignment of a type is usually equal to its size, but only up to the CPU’s word size
(which is 8 bytes on 64-bit Intel CPUs). So, the maximum default alignment for most
types is 8 bytes. Custom types (structs, arrays) may have larger alignment if specified
with <code class="language-plaintext highlighter-rouge">repr(align(N))</code>.</li>
</ul>

<p>Let’s play with the following example to understand how how alignment can affect the
layout of a struct in memory.</p>

<p>First add the following dependencies to your project:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo add r3bl_tui
</code></pre></div></div>

<p>Then you can run the following code to see the alignment in Rust:</p>

<div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::{</span><span class="n">size_of</span><span class="p">,</span> <span class="n">align_of</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">r3bl_tui</span><span class="p">::{</span><span class="n">fg_light_yellow_green</span><span class="p">,</span> <span class="n">fg_lizard_green</span><span class="p">};</span>
<span class="k">struct</span> <span class="n">Demo</span> <span class="p">{</span>
    <span class="n">a</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>  <span class="c1">// 1 byte, alignment 1</span>
    <span class="n">b</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="c1">// 4 bytes, alignment 4</span>
    <span class="n">c</span><span class="p">:</span> <span class="nb">u16</span><span class="p">,</span> <span class="c1">// 2 bytes, alignment 2</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">size</span> <span class="o">=</span> <span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Demo</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">align</span> <span class="o">=</span> <span class="nn">align_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Demo</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">align</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

    <span class="nf">fg_lizard_green</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Size of Demo: {size}"</span><span class="p">))</span><span class="nf">.println</span><span class="p">();</span>
    <span class="nf">fg_light_yellow_green</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"Alignment of Demo: {align}"</span><span class="p">))</span><span class="nf">.println</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here’s what this would like if we used C alignment rules instead of Rust:</p>

<div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::{</span><span class="n">size_of</span><span class="p">,</span> <span class="n">align_of</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">r3bl_tui</span><span class="p">::{</span><span class="n">fg_light_yellow_green</span><span class="p">,</span> <span class="n">fg_lizard_green</span><span class="p">};</span>
<span class="nd">#[repr(C)]</span>
<span class="k">struct</span> <span class="n">Demo</span> <span class="p">{</span>
    <span class="n">a</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>  <span class="c1">// 1 byte, alignment 1</span>
    <span class="n">b</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="c1">// 4 bytes, alignment 4</span>
    <span class="n">c</span><span class="p">:</span> <span class="nb">u16</span><span class="p">,</span> <span class="c1">// 2 bytes, alignment 2</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">size</span> <span class="o">=</span> <span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Demo</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">align</span> <span class="o">=</span> <span class="nn">align_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Demo</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">align</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

    <span class="nf">fg_lizard_green</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Size of Demo: {size}"</span><span class="p">))</span><span class="nf">.println</span><span class="p">();</span>
    <span class="nf">fg_light_yellow_green</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"Alignment of Demo: {align}"</span><span class="p">))</span><span class="nf">.println</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The default alignment of 4 bytes for many types (like <code class="language-plaintext highlighter-rouge">u32</code> or <code class="language-plaintext highlighter-rouge">i32</code>) is based on their
size and the requirements of most modern CPUs, especially 32-bit architectures. The
alignment ensures that memory accesses are efficient and compatible with the CPU’s
expectations.</p>

<ul>
  <li>On a 32-bit CPU, the natural word size is 4 bytes, so types like <code class="language-plaintext highlighter-rouge">u32</code> and pointers are
aligned to 4 bytes.</li>
  <li>On a 64-bit CPU, the natural word size is 8 bytes, so types like <code class="language-plaintext highlighter-rouge">u64</code> and pointers are
aligned to 8 bytes. However, smaller types (<code class="language-plaintext highlighter-rouge">u32</code>, <code class="language-plaintext highlighter-rouge">i32</code>, etc.) still have 4-byte
alignment, unless you use a type that requires more.</li>
</ul>

<p>Next, let’s work with an example that shows the alignment of different types.</p>

<p>First add the following dependencies to your project:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo add r3bl_tui
</code></pre></div></div>

<p>Then you can run the following code:</p>

<div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::{</span><span class="n">size_of</span><span class="p">,</span> <span class="n">align_of</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">r3bl_tui</span><span class="p">::{</span><span class="n">fg_light_yellow_green</span><span class="p">,</span> <span class="n">fg_lizard_green</span><span class="p">};</span>

<span class="k">fn</span> <span class="n">pretty_print</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">type_name</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">any</span><span class="p">::</span><span class="nn">type_name</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">size</span> <span class="o">=</span> <span class="nn">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">align</span> <span class="o">=</span> <span class="nn">align_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="nf">fg_lizard_green</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">{type_name}"</span><span class="p">))</span><span class="nf">.println</span><span class="p">();</span>
    <span class="nf">fg_light_yellow_green</span><span class="p">(</span>
        <span class="nd">format!</span><span class="p">(</span><span class="s">"  size = {size}</span><span class="se">\n</span><span class="s">  alignment = {align}"</span><span class="p">)</span>
    <span class="p">)</span><span class="nf">.println</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nn">pretty_print</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="nn">pretty_print</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u16</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="nn">pretty_print</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="nn">pretty_print</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="nn">pretty_print</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="nn">pretty_print</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">f64</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Resources:</p>

<ul>
  <li><a href="https://doc.rust-lang.org/reference/type-layout.html">Rust Reference: Type Layout</a></li>
  <li><a href="https://users.rust-lang.org/t/type-alignment-understanding-memory-layout/126503/56">Forum discussion</a></li>
</ul>
      <h2 id="global-allocators">
        
        
          Global allocators <a href="#global-allocators">#</a>
        
        
      </h2>
    

<p><code class="language-plaintext highlighter-rouge">jemalloc</code> is a replacement for the default global allocator. It’s optimized for
multi-threaded use cases where lots of small objects are created and destroyed. The
default allocator is the system allocator that’s optimized for single threaded use cases.</p>

<ul>
  <li><a href="https://www.svix.com/blog/heap-fragmentation-in-rust-applications/">https://www.svix.com/blog/heap-fragmentation-in-rust-applications/</a></li>
  <li><a href="https://news.ycombinator.com/item?id=35473271">https://news.ycombinator.com/item?id=35473271</a></li>
  <li><a href="https://crates.io/crates/jemallocator">https://crates.io/crates/jemallocator</a></li>
  <li><a href="https://engineering.fb.com/2011/01/03/core-infra/scalable-memory-allocation-using-jemalloc/">https://engineering.fb.com/2011/01/03/core-infra/scalable-memory-allocation-using-jemalloc/</a></li>
</ul>

<p>Here’s an example of how to use <code class="language-plaintext highlighter-rouge">jemalloc</code> as the global allocator in a Rust project.</p>

<p>First add the following dependencies to your project:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo add tikv-jemallocator r3bl_tui
</code></pre></div></div>

<p>Then you can use it in your code:</p>

<div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">r3bl_tui</span><span class="p">::</span><span class="n">set_jemalloc_in_main</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">set_jemalloc_in_main!</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"jemalloc allocator is set."</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
      <h2 id="using-arrays-for-stack-or-heap-allocation">
        
        
          Using arrays for stack or heap allocation <a href="#using-arrays-for-stack-or-heap-allocation">#</a>
        
        
      </h2>
    

<p>A ring buffer is a data structure that uses a fixed-size array to store elements in a
circular manner. It is often used in scenarios where a fixed-size buffer is needed, such
as in embedded systems or real-time applications. The ring buffer can be implemented using
either stack or heap allocation, depending on the requirements of the application.</p>

<p>Regardless of allocating this on the stack or the heap, we are working with a fixed-size
array, which can’t be resized. So instead of using a <code class="language-plaintext highlighter-rouge">Vec</code>, we can use a fixed-size array.</p>

<p>Here are some tips on how to work with these types of data structures in Rust:</p>

<ol>
  <li>Here’s the pattern we can use for declaring how the data will be stored in the ring
buffer struct: <code class="language-plaintext highlighter-rouge">internal_storage: [Option&lt;T&gt;; N]</code>. The type is <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code> because any
slot in the ring buffer can be empty or contain a value.</li>
  <li>In order to construct this struct, we can use the pattern
<code class="language-plaintext highlighter-rouge">internal_storage: [(); N].map(|_| None)</code>, which works for any <code class="language-plaintext highlighter-rouge">T</code>. Since
<code class="language-plaintext highlighter-rouge">internal_storage: [None; N]</code> does not work unless you are willing to constrain
<code class="language-plaintext highlighter-rouge">T: Copy</code> which can be limiting.</li>
  <li>The struct will have to use this generic header:
<code class="language-plaintext highlighter-rouge">pub struct RingBuffer&lt;T, const N: usize&gt;</code>. This allows us to create a ring buffer of
any type <code class="language-plaintext highlighter-rouge">T</code> with a fixed size <code class="language-plaintext highlighter-rouge">N</code>.</li>
  <li>The impl block of this struct will have to use the same generic header:
<code class="language-plaintext highlighter-rouge">impl&lt;T, const N: usize&gt; RingBuffer&lt;T, N&gt;</code>. This allows us to implement methods for the
ring buffer that can work with any type <code class="language-plaintext highlighter-rouge">T</code> and any size <code class="language-plaintext highlighter-rouge">N</code>.</li>
</ol>

<div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">//! - Show stack alloc ring buffer using array allocated on stack.</span>
<span class="cd">//! - And pre-allocate using the pattern `internal_storage: [Option&lt;T&gt;; N]`.</span>
<span class="cd">//! - Show this constructor magic: `internal_storage: [(); N].map(|_| None)`.</span>
<span class="cd">//! - Show this generic header: `pub struct RingBuffer&lt;T, const N: usize&gt;`.</span>
<span class="cd">//! - Show the impl block with the same generic header: `impl&lt;T, const N: usize&gt;`.</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">RingBuffer</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">internal_storage</span><span class="p">:</span> <span class="p">[</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span> <span class="n">N</span><span class="p">],</span>
    <span class="n">head</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">tail</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">count</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span> <span class="n">RingBuffer</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="n">RingBuffer</span> <span class="p">{</span>
            <span class="n">internal_storage</span><span class="p">:</span> <span class="p">[();</span> <span class="n">N</span><span class="p">]</span><span class="nf">.map</span><span class="p">(|</span><span class="n">_</span><span class="p">|</span> <span class="nb">None</span><span class="p">),</span>
            <span class="n">head</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">tail</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">count</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.count</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">cap</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="n">N</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.count</span> <span class="o">==</span> <span class="n">N</span> <span class="p">{</span>
            <span class="c1">// Buffer is full, overwrite the oldest item.</span>
            <span class="k">self</span><span class="py">.tail</span> <span class="o">=</span> <span class="p">(</span><span class="k">self</span><span class="py">.tail</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">self</span><span class="py">.internal_storage</span><span class="p">[</span><span class="k">self</span><span class="py">.head</span><span class="p">]</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
        <span class="k">self</span><span class="py">.head</span> <span class="o">=</span> <span class="p">(</span><span class="k">self</span><span class="py">.head</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">remove</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">None</span><span class="p">;</span> <span class="c1">// Buffer is empty.</span>
        <span class="p">}</span>
        <span class="k">let</span> <span class="n">item</span> <span class="o">=</span> <span class="k">self</span><span class="py">.internal_storage</span><span class="p">[</span><span class="k">self</span><span class="py">.tail</span><span class="p">]</span><span class="nf">.take</span><span class="p">();</span>
        <span class="k">self</span><span class="py">.tail</span> <span class="o">=</span> <span class="p">(</span><span class="k">self</span><span class="py">.tail</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span><span class="p">;</span>
        <span class="k">self</span><span class="py">.count</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">item</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">ring_buffer_inline_tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_queue_api</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">rb</span> <span class="o">=</span> <span class="nn">RingBuffer</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="c1">// Partially fill the ring buffer.</span>
        <span class="p">{</span>
            <span class="n">rb</span><span class="nf">.add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
            <span class="n">rb</span><span class="nf">.add</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
            <span class="n">rb</span><span class="nf">.add</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">rb</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">3</span><span class="p">);</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">rb</span><span class="nf">.cap</span><span class="p">(),</span> <span class="mi">4</span><span class="p">);</span>

            <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="n">rb</span><span class="nf">.remove</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">rb</span><span class="nf">.remove</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="n">rb</span><span class="nf">.remove</span><span class="p">();</span>

            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="c1">// Fill the ring buffer to capacity.</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">4</span> <span class="p">{</span>
                <span class="n">rb</span><span class="nf">.add</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">rb</span><span class="nf">.remove</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">rb</span><span class="nf">.remove</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">rb</span><span class="nf">.remove</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">rb</span><span class="nf">.remove</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">rb</span><span class="nf">.remove</span><span class="p">(),</span> <span class="nb">None</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Overfill the ring buffer.</span>
        <span class="p">{</span>
            <span class="n">rb</span><span class="nf">.add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
            <span class="n">rb</span><span class="nf">.add</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
            <span class="n">rb</span><span class="nf">.add</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
            <span class="n">rb</span><span class="nf">.add</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
            <span class="n">rb</span><span class="nf">.add</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">rb</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">4</span><span class="p">);</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">rb</span><span class="nf">.cap</span><span class="p">(),</span> <span class="mi">4</span><span class="p">);</span>

            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">rb</span><span class="nf">.remove</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">rb</span><span class="nf">.remove</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">rb</span><span class="nf">.remove</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">rb</span><span class="nf">.remove</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">rb</span><span class="nf">.remove</span><span class="p">(),</span> <span class="nb">None</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
      <h2 id="using-smallvec-and-smallstr-crates">
        
        
          Using smallvec and smallstr crates <a href="#using-smallvec-and-smallstr-crates">#</a>
        
        
      </h2>
    
      <h3 id="smallvec">
        
        
          smallvec <a href="#smallvec">#</a>
        
        
      </h3>
    

<p><code class="language-plaintext highlighter-rouge">smallvec</code> is a crate that is part of the Servo project (which is now in the Linux
Foundation) that provides a vector type that can store a small number of elements on the
stack. If the capacity of the vector exceeds the stack size, it will automatically
allocate on the heap. You can check this using the <code class="language-plaintext highlighter-rouge">spilled()</code> method.</p>

<p>This is useful if you want to allocate a small number of <code class="language-plaintext highlighter-rouge">Sized</code> items on the stack.
However, if you have a large number of items, then <code class="language-plaintext highlighter-rouge">Vec</code> is a better choice. Also the size
of the stack is typically limited to 8MB on most systems, so be careful when using
<code class="language-plaintext highlighter-rouge">smallvec</code> with large types or lots of items of a type, to avoid stack overflow.</p>

<p>The <code class="language-plaintext highlighter-rouge">r3bl_tui</code> crate provides a <code class="language-plaintext highlighter-rouge">InlineVec</code> type that is a wrapper around
<code class="language-plaintext highlighter-rouge">smallvec::SmallVec</code> and a <code class="language-plaintext highlighter-rouge">inline_vec!</code> macro that can be used to create an <code class="language-plaintext highlighter-rouge">InlineVec</code>
with items that are provided inline to the macro.</p>

<p>To run the example below, first add the following dependencies to your project:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo add smallvec r3bl_tui
</code></pre></div></div>

<p>Then you can run the following code:</p>

<div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">//! This module demonstrates the use of `smallvec` crate. And easier to</span>
<span class="cd">//! use version: `InlineVec`.</span>
<span class="cd">//!</span>
<span class="cd">//! - Show how to use smallvec -&gt; InlineVec</span>
<span class="cd">//! - Show how to use smallstr -&gt; InlineString</span>
<span class="cd">//! - Use the join_ macros from r3bl_tui</span>

<span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">inline_vec_ex_tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">r3bl_tui</span><span class="p">::{</span><span class="nb">Index</span><span class="p">,</span> <span class="n">InlineVec</span><span class="p">,</span> <span class="n">Length</span><span class="p">,</span> <span class="n">fg_lizard_green</span><span class="p">,</span> <span class="n">inline_vec</span><span class="p">,</span> <span class="n">len</span><span class="p">};</span>

    <span class="nd">#[serial_test::serial]</span>
    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">test_new_inline_vec</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Using with default capacity. Use `[]` accessor.</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">inline_vec</span> <span class="o">=</span> <span class="nn">InlineVec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">length</span><span class="p">:</span> <span class="n">Length</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// 5</span>
            <span class="k">let</span> <span class="n">max_index</span><span class="p">:</span> <span class="nb">Index</span> <span class="o">=</span> <span class="n">length</span><span class="nf">.convert_to_index</span><span class="p">();</span> <span class="c1">// 4</span>
            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..=</span><span class="n">max_index</span><span class="nf">.as_usize</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">inline_vec</span><span class="nf">.push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// 0, 1, 2, 3, 4</span>
            <span class="p">}</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="p">[</span><span class="nn">Index</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="nf">.as_usize</span><span class="p">()],</span> <span class="mi">0</span><span class="p">);</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="p">[</span><span class="n">max_index</span><span class="nf">.as_usize</span><span class="p">()],</span> <span class="mi">4</span><span class="p">);</span>
            <span class="c1">// assert_eq!(inline_vec[max_index.as_usize() + 1], 0); // OOB error!</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.get</span><span class="p">(</span><span class="n">max_index</span><span class="nf">.as_usize</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">None</span><span class="p">);</span>
            <span class="nf">fg_lizard_green</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"InlineVec: {:?}"</span><span class="p">,</span> <span class="n">inline_vec</span><span class="p">))</span><span class="nf">.println</span><span class="p">();</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.capacity</span><span class="p">(),</span> <span class="mi">8</span><span class="p">);</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">5</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Using with macro. Use `get()` accessor.</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">length</span><span class="p">:</span> <span class="n">Length</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// 5</span>
            <span class="k">let</span> <span class="n">max_index</span><span class="p">:</span> <span class="nb">Index</span> <span class="o">=</span> <span class="n">length</span><span class="nf">.convert_to_index</span><span class="p">();</span> <span class="c1">// 4</span>
            <span class="k">let</span> <span class="n">inline_vec</span> <span class="o">=</span> <span class="nd">inline_vec!</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.get</span><span class="p">(</span><span class="nn">Index</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="nf">.as_usize</span><span class="p">()),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">0</span><span class="p">));</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.get</span><span class="p">(</span><span class="n">max_index</span><span class="nf">.as_usize</span><span class="p">()),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">4</span><span class="p">));</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.get</span><span class="p">(</span><span class="n">max_index</span><span class="nf">.as_usize</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">None</span><span class="p">);</span>
            <span class="nf">fg_lizard_green</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"InlineVec: {:?}"</span><span class="p">,</span> <span class="n">inline_vec</span><span class="p">))</span><span class="nf">.println</span><span class="p">();</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.capacity</span><span class="p">(),</span> <span class="mi">8</span><span class="p">);</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">5</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Using with capacity (even though it is pre-allocated). Use `get()` accessor.</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">inline_vec</span> <span class="o">=</span> <span class="nn">InlineVec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">length</span><span class="p">:</span> <span class="n">Length</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// 5</span>
            <span class="k">let</span> <span class="n">max_index</span><span class="p">:</span> <span class="nb">Index</span> <span class="o">=</span> <span class="n">length</span><span class="nf">.convert_to_index</span><span class="p">();</span> <span class="c1">// 4</span>
            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..=</span><span class="n">max_index</span><span class="nf">.as_usize</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">inline_vec</span><span class="nf">.push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// 0, 1, 2, 3, 4</span>
            <span class="p">}</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.get</span><span class="p">(</span><span class="nn">Index</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="nf">.as_usize</span><span class="p">()),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">0</span><span class="p">));</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.get</span><span class="p">(</span><span class="n">max_index</span><span class="nf">.as_usize</span><span class="p">()),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">4</span><span class="p">));</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.get</span><span class="p">(</span><span class="n">max_index</span><span class="nf">.as_usize</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">None</span><span class="p">);</span>
            <span class="nf">fg_lizard_green</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"InlineVec: {:?}"</span><span class="p">,</span> <span class="n">inline_vec</span><span class="p">))</span><span class="nf">.println</span><span class="p">();</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.capacity</span><span class="p">(),</span> <span class="mi">8</span><span class="p">);</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">5</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">#[serial_test::serial]</span>
    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">test_mut_inline_vec</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">inline_vec</span> <span class="o">=</span> <span class="nn">InlineVec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="k">let</span> <span class="n">length</span><span class="p">:</span> <span class="n">Length</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// 5</span>
        <span class="k">let</span> <span class="n">max_index</span><span class="p">:</span> <span class="nb">Index</span> <span class="o">=</span> <span class="n">length</span><span class="nf">.convert_to_index</span><span class="p">();</span> <span class="c1">// 4</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..=</span><span class="n">max_index</span><span class="nf">.as_usize</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">inline_vec</span><span class="nf">.push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// 0, 1, 2, 3, 4</span>
        <span class="p">}</span>

        <span class="n">inline_vec</span><span class="p">[</span><span class="n">max_index</span><span class="nf">.as_usize</span><span class="p">()]</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="p">[</span><span class="n">max_index</span><span class="nf">.as_usize</span><span class="p">()],</span> <span class="mi">100</span><span class="p">);</span>

        <span class="nf">fg_lizard_green</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"InlineVec: {:?}"</span><span class="p">,</span> <span class="n">inline_vec</span><span class="p">))</span><span class="nf">.println</span><span class="p">();</span>

        <span class="c1">// Remove the first element, and shift the rest.</span>
        <span class="n">inline_vec</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">4</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.capacity</span><span class="p">(),</span> <span class="mi">8</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">100</span><span class="p">);</span>
        <span class="nf">fg_lizard_green</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"InlineVec: {:?}"</span><span class="p">,</span> <span class="n">inline_vec</span><span class="p">))</span><span class="nf">.println</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="nd">#[serial_test::serial]</span>
    <span class="nd">#[test]</span>
    <span class="nd">#[should_panic]</span>
    <span class="k">fn</span> <span class="nf">test_inline_vec_oob</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">inline_vec</span> <span class="o">=</span> <span class="nn">InlineVec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.capacity</span><span class="p">(),</span> <span class="mi">8</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">length</span><span class="p">:</span> <span class="n">Length</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// 5</span>
        <span class="k">let</span> <span class="n">max_index</span><span class="p">:</span> <span class="nb">Index</span> <span class="o">=</span> <span class="n">length</span><span class="nf">.convert_to_index</span><span class="p">();</span> <span class="c1">// 4</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..=</span><span class="n">max_index</span><span class="nf">.as_usize</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">inline_vec</span><span class="nf">.push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// 0, 1, 2, 3, 4</span>
        <span class="p">}</span>

        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.capacity</span><span class="p">(),</span> <span class="mi">8</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">inline_vec</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">5</span><span class="p">);</span>

        <span class="c1">// This should panic because we are trying to access an index that is out of</span>
        <span class="c1">// bounds.</span>
        <span class="n">inline_vec</span><span class="p">[</span><span class="n">max_index</span><span class="nf">.as_usize</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">smallvec_ex_tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">smallvec</span><span class="p">::{</span><span class="n">SmallVec</span><span class="p">,</span> <span class="n">smallvec</span><span class="p">};</span>

    <span class="c1">// Type alias to reduce typing.</span>
    <span class="k">type</span> <span class="n">MySmallVec</span> <span class="o">=</span> <span class="n">SmallVec</span><span class="o">&lt;</span><span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">4</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="nd">#[serial_test::serial]</span>
    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">test_new_smallvec</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// With new.</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">acc</span> <span class="o">=</span> <span class="nn">MySmallVec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..=</span><span class="mi">2</span> <span class="p">{</span>
                <span class="n">acc</span><span class="nf">.push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// 0, 1, 2</span>
            <span class="p">}</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">3</span><span class="p">);</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="nf">.capacity</span><span class="p">(),</span> <span class="mi">4</span><span class="p">);</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="nf">.get</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">0</span><span class="p">));</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="nf">.get</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">));</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="nf">.get</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">2</span><span class="p">));</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="nf">.get</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="nb">None</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// With macro.</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">acc</span><span class="p">:</span> <span class="n">MySmallVec</span> <span class="o">=</span> <span class="nd">smallvec!</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">3</span><span class="p">);</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="nf">.capacity</span><span class="p">(),</span> <span class="mi">4</span><span class="p">);</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">#[serial_test::serial]</span>
    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">test_mut_smallvec</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">acc</span> <span class="o">=</span> <span class="nn">MySmallVec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..=</span><span class="mi">2</span> <span class="p">{</span>
            <span class="n">acc</span><span class="nf">.push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// 0, 1, 2</span>
        <span class="p">}</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">3</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="nf">.capacity</span><span class="p">(),</span> <span class="mi">4</span><span class="p">);</span>

        <span class="n">acc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">100</span><span class="p">);</span>

        <span class="c1">// Remove the first element, and shift the rest.</span>
        <span class="n">acc</span><span class="nf">.remove</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">2</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="nf">.capacity</span><span class="p">(),</span> <span class="mi">4</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">100</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
      <h3 id="smallstr">
        
        
          smallstr <a href="#smallstr">#</a>
        
        
      </h3>
    

<p>The <code class="language-plaintext highlighter-rouge">smallstr</code> crate is similar to <code class="language-plaintext highlighter-rouge">smallvec</code>, and it is build on top of <code class="language-plaintext highlighter-rouge">smallvec</code>. It
provides a string type that can store a small number of characters on the stack. If the
capacity of the string exceeds the stack size, it will automatically allocate on the heap.
This is useful for storing small strings on the stack, but if you have a large string,
then <code class="language-plaintext highlighter-rouge">String</code> is a better choice.</p>

<p>The <code class="language-plaintext highlighter-rouge">r3bl_tui</code> crate provides a <code class="language-plaintext highlighter-rouge">InlineString</code> type that is a wrapper around
<code class="language-plaintext highlighter-rouge">smallstr::SmallStr</code> and a <code class="language-plaintext highlighter-rouge">inline_string!</code> macro that can be used to create an
<code class="language-plaintext highlighter-rouge">InlineString</code> with items that are provided inline to the macro (use it like you would
<code class="language-plaintext highlighter-rouge">println!</code> since it uses <code class="language-plaintext highlighter-rouge">FmtArgs</code> under the hood).</p>

<p>To run the example below, first add the following dependencies to your project:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo add smallstr r3bl_tui
</code></pre></div></div>

<p>Then you can run the following code:</p>

<div class="language-rs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">//! This module demonstrates the use of `smallstr` crate. And easier to</span>
<span class="cd">//! use version of them: `InlineString`.</span>
<span class="cd">//!</span>
<span class="cd">//! Show how to use smallstr -&gt; InlineString</span>

<span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">inline_string_ex_tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">r3bl_tui</span><span class="p">::{</span><span class="n">InlineString</span><span class="p">,</span> <span class="n">fg_lizard_green</span><span class="p">,</span> <span class="n">fg_soft_pink</span><span class="p">,</span> <span class="n">inline_string</span><span class="p">};</span>
    <span class="k">use</span> <span class="nn">smallstr</span><span class="p">::</span><span class="n">SmallString</span><span class="p">;</span>

    <span class="nd">#[serial_test::serial]</span>
    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">test_new_inline_string</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Constructor.</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">acc</span> <span class="o">=</span> <span class="nn">InlineString</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Write</span> <span class="k">as</span> <span class="n">_</span><span class="p">;</span>
            <span class="n">_</span> <span class="o">=</span> <span class="nd">write!</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="s">"Hello, world!"</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="s">"Hello, world!"</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Macro.</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">acc</span> <span class="o">=</span> <span class="nd">inline_string!</span><span class="p">(</span><span class="s">"Hello,"</span><span class="p">);</span>
            <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Write</span> <span class="k">as</span> <span class="n">_</span><span class="p">;</span>
            <span class="n">_</span> <span class="o">=</span> <span class="nd">write!</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="s">" world!"</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="s">"Hello, world!"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cd">/// Demonstrates the use of `inline_string!` macro to create an</span>
    <span class="cd">/// `InlineString` and then format it using the `Display` trait.</span>
    <span class="cd">/// Without allocating a new [String] (on the heap).</span>
    <span class="nd">#[serial_test::serial]</span>
    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">test_new_inline_string_display_impl</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">DemoStruct</span> <span class="p">{</span>
            <span class="n">id</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span>
            <span class="n">name</span><span class="p">:</span> <span class="n">InlineString</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">impl</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span> <span class="k">for</span> <span class="n">DemoStruct</span> <span class="p">{</span>
            <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
                <span class="nd">write!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"id: {}, name: {}"</span><span class="p">,</span> <span class="k">self</span><span class="py">.id</span><span class="p">,</span> <span class="k">self</span><span class="py">.name</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">demo</span> <span class="o">=</span> <span class="n">DemoStruct</span> <span class="p">{</span>
            <span class="n">id</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">name</span><span class="p">:</span> <span class="nd">inline_string!</span><span class="p">(</span><span class="s">"Hello, world!"</span><span class="p">),</span>
        <span class="p">};</span>
        <span class="k">let</span> <span class="n">to_inline_string</span> <span class="o">=</span> <span class="nd">inline_string!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">demo</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">to_inline_string</span><span class="p">,</span> <span class="s">"id: 1, name: Hello, world!"</span><span class="p">);</span>
        <span class="nf">fg_lizard_green</span><span class="p">(</span><span class="n">to_inline_string</span><span class="p">)</span><span class="nf">.println</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="nd">#[serial_test::serial]</span>
    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">test_new_smallstr</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">acc</span><span class="p">:</span> <span class="n">SmallString</span><span class="o">&lt;</span><span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">8</span><span class="p">]</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">SmallString</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="nf">.capacity</span><span class="p">(),</span> <span class="mi">8</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
        <span class="nf">fg_lizard_green</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"is spilled: {}"</span><span class="p">,</span> <span class="n">acc</span><span class="nf">.spilled</span><span class="p">()))</span><span class="nf">.println</span><span class="p">();</span>

        <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Write</span> <span class="k">as</span> <span class="n">_</span><span class="p">;</span>
        <span class="n">_</span> <span class="o">=</span> <span class="nd">write!</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="s">"Hello, world!"</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="s">"Hello, world!"</span><span class="p">);</span>

        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">13</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">acc</span><span class="nf">.spilled</span><span class="p">(),</span> <span class="kc">true</span><span class="p">);</span>
        <span class="nf">fg_soft_pink</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"is spilled: {}"</span><span class="p">,</span> <span class="n">acc</span><span class="nf">.spilled</span><span class="p">()))</span><span class="nf">.println</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
      <h2 id="other-code-examples">
        
        
          Other code examples <a href="#other-code-examples">#</a>
        
        
      </h2>
    

<ol>
  <li><a href="https://github.com/r3bl-org/r3bl-open-core/blob/0479c4deb620c1e75f7d053627566e332996ee8b/core/src/common/ring_buffer.rs#L28">Fixed size buffer, array, ring buffer, one time alloc, no delete penalty</a></li>
  <li><a href="https://github.com/r3bl-org/r3bl-open-core/blob/0479c4deb620c1e75f7d053627566e332996ee8b/core/src/common/telemetry.rs#L414">Telemetry generate report to stack allocated fixed size buffer, re-use this, instead of heap alloc string</a></li>
  <li><a href="https://github.com/r3bl-org/r3bl-open-core/blob/0479c4deb620c1e75f7d053627566e332996ee8b/tui/examples/demo/ex_app_no_layout/app_main.rs#L74">smallvec usage to store data for ‘static, instead of vec! or &amp;[], supports mut, on stack, “spills” into heap if gets too big</a></li>
  <li><a href="https://github.com/r3bl-org/r3bl-open-core/blob/0479c4deb620c1e75f7d053627566e332996ee8b/tui/src/tui/editor/editor_buffer/editor_buffer_struct.rs#L199">smallvec used with unicodestring in editor buffer</a></li>
  <li><a href="https://github.com/r3bl-org/r3bl-open-core/blob/0479c4deb620c1e75f7d053627566e332996ee8b/tui/src/tui/md_parser/block/parse_block_smart_list.rs#L720">smallvec in nom parser</a></li>
  <li><a href="https://github.com/r3bl-org/r3bl-open-core/blob/0479c4deb620c1e75f7d053627566e332996ee8b/tui/src/tui/syntax_highlighting/md_parser_syn_hi/md_parser_syn_hi_impl.rs#L641">smallvec in scratch or intermediate data structures</a></li>
  <li><a href="https://github.com/r3bl-org/r3bl-open-core/blob/0479c4deb620c1e75f7d053627566e332996ee8b/tui/src/tui/terminal_lib_backends/offscreen_buffer.rs#L165">smallvec and smallstr used in offscreen buffer to prevent heap alloc for small &amp; frequent operations, and alloc internal buffers on stack, not heap</a></li>
  <li><a href="https://github.com/r3bl-org/r3bl-open-core/blob/0479c4deb620c1e75f7d053627566e332996ee8b/tui/src/tui/terminal_lib_backends/render_op.rs#L243">smallvec and smallstr used for fast Debug impl w/ formatter</a></li>
</ol>
      <h2 id="build-with-naz-video-series-on-developerlifecom-youtube-channel">
        
        
          Build with Naz video series on developerlife.com YouTube channel <a href="#build-with-naz-video-series-on-developerlifecom-youtube-channel">#</a>
        
        
      </h2>
    

<p>You can watch Rust live coding videos with Naz on the
<a href="https://www.youtube.com/@developerlifecom">developerlife.com YouTube channel</a>.</p>

<ul>
  <li><a href="https://www.youtube.com/@developerlifecom">YT channel</a></li>
  <li>Playlists
    <ul>
      <li><a href="https://www.youtube.com/watch?v=bolScvh4x7I&amp;list=PLofhE49PEwmw3MKOU1Kn3xbP4FRQR4Mb3">Build with Naz, Linux TTY, process, signals, commands in async Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmza94sS7UmJnN9gSCHTVTfz">Build with Naz, fundamental effective Rust</a></li>
      <li><a href="https://www.youtube.com/playlist?list=PLofhE49PEwmwO69E7eiQ-ewnMME8ydgQ5">Build with Naz, effective async Rust and tokio</a></li>
      <li><a href="https://www.youtube.com/watch?v=3vQJguti02I&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE">Build with Naz, async readline and spinner for CLI in Rust</a></li>
      <li><a href="https://www.youtube.com/watch?v=Xt495QLrFFk&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8">Build with Naz, testing in Rust</a></li>
    </ul>
  </li>
</ul>

        <!--
    Display all the categories for this page
    More info:
    - Tutorial - http://tinyurl.com/yc6fq6zx
    - Liquid language reference - http://tinyurl.com/y8s4qpwo
-->
<div class="categories-block">
    
    
    <span class="category">
            <a href="/category/CS">
                #cs</a>
        </span>
    
    <span class="category">
            <a href="/category/Rust">
                #rust</a>
        </span>
    
    <span class="category">
            <a href="/category/Server">
                #server</a>
        </span>
    
</div>

        
<blockquote>

  👀 Watch Rust 🦀 live coding videos on our <a
  href="https://www.youtube.com/@developerlifecom">YouTube Channel</a>.

  <br/>
  <br/>

  <!-- video on rust polymorphism (no playlist) -->
  <iframe
      src="https://www.youtube.com/embed/kYTgGtJjSro?si=XmW-_CAvCfB5e269"
      title="YouTube video player" frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
      referrerpolicy="strict-origin-when-cross-origin"
      allowfullscreen
      >
  </iframe>

  <br/>
  <br/>

  📦 Install our useful Rust command line apps using <code>cargo install r3bl-cmdr</code>
  (they are from the <a href="https://github.com/r3bl-org/r3bl-open-core">r3bl-open-core</a>
  project):
  <ul>
    <li>🐱<code>giti</code>: run interactive git commands with confidence in your terminal</li>
    <li>🦜<code>edi</code>: edit Markdown with style in your terminal</li>
  </ul>

  <p>
  <kbd>giti in action</kbd>
  <video width="100%" controls>
    <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/262f59d1-a95c-4af3-accf-c3d6cac6e586" type="video/mp4"/>
  </video>
  </p>

  <p>
  <kbd>edi in action</kbd>
  <video width="100%" controls>
    <source src="https://github.com/nazmulidris/developerlife.com/assets/2966499/f2c4b07d-b5a2-4f41-af7a-06d1b6660c41" type="video/mp4"/>
  </video>
  </p>

  </blockquote>

        <!--
    Display related posts (by category)
    More info:
    - Tutorial - http://tinyurl.com/j5tevq7
    - Liquid language reference - http://tinyurl.com/y9ru5msq
-->
<div class="related-post-block">

    <h3>Related Posts</h3>

    <!-- Get all the related posts into the string `postsString`-->
    
    
    

    <!--
        At this point `postsString` string might look like:
        Post 3|Post 1|Post 3|Post 2|Post 1|Post 3|Post 2|
    -->

    <!-- Remove all the dupes from the `postsString` string, and split it into an array -->
    

    <ul>
        
            
        
            
                
                <li>
                    <a class="post-list" href="/2022/12/11/algo-ts-2/">
                        Algorithms and data structures in TypeScript: non binary tree traversal
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2022/11/21/algo-ts-1/">
                        Algorithms and data structures in TypeScript: string tokenizer, rate limiter
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2022/02/24/rust-non-binary-tree/">
                        Build a non-binary tree that is thread safe using Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2019/03/30/algorithms-in-kotlin-8/">
                        Algorithms in Kotlin, Schedule ordered tasks
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2018/08/16/algorithms-in-kotlin-7/">
                        Algorithms in Kotlin, Caches, Part 7/7
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2018/08/16/algorithms-in-kotlin-6/">
                        Algorithms in Kotlin, Binary Trees, Part 6/7
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2018/08/16/algorithms-in-kotlin-5/">
                        Algorithms in Kotlin, Graphs, Part 5/7
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2018/08/16/algorithms-in-kotlin-4/">
                        Algorithms in Kotlin, Recursion, Part 4/7
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2018/08/16/algorithms-in-kotlin-3/">
                        Algorithms in Kotlin, Stacks and Queues, Part 3/7
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2018/08/16/algorithms-in-kotlin-2/">
                        Algorithms in Kotlin, Strings, Part 2/7
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2018/08/16/algorithms-in-kotlin-1/">
                        Algorithms in Kotlin, Big-O-Notation, Part 1/7
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/11/28/rust-tls-rustls/">
                        Build with Naz : TLS (Transport Layer Security) in Rust with tokio, rustls, CFSSL
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/11/28/rust-sqlite-diesel/">
                        Build with Naz : Diesel ORM, SQLite, and Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/09/02/rust-lifetimes/">
                        Build with Naz : Rust lifetimes
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/08/20/tty-linux-async-rust/">
                        Build with Naz : Explore Linux TTY, process, signals w/ Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/07/16/pin-box-dynamic-duo/">
                        Build with Naz : Box and Pin exploration in Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/07/10/rust-async-cancellation-safety-tokio/">
                        Build with Naz : Rust async in practice tokio::select!, actor pattern &amp; cancel safety
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/07/08/ubuntu24/">
                        Build with Naz : Ubuntu 24.04 setup and config for dev productivity
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/06/28/md-parser-rust-from-r3bl-tui/">
                        Build with Naz : Markdown parser in Rust and nom from r3bl_tui
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/06/10/rust-miette-error-handling/">
                        Build with Naz : Rust error handling with miette
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/05/28/typestate-pattern-rust/">
                        Build with Naz : Rust typestate pattern
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/05/25/tokio-uring-exploration-rust/">
                        Build with Naz : Linux io_uring and tokio-uring exploration with Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/05/19/effective-async-rust/">
                        Build with Naz : Rust async, non-blocking, concurrent, parallel, event loops, graceful shutdown
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/05/15/tokio-tracing-otel-rust/">
                        Build with Naz : tokio tracing &amp; OTel and how to use it in Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/04/28/rust-polymorphism-dyn-impl-trait-objects-for-testing-and-extensibiity/">
                        Build with Naz : Rust Polymorphism, dyn, impl, using existing traits, trait objects for testing and extensibility
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/04/21/build-async-interactive-cli-apps-in-rust/">
                        Build with Naz : Build interactive and non blocking CLI apps with ease in Rust using r3bl_terminal_async
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/01/13/write-simple-netcat-in-rust/">
                        Write a simple netcat client and server in Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2024/01/13/write-simple-chat-server-in-rust/">
                        Write a simple TCP chat server in Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2023/09/17/tuify-clap/">
                        tuify your clap CLI apps and make them more interactive
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2023/08/28/justfile/">
                        Use just to manage project specific commands
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2023/02/20/guide-to-nom-parsing/">
                        Build with Naz : Comprehensive guide to nom parsing
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2022/08/04/rust-dsl-part-1/">
                        Create a simple DSL for CSS like syntax for TUIs
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2022/03/30/rust-proc-macro/">
                        Guide to Rust procedural macros
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2022/03/12/rust-redux/">
                        Write a Redux library in Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2022/03/12/rust-tokio/">
                        Write code using async/await in Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2022/03/02/rust-grep-cli-app/">
                        Build a grep CLI app in Rust
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2021/11/25/ink-v3-advanced-ui-components/">
                        Reference handbook for using Ink v3.2.0 components (w/ React, Node.js and TypeScript)
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2021/11/05/ink-v3-advanced/">
                        Advanced guide to Ink v3.2.0 (w/ React, Node.js and TypeScript)
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2021/11/04/introduction-to-ink-v3/">
                        Introduction to Ink v3.2.0 (w/ React, Node.js and TypeScript)
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2021/07/02/nodejs-typescript-handbook/">
                        Node.js (v16.3.0) Handbook using TypeScript (v4.3.4)
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2019/12/02/project-loom-experiment/">
                        Experimenting w/ Fibers in Project Loom preview
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2011/04/13/creating-asynchronous-servlets-with-tomcat-7-servlet-3-0-api/">
                        Creating asynchronous servlets with Tomcat 7 (Servlet 3.0 API)
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2009/03/06/using-json-for-mobile-object-exchange/">
                        Using JSON for mobile object exchange
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2008/04/21/geocoding-tutorial-accessing-google-static-maps-from-java/">
                        Geocoding tutorial - Accessing Google Static Maps from Java
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2007/11/27/what-is-xml-an-introduction/">
                        What is XML? An introduction
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/2000/09/20/advanced-threads/">
                        Advanced Threads
                    </a>
                </li>
            
        
            
                
                <li>
                    <a class="post-list" href="/1998/12/01/xml-and-java-tutorial-part-1/">
                        XML and Java Tutorial, Part 1
                    </a>
                </li>
            
        
    </ul>

</div>

        <a class="u-url" href="/2025/05/19/rust-mem-latency/" hidden></a>
    </div></article>
</div>
      </main><div>
  <section class="sidebar">
    <!-- video on intro to testing (with playlist) -->
    <!-- <iframe
      src="https://www.youtube.com/embed/videoseries?si=7gmhXY5DVYJG7OdU&amp;list=PLofhE49PEwmwLR_4Noa0dFOSPmSpIg_l8"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
      referrerpolicy="strict-origin-when-cross-origin"
      allowfullscreen
    >
    </iframe> -->

    <!-- rust async readline and spinner & playlist -->
    <!-- <iframe
      src="https://www.youtube.com/embed/videoseries?si=i37Ei9nCfvslOoaI&amp;list=PLofhE49PEwmwelPkhfiqdFQ9IXnmGdnSE"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
      referrerpolicy="strict-origin-when-cross-origin"
      allowfullscreen
    >
    </iframe> -->

    <!-- effective async rust & playlist -->
    <h2 class="star-us-github-heading">
      Subscribe to our
      <a href="https://www.youtube.com/@developerlifecom">YT Channel</a
      ><span class="heading-emoji"> 🦀</span>
    </h2>

    <iframe
    src="https://www.youtube.com/embed/qvIt8MF-pCM?si=S40pbhnvVDAohj-6"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
      referrerpolicy="strict-origin-when-cross-origin"
      allowfullscreen>
    </iframe>

    <hr />

    <h2 class="star-us-github-heading">
      <a href="https://r3bl.com#services">Need help with code?</a>
      <span class="heading-emoji"> 💼</span>
    </h2>

    <hr />

    <h2 class="star-us-github-heading">
      Use our crates & apps<span class="heading-emoji"> 📦</span>
    </h2>

    <ul class="sidebar-ul">
      <li class="app-container">
        <a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/cmdr" target="_blank">
          <img class="star-icon-img" src="/assets/r3bl-apps.svg" />
          <div class="sidebar-list-item">
            <p class="p-tag">INSTALL & USE OUR APPS (giti, edi)</p>
            <h3 class="sidebar-h3"><code>r3bl-cmdr</code></h3>
          </div>
        </a>
      </li>
      <li class="app-container">
        <a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/tui" target="_blank">
          <img class="star-icon-img" src="/assets/crate.png" />
          <div class="sidebar-list-item">
            <p class="p-tag">R3BL TUI LIB</p>
            <h3 class="sidebar-h3"><code>r3bl_tui</code></h3>
          </div>
        </a>
      </li>
      <li class="app-container">
        <a href="https://chromewebstore.google.com/detail/r3bl-shortlink/ffhfkgcfbjoadmhdmdcmigopbfkddial?hl=en-US&gl=US" target="_blank">
          <img class="star-icon-img" src="/assets/r3bl-shortlink.svg" />
          <div class="sidebar-list-item">
            <p class="p-tag">SHORTLINK browser extension</p>
            <h3 class="sidebar-h3"><code>shortlink</code></h3>
          </div>
        </a>
      </li>
      <!-- <li class="app-container">
        <a href="https://github.com/r3bl-org/r3bl-open-core/tree/main/tuify" target="_blank">
          <img class="star-icon-img" src="/assets/crate.png" />
          <div class="sidebar-list-item">
            <p class="p-tag">R3BL TUIFY LIB</p>
            <h3 class="sidebar-h3"><code>r3bl_tuify</code></h3>
          </div>
        </a>
      </li>
      <li class="app-container">
        <a
          href="https://github.com/r3bl-org/r3bl-open-core/tree/main/terminal_async"
          target="_blank"
        >
          <img class="star-icon-img" src="/assets/crate.png" />
          <div class="sidebar-list-item">
            <p class="p-tag">R3BL TERMINAL ASYNC LIB</p>
            <h3 class="sidebar-h3"><code>r3bl_terminal_async</code></h3>
          </div>
        </a>
      </li> -->
    </ul>

  </section>
</div>
</div><footer class="site-footer h-card">

    <div class="wrapper">

        <div class="footer-col-wrapper">

            <div class="footer-col"><!-- <p>
    developerlife.com site was started in Nov 1998 with coverage for
    topics related to Java, XML, and web and desktop technologies.
    Today it covers Kotlin, TypeScript, Node.js, React, Android, JDK,
    Web, Cloud technologies, User Experience Engineering (UXE)
    and design topics. © Nazmul Idris 1996-2025. All rights reserved.
</p> -->
<div>
  <p class="footer-p">
    developerlife.com site was started in Nov 1998 by <a
    href="https://developerlife.com/about-me/">Nazmul Idris</a>, with coverage for topics
    related to Java, XML, and web and desktop technologies. Today it covers Rust, TUI,
    CLI, Kotlin, TypeScript, Node.js, React, Android, JDK, Web, Cloud technologies, User
    Experience Engineering (UXE) and design topics. © Nazmul Idris 1996-2025. All rights
    reserved.
  </p>

  <!--
  <div class="footer-container">

    <kbd>
      <a class="footer-elem-2" href="https://r3bl.com#services" target="_blank">Need help with code?</a>
    </kbd>

    <kbd>
      <a class="footer-elem-1" href="/subscribe.html" target="_blank"
        >Newsletter</a
      >
    </kbd>

  </div>
  -->
</div>
</div>

        </div>

    </div>

</footer>
<script>
//open external links in a new window
function external_new_window() {
    for(var c = document.getElementsByTagName("a"), a = 0;a < c.length;a++) {
    var b = c[a];
    b.getAttribute("href") && b.hostname !== location.hostname && (b.target = "_blank")
    }
}
//open PDF links in a new window
function pdf_new_window ()
{
    if (!document.getElementsByTagName) return false;
    var links = document.getElementsByTagName("a");
    for (var eleLink=0; eleLink < links.length; eleLink ++) {
    if ((links[eleLink].href.indexOf('.pdf') !== -1)||(links[eleLink].href.indexOf('.doc') !== -1)||(links[eleLink].href.indexOf('.docx') !== -1)) {
        links[eleLink].onclick =
        function() {
            window.open(this.href);
            return false;
        }
    }
    }
} 
pdf_new_window()
external_new_window();
</script></body>
</html>
